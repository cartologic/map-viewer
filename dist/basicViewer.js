/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"basicViewer": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/basic_viewer/dist/";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([5,"materialUI","polyfill","extVendors","lodashLib"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/polyfill/noConflict.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/polyfill/noConflict.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./lib/noConflict */ "./node_modules/@babel/polyfill/lib/noConflict.js");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Add.js":
/*!************************************************!*\
  !*** ./node_modules/@material-ui/icons/Add.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
})), 'Add');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/ArrowBackSharp.js":
/*!***********************************************************!*\
  !*** ./node_modules/@material-ui/icons/ArrowBackSharp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
}), _react.default.createElement("path", {
  d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
})), 'ArrowBackSharp');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Close.js":
/*!**************************************************!*\
  !*** ./node_modules/@material-ui/icons/Close.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
})), 'Close');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Delete.js":
/*!***************************************************!*\
  !*** ./node_modules/@material-ui/icons/Delete.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
})), 'Delete');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/DragHandle.js":
/*!*******************************************************!*\
  !*** ./node_modules/@material-ui/icons/DragHandle.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("defs", null, _react.default.createElement("path", {
  id: "a",
  d: "M0 0h24v24H0V0z"
})), _react.default.createElement("path", {
  d: "M20 9H4v2h16V9zM4 15h16v-2H4v2z"
})), 'DragHandle');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/ExpandMore.js":
/*!*******************************************************!*\
  !*** ./node_modules/@material-ui/icons/ExpandMore.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
})), 'ExpandMore');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Image.js":
/*!**************************************************!*\
  !*** ./node_modules/@material-ui/icons/Image.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), _react.default.createElement("path", {
  d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
})), 'Image');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/KeyboardArrowLeft.js":
/*!**************************************************************!*\
  !*** ./node_modules/@material-ui/icons/KeyboardArrowLeft.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
})), 'KeyboardArrowLeft');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/KeyboardArrowRight.js":
/*!***************************************************************!*\
  !*** ./node_modules/@material-ui/icons/KeyboardArrowRight.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
})), 'KeyboardArrowRight');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Layers.js":
/*!***************************************************!*\
  !*** ./node_modules/@material-ui/icons/Layers.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), _react.default.createElement("path", {
  d: "M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z"
})), 'Layers');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Menu.js":
/*!*************************************************!*\
  !*** ./node_modules/@material-ui/icons/Menu.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), _react.default.createElement("path", {
  d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
})), 'Menu');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/MoreVert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@material-ui/icons/MoreVert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), _react.default.createElement("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
})), 'MoreVert');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Save.js":
/*!*************************************************!*\
  !*** ./node_modules/@material-ui/icons/Save.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), _react.default.createElement("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
})), 'Save');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/ZoomIn.js":
/*!***************************************************!*\
  !*** ./node_modules/@material-ui/icons/ZoomIn.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), _react.default.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
}), _react.default.createElement("path", {
  d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"
})), 'ZoomIn');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/utils/createSvgIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/@material-ui/icons/utils/createSvgIcon.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _pure = _interopRequireDefault(__webpack_require__(/*! recompose/pure */ "./node_modules/recompose/pure.js"));

var _SvgIcon = _interopRequireDefault(__webpack_require__(/*! @material-ui/core/SvgIcon */ "./node_modules/@material-ui/core/SvgIcon/index.js"));

function createSvgIcon(path, displayName) {
  var Icon = function Icon(props) {
    return _react.default.createElement(_SvgIcon.default, props, path);
  };

  Icon.displayName = "".concat(displayName, "Icon");
  Icon = (0, _pure.default)(Icon);
  Icon.muiName = 'SvgIcon';
  return Icon;
}

;
var _default = createSvgIcon;
exports.default = _default;

/***/ }),

/***/ "./node_modules/autobind-decorator/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/autobind-decorator/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @copyright 2015, Andrey Popp <8mayday@gmail.com>
 *
 * The decorator may be used on classes or methods
 * ```
 * @autobind
 * class FullBound {}
 *
 * class PartBound {
 *   @autobind
 *   method () {}
 * }
 * ```
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = autobind;

function autobind() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 1) {
    return boundClass.apply(undefined, args);
  } else {
    return boundMethod.apply(undefined, args);
  }
}
/**
 * Use boundMethod to bind all methods on the target.prototype
 */


function boundClass(target) {
  // (Using reflect to get all keys including symbols)
  var keys = undefined; // Use Reflect if exists

  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {
    keys = Reflect.ownKeys(target.prototype);
  } else {
    keys = Object.getOwnPropertyNames(target.prototype); // use symbols if support is provided

    if (typeof Object.getOwnPropertySymbols === 'function') {
      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));
    }
  }

  keys.forEach(function (key) {
    // Ignore special case target method
    if (key === 'constructor') {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding

    if (typeof descriptor.value === 'function') {
      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));
    }
  });
  return target;
}
/**
 * Return a descriptor removing the value and returning a getter
 * The getter will return a .bind version of the function
 * and memoize the result against a symbol on the instance
 */


function boundMethod(target, key, descriptor) {
  var fn = descriptor.value;

  if (typeof fn !== 'function') {
    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);
  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the
  // getter for the property which is being replaced. This causes infinite
  // recursion and an "Out of stack space" error.


  var definingProperty = false;
  return {
    configurable: true,
    get: function get() {
      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {
        return fn;
      }

      var boundFn = fn.bind(this);
      definingProperty = true;
      Object.defineProperty(this, key, {
        value: boundFn,
        configurable: true,
        writable: true
      });
      definingProperty = false;
      return boundFn;
    }
  };
}

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");

var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false; // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.

    if ( true && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;

      request.onprogress = function handleProgress() {};

      request.ontimeout = function handleTimeout() {};
    } // HTTP basic authentication


    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js"); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (config.withCredentials) {
      request.withCredentials = true;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {
    method: 'get'
  }, this.defaults, config);
  config.method = config.method.toLowerCase(); // Hook up interceptors middleware

  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Support baseURL config

  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  } // Ensure headers exist


  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus; // Note: status is not exposed by XDomainRequest

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}

E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';

  for ( // initialize result and counter
  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xFF) {
      throw new E();
    }

    block = block << 8 | charCode;
  }

  return output;
}

module.exports = btoa;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/AnimationHelper.js":
/*!***************************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/AnimationHelper.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationHelper = undefined;

var _circle = __webpack_require__(/*! ol/style/circle */ "./node_modules/ol/style/circle.js");

var _circle2 = _interopRequireDefault(_circle);

var _observable = __webpack_require__(/*! ol/observable */ "./node_modules/ol/observable.js");

var _observable2 = _interopRequireDefault(_observable);

var _stroke = __webpack_require__(/*! ol/style/stroke */ "./node_modules/ol/style/stroke.js");

var _stroke2 = _interopRequireDefault(_stroke);

var _style = __webpack_require__(/*! ol/style/style */ "./node_modules/ol/style/style.js");

var _style2 = _interopRequireDefault(_style);

var _easing = __webpack_require__(/*! ol/easing */ "./node_modules/ol/easing.js");

var _easing2 = _interopRequireDefault(_easing);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/** Class for Animation manipulation */


var AnimationHelper = exports.AnimationHelper = function () {
  function AnimationHelper() {
    _classCallCheck(this, AnimationHelper);
  }
  /**
  * This function add flash style to feature (point)
  * @param {ol.Feature} feature
  * @param {ol.Map} map
  * @returns {void}
  */


  AnimationHelper.prototype.flash = function flash(feature, map) {
    var start = new Date().getTime();
    var listenerKey = void 0;
    var duration = 5000;

    function animate(event) {
      var vectorContext = event.vectorContext;
      var frameState = event.frameState;
      var flashGeom = feature.getGeometry().clone();
      var elapsed = frameState.time - start;
      var elapsedRatio = elapsed / duration; // radius will be 5 at start and 30 at end.

      var radius = _easing2.default.easeOut(elapsedRatio) * 25 + 5;

      var opacity = _easing2.default.easeOut(1 - elapsedRatio);

      var featureStyle = new _style2.default({
        image: new _circle2.default({
          radius: radius,
          snapToPixel: false,
          stroke: new _stroke2.default({
            color: 'rgba(21, 84, 75,' + opacity + ')',
            width: 0.25 + opacity
          })
        })
      });
      vectorContext.setStyle(featureStyle);
      vectorContext.drawGeometry(flashGeom);

      if (elapsed > duration) {
        _observable2.default.unByKey(listenerKey);

        return;
      }

      map.render();
    }

    listenerKey = map.on('postcompose', animate);
  };
  /**
  * This function apply animation fly when zoom to feature
  * @param {Array.<Number>} location
  * @param {ol.View} view
  * @param {Number} zoom
  * @param {Boolean} done
  * @returns {void}
  */


  AnimationHelper.prototype.flyTo = function flyTo(location, view, zoom, done) {
    var duration = 3000;
    var parts = 2;
    var called = false;

    function callback(complete) {
      --parts;

      if (called) {
        return;
      }

      if (parts === 0 || !complete) {
        called = true;
        done(complete);
      }
    }

    view.animate({
      center: location,
      duration: duration
    }, callback);
    view.animate({
      zoom: zoom - 1,
      duration: duration / 2
    }, {
      zoom: zoom,
      duration: duration / 2
    }, callback);
  };

  return AnimationHelper;
}();

exports.default = new AnimationHelper();

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/BasicViewerHelper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/BasicViewerHelper.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BasicViewerHelper = undefined;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _utils = __webpack_require__(/*! ../utils/utils */ "./node_modules/cartoview-sdk/utils/utils.js");

var _dragrotateandzoom = __webpack_require__(/*! ol/interaction/dragrotateandzoom */ "./node_modules/ol/interaction/dragrotateandzoom.js");

var _dragrotateandzoom2 = _interopRequireDefault(_dragrotateandzoom);

var _fileSaver = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/dist/FileSaver.min.js");

var _fileSaver2 = _interopRequireDefault(_fileSaver);

var _fullscreen = __webpack_require__(/*! ol/control/fullscreen */ "./node_modules/ol/control/fullscreen.js");

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _map = __webpack_require__(/*! ol/map */ "./node_modules/ol/map.js");

var _map2 = _interopRequireDefault(_map);

var _MapConfigService = __webpack_require__(/*! ../services/MapConfigService */ "./node_modules/cartoview-sdk/services/MapConfigService.js");

var _MapConfigService2 = _interopRequireDefault(_MapConfigService);

var _MapConfigTransformService = __webpack_require__(/*! ../services/MapConfigTransformService */ "./node_modules/cartoview-sdk/services/MapConfigTransformService.js");

var _MapConfigTransformService2 = _interopRequireDefault(_MapConfigTransformService);

var _osm = __webpack_require__(/*! ol/source/osm */ "./node_modules/ol/source/osm.js");

var _osm2 = _interopRequireDefault(_osm);

var _projection = __webpack_require__(/*! ol/proj/projection */ "./node_modules/ol/proj/projection.js");

var _projection2 = _interopRequireDefault(_projection);

var _scaleline = __webpack_require__(/*! ol/control/scaleline */ "./node_modules/ol/control/scaleline.js");

var _scaleline2 = _interopRequireDefault(_scaleline);

var _tile = __webpack_require__(/*! ol/layer/tile */ "./node_modules/ol/layer/tile.js");

var _tile2 = _interopRequireDefault(_tile);

var _view = __webpack_require__(/*! ol/view */ "./node_modules/ol/view.js");

var _view2 = _interopRequireDefault(_view);

var _zoomslider = __webpack_require__(/*! ol/control/zoomslider */ "./node_modules/ol/control/zoomslider.js");

var _zoomslider2 = _interopRequireDefault(_zoomslider);

var _control = __webpack_require__(/*! ol/control */ "./node_modules/ol/control.js");

var _control2 = _interopRequireDefault(_control);

var _extent = __webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _interaction = __webpack_require__(/*! ol/interaction */ "./node_modules/ol/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _pica = __webpack_require__(/*! pica/dist/pica */ "./node_modules/pica/dist/pica.js");

var _pica2 = _interopRequireDefault(_pica);

var _proj = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/** Class for Basic Viewer main Operation */


var BasicViewerHelper = exports.BasicViewerHelper = function () {
  function BasicViewerHelper() {
    _classCallCheck(this, BasicViewerHelper);
  }
  /**
  * This function return center of extent
  * @param {ol.Extent} extent openlayers extent
  * @returns {Array.<Number>}
  */


  BasicViewerHelper.prototype.getCenterOfExtent = function getCenterOfExtent(ext) {
    var center = _extent2.default.getCenter(ext);

    return center;
  };
  /**
  * This function initialize openlayer map instance from geonode json obj
  * @param {string} mapJsonUrl url to get geonode json object from 
  * @param {ol.Map} map openlayers map instance
  * @param {string} proxyURL proxy url
  * @param {string} access_token user access token
  * @param {Function} callback function to be invoked after initializtion
  * @returns {void}
  */


  BasicViewerHelper.prototype.mapInit = function mapInit(mapJsonUrl, map, proxyURL, access_token) {
    var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};
    (0, _utils.doGet)(mapJsonUrl).then(function (config) {
      _MapConfigService2.default.load(_MapConfigTransformService2.default.transform(config), map, proxyURL, access_token);

      callback();
    });
  };
  /**
  * This function get map as images resizing it and sending it to the server
  * @param {HTMLCanvasElement}  originalCanvas
  * @param {string} thumnailURL save thumbnail url
  * @returns {Promise}
  */


  BasicViewerHelper.prototype.resizeSendThumbnail = function resizeSendThumbnail(originalCanvas, thumnailURL) {
    var thumbnailPromise = new Promise(function (resolve, reject) {
      var picaResizer = (0, _pica2.default)();
      var resizedCanvas = document.createElement('canvas');
      resizedCanvas.width = 280;
      resizedCanvas.height = 210;
      picaResizer.resize(originalCanvas, resizedCanvas).then(function (result) {
        return picaResizer.toBlob(result, 'image/jpeg', 0.90);
      }).then(function (blob) {
        var reader = new FileReader();
        reader.readAsDataURL(blob);

        reader.onloadend = function () {
          var postData = JSON.stringify({
            image: reader.result,
            preview: "react"
          });

          try {
            (0, _utils.doPost)(thumnailURL, postData, {}, 'xml').then(function (result) {
              return resolve(result);
            });
          } catch (err) {
            reject(err.message);
          }
        };
      });
    });
    return thumbnailPromise;
  };
  /**
  * This function get map as images resizing it and sending it to the server
  * @param {ol.Map}  map openlayers map instance
  * @param {string} thumnailURL save thumbnail url
  * @returns {Promise}
  */


  BasicViewerHelper.prototype.setThumbnail = function setThumbnail(map, thumnailURL) {
    var _this = this;

    var generationPromise = new Promise(function (resolve, reject) {
      map.once('postcompose', function (event) {
        var canvas = event.context.canvas;

        _this.resizeSendThumbnail(canvas, thumnailURL).then(function (result) {
          return resolve(result);
        }).catch(function (err) {
          reject(err);
        });
      });
      map.renderSync();
    });
    return generationPromise;
  };
  /**
  * This function return array of openlayers controls based on configuration object
  * @typedef {Object} Zoom
  * @property {Number} minZoom - minimum zoom of map
  * @property {Number} maxZoom - maximum zoom of map
  * @property {Number} zoom - initial zoom of map
  * @typedef {Object} Configuration
  * @property {Boolean} scaleLine - scaleline control
  * @property {Boolean} zoomSlider - zoom slider control
  * @property {Boolean} fullScreen - fullScreen control
  * @property {Boolean} dragRotateAndZoom - dragRotateAndZoom interaction
  * @property {Zoom} zoom - zoom configuration
  * @property {Array.<string>} attachmentTags - attachment tags
  * @param {Configuration}  config 
  * @returns {Promise}
  */


  BasicViewerHelper.prototype.getControls = function getControls(config) {
    var controls = [];

    if (config.scaleLine) {
      controls.push(new _scaleline2.default());
    }

    if (config.zoomSlider) {
      controls.push(new _zoomslider2.default());
    }

    if (config.fullScreen) {
      controls.push(new _fullscreen2.default({
        source: "root"
      }));
    }

    return controls;
  };
  /**
  * This function return array of openlayers interactions based on configuration object
  * @param {Configuration}  config 
  * @returns {Promise}
  */


  BasicViewerHelper.prototype.getInteractions = function getInteractions(config) {
    var interactions = [];

    if (config.dragRotateAndZoom) {
      interactions.push(new _dragrotateandzoom2.default());
    }

    return interactions;
  };
  /**
  * This function return default configuration object
  * @returns {Configuration}
  */


  BasicViewerHelper.prototype.getMapDefaultConfig = function getMapDefaultConfig() {
    var config = {
      dragRotateAndZoom: true,
      scaleLine: true,
      zoomSlider: true,
      fullScreen: true,
      zoom: {
        minZoom: 1,
        zoom: 2,
        maxZoom: 19
      }
    };
    return config;
  };
  /**
  * This function return openlayers map instance based on configuration
  * @param {Configuration}  config 
  * @returns {ol.Map}
  */


  BasicViewerHelper.prototype.getMap = function getMap() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getMapDefaultConfig();
    var zoomConfig = config && config.zoom ? config.zoom : {
      minZoom: 1,
      zoom: 2,
      maxZoom: 19
    };
    var controls = this.getControls(config);
    var map = new _map2.default({
      interactions: _interaction2.default.defaults({
        dragPan: true
      }),
      controls: _control2.default.defaults().extend(controls),
      layers: [new _tile2.default({
        title: 'OpenStreetMap',
        source: new _osm2.default()
      })],
      loadTilesWhileInteracting: true,
      view: new _view2.default(_extends({
        center: _proj2.default.fromLonLat([0, 0])
      }, zoomConfig))
    });
    return map;
  };
  /**
  * This function return openlayers map instance for print
  * @returns {ol.Map}
  */


  BasicViewerHelper.prototype.getPrintMap = function getPrintMap() {
    var map = new _map2.default({
      interactions: _interaction2.default.defaults({
        doubleClickZoom: false,
        mouseWheelZoom: false,
        shiftDragZoom: false,
        pinchZoom: false
      }),
      controls: [],
      layers: [new _tile2.default({
        title: 'OpenStreetMap',
        source: new _osm2.default()
      })],
      loadTilesWhileInteracting: true,
      view: new _view2.default({
        center: _proj2.default.fromLonLat([0, 0]),
        minZoom: 1,
        zoom: 2,
        maxZoom: 19
      })
    });
    map.addControl(new _scaleline2.default());
    return map;
  };
  /**
  * This function fit map view to point or coordinate
  * @param {Array.<Number>} pointArray
  * @param {ol.Map} map
  * @param {Boolean} changeZoom
  * @returns {void}
  */


  BasicViewerHelper.prototype.zoomToLocation = function zoomToLocation(pointArray, map) {
    var changeZoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var zoom = map.getView().getMaxZoom();
    var lonLat = this.reprojectLocation(pointArray, map);
    map.getView().setCenter(lonLat);

    if (changeZoom) {
      map.getView().setZoom(zoom - 4);
    }
  };
  /**
  * This function reproject coordinates from projection to map projection
  * @param {Array.<Number>} pointArray
  * @param {ol.Map} map
  * @param {string|ol.ProjectionLike} from
  * @returns {Array.<Number>}
  */


  BasicViewerHelper.prototype.reprojectLocation = function reprojectLocation(pointArray, map) {
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:4326';
    /**
     * Reproject x,y .
     * @constructor
     * @param {array} point - [longitude,latitude].
     */

    var mapProjection = map.getView().getProjection();

    if (from instanceof _projection2.default) {
      from = from.getCode();
    }

    return _proj2.default.transform(pointArray, from, mapProjection);
  };
  /**
  * This function reproject extent from projection to map projection
  * @param {ol.Extent} extent
  * @param {ol.Map} map
  * @param {string|ol.ProjectionLike} from
  * @returns {ol.Extent}
  */


  BasicViewerHelper.prototype.reprojectExtent = function reprojectExtent(extent, map) {
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:4326';
    /**
     * Reproject extent .
     * @constructor
     * @param {array} extent - [minX,minY,maxX,maxY].
     */

    var mapProjection = map.getView().getProjection();

    if (from instanceof _projection2.default) {
      from = from.getCode();
    }

    var transformedExtent = from === mapProjection.getCode() ? extent : _proj2.default.transformExtent(extent, from, mapProjection);
    return transformedExtent;
  };
  /**
  * This function fit map view to extent
  * @param {ol.Extent} extent
  * @param {ol.Map} map
  * @param {Number} duration
  * @returns {void}
  */


  BasicViewerHelper.prototype.fitExtent = function fitExtent(extent, map) {
    var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    map.getView().fit(extent, map.getSize(), {
      duration: duration
    });
  };
  /**
  * This function save map as png
  * @param {ol.Map} map
  * @returns {void}
  */


  BasicViewerHelper.prototype.exportMap = function exportMap(map) {
    map.once('postcompose', function (event) {
      var canvas = event.context.canvas;

      if (navigator.msSaveBlob) {
        navigator.msSaveBlob(canvas.msToBlob(), 'map.png');
      } else {
        canvas.toBlob(function (blob) {
          _fileSaver2.default.saveAs(blob, 'map.png');
        });
      }
    });
    map.renderSync();
  };

  return BasicViewerHelper;
}();

exports.default = new BasicViewerHelper();

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/FeaturesHelper.js":
/*!**************************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/FeaturesHelper.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureHelper = exports.wmsGetFeatureInfoFormats = undefined;

var _utils = __webpack_require__(/*! ../utils/utils */ "./node_modules/cartoview-sdk/utils/utils.js");

var _BasicViewerHelper = __webpack_require__(/*! ./BasicViewerHelper */ "./node_modules/cartoview-sdk/helpers/BasicViewerHelper.js");

var _BasicViewerHelper2 = _interopRequireDefault(_BasicViewerHelper);

var _geojson = __webpack_require__(/*! ol/format/geojson */ "./node_modules/ol/format/geojson.js");

var _geojson2 = _interopRequireDefault(_geojson);

var _LayersHelper = __webpack_require__(/*! ./LayersHelper */ "./node_modules/cartoview-sdk/helpers/LayersHelper.js");

var _LayersHelper2 = _interopRequireDefault(_LayersHelper);

var _urls = __webpack_require__(/*! ../urls/urls */ "./node_modules/cartoview-sdk/urls/urls.js");

var _urls2 = _interopRequireDefault(_urls);

var _wmsgetfeatureinfo = __webpack_require__(/*! ol/format/wmsgetfeatureinfo */ "./node_modules/ol/format/wmsgetfeatureinfo.js");

var _wmsgetfeatureinfo2 = _interopRequireDefault(_wmsgetfeatureinfo);

var _proj = __webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/** @constant wmsGetFeatureInfoFormats
    @type {Object}
    @default
*/


var wmsGetFeatureInfoFormats = exports.wmsGetFeatureInfoFormats = {
  'application/json': new _geojson2.default(),
  'application/vnd.ogc.gml': new _wmsgetfeatureinfo2.default()
  /** Class for Features manipulation */

};

var FeatureHelper = exports.FeatureHelper = function () {
  function FeatureHelper() {
    _classCallCheck(this, FeatureHelper);
  }
  /**
  * This function return openlayers format
  * @param {string} format desired format one of application/json or application/vnd.ogc.gml
  * @returns {ol.format} instance of openlayers format
  */


  FeatureHelper.prototype.getFormat = function getFormat(format) {
    return wmsGetFeatureInfoFormats[format];
  };
  /**
  * This function return feature info url
  * @param {ol.layer} layer openlayers layer to get url from
  * @param {ol.Coordinate} coordinate coordinate 
  * @param {ol.View} view view  map view
  * @param {ol.format} infoFormat format of result
  * @param {string} [token=null] user access token
  * @param {number} [featureCount=null] max number of features to return
  * @returns {string}
  */


  FeatureHelper.prototype.getFeatureInfoUrl = function getFeatureInfoUrl(layer, coordinate, view, infoFormat) {
    var token = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var featureCount = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;
    var resolution = view.getResolution(),
        projection = view.getProjection();
    var url = layer.getSource().getGetFeatureInfoUrl(coordinate, resolution, projection, {
      'INFO_FORMAT': infoFormat
    });
    var query = {
      "FEATURE_COUNT": featureCount
    };

    if (token) {
      query.access_token = token;
    }

    var paramterizedURL = new _urls2.default(null).getParamterizedURL(url, query);
    return paramterizedURL;
  };

  FeatureHelper.prototype.getFeatureByURL = function getFeatureByURL() {
    var proxyURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var url = arguments[1];
    var proxiedURL = new _urls2.default(proxyURL).getProxiedURL(url);
    return (0, _utils.doGet)(proxiedURL);
  };
  /**
  * This function return feature after removing hidden attributes
  * @param {ol.Feature} feature
  * @typedef {Object} Attribute
  * @property {string} attribute - attribute name
  * @property {string|null} attribute_label - attribute label
  * @property {string|null} attribute_type - attribute type geoserver attribute type
  * @property {bool} visible - attribute type geoserver attribute type
  * @param {Array.<Attribute>} features to be transformed 
  * @returns {ol.Feature}
  */


  FeatureHelper.prototype._flagHidden = function _flagHidden(feature) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var hidden = [];
    attributes.filter(function (attr) {
      return attr.visible === false && !attr.attribute_type.includes('gml');
    }).forEach(function (attr) {
      hidden.push(attr.attribute);
    }, this);
    feature.set('_hiddenAttrs', hidden);
    return feature;
  };
  /**
  * This function return feature info url
  * @param {ol.layer} layer openlayers layer to get url from
  * @param {Array.<ol.Feature>} features to be transformed 
  * @param {ol.Map} map openlayers map instance
  * @param {Number} crs target Projection
  * @param {Array} [attributes=[]] Layer Attributes
  * @returns {Array.<ol.Feature>}
  */


  FeatureHelper.prototype.transformFeatures = function transformFeatures(layer, features, map, crs) {
    var _this = this;

    var attributes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    var transformedFeatures = [];
    features.forEach(function (f) {
      var feature = _this._flagHidden(f, attributes);

      feature.getGeometry().transform('EPSG:' + crs, map.getView().getProjection());

      if (attributes && attributes.length > 0) {
        var attributesAlias = {};
        attributes.filter(function (attr) {
          return attr.visible;
        }).map(function (metaAttr) {
          return attributesAlias[metaAttr.attribute] = metaAttr.attribute_label;
        });
        feature.set("_attributesAlias", attributesAlias);
      }

      feature.set("_layerTitle", layer.get('title'));
      feature.set("_layerName", layer.get('name'));
      transformedFeatures.push(feature);
    });
    return transformedFeatures;
  };
  /**
  * This function return feature info url
  * @param {string} metaAtrributesURL layer attributes api url
  * @returns {Promise}
  */


  FeatureHelper.prototype.getAtrributes = function getAtrributes(metaAtrributesURL) {
    return (0, _utils.doGet)(metaAtrributesURL);
  };

  FeatureHelper.prototype.getCoordsCenter = function getCoordsCenter(coords) {
    if (coords.length === 2 && typeof coords[0] === "number") {
      return coords;
    }

    return this.getCoordsCenter(coords[Math.floor(coords.length / 2)]);
  };
  /**
  * This function return center of geometry
  * @param {ol.geom} geometry layer attributes api url
  * @returns {Array.<Number>}
  */


  FeatureHelper.prototype.getGeometryCenter = function getGeometryCenter(geometry) {
    var type = geometry.getType();
    var center = null;

    switch (type) {
      case 'LineString':
        {
          var coords = geometry.getCoordinates();
          center = this.getCoordsCenter(coords);
          break;
        }

      case 'MultiLineString':
        {
          var _coords = geometry.getCoordinates();

          center = this.getCoordsCenter(_coords);
          break;
        }

      default:
        {
          var extent = geometry.getExtent();
          center = _BasicViewerHelper2.default.getCenterOfExtent(extent);
          break;
        }
    }

    return center;
  };
  /**
  * This function used to identify features
  * @param {ol.Map} map openlayers map instance
  * @param {ol.Coordinate} coordinate coordinate 
  * @param {string} [proxyURL=null] view  map view
  * @param {string} [token=null] user access token
  * @param {string} [metaAtrributesURL=null] layer atrributes api url
  * @returns {Array.<ol.Feature>}
  */


  FeatureHelper.prototype.featureIdentify = function featureIdentify(map, coordinate) {
    var proxyURL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var _this2 = this;

    var token = arguments[3];
    var metaAtrributesURL = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var view = map.getView();

    var layers = _LayersHelper2.default.getLayers(map.getLayers().getArray()).reverse();

    var identifyPromises = layers.map(function (layer) {
      var attributes = [];
      var layerName = layer.get("name");
      var identifyPromiseHandler = new Promise(function (resolve, reject) {
        if (metaAtrributesURL) {
          _this2.getAtrributes(metaAtrributesURL + "?layer__typename=" + layerName).then(function (metaAttributes) {
            attributes = metaAttributes.objects;

            _this2.readFeaturesThenTransform(proxyURL, layer, coordinate, view, map, token, attributes).then(function (result) {
              resolve(result);
            }).catch(function (err) {
              console.error('Layer ' + layerName + ' => Feature Identify Error:', err);
              resolve([]);
            });
          });
        } else {
          _this2.readFeaturesThenTransform(proxyURL, layer, coordinate, view, map, token, attributes).then(function (result) {
            resolve(result);
          }).catch(function (err) {
            console.error('Layer ' + layerName + ' => Feature Identify Error:', err);
            resolve([]);
          });
        }
      });
      return identifyPromiseHandler;
    });
    var identifyAllPromise = new Promise(function (resolve, reject) {
      Promise.all(identifyPromises).then(function (result) {
        var featureIdentifyResult = result.reduce(function (array1, array2) {
          return array1.concat(array2);
        }, []); //sort features based on layer order

        var sortedFeatures = [];
        layers.forEach(function (lyr) {
          var layerName = lyr.get('name');
          featureIdentifyResult.map(function (f) {
            var featureLayer = f.get('_layerName');

            if (layerName === featureLayer) {
              sortedFeatures.push(f);
            }
          });
        }, _this2);
        resolve(sortedFeatures);
      });
    });
    return identifyAllPromise;
  };
  /**
  * This function check if crs defiend or not , if not defined if define the crs and return it back
  * @param {Number} crs projection number e.g 4326
  * @returns {Promise}
  */


  FeatureHelper.prototype.getCRS = function getCRS(crs) {
    var promise = new Promise(function (resolve, reject) {
      if (_proj2.default.defs('EPSG:' + crs)) {
        resolve(crs);
      } else {
        (0, _utils.doExternalGet)('https://epsg.io/?format=json&q=' + crs).then(function (projres) {
          _proj2.default.defs('EPSG:' + crs, projres.results[0].proj4);

          resolve(crs);
        }).catch(function (err) {
          reject(err);
        });
      }
    });
    return promise;
  };
  /**
  * This function return feature info url
  * @param {string} [proxyURL=null] user access token
  * @param {ol.layer} layer openlayers layer to get url from
  * @param {ol.Coordinate} coordinate coordinate 
  * @param {ol.View} view view  map view
  * @param {ol.Map} map openlayers map instance
  * @param {string} user access token
  * @param {Array} attributes layer attributes
  * @returns {Array.<ol.Feature>}
  */


  FeatureHelper.prototype.readFeaturesThenTransform = function readFeaturesThenTransform() {
    var proxyURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var layer = arguments[1];
    var coordinate = arguments[2];
    var view = arguments[3];
    var map = arguments[4];

    var _this3 = this;

    var token = arguments[5];
    var attributes = arguments[6];
    var url = this.getFeatureInfoUrl(layer, coordinate, view, 'application/json', token);
    return this.getFeatureByURL(proxyURL, url).then(function (result) {
      var promise = new Promise(function (resolve, reject) {
        var features = wmsGetFeatureInfoFormats['application/json'].readFeatures(result);

        if (features.length > 0) {
          var crs = result.features.length > 0 ? result.crs.properties.name.split(":").pop() : null;

          _this3.getCRS(crs).then(function (newCRS) {
            var transformedFeatures = _this3.transformFeatures(layer, features, map, newCRS, attributes);

            resolve(transformedFeatures);
          }, function (error) {
            reject(error);
          });
        } else {
          resolve([]);
        }
      });
      return promise;
    });
  };

  return FeatureHelper;
}();

exports.default = new FeatureHelper();

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/LayersHelper.js":
/*!************************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/LayersHelper.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayersHelper = undefined;

var _AnimationHelper = __webpack_require__(/*! ./AnimationHelper */ "./node_modules/cartoview-sdk/helpers/AnimationHelper.js");

var _AnimationHelper2 = _interopRequireDefault(_AnimationHelper);

var _geojson = __webpack_require__(/*! ol/format/geojson */ "./node_modules/ol/format/geojson.js");

var _geojson2 = _interopRequireDefault(_geojson);

var _group = __webpack_require__(/*! ol/layer/group */ "./node_modules/ol/layer/group.js");

var _group2 = _interopRequireDefault(_group);

var _imagewms = __webpack_require__(/*! ol/source/imagewms */ "./node_modules/ol/source/imagewms.js");

var _imagewms2 = _interopRequireDefault(_imagewms);

var _tilewms = __webpack_require__(/*! ol/source/tilewms */ "./node_modules/ol/source/tilewms.js");

var _tilewms2 = _interopRequireDefault(_tilewms);

var _urls = __webpack_require__(/*! ../urls/urls */ "./node_modules/cartoview-sdk/urls/urls.js");

var _urls2 = _interopRequireDefault(_urls);

var _vector = __webpack_require__(/*! ol/source/vector */ "./node_modules/ol/source/vector.js");

var _vector2 = _interopRequireDefault(_vector);

var _vector3 = __webpack_require__(/*! ol/layer/vector */ "./node_modules/ol/layer/vector.js");

var _vector4 = _interopRequireDefault(_vector3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/** Class for Layers manipulation */


var LayersHelper = exports.LayersHelper = function () {
  function LayersHelper() {
    _classCallCheck(this, LayersHelper);
  }
  /**
  * this function check if layer is a wms layer
  * @param {ol.layer} layer to be checked if it is wms layer or not
  * @returns {bool}
  */


  LayersHelper.prototype.isWMSLayer = function isWMSLayer(layer) {
    return layer.getSource() instanceof _tilewms2.default || layer.getSource() instanceof _imagewms2.default;
  };
  /**
  * this function return layer name from geoserver typename
  * @param {string} typeName layer typename
  * @returns {string} layer name
  */


  LayersHelper.prototype.layerName = function layerName(typeName) {
    return typeName.split(":").pop();
  };
  /**
  * this function return layer namespace/workspace from geoserver typename
  * @param {string} typeName layer typename
  * @returns {string} namespace/workspace
  */


  LayersHelper.prototype.layerNameSpace = function layerNameSpace(typeName) {
    return typeName.split(":")[0];
  };
  /**
  * this function return layer namespace/workspace from geoserver typename
  * @param {ol.layer} layer layer object
  * @param {string} [accessToken=null] the geoserver accessToken 
  * @param {string} [proxy=null] geoserver proxy(geonode proxy)
  * @returns {string} layer url
  */


  LayersHelper.prototype.getLayerURL = function getLayerURL(layer) {
    var accessToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var proxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var wmsURL = null;

    try {
      wmsURL = layer.getSource().getUrls()[0];
    } catch (err) {
      wmsURL = layer.getSource().getUrl();
    }

    return !accessToken ? wmsURL : new _urls2.default(proxy).getParamterizedURL(wmsURL, {
      'access_token': accessToken
    });
  };
  /**
  * this function return layer namespace/workspace from geoserver typename
  * @param {ol.Map} layer layer object
  * @returns {Array} map local layers (i.e layers without base layers)
  */


  LayersHelper.prototype.getLocalLayers = function getLocalLayers(map) {
    var _this = this;

    var layers = [];
    map.getLayers().getArray().map(function (layer) {
      if (!(layer instanceof _group2.default) && layer.get('type') !== 'base-group') {
        layers.push(layer);
      } else if (layer instanceof _group2.default && layer.get('type') !== 'base-group') {
        layers.push.apply(layers, _toConsumableArray(_this.getLocalLayers(layer)));
      }
    });
    return layers.slice(0).reverse();
  };
  /**
  * this function return layer namespace/workspace from geoserver typename
  * @param {ol.Map} layer layer object
  * @returns {Array} map base layers (ex:osm)
  */


  LayersHelper.prototype.getBaseLayers = function getBaseLayers(map) {
    var layers = [];
    map.getLayers().getArray().map(function (layer) {
      if (layer instanceof _group2.default && layer.get('type') === 'base-group') {
        layer.getLayers().getArray().map(function (lyr) {
          return layers.push(lyr);
        });
      }
    });
    return layers.slice(0).reverse();
  };
  /**
  * this function return legends of layers 
  * @param {Array.<ol.layer>} layer local layers
  * @param {string} accessToken is the geoserver access token
  * @param {string} proxy is the geoserver proxy/geonode proxy
  * @typedef {Object} Legend
  * @property {string} layer - The title of the layer
  * @property {string} url - The url of the legend
  * @returns {Array.<Legend>} array of Legend
  */


  LayersHelper.prototype.getLegends = function getLegends(layers, accessToken) {
    var _this2 = this;

    var proxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var legends = [];
    layers.map(function (layer) {
      if (layer.getVisible()) {
        var layerTitle = layer.getProperties().title;
        legends.push({
          layer: layerTitle,
          url: _this2.getLegendURL(layer, accessToken, proxy)
        });
      }
    });
    return legends;
  };
  /**
  * this function return legend for layer 
  * @param {ol.layer} layer local layers
  * @param {string} accessToken is the geoserver access token
  * @param {string} proxy is the geoserver proxy/geonode proxy
  * @typedef {Object} Legend
  * @property {string} layer - The title of the layer
  * @property {string} url - The url of the legend
  * @returns {Legend} layer legend object
  */


  LayersHelper.prototype.getLegendURL = function getLegendURL(layer, accessToken) {
    var proxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var wmsURL = this.getLayerURL(layer, accessToken);
    var query = {
      'REQUEST': 'GetLegendGraphic',
      'VERSION': '1.0.0',
      'FORMAT': 'image/png',
      "LAYER": layer.getProperties().name
    };
    var url = new _urls2.default(proxy).getParamterizedURL(wmsURL, query);
    return url;
  };

  LayersHelper.prototype.addSelectionLayer = function addSelectionLayer(map, featureCollection, styleFunction) {
    var source = new _vector2.default({
      features: featureCollection
    });
    new _vector4.default({
      source: source,
      style: styleFunction,
      title: "Selected Features",
      zIndex: 10000,
      format: new _geojson2.default({
        defaultDataProjection: map.getView().getProjection(),
        featureProjection: map.getView().getProjection()
      }),
      map: map
    });
    source.on('addfeature', function (e) {
      _AnimationHelper2.default.flash(e.feature, map);
    });
  };
  /**
  * this function return map WMS layers from map layers
  * @param {Array.<ol.layer>} mapLayers local layers
  * @returns {Array.<ol.layer>} array of WMS Layers
  */


  LayersHelper.prototype.getLayers = function getLayers(mapLayers) {
    var _this3 = this;

    var children = [];
    mapLayers.forEach(function (layer) {
      if (layer instanceof _group2.default) {
        children = children.concat(_this3.getLayers(layer.getLayers()));
      } else if (layer.getVisible() && _this3.isWMSLayer(layer)) {
        children.push(layer);
      }
    });
    return children;
  };
  /**
  * this function search for a WMS layer with name
  * @param {string} name LayerName
  * @returns {ol.layer|null}
  */


  LayersHelper.prototype.getWMSLayer = function getWMSLayer(name, layers) {
    var _this4 = this;

    var wmsLayer = null;
    layers.forEach(function (layer) {
      if (layer instanceof _group2.default) {
        wmsLayer = _this4.getWMSLayer(name, layer.getLayers());
      } else if (_this4.isWMSLayer(layer) && layer.getSource().getParams().LAYERS == name) {
        wmsLayer = layer;
      }

      if (wmsLayer) {
        return false;
      }
    });
    return wmsLayer;
  };

  return LayersHelper;
}();

exports.default = new LayersHelper();

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/StyleHelper.js":
/*!***********************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/StyleHelper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _circle = __webpack_require__(/*! ol/style/circle */ "./node_modules/ol/style/circle.js");

var _circle2 = _interopRequireDefault(_circle);

var _fill = __webpack_require__(/*! ol/style/fill */ "./node_modules/ol/style/fill.js");

var _fill2 = _interopRequireDefault(_fill);

var _icon = __webpack_require__(/*! ol/style/icon */ "./node_modules/ol/style/icon.js");

var _icon2 = _interopRequireDefault(_icon);

var _stroke = __webpack_require__(/*! ol/style/stroke */ "./node_modules/ol/style/stroke.js");

var _stroke2 = _interopRequireDefault(_stroke);

var _style = __webpack_require__(/*! ol/style/style */ "./node_modules/ol/style/style.js");

var _style2 = _interopRequireDefault(_style);

var _text = __webpack_require__(/*! ol/style/text */ "./node_modules/ol/style/text.js");

var _text2 = _interopRequireDefault(_text);

var _randomcolor = __webpack_require__(/*! randomcolor */ "./node_modules/randomcolor/randomColor.js");

var _randomcolor2 = _interopRequireDefault(_randomcolor);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/**
* this function return image Style
* @returns {ol.style}
*/


function getImageStyle() {
  var fill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return new _circle2.default({
    radius: 5,
    fill: fill,
    stroke: new _stroke2.default({
      color: 'black',
      width: 2
    })
  });
}
/**
* this function return opaque bright color(rgb) as string
* @returns {string}
*/


function randomBright() {
  return (0, _randomcolor2.default)({
    luminosity: 'bright',
    format: 'rgb'
  });
}
/**
* this function return transparent bright color(rgba) as string
* @returns {string}
*/


function randomBrightTrans() {
  return (0, _randomcolor2.default)({
    luminosity: 'bright',
    format: 'rgba',
    alpha: 0.4
  });
}
/**
* this function return opaque dark color(rgba) as string
* @returns {string}
*/


function randomDark() {
  return (0, _randomcolor2.default)({
    luminosity: 'dark',
    format: 'rgba',
    alpha: 1
  });
}
/**
* this function return transparent dark color(rgba) as string
* @returns {string}
*/


function randomDarkTrans() {
  return (0, _randomcolor2.default)({
    luminosity: 'dark',
    format: 'rgba',
    alpha: 0.4
  });
}
/** @constant styles
    @type {Object}
    @default
*/


var styles = {
  'Point': function Point() {
    var rc = randomDark();
    return new _style2.default({
      image: getImageStyle(new _fill2.default({
        color: rc
      }))
    });
  },
  'LineString': function LineString() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: randomDark(),
        width: 2
      })
    });
  },
  'MultiLineString': function MultiLineString() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: randomBright(),
        width: 2
      })
    });
  },
  'MultiPoint': function MultiPoint() {
    var rc = randomDark();
    return new _style2.default({
      image: getImageStyle(new _fill2.default({
        color: rc
      }))
    });
  },
  'MultiPolygon': function MultiPolygon() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: 'black',
        width: 2
      }),
      fill: new _fill2.default({
        color: randomBrightTrans()
      })
    });
  },
  'Polygon': function Polygon() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: 'black',
        lineDash: [4],
        width: 3
      }),
      fill: new _fill2.default({
        color: randomBrightTrans()
      })
    });
  },
  'GeometryCollection': function GeometryCollection() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: 'black',
        width: 2
      }),
      fill: new _fill2.default({
        color: randomBrightTrans()
      }),
      image: new _circle2.default({
        radius: 10,
        fill: null,
        stroke: new _stroke2.default({
          color: 'black'
        })
      })
    });
  },
  'Circle': function Circle() {
    return new _style2.default({
      stroke: new _stroke2.default({
        color: 'black',
        width: 2
      }),
      fill: new _fill2.default({
        color: randomBrightTrans()
      })
    });
  }
};

var StylesGenerator = function () {
  function StylesGenerator() {
    _classCallCheck(this, StylesGenerator);

    this._stylesCache = {};
  }

  StylesGenerator.prototype.getStyle = function getStyle(geometryType) {
    if (this._stylesCache[geometryType]) {
      return this._stylesCache[geometryType];
    }

    this._stylesCache[geometryType] = styles[geometryType]();
    return this._stylesCache[geometryType];
  };

  return StylesGenerator;
}();

var generator = new StylesGenerator();
/** Class for Styles manipulation */

var StyleHelper = function () {
  /**
  * Create a StyleHelper instance.
  * @param {string} [iconImage="https://openlayers.org/en/v4.6.5/examples/data/icon.png"] default marker icon
  */
  function StyleHelper() {
    var iconImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "https://openlayers.org/en/v4.6.5/examples/data/icon.png";

    _classCallCheck(this, StyleHelper);

    this.icon = iconImage;
  }
  /**
  * this function feature styles based on geometry type
  * @param {ol.Feature} feature feature you want to get style for it
  * @returns {ol.style}
  */


  StyleHelper.prototype.styleFunction = function styleFunction(feature) {
    var style = feature ? generator.getStyle(feature.getGeometry().getType()) : null;
    return style;
  };
  /**
  * this function marker style
  * @returns {ol.style}
  */


  StyleHelper.prototype.getMarker = function getMarker() {
    var marker = new _style2.default({
      image: new _icon2.default({
        anchor: [0.5, 31],
        anchorXUnits: 'fraction',
        anchorYUnits: 'pixels',
        src: this.icon
      }),
      text: new _text2.default({
        text: '+',
        fill: new _fill2.default({
          color: '#fff'
        }),
        stroke: new _stroke2.default({
          color: '#fff',
          width: 2
        }),
        textAlign: 'center',
        offsetY: -20,
        font: '18px serif'
      })
    });
    return marker;
  };

  return StyleHelper;
}();

exports.default = StyleHelper;

/***/ }),

/***/ "./node_modules/cartoview-sdk/helpers/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/cartoview-sdk/helpers/helpers.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCRSFToken = getCRSFToken;
exports.hasTrailingSlash = hasTrailingSlash;
exports.removeTrailingSlash = removeTrailingSlash;
/**
 * this function get django csrf token from cookie
 * @returns {string} return django csrf token
 */

function getCRSFToken() {
  var csrfToken = void 0,
      csrfMatch = document.cookie.match(/csrftoken=(\w+)/);

  if (csrfMatch && csrfMatch.length > 0) {
    csrfToken = csrfMatch[1];
  }

  return csrfToken;
}
/**
 * this function check if URL has a slash at the end
 * @param {string} str url to check
 * @returns {bool} return true if has Trailing Slash, false if not
 */


function hasTrailingSlash(str) {
  return /.*\/$/.test(str);
}
/**
 * this function check if URL has a slash at the end
 * @param {string} str url to remove slash from
 * @returns {string}
 */


function removeTrailingSlash(str) {
  return hasTrailingSlash(str) ? str.slice(0, -1) : str;
}

/***/ }),

/***/ "./node_modules/cartoview-sdk/services/LayerIdService.js":
/*!***************************************************************!*\
  !*** ./node_modules/cartoview-sdk/services/LayerIdService.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/*
 * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
 */


var LayerIdService = function () {
  function LayerIdService() {
    _classCallCheck(this, LayerIdService);

    this._counter = 0;
  }

  LayerIdService.prototype.generateId = function generateId() {
    this._counter++;
    return 'sdk-layer-' + this._counter;
  };

  return LayerIdService;
}();

exports.default = new LayerIdService();

/***/ }),

/***/ "./node_modules/cartoview-sdk/services/MapConfigService.js":
/*!*****************************************************************!*\
  !*** ./node_modules/cartoview-sdk/services/MapConfigService.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sources = undefined;

var _attribution = __webpack_require__(/*! ol/attribution */ "./node_modules/ol/attribution.js");

var _attribution2 = _interopRequireDefault(_attribution);

var _base = __webpack_require__(/*! ol/layer/base */ "./node_modules/ol/layer/base.js");

var _base2 = _interopRequireDefault(_base);

var _bingmaps = __webpack_require__(/*! ol/source/bingmaps */ "./node_modules/ol/source/bingmaps.js");

var _bingmaps2 = _interopRequireDefault(_bingmaps);

var _cartodb = __webpack_require__(/*! ol/source/cartodb */ "./node_modules/ol/source/cartodb.js");

var _cartodb2 = _interopRequireDefault(_cartodb);

var _cluster = __webpack_require__(/*! ol/source/cluster */ "./node_modules/ol/source/cluster.js");

var _cluster2 = _interopRequireDefault(_cluster);

var _geojson = __webpack_require__(/*! ol/format/geojson */ "./node_modules/ol/format/geojson.js");

var _geojson2 = _interopRequireDefault(_geojson);

var _group = __webpack_require__(/*! ol/layer/group */ "./node_modules/ol/layer/group.js");

var _group2 = _interopRequireDefault(_group);

var _heatmap = __webpack_require__(/*! ol/layer/heatmap */ "./node_modules/ol/layer/heatmap.js");

var _heatmap2 = _interopRequireDefault(_heatmap);

var _image = __webpack_require__(/*! ol/layer/image */ "./node_modules/ol/layer/image.js");

var _image2 = _interopRequireDefault(_image);

var _imagearcgisrest = __webpack_require__(/*! ol/source/imagearcgisrest */ "./node_modules/ol/source/imagearcgisrest.js");

var _imagearcgisrest2 = _interopRequireDefault(_imagearcgisrest);

var _imagecanvas = __webpack_require__(/*! ol/source/imagecanvas */ "./node_modules/ol/source/imagecanvas.js");

var _imagecanvas2 = _interopRequireDefault(_imagecanvas);

var _imagemapguide = __webpack_require__(/*! ol/source/imagemapguide */ "./node_modules/ol/source/imagemapguide.js");

var _imagemapguide2 = _interopRequireDefault(_imagemapguide);

var _imagestatic = __webpack_require__(/*! ol/source/imagestatic */ "./node_modules/ol/source/imagestatic.js");

var _imagestatic2 = _interopRequireDefault(_imagestatic);

var _imagevector = __webpack_require__(/*! ol/source/imagevector */ "./node_modules/ol/source/imagevector.js");

var _imagevector2 = _interopRequireDefault(_imagevector);

var _imagewms = __webpack_require__(/*! ol/source/imagewms */ "./node_modules/ol/source/imagewms.js");

var _imagewms2 = _interopRequireDefault(_imagewms);

var _layer = __webpack_require__(/*! ol/layer/layer */ "./node_modules/ol/layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _LayerIdService = __webpack_require__(/*! ./LayerIdService */ "./node_modules/cartoview-sdk/services/LayerIdService.js");

var _LayerIdService2 = _interopRequireDefault(_LayerIdService);

var _osm = __webpack_require__(/*! ol/source/osm */ "./node_modules/ol/source/osm.js");

var _osm2 = _interopRequireDefault(_osm);

var _raster = __webpack_require__(/*! ol/source/raster */ "./node_modules/ol/source/raster.js");

var _raster2 = _interopRequireDefault(_raster);

var _source = __webpack_require__(/*! ol/source/source */ "./node_modules/ol/source/source.js");

var _source2 = _interopRequireDefault(_source);

var _image3 = __webpack_require__(/*! ol/source/image */ "./node_modules/ol/source/image.js");

var _image4 = _interopRequireDefault(_image3);

var _tile = __webpack_require__(/*! ol/source/tile */ "./node_modules/ol/source/tile.js");

var _tile2 = _interopRequireDefault(_tile);

var _vector = __webpack_require__(/*! ol/source/vector */ "./node_modules/ol/source/vector.js");

var _vector2 = _interopRequireDefault(_vector);

var _vectortile = __webpack_require__(/*! ol/source/vectortile */ "./node_modules/ol/source/vectortile.js");

var _vectortile2 = _interopRequireDefault(_vectortile);

var _stamen = __webpack_require__(/*! ol/source/stamen */ "./node_modules/ol/source/stamen.js");

var _stamen2 = _interopRequireDefault(_stamen);

var _tile3 = __webpack_require__(/*! ol/layer/tile */ "./node_modules/ol/layer/tile.js");

var _tile4 = _interopRequireDefault(_tile3);

var _tilearcgisrest = __webpack_require__(/*! ol/source/tilearcgisrest */ "./node_modules/ol/source/tilearcgisrest.js");

var _tilearcgisrest2 = _interopRequireDefault(_tilearcgisrest);

var _tiledebug = __webpack_require__(/*! ol/source/tiledebug */ "./node_modules/ol/source/tiledebug.js");

var _tiledebug2 = _interopRequireDefault(_tiledebug);

var _tileimage = __webpack_require__(/*! ol/source/tileimage */ "./node_modules/ol/source/tileimage.js");

var _tileimage2 = _interopRequireDefault(_tileimage);

var _tilejson = __webpack_require__(/*! ol/source/tilejson */ "./node_modules/ol/source/tilejson.js");

var _tilejson2 = _interopRequireDefault(_tilejson);

var _tileutfgrid = __webpack_require__(/*! ol/source/tileutfgrid */ "./node_modules/ol/source/tileutfgrid.js");

var _tileutfgrid2 = _interopRequireDefault(_tileutfgrid);

var _tilewms = __webpack_require__(/*! ol/source/tilewms */ "./node_modules/ol/source/tilewms.js");

var _tilewms2 = _interopRequireDefault(_tilewms);

var _urls = __webpack_require__(/*! ../urls/urls */ "./node_modules/cartoview-sdk/urls/urls.js");

var _urls2 = _interopRequireDefault(_urls);

var _vector3 = __webpack_require__(/*! ol/layer/vector */ "./node_modules/ol/layer/vector.js");

var _vector4 = _interopRequireDefault(_vector3);

var _vectortile3 = __webpack_require__(/*! ol/layer/vectortile */ "./node_modules/ol/layer/vectortile.js");

var _vectortile4 = _interopRequireDefault(_vectortile3);

var _view = __webpack_require__(/*! ol/view */ "./node_modules/ol/view.js");

var _view2 = _interopRequireDefault(_view);

var _wmts = __webpack_require__(/*! ol/source/wmts */ "./node_modules/ol/source/wmts.js");

var _wmts2 = _interopRequireDefault(_wmts);

var _xyz = __webpack_require__(/*! ol/source/xyz */ "./node_modules/ol/source/xyz.js");

var _xyz2 = _interopRequireDefault(_xyz);

var _zoomify = __webpack_require__(/*! ol/source/zoomify */ "./node_modules/ol/source/zoomify.js");

var _zoomify2 = _interopRequireDefault(_zoomify);

var _proj = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/*
 * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
 */


var sources = exports.sources = {
  'BingMaps': _bingmaps2.default,
  'CartoDB': _cartodb2.default,
  'Cluster': _cluster2.default,
  'Image': _image4.default,
  'ImageArcGISRest': _imagearcgisrest2.default,
  'ImageCanvas': _imagecanvas2.default,
  'ImageMapGuide': _imagemapguide2.default,
  'ImageStatic': _imagestatic2.default,
  'ImageVector': _imagevector2.default,
  'ImageWMS': _imagewms2.default,
  'Stamen': _stamen2.default,
  'Raster': _raster2.default,
  'Source': _source2.default,
  'Tile': _tile2.default,
  'TileArcGISRest': _tilearcgisrest2.default,
  'TileDebug': _tiledebug2.default,
  'TileImage': _tileimage2.default,
  'TileJSON': _tilejson2.default,
  'TileUTFGrid': _tileutfgrid2.default,
  'TileWMS': _tilewms2.default,
  'Zoomify': _zoomify2.default,
  'SourceVectorTile': _vectortile2.default,
  'WMTS': _wmts2.default,
  'OSM': _osm2.default,
  'XYZ': _xyz2.default,
  'Vector': _vector2.default
};
var layersMaping = {
  'Tile': _tile4.default,
  'Group': _group2.default,
  'Base': _base2.default,
  'Heatmap': _heatmap2.default,
  'Image': _image2.default,
  'Layer': _layer2.default,
  'Vector': _vector4.default,
  'VectorTile': _vectortile4.default
};

var MapConfigService = function () {
  function MapConfigService() {
    _classCallCheck(this, MapConfigService);
  }

  MapConfigService.prototype.generateSourceFromConfig = function generateSourceFromConfig(map, config, opt_proxy, access_token, opt_wfsUrl, opt_wfsTypeName) {
    var props = config.properties || {};

    if (props.attributions) {
      var attributions = [];

      for (var i = 0, ii = props.attributions.length; i < ii; ++i) {
        attributions.push(new _attribution2.default({
          html: props.attributions[i]
        }));
      }

      props.attributions = attributions;
    }

    props.wrapX = true;

    if (config.type === 'Cluster') {
      props.source = this.generateSourceFromConfig(map, config.source, opt_proxy, access_token, opt_wfsUrl, opt_wfsTypeName);
    }

    if (config.type === 'TMS') {
      config.type = 'XYZ';
      var urls = props.urls || [props.url];

      props.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
        var min = 0;
        var max = urls.length - 1;
        var idx = Math.floor(Math.random() * (max - min + 1)) + min;
        var x, y, z;
        z = tileCoord[0];
        x = tileCoord[1];
        y = tileCoord[2] + (1 << z);
        return urls[idx] + z + '/' + x + '/' + y + '.' + props.format;
      };

      delete props.urls;
      delete props.url;
      var source = new sources[config.type](props);
      source.set('originalType', 'TMS');
      source.set('originalProperties', Object.assign({}, props, {
        urls: urls
      }));
      return source;
    }

    var sourceObj = new sources[config.type](props);

    if ((opt_proxy || access_token) && config.type === 'TileWMS') {
      sourceObj.once('tileloaderror', function () {
        sourceObj.setTileLoadFunction(function () {
          var tileLoadFn = sourceObj.getTileLoadFunction();
          return function (tile, src) {
            var query = access_token ? {
              "access_token": access_token
            } : {};
            var urlHelper = new _urls2.default(opt_proxy);
            var targetURL = urlHelper.getParamterizedURL(src, query);
            targetURL = urlHelper.getProxiedURL(targetURL);
            tileLoadFn(tile, targetURL);
          };
        }());
      });
    }

    if ((opt_proxy || access_token) && config.type === 'ImageWMS') {
      sourceObj.once('imageloaderror', function () {
        sourceObj.setImageLoadFunction(function () {
          var imageLoadFn = sourceObj.getImageLoadFunction();
          return function (image, src) {
            var query = access_token ? {
              "access_token": access_token
            } : {};
            var urlHelper = new _urls2.default(opt_proxy);
            var targetURL = urlHelper.getParamterizedURL(src, query);
            targetURL = urlHelper.getProxiedURL(targetURL);
            imageLoadFn(image, targetURL);
          };
        }());
      });
    }

    return sourceObj;
  };

  MapConfigService.prototype.generateLayerFromConfig = function generateLayerFromConfig(config, map, opt_proxy, access_token) {
    var type = config.type;
    var layerConfig = config.properties || {};
    layerConfig.id = _LayerIdService2.default.generateId();

    if (type === 'Group') {
      layerConfig.layers = [];

      for (var i = 0, ii = config.children.length; i < ii; ++i) {
        layerConfig.layers.push(this.generateLayerFromConfig(config.children[i], map, opt_proxy, access_token));
      }
    }

    var layer = new layersMaping[type](layerConfig);
    var sourceConfig = config.source;

    if (sourceConfig) {
      var source = this.generateSourceFromConfig(map, sourceConfig, opt_proxy, access_token, layerConfig.url, layerConfig.name);
      layer.setSource(source);
    }

    return layer;
  };

  MapConfigService.prototype.getLayerType = function getLayerType(layer) {
    if (layer instanceof _group2.default) {
      return 'Group';
    } else if (layer instanceof _vector4.default) {
      return 'Vector';
    } else if (layer instanceof _tile4.default) {
      return 'Tile';
    } else if (layer instanceof _image2.default) {
      return 'Image';
    }
  };

  MapConfigService.prototype.getFormatType = function getFormatType(format) {
    if (format instanceof _geojson2.default) {
      return 'GeoJSON';
    }
  };

  MapConfigService.prototype.getSourceConfig = function getSourceConfig(source) {
    var config = {};
    var attributions;
    var attr = source.getAttributions();

    if (attr !== null) {
      attributions = [];

      for (var i = 0, ii = attr.length; i < ii; ++i) {
        attributions.push(attr[i].getHTML());
      }
    }

    if (source instanceof _tilewms2.default) {
      config.type = 'TileWMS';
      config.properties = {
        params: source.getParams(),
        urls: source.getUrls()
      };
    } else if (source instanceof _cluster2.default) {
      config.type = 'Cluster';
      config.source = this.getSourceConfig(source.getSource());
    } else if (source instanceof _vector2.default) {
      config.type = 'Vector';
      config.properties = {
        attributions: attributions,
        format: {
          type: this.getFormatType(source.getFormat())
        },
        url: source.getUrl()
      };
    } else if (source instanceof _imagewms2.default) {
      config.type = 'ImageWMS';
      config.properties = {
        url: source.getUrl(),
        params: source.getParams(),
        attributions: attributions
      };
    } else if (source instanceof _osm2.default) {
      config.type = 'OSM';
      config.properties = {
        attributions: attributions
      };
    } else if (source instanceof _bingmaps2.default) {
      config.type = 'BingMaps';
      config.properties = {
        key: source.getApiKey(),
        imagerySet: source.getImagerySet()
      };
    } else if (source instanceof _xyz2.default) {
      if (source.get('originalType') === 'TMS') {
        config.type = 'TMS';
        config.properties = source.get('originalProperties');
      } else {
        config.type = 'XYZ';
        config.properties = {
          attributions: attributions,
          urls: source.getUrls()
        };
      }
    } else if (source instanceof _tilearcgisrest2.default) {
      config.type = 'TileArcGISRest';
      config.properties = {
        urls: source.getUrls(),
        params: source.getParams()
      };
    }

    return config;
  };

  MapConfigService.prototype.getLayerConfig = function getLayerConfig(config, layer) {
    config.type = this.getLayerType(layer);
    config.properties = layer.getProperties();
    delete config.properties.maxResolution;
    delete config.properties.minResolution;
    var source = config.type !== 'Group' ? layer.getSource() : null;

    if (source) {
      delete config.properties.source;
      config.source = this.getSourceConfig(source);
    }

    if (layer instanceof _group2.default) {
      delete config.properties.layers;
      config.children = [];
      layer.getLayers().forEach(function (child) {
        if (child.get('title') !== null) {
          var childConfig = {};
          config.children.push(childConfig);
          this.getLayerConfig(childConfig, child);
        }
      }, this);
    }

    return config;
  };

  MapConfigService.prototype.load = function load(mapConfig, map, opt_proxy, access_token) {
    var viewConfig = mapConfig.view;
    var layerConfig = mapConfig.layers;
    var remove = [];
    map.getLayers().forEach(function (lyr) {
      if (lyr.get('title') !== null) {
        remove.push(lyr);
      }
    });
    var i, ii;

    for (i = 0, ii = remove.length; i < ii; ++i) {
      map.removeLayer(remove[i]);
    }

    for (i = 0, ii = layerConfig.length; i < ii; ++i) {
      var layer = this.generateLayerFromConfig(layerConfig[i], map, opt_proxy, access_token);
      map.addLayer(layer);
    }

    var view = map.getView(),
        proj = _proj2.default.get(viewConfig.projection);

    if (proj && !_proj2.default.equivalent(view.getProjection(), proj)) {
      map.setView(new _view2.default({
        center: viewConfig.center,
        resolution: viewConfig.resolution,
        zoom: viewConfig.zoom,
        rotation: viewConfig.rotation,
        projection: viewConfig.projection
      }));
    } else {
      view.setCenter(viewConfig.center);

      if (viewConfig.resolution !== undefined) {
        view.setResolution(viewConfig.resolution);
      } else if (viewConfig.zoom !== undefined) {
        view.setZoom(viewConfig.zoom);
      }

      if (viewConfig.rotation !== undefined) {
        view.setRotation(viewConfig.rotation);
      }
    }
  };

  MapConfigService.prototype.save = function save(map) {
    var layers = [];
    map.getLayers().forEach(function (layer) {
      if (layer.get('title') !== null) {
        var config = {};
        layers.push(config);
        this.getLayerConfig(config, layer);
      }
    }, this);
    var config = {};
    config.layers = layers;
    var view = map.getView();
    config.view = {
      projection: view.getProjection().getCode(),
      center: view.getCenter(),
      resolution: view.getResolution(),
      zoom: view.getZoom(),
      rotation: view.getRotation()
    };
    return config;
  };

  return MapConfigService;
}();

exports.default = new MapConfigService();

/***/ }),

/***/ "./node_modules/cartoview-sdk/services/MapConfigTransformService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/cartoview-sdk/services/MapConfigTransformService.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _proj = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/*
 * Copyright 2015-present Boundless Spatial Inc., http://boundlessgeo.com
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
 */


var sourceIdx;
var baseMapTitle = 'Base Maps';
var gxpGroup = 'background';
/**
 * Transforms GXP style map config to our internal format.
 */

var MapConfigTransformService = function () {
  function MapConfigTransformService() {
    _classCallCheck(this, MapConfigTransformService);
  }

  MapConfigTransformService.prototype._writeLayer = function _writeLayer(config, sources, layers, group) {
    var key;
    var layerConfig = {}; // name is mandatory

    layerConfig.name = config.properties.name || config.properties.title.split(' ').join('_');
    layerConfig.title = config.properties.title;
    layerConfig.visibility = config.properties.visible;

    if (group) {
      layerConfig.group = group;
    }

    layers.push(layerConfig);

    if (config.source.type === 'XYZ') {
      layerConfig.type = 'OpenLayers.Layer.XYZ';
      var options;

      if (config.source.properties.attributions && config.source.properties.attributions.length > 0) {
        options = {
          attribution: config.source.properties.attributions[0]
        };
      }

      layerConfig.args = [config.properties.title, config.source.properties.urls[0]];

      if (options) {
        layerConfig.args.push(options);
      }

      sourceIdx++;
      sources[sourceIdx] = {
        ptype: 'gxp_olsource'
      };
    } else if (config.source.type === 'TileArcGISRest') {
      layerConfig.layerid = config.source.properties.params.LAYERS;
      sourceIdx++;
      sources[sourceIdx] = {
        url: config.source.properties.urls[0],
        ptype: 'gxp_arcrestsource'
      };
    } else if (config.source.type === 'BingMaps') {
      var hasBing = false;

      for (key in sources) {
        if (sources[key].ptype == 'gxp_bingsource' && sources[key].apiKey === config.source.properties.key) {
          hasBing = true;
          break;
        }
      }

      if (!hasBing) {
        sourceIdx++;
        sources[sourceIdx] = {
          ptype: 'gxp_bingsource',
          apiKey: config.source.properties.key
        };
      }
    } else if (config.source.type === 'TMS') {
      if (config.source.properties.urls[0].indexOf('tiles.mapbox.com/v1/mapbox') !== -1) {
        var hasMapBox = false;

        for (key in sources) {
          if (sources[key].ptype == 'gxp_mapboxsource') {
            hasMapBox = true;
            break;
          }
        }

        if (!hasMapBox) {
          sourceIdx++;
          sources[sourceIdx] = {
            ptype: 'gxp_mapboxsource'
          };
        }
      }
    } else if (config.source.type === 'TileWMS') {
      if (config.source.properties.params.SLD_BODY) {
        layerConfig.params = {
          TILED: 'false',
          SLD_BODY: config.source.properties.params.SLD_BODY
        };
      }

      layerConfig.queryable = config.properties.isSelectable;
      layerConfig.capability = {
        queryable: config.properties.isSelectable,
        styles: [{
          name: config.properties.styleName,
          legend: {
            href: config.properties.legendUrl
          }
        }],
        llbbox: config.properties.EX_GeographicBoundingBox
      };
      var hasWMSC = false;

      for (key in sources) {
        if (sources[key].ptype == 'gxp_wmscsource' && sources[key].url === config.source.url) {
          hasWMSC = true;
          break;
        }
      }

      if (!hasWMSC) {
        sourceIdx++;
        sources[sourceIdx] = {
          ptype: 'gxp_wmscsource',
          url: config.source.properties.urls[0]
        };
      }
    } else if (config.source.type === 'OSM') {
      var hasOSM = false;

      for (key in sources) {
        if (sources[key].ptype == 'gxp_osmsource') {
          hasOSM = true;
          break;
        }
      }

      if (!hasOSM) {
        sourceIdx++;
        sources[sourceIdx] = {
          ptype: 'gxp_osmsource'
        };
      }

      if (!layerConfig.name) {
        layerConfig.name = 'mapnik';
      }
    }

    layerConfig.source = '' + sourceIdx;
  };

  MapConfigTransformService.prototype.write = function write(data) {
    var viewConfig = data.view;
    var layerConfig = data.layers;
    var layers = [];
    var sources = {};
    sourceIdx = -1;

    for (var i = 0, ii = layerConfig.length; i < ii; ++i) {
      if (layerConfig[i].type === 'Group') {
        for (var j = 0, jj = layerConfig[i].children.length; j < jj; ++j) {
          var config = layerConfig[i].children[j];

          this._writeLayer(config, sources, layers, layerConfig[i].properties.title.replace(baseMapTitle, gxpGroup));
        }
      } else {
        this._writeLayer(layerConfig[i], sources, layers);
      }
    }

    var result = {
      sources: sources
    };
    result.map = {
      layers: layers,
      center: viewConfig.center,
      projection: viewConfig.projection,
      zoom: viewConfig.zoom
    };
    return result;
  };

  MapConfigTransformService.prototype._transformTileService = function _transformTileService(layerConfig) {
    var thumbnail;

    if (layerConfig.source.type === 'OSM') {
      thumbnail = 'https://a.tile.openstreetmap.org/0/0/0.png';
    } else {
      if (layerConfig.source.properties.urls) {
        thumbnail = layerConfig.source.properties.urls[0].replace('{z}', '0').replace('{y}', '0').replace('{x}', '0');
      }
    }

    return {
      name: layerConfig.properties.name,
      description: layerConfig.properties.title,
      standard: layerConfig.source.type,
      attribution: layerConfig.source.properties.attributions ? layerConfig.source.properties.attributions[0] : undefined,
      endpoint: layerConfig.source.properties.urls ? layerConfig.source.properties.urls[0] : undefined,
      thumbnail: thumbnail
    };
  };

  MapConfigTransformService.prototype.transform = function transform(data, opt_errors, opt_tileServices, opt_useCredentials) {
    var crossOrigin = 'anonymous';

    if (opt_useCredentials === true) {
      crossOrigin = 'use-credentials';
    }

    var i,
        ii,
        layers = [];
    var groups = {};

    for (i = 0, ii = data.map.layers.length; i < ii; ++i) {
      var layer = data.map.layers[i];
      var source = data.sources[layer.source];
      var url = source.url;
      var layerConfig = {
        properties: {
          isRemovable: true,
          visible: layer.visibility,
          title: layer.title || (layer.name ? layer.name.split(':').pop() : undefined),
          id: layer.name,
          name: layer.name
        }
      };

      if (source.ptype === 'gxp_olsource' && layer.type === 'OpenLayers.Layer.XYZ') {
        layerConfig.type = 'Tile';
        layerConfig.properties.title = layer.args[0];
        layerConfig.properties.name = layerConfig.properties.title.split(' ').join('_');
        var xyzUrls;
        var urlConfig = layer.args[1];

        if (Array.isArray(urlConfig)) {
          xyzUrls = urlConfig;
        } else {
          xyzUrls = [urlConfig];
        }

        for (var j = 0, jj = xyzUrls.length; j < jj; ++j) {
          xyzUrls[j] = xyzUrls[j].replace(/\$/g, '');

          if (xyzUrls[j].indexOf('cartocdn') !== -1) {
            xyzUrls[j] = xyzUrls[j].replace('https:', 'http:');
          }
        }

        layerConfig.source = {
          type: 'XYZ',
          properties: {
            crossOrigin: crossOrigin,
            urls: xyzUrls
          }
        };

        if (layer.args.length === 3 && layer.args[2].attribution) {
          layerConfig.source.properties.attributions = [layer.args[2].attribution];
        }
      } else if (source.ptype === 'gxp_osmsource') {
        if (!layer.group) {
          // force OSM as base layer
          layerConfig.properties.type = 'base';
        }

        layerConfig.type = 'Tile';
        layerConfig.source = {
          type: 'OSM',
          properties: {
            crossOrigin: 'anonymous'
          }
        };
      } else if (source.ptype === 'gxp_arcrestsource') {
        layerConfig.type = 'Tile';
        layerConfig.source = {
          type: 'TileArcGISRest',
          properties: {
            crossOrigin: crossOrigin,
            urls: [url],
            params: {
              LAYERS: layer.layerid,
              FORMAT: layer.format
            }
          }
        };
      } else if (source.ptype === 'gxp_wmscsource' && layer.name) {
        layerConfig.properties.popupInfo = '#AllAttributes';
        layerConfig.properties.isSelectable = layer.queryable;
        layerConfig.properties.isWFST = layer.queryable;

        if (layer.capability) {
          if (layer.queryable === undefined) {
            layerConfig.properties.isSelectable = layer.capability.queryable;
            layerConfig.properties.isWFST = layer.capability.queryable;
          }

          layerConfig.properties.styleName = layer.capability.styles[0].name;
          layerConfig.properties.legendUrl = layer.capability.styles[0].legend.href;
          layerConfig.properties.EX_GeographicBoundingBox = layer.capability.llbbox;
        }

        if (!layerConfig.properties.EX_GeographicBoundingBox) {
          if (layer.bbox && layer.srs && _proj2.default.get(layer.srs)) {
            layerConfig.properties.EX_GeographicBoundingBox = _proj2.default.transformExtent(layer.bbox, layer.srs, 'EPSG:4326');
          }
        }

        layerConfig.type = layer.tiled ? 'Tile' : 'Image';
        var params = layer.params || {};
        params.LAYERS = layer.name;

        if (params.TILED === undefined) {
          params.TILED = 'TRUE';
        }

        if (layer.styles) {
          params.STYLES = layer.styles;
        }

        if (layer.format) {
          params.FORMAT = layer.format;
        }

        if (layer.transparent !== undefined) {
          params.TRANSPARENT = layer.transparent;
        }

        layerConfig.source = {
          type: layer.tiled ? 'TileWMS' : 'ImageWMS',
          properties: {
            crossOrigin: crossOrigin,
            params: params,
            urls: [url]
          }
        };

        if (!layer.tiled) {
          delete layerConfig.properties.maxResolution;
          delete layerConfig.properties.minResolution;
          delete layerConfig.source.urls;
          layerConfig.source.properties.url = url;
          layerConfig.source.properties.hidpi = false;

          if (layer.srs === "EPSG:900913") {
            layerConfig.properties.extent = _proj2.default.transformExtent(layer.bbox, "EPSG:4326", "EPSG:3857");
          } else {
            layerConfig.properties.extent = _proj2.default.transformExtent(layer.bbox, layer.srs, data.map.projection);
          }
        }

        ;
      } else if (source.ptype === 'gxp_mapboxsource') {
        var urls = ['http://a.tiles.mapbox.com/v1/mapbox.' + layer.name + '/', 'http://b.tiles.mapbox.com/v1/mapbox.' + layer.name + '/', 'http://c.tiles.mapbox.com/v1/mapbox.' + layer.name + '/', 'http://d.tiles.mapbox.com/v1/mapbox.' + layer.name + '/'];
        var attribution = /^world/.test(layer.name) ? '<a href="http://mapbox.com">MapBox</a> | Some Data &copy; OSM CC-BY-SA | <a href="http://mapbox.com/tos">Terms of Service</a>' : '<a href="http://mapbox.com">MapBox</a> | <a href="http://mapbox.com/tos">Terms of Service</a>';
        var maxZoom = {
          'blue-marble-topo-bathy-jan': 8,
          'blue-marble-topo-bathy-jul': 8,
          'blue-marble-topo-jan': 8,
          'blue-marble-topo-jul': 8,
          'control-room': 8,
          'geography-class': 8,
          'natural-earth-hypso': 6,
          'natural-earth-hypso-bathy': 6,
          'natural-earth-1': 6,
          'natural-earth-2': 6,
          'world-dark': 11,
          'world-light': 11,
          'world-glass': 10,
          'world-print': 9
        };
        layerConfig.type = 'Tile';
        layerConfig.source = {
          type: 'TMS',
          properties: {
            attributions: [attribution],
            format: 'png',
            urls: urls,
            maxZoom: maxZoom[layer.name]
          }
        };
      } else if (source.ptype === 'gxp_bingsource') {
        layerConfig.type = 'Tile';
        layerConfig.source = {
          type: 'BingMaps',
          properties: {
            key: source.apiKey,
            imagerySet: layer.name
          }
        };
      } else {
        if (opt_errors) {
          opt_errors.push({
            msg: 'Unable to load layer ' + layerConfig.properties.title,
            layer: layer,
            source: source
          });
        }

        layerConfig = undefined;
      }

      if (layerConfig !== undefined) {
        if (layer.group) {
          if (layer.group === gxpGroup) {
            layerConfig.properties.type = 'base';

            if (opt_tileServices) {
              var tileService = this._transformTileService(layerConfig);

              if (tileService) {
                opt_tileServices.push(tileService);
              }
            }
          }

          if (!groups[layer.group]) {
            groups[layer.group] = {
              type: 'Group',
              properties: {
                name: layer.group,
                title: layer.group === gxpGroup ? baseMapTitle : layer.group,
                type: layer.group === gxpGroup ? 'base-group' : undefined
              },
              children: []
            };
            layers.push(groups[layer.group]);
          }

          groups[layer.group].children.push(layerConfig);
        } else {
          layers.push(layerConfig);
        }
      }
    }

    return {
      layers: layers,
      view: {
        center: data.map.center,
        projection: data.map.projection,
        zoom: data.map.zoom
      }
    };
  };

  return MapConfigTransformService;
}();

exports.default = new MapConfigTransformService();

/***/ }),

/***/ "./node_modules/cartoview-sdk/urls/urls.js":
/*!*************************************************!*\
  !*** ./node_modules/cartoview-sdk/urls/urls.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
/** Class for URLS manipulation */


var URLS = function () {
  /**
   * Create a URLS helper.
   * @param {string|null} proxyURL - proxy
   */
  function URLS() {
    var proxyURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, URLS);

    this.proxy = proxyURL;
  }
  /**
   * This function encodes special characters. In addition, it encodes the following characters: , / ? : @ & = + $ #
   * @param {string} url url to encode
   * @returns {string} encoded url
   */


  URLS.prototype.encodeURL = function encodeURL(url) {
    return encodeURIComponent(url);
  };
  /**
   * This function add paramters to url as query string
   * @param {string} url url to add paramters to 
   * @param {object} query paramters to be added to the url
   * @returns {string} paramterized url
   */


  URLS.prototype.getParamterizedURL = function getParamterizedURL(url, query) {
    var newURL = url;

    if (query && query != {}) {
      if (Object.keys(query).length > 0 && newURL.indexOf('?') === -1) {
        newURL += '?';
      } else {
        newURL += '&';
      }

      var newQuery = [];
      Object.keys(query).map(function (key) {
        newQuery.push(key + '=' + query[key]);
      });
      newURL += newQuery.join('&');
    }

    return newURL;
  };
  /**
   * This function add paramters to url as query string
   * @param {string} url url to to be proxied
   * @returns {string} proxied url
   */


  URLS.prototype.getProxiedURL = function getProxiedURL(url) {
    var proxy = this.proxy;
    var proxiedURL = url;

    if (proxy) {
      proxiedURL = this.proxy + this.encodeURL(url);
    }

    return proxiedURL;
  };

  return URLS;
}();

exports.default = URLS;

/***/ }),

/***/ "./node_modules/cartoview-sdk/utils/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/cartoview-sdk/utils/utils.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.doGet = doGet;
exports.doExternalGet = doExternalGet;
exports.capitalizeFirstLetter = capitalizeFirstLetter;
exports.doPost = doPost;
exports.downloadFile = downloadFile;
exports.copyToClipboard = copyToClipboard;
exports.ensureOptsDefaults = ensureOptsDefaults;

var _fileSaver = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/dist/FileSaver.min.js");

var _fileSaver2 = _interopRequireDefault(_fileSaver);

var _clipboardCopy = __webpack_require__(/*! clipboard-copy */ "./node_modules/clipboard-copy/index.js");

var _clipboardCopy2 = _interopRequireDefault(_clipboardCopy);

var _helpers = __webpack_require__(/*! ../helpers/helpers */ "./node_modules/cartoview-sdk/helpers/helpers.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * send get Request to an URL 
 * @param {string} url to send request to
 * @param {object} [extraHeaders={}] custom headers to add to the request
 * @param {string} [type='json'] expected response type to parse
 * @returns {Promise} result
 */


function doGet(url) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'json';
  return fetch(url, {
    method: 'GET',
    credentials: 'include',
    headers: _extends({
      "X-CSRFToken": (0, _helpers.getCRSFToken)()
    }, extraHeaders)
  }).then(function (response) {
    if (type === 'json') {
      return response.json();
    } else if (type === 'xml') {
      return response.text();
    }
  });
}
/**
 * send get Request to an External URL (i.e not on the same domain)
 * @param {string} url to send request to
 * @param {object} [extraHeaders={}] custom headers to add to the request
 * @param {string} [type='json'] expected response type to parse
 * @returns {Promise} result
 */


function doExternalGet(url) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'json';
  return fetch(url, {
    method: 'GET',
    mode: 'cors',
    headers: _extends({}, extraHeaders)
  }).then(function (response) {
    if (type === 'json') {
      return response.json();
    } else if (type === 'xml') {
      return response.text();
    }
  });
}
/**
 * capitalize First Letter of string
 * @param {string} string the word to capitalize
 * @returns {string} capitalized word
 */


function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * send post Request to an URL 
 * @param {string} url to send request to
 * @param {object} [extraHeaders={}] custom headers to add to the request
 * @param {string} [type='json'] expected response type to parse
 * @returns {Promise} result
 */


function doPost(url, data) {
  var extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'json';
  return fetch(url, {
    method: 'POST',
    mode: 'cors',
    credentials: 'include',
    headers: new Headers(_extends({
      "X-CSRFToken": (0, _helpers.getCRSFToken)()
    }, extraHeaders)),
    body: data
  }).then(function (response) {
    if (type === 'json') {
      return response.json();
    } else if (type === 'xml') {
      return response.text();
    }
  });
}
/**
 * Download binary data as file from the server
 * @param {string} url to send request to
 * @param {string} fileName the desired name of the file
 * @param {string} [data=null] request body if you want to send post request
 * @returns {Promise}
 */


function downloadFile(url, fileName) {
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var downloadPromise = new Promise(function (resolve, reject) {
    var mainProps = {
      method: 'GET'
    };

    if (data) {
      mainProps.method = 'POST';
      mainProps.body = data;
    }

    fetch(url, _extends({}, mainProps, {
      credentials: 'include',
      cache: 'no-cache',
      mode: 'cors',
      headers: new Headers({
        "X-CSRFToken": (0, _helpers.getCRSFToken)()
      })
    })).then(function (response) {
      if (response.ok) {
        return response.blob();
      }

      throw Error("Error Downloading file");
    }).then(function (data) {
      _fileSaver2.default.saveAs(data, fileName);

      resolve(true);
    }).catch(function (err) {
      reject(err);
    });
  });
  return downloadPromise;
}
/**
 * Copy data to system Clipboard
 * @param {string} [text=''] text you want to copy
 * @returns {Promise}
 */


function copyToClipboard() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return (0, _clipboardCopy2.default)(text);
}
/**
 * ensure default paramters
 * @param {object} optsParam 
 * @param {object} defaultOpts
 * @returns {object}
 */


function ensureOptsDefaults(optsParam, defaultOpts) {
  var newOpts = _extends({}, optsParam);

  Object.keys(defaultOpts).forEach(function (key) {
    if (!newOpts[key]) {
      newOpts[key] = defaultOpts[key];
    }
  }, this);
  return newOpts;
}

/***/ }),

/***/ "./node_modules/clipboard-copy/index.js":
/*!**********************************************!*\
  !*** ./node_modules/clipboard-copy/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = clipboardCopy;

function clipboardCopy(text) {
  // Use the Async Clipboard API when available
  if (navigator.clipboard) {
    return navigator.clipboard.writeText(text);
  } // ...Otherwise, use document.execCommand() fallback
  // Put the text to copy into a <span>


  var span = document.createElement('span');
  span.textContent = text; // Preserve consecutive spaces and newlines

  span.style.whiteSpace = 'pre'; // An <iframe> isolates the <span> from the page's styles

  var iframe = document.createElement('iframe');
  iframe.sandbox = 'allow-same-origin'; // Add the <iframe> to the page

  document.body.appendChild(iframe);
  var win = iframe.contentWindow; // Add the <span> to the <iframe>

  win.document.body.appendChild(span); // Get a Selection object representing the range of text selected by the user

  var selection = win.getSelection(); // Fallback for Firefox which fails to get a selection from an <iframe>

  if (!selection) {
    win = window;
    selection = win.getSelection();
    document.body.appendChild(span);
  }

  var range = win.document.createRange();
  selection.removeAllRanges();
  range.selectNode(span);
  selection.addRange(range);
  var success = false;

  try {
    success = win.document.execCommand('copy');
  } catch (err) {}

  selection.removeAllRanges();
  win.document.body.removeChild(span);
  document.body.removeChild(iframe); // The Async Clipboard API returns a promise that may reject with `undefined` so we
  // match that here for consistency.

  return success ? Promise.resolve() : Promise.reject(); // eslint-disable-line prefer-promise-reject-errors
}

/***/ }),

/***/ "./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (a, b) {
  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(this, function () {
  "use strict";

  function b(a, b) {
    return "undefined" == typeof b ? b = {
      autoBom: !1
    } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
      autoBom: !b
    }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], {
      type: a.type
    }) : a;
  }

  function c(b, c, d) {
    var e = new XMLHttpRequest();
    e.open("GET", b), e.responseType = "blob", e.onload = function () {
      a(e.response, c, d);
    }, e.onerror = function () {
      console.error("could not download file");
    }, e.send();
  }

  function d(a) {
    var b = new XMLHttpRequest();
    return b.open("HEAD", a, !1), b.send(), 200 <= b.status && 299 >= b.status;
  }

  function e(a) {
    try {
      a.dispatchEvent(new MouseEvent("click"));
    } catch (c) {
      var b = document.createEvent("MouseEvents");
      b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
    }
  }

  var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0,
      a = f.saveAs || ("object" != typeof window || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype ? function (b, g, h) {
    var i = f.URL || f.webkitURL,
        j = document.createElement("a");
    g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
      i.revokeObjectURL(j.href);
    }, 4E4), setTimeout(function () {
      e(j);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
    if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
      var i = document.createElement("a");
      i.href = f, i.target = "_blank", setTimeout(function () {
        e(i);
      });
    }
  } : function (a, b, d, e) {
    if (e = e || open("", "_blank"), e && (e.document.title = e.document.body.innerText = "downloading..."), "string" == typeof a) return c(a, b, d);
    var g = "application/octet-stream" === a.type,
        h = /constructor/i.test(f.HTMLElement) || f.safari,
        i = /CriOS\/[\d]+/.test(navigator.userAgent);

    if ((i || g && h) && "object" == typeof FileReader) {
      var j = new FileReader();
      j.onloadend = function () {
        var a = j.result;
        a = i ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), e ? e.location.href = a : location = a, e = null;
      }, j.readAsDataURL(a);
    } else {
      var k = f.URL || f.webkitURL,
          l = k.createObjectURL(a);
      e ? e.location = l : location.href = l, e = null, setTimeout(function () {
        k.revokeObjectURL(l);
      }, 4E4);
    }
  });
  f.saveAs = a.saveAs = a,  true && (module.exports = a);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),

/***/ "./node_modules/material-ui-flat-pagination/lib/PageButton.js":
/*!********************************************************************!*\
  !*** ./node_modules/material-ui-flat-pagination/lib/PageButton.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var Button_1 = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/Button/index.js");

var styles_1 = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");

var classnames_1 = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");

var core_1 = __webpack_require__(/*! ./core */ "./node_modules/material-ui-flat-pagination/lib/core.js");

var styles = function (theme) {
  return styles_1.createStyles({
    root: {
      minWidth: 16
    },
    rootCurrent: {
      paddingLeft: theme.spacing.unit * 1.5,
      paddingRight: theme.spacing.unit * 1.5
    },
    rootEllipsis: {
      paddingLeft: theme.spacing.unit * 0.5,
      paddingRight: theme.spacing.unit * 0.5
    },
    rootEnd: {
      paddingLeft: theme.spacing.unit * 1.5,
      paddingRight: theme.spacing.unit * 1.5
    },
    rootStandard: {
      paddingLeft: theme.spacing.unit * 1.5,
      paddingRight: theme.spacing.unit * 1.5
    },
    label: {},
    text: {},
    textPrimary: {},
    textSecondary: {},
    colorInherit: {},
    colorInheritCurrent: {},
    colorInheritOther: {},
    disabled: {},
    sizeSmall: {
      minWidth: 8
    },
    sizeSmallCurrent: {
      paddingLeft: theme.spacing.unit,
      paddingRight: theme.spacing.unit
    },
    sizeSmallEllipsis: {
      paddingLeft: theme.spacing.unit * 0.25,
      paddingRight: theme.spacing.unit * 0.25
    },
    sizeSmallEnd: {
      paddingLeft: theme.spacing.unit,
      paddingRight: theme.spacing.unit
    },
    sizeSmallStandard: {
      paddingLeft: theme.spacing.unit,
      paddingRight: theme.spacing.unit
    },
    sizeLarge: {
      minWidth: 24
    },
    sizeLargeCurrent: {
      paddingLeft: theme.spacing.unit * 2,
      paddingRight: theme.spacing.unit * 2
    },
    sizeLargeEllipsis: {
      paddingLeft: theme.spacing.unit * 0.75,
      paddingRight: theme.spacing.unit * 0.75
    },
    sizeLargeEnd: {
      paddingLeft: theme.spacing.unit * 2,
      paddingRight: theme.spacing.unit * 2
    },
    sizeLargeStandard: {
      paddingLeft: theme.spacing.unit * 2,
      paddingRight: theme.spacing.unit * 2
    },
    fullWidth: {}
  });
};

var handleClick = function (page, limit, onClick) {
  return function (ev) {
    onClick(ev, core_1.getOffset(page, limit), page);
  };
};

var PageButton = function (props) {
  var _a, _b, _c, _d;

  var limit = props.limit,
      page = props.page,
      total = props.total,
      pageVariant = props.pageVariant,
      classesProp = props.classes,
      currentPageColor = props.currentPageColor,
      disabledProp = props.disabled,
      disableRippleProp = props.disableRipple,
      onClickProp = props.onClick,
      otherPageColor = props.otherPageColor,
      size = props.size,
      other = __rest(props, ["limit", "page", "total", "pageVariant", "classes", "currentPageColor", "disabled", "disableRipple", "onClick", "otherPageColor", "size"]);

  var isCurrent = pageVariant === 'current';
  var isEllipsis = pageVariant === 'ellipsis';
  var isEnd = pageVariant === 'end';
  var isStandard = pageVariant === 'standard';
  var isSmall = size === 'small';
  var isLarge = size === 'large';

  var rootCurrent = classesProp.rootCurrent,
      rootEllipsis = classesProp.rootEllipsis,
      rootEnd = classesProp.rootEnd,
      rootStandard = classesProp.rootStandard,
      colorInheritCurrent = classesProp.colorInheritCurrent,
      colorInheritOther = classesProp.colorInheritOther,
      sizeSmallCurrent = classesProp.sizeSmallCurrent,
      sizeSmallEllipsis = classesProp.sizeSmallEllipsis,
      sizeSmallEnd = classesProp.sizeSmallEnd,
      sizeSmallStandard = classesProp.sizeSmallStandard,
      sizeLargeCurrent = classesProp.sizeLargeCurrent,
      sizeLargeEllipsis = classesProp.sizeLargeEllipsis,
      sizeLargeEnd = classesProp.sizeLargeEnd,
      sizeLargeStandard = classesProp.sizeLargeStandard,
      classes = __rest(classesProp, ["rootCurrent", "rootEllipsis", "rootEnd", "rootStandard", "colorInheritCurrent", "colorInheritOther", "sizeSmallCurrent", "sizeSmallEllipsis", "sizeSmallEnd", "sizeSmallStandard", "sizeLargeCurrent", "sizeLargeEllipsis", "sizeLargeEnd", "sizeLargeStandard"]);

  classes.root = classnames_1.default(classes.root, (_a = {}, _a[rootCurrent] = isCurrent, _a[rootEllipsis] = isEllipsis, _a[rootEnd] = isEnd, _a[rootStandard] = isStandard, _a));
  classes.colorInherit = classnames_1.default(classes.colorInherit, (_b = {}, _b[colorInheritCurrent] = isCurrent, _b[colorInheritOther] = !isCurrent, _b));
  classes.sizeSmall = classnames_1.default(classes.sizeSmall, (_c = {}, _c[sizeSmallCurrent] = isCurrent && isSmall, _c[sizeSmallEllipsis] = isEllipsis && isSmall, _c[sizeSmallEnd] = isEnd && isSmall, _c[sizeSmallStandard] = isStandard && isSmall, _c));
  classes.sizeLarge = classnames_1.default(classes.sizeLarge, (_d = {}, _d[sizeLargeCurrent] = isCurrent && isLarge, _d[sizeLargeEllipsis] = isEllipsis && isLarge, _d[sizeLargeEnd] = isEnd && isLarge, _d[sizeLargeStandard] = isStandard && isLarge, _d));
  var color = isCurrent ? currentPageColor : otherPageColor;
  var disabled = disabledProp || isEllipsis || page <= 0 || total <= 0;
  var disableRipple = disableRippleProp || disabled || isCurrent;
  var onClick;

  if (onClickProp && !disabled && (isEnd || isStandard)) {
    onClick = handleClick(page, limit, onClickProp);
  }

  return React.createElement(Button_1.default, __assign({
    classes: classes,
    color: color,
    disabled: disabled,
    disableRipple: disableRipple,
    onClick: onClick,
    size: size
  }, other));
};

PageButton.defaultProps = {
  limit: 1,
  page: 0,
  total: 0,
  pageVariant: 'standard',
  disabled: false,
  disableRipple: false
};
var PageButtonWithStyles = styles_1.withStyles(styles, {
  name: 'MuiFlatPageButton'
})(PageButton);
exports.default = PageButtonWithStyles;

/***/ }),

/***/ "./node_modules/material-ui-flat-pagination/lib/Pagination.js":
/*!********************************************************************!*\
  !*** ./node_modules/material-ui-flat-pagination/lib/Pagination.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var styles_1 = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");

var classnames_1 = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");

var PageButton_1 = __webpack_require__(/*! ./PageButton */ "./node_modules/material-ui-flat-pagination/lib/PageButton.js");

var core_1 = __webpack_require__(/*! ./core */ "./node_modules/material-ui-flat-pagination/lib/core.js");

var styles = styles_1.createStyles({
  root: {},
  rootCurrent: {},
  rootEllipsis: {},
  rootEnd: {},
  rootStandard: {},
  label: {},
  text: {},
  textPrimary: {},
  textSecondary: {},
  colorInherit: {},
  colorInheritCurrent: {},
  colorInheritOther: {},
  disabled: {},
  sizeSmall: {},
  sizeSmallCurrent: {},
  sizeSmallEllipsis: {},
  sizeSmallEnd: {},
  sizeSmallStandard: {},
  sizeLarge: {},
  sizeLargeCurrent: {},
  sizeLargeEllipsis: {},
  sizeLargeEnd: {},
  sizeLargeStandard: {},
  fullWidth: {}
});

var Pagination = function (props) {
  var limit = props.limit,
      offset = props.offset,
      total = props.total,
      centerRipple = props.centerRipple,
      classes = props.classes,
      classNameProp = props.className,
      component = props.component,
      currentPageColor = props.currentPageColor,
      disabled = props.disabled,
      disableFocusRipple = props.disableFocusRipple,
      disableRipple = props.disableRipple,
      fullWidth = props.fullWidth,
      nextPageLabel = props.nextPageLabel,
      innerButtonCountProp = props.innerButtonCount,
      onClick = props.onClick,
      otherPageColor = props.otherPageColor,
      outerButtonCountProp = props.outerButtonCount,
      previousPageLabel = props.previousPageLabel,
      reduced = props.reduced,
      size = props.size,
      other = __rest(props, ["limit", "offset", "total", "centerRipple", "classes", "className", "component", "currentPageColor", "disabled", "disableFocusRipple", "disableRipple", "fullWidth", "nextPageLabel", "innerButtonCount", "onClick", "otherPageColor", "outerButtonCount", "previousPageLabel", "reduced", "size"]);

  var root = classes.root,
      buttonClasses = __rest(classes, ["root"]);

  var className = classnames_1.default(root, classNameProp);
  var innerButtonCount = reduced ? 1 : innerButtonCountProp;
  var outerButtonCount = reduced ? 1 : outerButtonCountProp;
  var Component = component;
  return React.createElement(Component, __assign({
    className: className
  }, other), core_1.computePages(limit, offset, total, innerButtonCount, outerButtonCount).map(function (pp) {
    var key;
    var children;
    var pageVariant;

    switch (pp.position) {
      case 0:
        key = pp.position;
        children = pp.page;
        pageVariant = 'current';
        break;

      case 1:
      case 2:
        key = -pp.position;
        children = '...';
        pageVariant = 'ellipsis';
        break;

      case 3:
      case 4:
        key = -pp.position;
        children = pp.position === 3 ? previousPageLabel : nextPageLabel;
        pageVariant = 'end';
        break;

      default:
        key = pp.page;
        children = pp.page;
        pageVariant = 'standard';
        break;
    }

    return React.createElement(PageButton_1.default, {
      limit: limit,
      page: pp.page,
      total: total,
      centerRipple: centerRipple,
      classes: buttonClasses,
      currentPageColor: currentPageColor,
      disabled: disabled,
      disableFocusRipple: disableFocusRipple,
      disableRipple: disableRipple,
      fullWidth: fullWidth,
      key: key,
      onClick: onClick,
      otherPageColor: otherPageColor,
      pageVariant: pageVariant,
      size: size
    }, children);
  }));
};

Pagination.defaultProps = {
  limit: 1,
  offset: 0,
  total: 0,
  centerRipple: false,
  component: 'div',
  currentPageColor: 'secondary',
  disabled: false,
  disableFocusRipple: false,
  disableRipple: false,
  fullWidth: false,
  innerButtonCount: 2,
  nextPageLabel: '>',
  otherPageColor: 'primary',
  outerButtonCount: 2,
  previousPageLabel: '<',
  reduced: false,
  size: 'medium'
};
var PaginationWithStyles = styles_1.withStyles(styles, {
  name: 'MuiFlatPagination'
})(Pagination);
exports.default = PaginationWithStyles;

/***/ }),

/***/ "./node_modules/material-ui-flat-pagination/lib/core.js":
/*!**************************************************************!*\
  !*** ./node_modules/material-ui-flat-pagination/lib/core.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var createPagePosition = function (position, page) {
  if (page === void 0) {
    page = 0;
  }

  return {
    page: page,
    position: position
  };
};

exports.computePages = function (limitProp, offsetProp, totalProp, innerButtonCountProp, outerButtonCountProp) {
  var limit = limitProp >= 1 ? limitProp : 1;
  var offset = offsetProp >= 0 ? offsetProp : 0;
  var total = totalProp >= 0 ? totalProp : 0;
  var innerButtonCount = innerButtonCountProp >= 0 ? innerButtonCountProp : 0;
  var outerButtonCount = outerButtonCountProp >= 1 ? outerButtonCountProp : 1;
  var minPage = 1;
  var maxPage = Math.floor(total / limit) + (total % limit === 0 ? 0 : 1);
  var currentPage = Math.floor(offset / limit) + 1;
  var previousPage = currentPage <= minPage ? 0 : currentPage - 1;
  var nextPage = currentPage >= maxPage ? 0 : currentPage + 1;
  var pages = [];
  pages.push(createPagePosition(3, previousPage));
  var lowInnerReservedButtonCount = Math.max(innerButtonCount + currentPage - maxPage, 0);
  var lowInnerEllipsisPage = currentPage - innerButtonCount - lowInnerReservedButtonCount - 1;
  var lowOuterEllipsisPage = minPage + outerButtonCount;

  for (var i = minPage; i < currentPage; i++) {
    if (i < lowOuterEllipsisPage) {
      pages.push(createPagePosition(5, i));
    } else {
      pages.push(i === lowOuterEllipsisPage && i < lowInnerEllipsisPage ? createPagePosition(1) : createPagePosition(5, i));

      for (var j = Math.max(i, lowInnerEllipsisPage) + 1; j < currentPage; j++) {
        pages.push(createPagePosition(5, j));
      }

      break;
    }
  }

  pages.push(createPagePosition(0, currentPage));
  var highInnerReservedButtonCount = Math.max(innerButtonCount - currentPage + minPage, 0);
  var highInnerEllipsisPage = currentPage + innerButtonCount + highInnerReservedButtonCount + 1;
  var highOuterEllipsisPage = maxPage - outerButtonCount;

  for (var i = currentPage + 1; i <= maxPage; i++) {
    if (i < highInnerEllipsisPage) {
      pages.push(createPagePosition(5, i));
    } else {
      pages.push(i === highInnerEllipsisPage && i < highOuterEllipsisPage ? createPagePosition(2) : createPagePosition(5, i));

      for (var j = Math.max(i, highOuterEllipsisPage) + 1; j <= maxPage; j++) {
        pages.push(createPagePosition(5, j));
      }

      break;
    }
  }

  pages.push(createPagePosition(4, nextPage));
  return pages;
};

exports.getOffset = function (page, limit) {
  var offset = (page - 1) * limit;
  return offset < 0 ? 0 : offset;
};

/***/ }),

/***/ "./node_modules/material-ui-flat-pagination/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/material-ui-flat-pagination/lib/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Pagination_1 = __webpack_require__(/*! ./Pagination */ "./node_modules/material-ui-flat-pagination/lib/Pagination.js");

exports.default = Pagination_1.default;

__export(__webpack_require__(/*! ./Pagination */ "./node_modules/material-ui-flat-pagination/lib/Pagination.js"));

/***/ }),

/***/ "./node_modules/merge-images/dist/index.es2015.js":
/*!********************************************************!*\
  !*** ./node_modules/merge-images/dist/index.es2015.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Defaults
var defaultOptions = {
  format: 'image/png',
  quality: 0.92,
  width: undefined,
  height: undefined,
  Canvas: undefined
}; // Return Promise

var mergeImages = function (sources, options) {
  if (sources === void 0) sources = [];
  if (options === void 0) options = {};
  return new Promise(function (resolve) {
    options = Object.assign({}, defaultOptions, options); // Setup browser/Node.js specific variables

    var canvas = options.Canvas ? new options.Canvas() : window.document.createElement('canvas');
    var Image = options.Canvas ? options.Canvas.Image : window.Image;

    if (options.Canvas) {
      options.quality *= 100;
    } // Load sources


    var images = sources.map(function (source) {
      return new Promise(function (resolve, reject) {
        // Convert sources to objects
        if (source.constructor.name !== 'Object') {
          source = {
            src: source
          };
        } // Resolve source and img when loaded


        var img = new Image();

        img.onerror = function () {
          return reject(new Error('Couldn\'t load image'));
        };

        img.onload = function () {
          return resolve(Object.assign({}, source, {
            img: img
          }));
        };

        img.src = source.src;
      });
    }); // Get canvas context

    var ctx = canvas.getContext('2d'); // When sources have loaded

    resolve(Promise.all(images).then(function (images) {
      // Set canvas dimensions
      var getSize = function (dim) {
        return options[dim] || Math.max.apply(Math, images.map(function (image) {
          return image.img[dim];
        }));
      };

      canvas.width = getSize('width');
      canvas.height = getSize('height'); // Draw images to canvas

      images.forEach(function (image) {
        ctx.globalAlpha = image.opacity ? image.opacity : 1;
        return ctx.drawImage(image.img, image.x || 0, image.y || 0);
      });

      if (options.Canvas && options.format === 'image/jpeg') {
        // Resolve data URI for node-canvas jpeg async
        return new Promise(function (resolve) {
          canvas.toDataURL(options.format, {
            quality: options.quality,
            progressive: false
          }, function (err, jpeg) {
            if (err) {
              throw err;
            }

            resolve(jpeg);
          });
        });
      } // Resolve all other data URIs sync


      return canvas.toDataURL(options.format, options.quality);
    }));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (mergeImages);

/***/ }),

/***/ "./node_modules/mgrs/mgrs.js":
/*!***********************************!*\
  !*** ./node_modules/mgrs/mgrs.js ***!
  \***********************************/
/*! exports provided: default, forward, inverse, toPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPoint", function() { return toPoint; });
/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;
/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
var A = 65; // A

var I = 73; // I

var O = 79; // O

var V = 86; // V

var Z = 90; // Z

/* harmony default export */ __webpack_exports__["default"] = ({
  forward: forward,
  inverse: inverse,
  toPoint: toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */

function forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m

  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
;
/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */

function inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }

  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
;
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }

  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
;
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */

function degToRad(deg) {
  return deg * (Math.PI / 180.0);
}
/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */


function radToDeg(rad) {
  return 180.0 * (rad / Math.PI);
}
/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */


function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber; // (int)

  ZoneNumber = Math.floor((Long + 180) / 6) + 1; //Make sure the longitude 180.00 is in Zone 60

  if (Long === 180) {
    ZoneNumber = 60;
  } // Special zone for Norway


  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  } // Special zones for Svalbard


  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    } else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    } else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    } else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone

  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));

  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */


function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber; // check the ZoneNummber is valid

  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad; // remove 500,000 meter offset for longitude

  var x = UTMEasting - 500000.0;
  var y = UTMNorthing; // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly

  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  } // There are 60 zones with zone 1 being at West -180 to -174


  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu); // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;

  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat: lat,
      lon: lon
    };
  }

  return result;
}
/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */


function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if (84 >= lat && lat >= 72) {
    LetterDesignator = 'X';
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = 'W';
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = 'V';
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = 'U';
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = 'T';
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = 'S';
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = 'R';
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = 'Q';
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = 'P';
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = 'N';
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = 'M';
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = 'L';
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = 'K';
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = 'J';
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = 'H';
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = 'G';
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = 'F';
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = 'E';
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = 'D';
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = 'C';
  }

  return LetterDesignator;
}
/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */


function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */


function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */


function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;

  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}
/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */


function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index); // colInt and rowInt are the letters to build to return

  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }

  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }

  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }

  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */


function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }

  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0; // get Zone number

  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }

    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }

  var zoneLetter = mgrsString.charAt(i++); // Should we check the zone letter here? Why not.

  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }

  hunK = mgrsString.substring(i, i += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set); // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  } // calculate the char index for easting/northing separator


  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }

  var sep = remainder / 2;
  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;

  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}
/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */


function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;

    if (curCol === I) {
      curCol++;
    }

    if (curCol === O) {
      curCol++;
    }

    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }

      curCol = A;
      rewindMarker = true;
    }

    eastingValue += 100000.0;
  }

  return eastingValue;
}
/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */


function getNorthingFromChar(n, set) {
  if (n > 'V') {
    throw "MGRSPoint given invalid Northing " + n;
  } // rowOrigin is the letter at the origin of the set for the
  // column


  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;

    if (curRow === I) {
      curRow++;
    }

    if (curRow === O) {
      curRow++;
    } // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character


    if (curRow > V) {
      if (rewindMarker) {
        // making sure that this loop ends
        throw "Bad character: " + n;
      }

      curRow = A;
      rewindMarker = true;
    }

    northingValue += 100000.0;
  }

  return northingValue;
}
/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */


function getMinNorthing(zoneLetter) {
  var northing;

  switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;

    case 'D':
      northing = 2000000.0;
      break;

    case 'E':
      northing = 2800000.0;
      break;

    case 'F':
      northing = 3700000.0;
      break;

    case 'G':
      northing = 4600000.0;
      break;

    case 'H':
      northing = 5500000.0;
      break;

    case 'J':
      northing = 6400000.0;
      break;

    case 'K':
      northing = 7300000.0;
      break;

    case 'L':
      northing = 8200000.0;
      break;

    case 'M':
      northing = 9100000.0;
      break;

    case 'N':
      northing = 0.0;
      break;

    case 'P':
      northing = 800000.0;
      break;

    case 'Q':
      northing = 1700000.0;
      break;

    case 'R':
      northing = 2600000.0;
      break;

    case 'S':
      northing = 3500000.0;
      break;

    case 'T':
      northing = 4400000.0;
      break;

    case 'U':
      northing = 5300000.0;
      break;

    case 'V':
      northing = 6200000.0;
      break;

    case 'W':
      northing = 7000000.0;
      break;

    case 'X':
      northing = 7900000.0;
      break;

    default:
      northing = -1.0;
  }

  if (northing >= 0.0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/ol/ol.css":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader??ref--5-2!./node_modules/postcss-loader/src??postcss!./node_modules/ol/ol.css ***!
  \*********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/react-input-range/lib/css/index.css":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader??ref--5-2!./node_modules/postcss-loader/src??postcss!./node_modules/react-input-range/lib/css/index.css ***!
  \***********************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/css/base.css":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader??ref--5-2!./node_modules/postcss-loader/src??postcss!./src/css/base.css ***!
  \***************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/css/popup.css":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader??ref--5-2!./node_modules/postcss-loader/src??postcss!./src/css/popup.css ***!
  \****************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_array_ = {};
/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */

_ol_array_.binarySearch = function (haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || _ol_array_.numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
};
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */


_ol_array_.numberSafeCompareFunction = function (a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};
/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */


_ol_array_.includes = function (arr, obj) {
  return arr.indexOf(obj) >= 0;
};
/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */


_ol_array_.linearFindNearest = function (arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
};
/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */


_ol_array_.reverseSubArray = function (arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
};
/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements
 *     to add to arr.
 * @template VALUE
 */


_ol_array_.extend = function (arr, data) {
  var i;
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
};
/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */


_ol_array_.remove = function (arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
};
/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE} The element found.
 */


_ol_array_.find = function (arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];

    if (func(value, i, arr)) {
      return value;
    }
  }

  return null;
};
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */


_ol_array_.equals = function (arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */


_ol_array_.stableSort = function (arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
};
/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */


_ol_array_.findIndex = function (arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
};
/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */


_ol_array_.isSorted = function (arr, opt_func, opt_strict) {
  var compare = opt_func || _ol_array_.numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_array_);

/***/ }),

/***/ "./node_modules/ol/assertionerror.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/assertionerror.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */

var _ol_AssertionError_ = function (code) {
  var path = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].VERSION ? _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].VERSION.split('-')[0] : 'latest';
  /**
   * @type {string}
   */

  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */

  this.code = code;
  this.name = 'AssertionError';
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_AssertionError_, Error);

/* harmony default export */ __webpack_exports__["default"] = (_ol_AssertionError_);

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assertionerror_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assertionerror.js */ "./node_modules/ol/assertionerror.js");

var _ol_asserts_ = {};
/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */

_ol_asserts_.assert = function (assertion, errorCode) {
  if (!assertion) {
    throw new _assertionerror_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_asserts_);

/***/ }),

/***/ "./node_modules/ol/attribution.js":
/*!****************************************!*\
  !*** ./node_modules/ol/attribution.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tilerange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilerange.js */ "./node_modules/ol/tilerange.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilegrid.js */ "./node_modules/ol/tilegrid.js");



/**
 * @classdesc
 * An attribution for a layer source.
 *
 * Example:
 *
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="https://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 *
 * @constructor
 * @deprecated This class is deprecated and will removed in the next major release.
 * @param {olx.AttributionOptions} options Attribution options.
 * @struct
 * @api
 */

var _ol_Attribution_ = function (options) {
  /**
   * @private
   * @type {string}
   */
  this.html_ = options.html;
  /**
   * @private
   * @type {Object.<string, Array.<ol.TileRange>>}
   */

  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;
};
/**
 * Get the attribution markup.
 * @return {string} The attribution HTML.
 * @api
 */


_ol_Attribution_.prototype.getHTML = function () {
  return this.html_;
};
/**
 * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {boolean} Intersects any tile range.
 */


_ol_Attribution_.prototype.intersectsAnyTileRange = function (tileRanges, tileGrid, projection) {
  if (!this.tileRanges_) {
    return true;
  }

  var i, ii, tileRange, zKey;

  for (zKey in tileRanges) {
    if (!(zKey in this.tileRanges_)) {
      continue;
    }

    tileRange = tileRanges[zKey];
    var testTileRange;

    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {
      testTileRange = this.tileRanges_[zKey][i];

      if (testTileRange.intersects(tileRange)) {
        return true;
      }

      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(_tilegrid_js__WEBPACK_IMPORTED_MODULE_2__["default"].extentFromProjection(projection), parseInt(zKey, 10));
      var width = extentTileRange.getWidth();

      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {
        if (testTileRange.intersects(new _tilerange_js__WEBPACK_IMPORTED_MODULE_0__["default"](_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].modulo(tileRange.minX, width), _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {
          return true;
        }

        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {
          return true;
        }
      }
    }
  }

  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Attribution_);

/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _ol_CenterConstraint_ = {};
/**
 * @param {ol.Extent} extent Extent.
 * @return {ol.CenterConstraintType} The constraint.
 */

_ol_CenterConstraint_.createExtent = function (extent) {
  return (
    /**
     * @param {ol.Coordinate|undefined} center Center.
     * @return {ol.Coordinate|undefined} Center.
     */
    function (center) {
      if (center) {
        return [_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].clamp(center[0], extent[0], extent[2]), _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].clamp(center[1], extent[1], extent[3])];
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Center.
 */


_ol_CenterConstraint_.none = function (center) {
  return center;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_CenterConstraint_);

/***/ }),

/***/ "./node_modules/ol/collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/collection.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _assertionerror_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertionerror.js */ "./node_modules/ol/assertionerror.js");
/* harmony import */ var _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collectioneventtype.js */ "./node_modules/ol/collectioneventtype.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/event.js */ "./node_modules/ol/events/event.js");
/**
 * An implementation of Google Maps' MVCArray.
 * @see https://developers.google.com/maps/documentation/javascript/reference
 */





/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @constructor
 * @extends {ol.Object}
 * @fires ol.Collection.Event
 * @param {Array.<T>=} opt_array Array.
 * @param {olx.CollectionOptions=} opt_options Collection options.
 * @template T
 * @api
 */

var _ol_Collection_ = function (opt_array, opt_options) {
  _object_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this);

  var options = opt_options || {};
  /**
   * @private
   * @type {boolean}
   */

  this.unique_ = !!options.unique;
  /**
   * @private
   * @type {!Array.<T>}
   */

  this.array_ = opt_array ? opt_array : [];

  if (this.unique_) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      this.assertUnique_(this.array_[i], i);
    }
  }

  this.updateLength_();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Collection_, _object_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * Remove all elements from the collection.
 * @api
 */


_ol_Collection_.prototype.clear = function () {
  while (this.getLength() > 0) {
    this.pop();
  }
};
/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * @param {!Array.<T>} arr Array.
 * @return {ol.Collection.<T>} This collection.
 * @api
 */


_ol_Collection_.prototype.extend = function (arr) {
  var i, ii;

  for (i = 0, ii = arr.length; i < ii; ++i) {
    this.push(arr[i]);
  }

  return this;
};
/**
 * Iterate over each element, calling the provided callback.
 * @param {function(this: S, T, number, Array.<T>): *} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 * @api
 */


_ol_Collection_.prototype.forEach = function (f, opt_this) {
  var fn = opt_this ? f.bind(opt_this) : f;
  var array = this.array_;

  for (var i = 0, ii = array.length; i < ii; ++i) {
    fn(array[i], i, array);
  }
};
/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * @return {!Array.<T>} Array.
 * @api
 */


_ol_Collection_.prototype.getArray = function () {
  return this.array_;
};
/**
 * Get the element at the provided index.
 * @param {number} index Index.
 * @return {T} Element.
 * @api
 */


_ol_Collection_.prototype.item = function (index) {
  return this.array_[index];
};
/**
 * Get the length of this collection.
 * @return {number} The length of the array.
 * @observable
 * @api
 */


_ol_Collection_.prototype.getLength = function () {
  return (
    /** @type {number} */
    this.get(_ol_Collection_.Property_.LENGTH)
  );
};
/**
 * Insert an element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */


_ol_Collection_.prototype.insertAt = function (index, elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }

  this.array_.splice(index, 0, elem);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem));
};
/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * @return {T|undefined} Element.
 * @api
 */


_ol_Collection_.prototype.pop = function () {
  return this.removeAt(this.getLength() - 1);
};
/**
 * Insert the provided element at the end of the collection.
 * @param {T} elem Element.
 * @return {number} New length of the collection.
 * @api
 */


_ol_Collection_.prototype.push = function (elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }

  var n = this.getLength();
  this.insertAt(n, elem);
  return this.getLength();
};
/**
 * Remove the first occurrence of an element from the collection.
 * @param {T} elem Element.
 * @return {T|undefined} The removed element or undefined if none found.
 * @api
 */


_ol_Collection_.prototype.remove = function (elem) {
  var arr = this.array_;
  var i, ii;

  for (i = 0, ii = arr.length; i < ii; ++i) {
    if (arr[i] === elem) {
      return this.removeAt(i);
    }
  }

  return undefined;
};
/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * @param {number} index Index.
 * @return {T|undefined} Value.
 * @api
 */


_ol_Collection_.prototype.removeAt = function (index) {
  var prev = this.array_[index];
  this.array_.splice(index, 1);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev));
  return prev;
};
/**
 * Set the element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */


_ol_Collection_.prototype.setAt = function (index, elem) {
  var n = this.getLength();

  if (index < n) {
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }

    var prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev));
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem));
  } else {
    var j;

    for (j = n; j < index; ++j) {
      this.insertAt(j, undefined);
    }

    this.insertAt(index, elem);
  }
};
/**
 * @private
 */


_ol_Collection_.prototype.updateLength_ = function () {
  this.set(_ol_Collection_.Property_.LENGTH, this.array_.length);
};
/**
 * @private
 * @param {T} elem Element.
 * @param {number=} opt_except Optional index to ignore.
 */


_ol_Collection_.prototype.assertUnique_ = function (elem, opt_except) {
  for (var i = 0, ii = this.array_.length; i < ii; ++i) {
    if (this.array_[i] === elem && i !== opt_except) {
      throw new _assertionerror_js__WEBPACK_IMPORTED_MODULE_1__["default"](58);
    }
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_Collection_.Property_ = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link ol.Collection} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.Collection.Event}
 * @param {ol.CollectionEventType} type Type.
 * @param {*=} opt_element Element.
 */

_ol_Collection_.Event = function (type, opt_element) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, type);
  /**
   * The element that is added to or removed from the collection.
   * @type {*}
   * @api
   */


  this.element = opt_element;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Collection_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_Collection_);

/***/ }),

/***/ "./node_modules/ol/collectioneventtype.js":
/*!************************************************!*\
  !*** ./node_modules/ol/collectioneventtype.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_CollectionEventType_ = {
  /**
   * Triggered when an item is added to the collection.
   * @event ol.Collection.Event#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event ol.Collection.Event#remove
   * @api
   */
  REMOVE: 'remove'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_CollectionEventType_);

/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");


var _ol_color_ = {};
/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */

_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */

_ol_color_.asArray = function (color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return _ol_color_.fromString(
    /** @type {string} */
    color);
  }
};
/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */


_ol_color_.asString = function (color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return _ol_color_.toString(color);
  }
};
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */


_ol_color_.fromNamed = function (color) {
  var el = document.createElement('div');
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};
/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */


_ol_color_.fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object.<string, ol.Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {ol.Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          var key;

          for (key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = _ol_color_.fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */


_ol_color_.fromStringInternal_ = function (s) {
  var r, g, b, a, color, parts;

  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {
    s = _ol_color_.fromNamed(s);
  }

  if (_ol_color_.HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    parts = s.slice(5, -1).split(',').map(Number);
    color = _ol_color_.normalize(parts);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    parts = s.slice(4, -1).split(',').map(Number);
    parts.push(1);
    color = _ol_color_.normalize(parts);
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(false, 14); // Invalid color

  }

  return (
    /** @type {ol.Color} */
    color
  );
};
/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */


_ol_color_.normalize = function (color, opt_color) {
  var result = opt_color || [];
  result[0] = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(color[3], 0, 1);
  return result;
};
/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */


_ol_color_.toString = function (color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_color_);

/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");

var _ol_colorlike_ = {};
/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */

_ol_colorlike_.asColorLike = function (color) {
  if (_ol_colorlike_.isColorLike(color)) {
    return (
      /** @type {string|CanvasPattern|CanvasGradient} */
      color
    );
  } else {
    return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"].asString(
    /** @type {ol.Color} */
    color);
  }
};
/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */


_ol_colorlike_.isColorLike = function (color) {
  return typeof color === 'string' || color instanceof CanvasPattern || color instanceof CanvasGradient;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_colorlike_);

/***/ }),

/***/ "./node_modules/ol/control.js":
/*!************************************!*\
  !*** ./node_modules/ol/control.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collection.js */ "./node_modules/ol/collection.js");
/* harmony import */ var _control_attribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/attribution.js */ "./node_modules/ol/control/attribution.js");
/* harmony import */ var _control_rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./control/rotate.js */ "./node_modules/ol/control/rotate.js");
/* harmony import */ var _control_zoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control/zoom.js */ "./node_modules/ol/control/zoom.js");




var _ol_control_ = {};
/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link ol.control.Zoom}
 * * {@link ol.control.Rotate}
 * * {@link ol.control.Attribution}
 *
 * @param {olx.control.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */

_ol_control_.defaults = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new _collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new _control_zoom_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new _control_rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new _control_attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.attributionOptions));
  }

  return controls;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_);

/***/ }),

/***/ "./node_modules/ol/control/attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/attribution.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
// FIXME handle date line wrap









/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.AttributionOptions=} opt_options Attribution options.
 * @api
 */

var _ol_control_Attribution_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {Element}
   */

  this.ulElement_ = document.createElement('UL');
  /**
   * @private
   * @type {Element}
   */

  this.logoLi_ = document.createElement('LI');
  this.ulElement_.appendChild(this.logoLi_);
  this.logoLi_.style.display = 'none';
  /**
   * @private
   * @type {boolean}
   */

  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
  /**
   * @private
   * @type {boolean}
   */

  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

  if (!this.collapsible_) {
    this.collapsed_ = false;
  }

  var className = options.className !== undefined ? options.className : 'ol-attribution';
  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

  if (typeof collapseLabel === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.collapseLabel_ = document.createElement('span');
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }

  var label = options.label !== undefined ? options.label : 'i';

  if (typeof label === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.label_ = document.createElement('span');
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }

  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement('button');
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(activeLabel);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(button, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLICK, this.handleClick_, this);

  var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(this.ulElement_);
  element.appendChild(button);
  var render = options.render ? options.render : _ol_control_Attribution_.render;

  _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, {
    element: element,
    render: render,
    target: options.target
  });
  /**
   * A list of currently rendered resolutions.
   * @type {Array.<string>}
   * @private
   */


  this.renderedAttributions_ = [];
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {Object.<string, Element>}
   */

  this.logoElements_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_Attribution_, _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Get a list of visible attributions.
 * @param {olx.FrameState} frameState Frame state.
 * @return {Array.<string>} Attributions.
 * @private
 */


_ol_control_Attribution_.prototype.getSourceAttributions_ = function (frameState) {
  /**
   * Used to determine if an attribution already exists.
   * @type {Object.<string, boolean>}
   */
  var lookup = {};
  /**
   * A list of visible attributions.
   * @type {Array.<string>}
   */

  var visibleAttributions = [];
  var layerStatesArray = frameState.layerStatesArray;
  var resolution = frameState.viewState.resolution;

  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    var layerState = layerStatesArray[i];

    if (!_layer_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"].visibleAtResolution(layerState, resolution)) {
      continue;
    }

    var source = layerState.layer.getSource();

    if (!source) {
      continue;
    }

    var attributionGetter = source.getAttributions2();

    if (!attributionGetter) {
      continue;
    }

    var attributions = attributionGetter(frameState);

    if (!attributions) {
      continue;
    }

    if (Array.isArray(attributions)) {
      for (var j = 0, jj = attributions.length; j < jj; ++j) {
        if (!(attributions[j] in lookup)) {
          visibleAttributions.push(attributions[j]);
          lookup[attributions[j]] = true;
        }
      }
    } else {
      if (!(attributions in lookup)) {
        visibleAttributions.push(attributions);
        lookup[attributions] = true;
      }
    }
  }

  return visibleAttributions;
};
/**
 * Update the attribution element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Attribution}
 * @api
 */


_ol_control_Attribution_.render = function (mapEvent) {
  this.updateElement_(mapEvent.frameState);
};
/**
 * @private
 * @param {?olx.FrameState} frameState Frame state.
 */


_ol_control_Attribution_.prototype.updateElement_ = function (frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.element.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return;
  }

  var attributions = this.getSourceAttributions_(frameState);

  if (_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(attributions, this.renderedAttributions_)) {
    return;
  } // remove everything but the logo


  while (this.ulElement_.lastChild !== this.logoLi_) {
    this.ulElement_.removeChild(this.ulElement_.lastChild);
  } // append the attributions


  for (var i = 0, ii = attributions.length; i < ii; ++i) {
    var element = document.createElement('LI');
    element.innerHTML = attributions[i];
    this.ulElement_.appendChild(element);
  }

  if (attributions.length === 0 && this.renderedAttributions_.length > 0) {
    this.element.classList.add('ol-logo-only');
  } else if (this.renderedAttributions_.length === 0 && attributions.length > 0) {
    this.element.classList.remove('ol-logo-only');
  }

  var visible = attributions.length > 0 || !_obj_js__WEBPACK_IMPORTED_MODULE_8__["default"].isEmpty(frameState.logos);

  if (this.renderedVisible_ != visible) {
    this.element.style.display = visible ? '' : 'none';
    this.renderedVisible_ = visible;
  }

  this.renderedAttributions_ = attributions;
  this.insertLogos_(frameState);
};
/**
 * @param {?olx.FrameState} frameState Frame state.
 * @private
 */


_ol_control_Attribution_.prototype.insertLogos_ = function (frameState) {
  var logo;
  var logos = frameState.logos;
  var logoElements = this.logoElements_;

  for (logo in logoElements) {
    if (!(logo in logos)) {
      _dom_js__WEBPACK_IMPORTED_MODULE_4__["default"].removeNode(logoElements[logo]);

      delete logoElements[logo];
    }
  }

  var image, logoElement, logoKey;

  for (logoKey in logos) {
    var logoValue = logos[logoKey];

    if (logoValue instanceof HTMLElement) {
      this.logoLi_.appendChild(logoValue);
      logoElements[logoKey] = logoValue;
    }

    if (!(logoKey in logoElements)) {
      image = new Image();
      image.src = logoKey;

      if (logoValue === '') {
        logoElement = image;
      } else {
        logoElement = document.createElement('a');
        logoElement.href = logoValue;
        logoElement.appendChild(image);
      }

      this.logoLi_.appendChild(logoElement);
      logoElements[logoKey] = logoElement;
    }
  }

  this.logoLi_.style.display = !_obj_js__WEBPACK_IMPORTED_MODULE_8__["default"].isEmpty(logos) ? '' : 'none';
};
/**
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Attribution_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  this.handleToggle_();
};
/**
 * @private
 */


_ol_control_Attribution_.prototype.handleToggle_ = function () {
  this.element.classList.toggle('ol-collapsed');

  if (this.collapsed_) {
    _dom_js__WEBPACK_IMPORTED_MODULE_4__["default"].replaceNode(this.collapseLabel_, this.label_);
  } else {
    _dom_js__WEBPACK_IMPORTED_MODULE_4__["default"].replaceNode(this.label_, this.collapseLabel_);
  }

  this.collapsed_ = !this.collapsed_;
};
/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * @return {boolean} True if the widget is collapsible.
 * @api
 */


_ol_control_Attribution_.prototype.getCollapsible = function () {
  return this.collapsible_;
};
/**
 * Set whether the attribution should be collapsible.
 * @param {boolean} collapsible True if the widget is collapsible.
 * @api
 */


_ol_control_Attribution_.prototype.setCollapsible = function (collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }

  this.collapsible_ = collapsible;
  this.element.classList.toggle('ol-uncollapsible');

  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};
/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * @param {boolean} collapsed True if the widget is collapsed.
 * @api
 */


_ol_control_Attribution_.prototype.setCollapsed = function (collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }

  this.handleToggle_();
};
/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * @return {boolean} True if the widget is collapsed.
 * @api
 */


_ol_control_Attribution_.prototype.getCollapsed = function () {
  return this.collapsed_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_Attribution_);

/***/ }),

/***/ "./node_modules/ol/control/control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/control.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _mapeventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mapeventtype.js */ "./node_modules/ol/mapeventtype.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");





/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @constructor
 * @extends {ol.Object}
 * @implements {oli.control.Control}
 * @param {olx.control.ControlOptions} options Control options.
 * @api
 */

var _ol_control_Control_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @protected
   * @type {Element}
   */


  this.element = options.element ? options.element : null;
  /**
   * @private
   * @type {Element}
   */

  this.target_ = null;
  /**
   * @private
   * @type {ol.PluggableMap}
   */

  this.map_ = null;
  /**
   * @protected
   * @type {!Array.<ol.EventsKey>}
   */

  this.listenerKeys = [];
  /**
   * @type {function(ol.MapEvent)}
   */

  this.render = options.render ? options.render : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;

  if (options.target) {
    this.setTarget(options.target);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_Control_, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @inheritDoc
 */


_ol_control_Control_.prototype.disposeInternal = function () {
  _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].removeNode(this.element);

  _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.disposeInternal.call(this);
};
/**
 * Get the map associated with this control.
 * @return {ol.PluggableMap} Map.
 * @api
 */


_ol_control_Control_.prototype.getMap = function () {
  return this.map_;
};
/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 * @override
 * @api
 */


_ol_control_Control_.prototype.setMap = function (map) {
  if (this.map_) {
    _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].removeNode(this.element);
  }

  for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
    _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey(this.listenerKeys[i]);
  }

  this.listenerKeys.length = 0;
  this.map_ = map;

  if (this.map_) {
    var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
    target.appendChild(this.element);

    if (this.render !== _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction) {
      this.listenerKeys.push(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(map, _mapeventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSTRENDER, this.render, this));
    }

    map.render();
  }
};
/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * @param {Element|string} target Target.
 * @api
 */


_ol_control_Control_.prototype.setTarget = function (target) {
  this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_Control_);

/***/ }),

/***/ "./node_modules/ol/control/fullscreen.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/control/fullscreen.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");






/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.FullScreenOptions=} opt_options Options.
 * @api
 */

var _ol_control_FullScreen_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {string}
   */

  this.cssClassName_ = options.className !== undefined ? options.className : 'ol-full-screen';
  var label = options.label !== undefined ? options.label : '\u2922';
  /**
   * @private
   * @type {Node}
   */

  this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;
  var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
  /**
   * @private
   * @type {Node}
   */

  this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;
  var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';
  var button = document.createElement('button');
  button.className = this.cssClassName_ + '-' + _ol_control_FullScreen_.isFullScreen();
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(this.labelNode_);

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(button, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLICK, this.handleClick_, this);

  var cssClasses = this.cssClassName_ + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLASS_CONTROL + ' ' + (!_ol_control_FullScreen_.isFullScreenSupported() ? _css_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLASS_UNSUPPORTED : '');
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(button);

  _control_control_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, {
    element: element,
    target: options.target
  });
  /**
   * @private
   * @type {boolean}
   */


  this.keys_ = options.keys !== undefined ? options.keys : false;
  /**
   * @private
   * @type {Element|string|undefined}
   */

  this.source_ = options.source;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_FullScreen_, _control_control_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_FullScreen_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  this.handleFullScreen_();
};
/**
 * @private
 */


_ol_control_FullScreen_.prototype.handleFullScreen_ = function () {
  if (!_ol_control_FullScreen_.isFullScreenSupported()) {
    return;
  }

  var map = this.getMap();

  if (!map) {
    return;
  }

  if (_ol_control_FullScreen_.isFullScreen()) {
    _ol_control_FullScreen_.exitFullScreen();
  } else {
    var element;

    if (this.source_) {
      element = typeof this.source_ === 'string' ? document.getElementById(this.source_) : this.source_;
    } else {
      element = map.getTargetElement();
    }

    if (this.keys_) {
      _ol_control_FullScreen_.requestFullScreenWithKeys(element);
    } else {
      _ol_control_FullScreen_.requestFullScreen(element);
    }
  }
};
/**
 * @private
 */


_ol_control_FullScreen_.prototype.handleFullScreenChange_ = function () {
  var button = this.element.firstElementChild;
  var map = this.getMap();

  if (_ol_control_FullScreen_.isFullScreen()) {
    button.className = this.cssClassName_ + '-true';

    _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].replaceNode(this.labelActiveNode_, this.labelNode_);
  } else {
    button.className = this.cssClassName_ + '-false';

    _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].replaceNode(this.labelNode_, this.labelActiveNode_);
  }

  if (map) {
    map.updateSize();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_control_FullScreen_.prototype.setMap = function (map) {
  _control_control_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.setMap.call(this, map);

  if (map) {
    this.listenerKeys.push(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(document, _ol_control_FullScreen_.getChangeType_(), this.handleFullScreenChange_, this));
  }
};
/**
 * @return {boolean} Fullscreen is supported by the current platform.
 */


_ol_control_FullScreen_.isFullScreenSupported = function () {
  var body = document.body;
  return !!(body.webkitRequestFullscreen || body.mozRequestFullScreen && document.mozFullScreenEnabled || body.msRequestFullscreen && document.msFullscreenEnabled || body.requestFullscreen && document.fullscreenEnabled);
};
/**
 * @return {boolean} Element is currently in fullscreen.
 */


_ol_control_FullScreen_.isFullScreen = function () {
  return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
};
/**
 * Request to fullscreen an element.
 * @param {Node} element Element to request fullscreen
 */


_ol_control_FullScreen_.requestFullScreen = function (element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  }
};
/**
 * Request to fullscreen an element with keyboard input.
 * @param {Node} element Element to request fullscreen
 */


_ol_control_FullScreen_.requestFullScreenWithKeys = function (element) {
  if (element.mozRequestFullScreenWithKeys) {
    element.mozRequestFullScreenWithKeys();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
  } else {
    _ol_control_FullScreen_.requestFullScreen(element);
  }
};
/**
 * Exit fullscreen.
 */


_ol_control_FullScreen_.exitFullScreen = function () {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  }
};
/**
 * @return {string} Change type.
 * @private
 */


_ol_control_FullScreen_.getChangeType_ = function () {
  var changeType;
  return function () {
    if (!changeType) {
      var body = document.body;

      if (body.webkitRequestFullscreen) {
        changeType = 'webkitfullscreenchange';
      } else if (body.mozRequestFullScreen) {
        changeType = 'mozfullscreenchange';
      } else if (body.msRequestFullscreen) {
        changeType = 'MSFullscreenChange';
      } else if (body.requestFullscreen) {
        changeType = 'fullscreenchange';
      }
    }

    return changeType;
  };
}();

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_FullScreen_);

/***/ }),

/***/ "./node_modules/ol/control/rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/rotate.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");






/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.RotateOptions=} opt_options Rotate options.
 * @api
 */

var _ol_control_Rotate_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : 'ol-rotate';
  var label = options.label !== undefined ? options.label : '\u21E7';
  /**
   * @type {Element}
   * @private
   */

  this.label_ = null;

  if (typeof label === 'string') {
    this.label_ = document.createElement('span');
    this.label_.className = 'ol-compass';
    this.label_.textContent = label;
  } else {
    this.label_ = label;
    this.label_.classList.add('ol-compass');
  }

  var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
  var button = document.createElement('button');
  button.className = className + '-reset';
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(this.label_);

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(button, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, _ol_control_Rotate_.prototype.handleClick_, this);

  var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(button);
  var render = options.render ? options.render : _ol_control_Rotate_.render;
  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

  _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    element: element,
    render: render,
    target: options.target
  });
  /**
   * @type {number}
   * @private
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
  /**
   * @type {boolean}
   * @private
   */

  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = undefined;

  if (this.autoHide_) {
    this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_HIDDEN);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].inherits(_ol_control_Rotate_, _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Rotate_.prototype.handleClick_ = function (event) {
  event.preventDefault();

  if (this.callResetNorth_ !== undefined) {
    this.callResetNorth_();
  } else {
    this.resetNorth_();
  }
};
/**
 * @private
 */


_ol_control_Rotate_.prototype.resetNorth_ = function () {
  var map = this.getMap();
  var view = map.getView();

  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }

  if (view.getRotation() !== undefined) {
    if (this.duration_ > 0) {
      view.animate({
        rotation: 0,
        duration: this.duration_,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_5__["default"].easeOut
      });
    } else {
      view.setRotation(0);
    }
  }
};
/**
 * Update the rotate control element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Rotate}
 * @api
 */


_ol_control_Rotate_.render = function (mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    return;
  }

  var rotation = frameState.viewState.rotation;

  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';

    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_HIDDEN);

      if (!contains && rotation === 0) {
        this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_HIDDEN);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_HIDDEN);
      }
    }

    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }

  this.rotation_ = rotation;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_Rotate_);

/***/ }),

/***/ "./node_modules/ol/control/scaleline.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/control/scaleline.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../control/scalelineunits.js */ "./node_modules/ol/control/scalelineunits.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../proj/units.js */ "./node_modules/ol/proj/units.js");









/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ScaleLineOptions=} opt_options Scale line options.
 * @api
 */

var _ol_control_ScaleLine_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : 'ol-scale-line';
  /**
   * @private
   * @type {Element}
   */

  this.innerElement_ = document.createElement('DIV');
  this.innerElement_.className = className + '-inner';
  /**
   * @private
   * @type {Element}
   */

  this.element_ = document.createElement('DIV');
  this.element_.className = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLASS_UNSELECTABLE;
  this.element_.appendChild(this.innerElement_);
  /**
   * @private
   * @type {?olx.ViewState}
   */

  this.viewState_ = null;
  /**
   * @private
   * @type {number}
   */

  this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = false;
  /**
   * @private
   * @type {number|undefined}
   */

  this.renderedWidth_ = undefined;
  /**
   * @private
   * @type {string}
   */

  this.renderedHTML_ = '';
  var render = options.render ? options.render : _ol_control_ScaleLine_.render;

  _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    element: this.element_,
    render: render,
    target: options.target
  });

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_1__["default"].getChangeEventType(_ol_control_ScaleLine_.Property_.UNITS), this.handleUnitsChanged_, this);

  this.setUnits(
  /** @type {ol.control.ScaleLineUnits} */
  options.units || _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].METRIC);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_ScaleLine_, _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @const
 * @type {Array.<number>}
 */


_ol_control_ScaleLine_.LEADING_DIGITS = [1, 2, 5];
/**
 * Return the units to use in the scale line.
 * @return {ol.control.ScaleLineUnits|undefined} The units to use in the scale
 *     line.
 * @observable
 * @api
 */

_ol_control_ScaleLine_.prototype.getUnits = function () {
  return (
    /** @type {ol.control.ScaleLineUnits|undefined} */
    this.get(_ol_control_ScaleLine_.Property_.UNITS)
  );
};
/**
 * Update the scale line element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.ScaleLine}
 * @api
 */


_ol_control_ScaleLine_.render = function (mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    this.viewState_ = null;
  } else {
    this.viewState_ = frameState.viewState;
  }

  this.updateElement_();
};
/**
 * @private
 */


_ol_control_ScaleLine_.prototype.handleUnitsChanged_ = function () {
  this.updateElement_();
};
/**
 * Set the units to use in the scale line.
 * @param {ol.control.ScaleLineUnits} units The units to use in the scale line.
 * @observable
 * @api
 */


_ol_control_ScaleLine_.prototype.setUnits = function (units) {
  this.set(_ol_control_ScaleLine_.Property_.UNITS, units);
};
/**
 * @private
 */


_ol_control_ScaleLine_.prototype.updateElement_ = function () {
  var viewState = this.viewState_;

  if (!viewState) {
    if (this.renderedVisible_) {
      this.element_.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return;
  }

  var center = viewState.center;
  var projection = viewState.projection;
  var units = this.getUnits();
  var pointResolutionUnits = units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].DEGREES ? _proj_units_js__WEBPACK_IMPORTED_MODULE_8__["default"].DEGREES : _proj_units_js__WEBPACK_IMPORTED_MODULE_8__["default"].METERS;

  var pointResolution = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);

  if (units != _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].DEGREES) {
    pointResolution *= projection.getMetersPerUnit();
  }

  var nominalCount = this.minWidth_ * pointResolution;
  var suffix = '';

  if (units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].DEGREES) {
    var metersPerDegree = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].METERS_PER_UNIT[_proj_units_js__WEBPACK_IMPORTED_MODULE_8__["default"].DEGREES];

    if (projection.getUnits() == _proj_units_js__WEBPACK_IMPORTED_MODULE_8__["default"].DEGREES) {
      nominalCount *= metersPerDegree;
    } else {
      pointResolution /= metersPerDegree;
    }

    if (nominalCount < metersPerDegree / 60) {
      suffix = '\u2033'; // seconds

      pointResolution *= 3600;
    } else if (nominalCount < metersPerDegree) {
      suffix = '\u2032'; // minutes

      pointResolution *= 60;
    } else {
      suffix = '\u00b0'; // degrees
    }
  } else if (units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].IMPERIAL) {
    if (nominalCount < 0.9144) {
      suffix = 'in';
      pointResolution /= 0.0254;
    } else if (nominalCount < 1609.344) {
      suffix = 'ft';
      pointResolution /= 0.3048;
    } else {
      suffix = 'mi';
      pointResolution /= 1609.344;
    }
  } else if (units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].NAUTICAL) {
    pointResolution /= 1852;
    suffix = 'nm';
  } else if (units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].METRIC) {
    if (nominalCount < 0.001) {
      suffix = 'μm';
      pointResolution *= 1000000;
    } else if (nominalCount < 1) {
      suffix = 'mm';
      pointResolution *= 1000;
    } else if (nominalCount < 1000) {
      suffix = 'm';
    } else {
      suffix = 'km';
      pointResolution /= 1000;
    }
  } else if (units == _control_scalelineunits_js__WEBPACK_IMPORTED_MODULE_4__["default"].US) {
    if (nominalCount < 0.9144) {
      suffix = 'in';
      pointResolution *= 39.37;
    } else if (nominalCount < 1609.344) {
      suffix = 'ft';
      pointResolution /= 0.30480061;
    } else {
      suffix = 'mi';
      pointResolution /= 1609.3472;
    }
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(false, 33); // Invalid units

  }

  var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));
  var count, width;

  while (true) {
    count = _ol_control_ScaleLine_.LEADING_DIGITS[(i % 3 + 3) % 3] * Math.pow(10, Math.floor(i / 3));
    width = Math.round(count / pointResolution);

    if (isNaN(width)) {
      this.element_.style.display = 'none';
      this.renderedVisible_ = false;
      return;
    } else if (width >= this.minWidth_) {
      break;
    }

    ++i;
  }

  var html = count + ' ' + suffix;

  if (this.renderedHTML_ != html) {
    this.innerElement_.innerHTML = html;
    this.renderedHTML_ = html;
  }

  if (this.renderedWidth_ != width) {
    this.innerElement_.style.width = width + 'px';
    this.renderedWidth_ = width;
  }

  if (!this.renderedVisible_) {
    this.element_.style.display = '';
    this.renderedVisible_ = true;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_control_ScaleLine_.Property_ = {
  UNITS: 'units'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_control_ScaleLine_);

/***/ }),

/***/ "./node_modules/ol/control/scalelineunits.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/control/scalelineunits.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
 * `'nautical'`, `'metric'`, `'us'`.
 * @enum {string}
 */
var _ol_control_ScaleLineUnits_ = {
  DEGREES: 'degrees',
  IMPERIAL: 'imperial',
  NAUTICAL: 'nautical',
  METRIC: 'metric',
  US: 'us'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_control_ScaleLineUnits_);

/***/ }),

/***/ "./node_modules/ol/control/zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/zoom.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");






/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api
 */

var _ol_control_Zoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : 'ol-zoom';
  var delta = options.delta !== undefined ? options.delta : 1;
  var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
  var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
  var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
  var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
  var inElement = document.createElement('button');
  inElement.className = className + '-in';
  inElement.setAttribute('type', 'button');
  inElement.title = zoomInTipLabel;
  inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);

  _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(inElement, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, delta));

  var outElement = document.createElement('button');
  outElement.className = className + '-out';
  outElement.setAttribute('type', 'button');
  outElement.title = zoomOutTipLabel;
  outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);

  _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(outElement, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, -delta));

  var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(inElement);
  element.appendChild(outElement);

  _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    element: element,
    target: options.target
  });
  /**
   * @type {number}
   * @private
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_Zoom_, _control_control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {number} delta Zoom delta.
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Zoom_.prototype.handleClick_ = function (delta, event) {
  event.preventDefault();
  this.zoomByDelta_(delta);
};
/**
 * @param {number} delta Zoom delta.
 * @private
 */


_ol_control_Zoom_.prototype.zoomByDelta_ = function (delta) {
  var map = this.getMap();
  var view = map.getView();

  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }

  var currentResolution = view.getResolution();

  if (currentResolution) {
    var newResolution = view.constrainResolution(currentResolution, delta);

    if (this.duration_ > 0) {
      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      view.animate({
        resolution: newResolution,
        duration: this.duration_,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_5__["default"].easeOut
      });
    } else {
      view.setResolution(newResolution);
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_Zoom_);

/***/ }),

/***/ "./node_modules/ol/control/zoomslider.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/control/zoomslider.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _control_control_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../control/control.js */ "./node_modules/ol/control/control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pointer/eventtype.js */ "./node_modules/ol/pointer/eventtype.js");
/* harmony import */ var _pointer_pointereventhandler_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../pointer/pointereventhandler.js */ "./node_modules/ol/pointer/pointereventhandler.js");
// FIXME should possibly show tooltip when dragging?











/**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ol.control.ZoomSlider());
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomSliderOptions=} opt_options Zoom slider options.
 * @api
 */

var _ol_control_ZoomSlider_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * Will hold the current resolution of the view.
   *
   * @type {number|undefined}
   * @private
   */

  this.currentResolution_ = undefined;
  /**
   * The direction of the slider. Will be determined from actual display of the
   * container and defaults to ol.control.ZoomSlider.Direction_.VERTICAL.
   *
   * @type {ol.control.ZoomSlider.Direction_}
   * @private
   */

  this.direction_ = _ol_control_ZoomSlider_.Direction_.VERTICAL;
  /**
   * @type {boolean}
   * @private
   */

  this.dragging_;
  /**
   * @type {number}
   * @private
   */

  this.heightLimit_ = 0;
  /**
   * @type {number}
   * @private
   */

  this.widthLimit_ = 0;
  /**
   * @type {number|undefined}
   * @private
   */

  this.previousX_;
  /**
   * @type {number|undefined}
   * @private
   */

  this.previousY_;
  /**
   * The calculated thumb size (border box plus margins).  Set when initSlider_
   * is called.
   * @type {ol.Size}
   * @private
   */

  this.thumbSize_ = null;
  /**
   * Whether the slider is initialized.
   * @type {boolean}
   * @private
   */

  this.sliderInitialized_ = false;
  /**
   * @type {number}
   * @private
   */

  this.duration_ = options.duration !== undefined ? options.duration : 200;
  var className = options.className !== undefined ? options.className : 'ol-zoomslider';
  var thumbElement = document.createElement('button');
  thumbElement.setAttribute('type', 'button');
  thumbElement.className = className + '-thumb ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_UNSELECTABLE;
  var containerElement = document.createElement('div');
  containerElement.className = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_CONTROL;
  containerElement.appendChild(thumbElement);
  /**
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */

  this.dragger_ = new _pointer_pointereventhandler_js__WEBPACK_IMPORTED_MODULE_10__["default"](containerElement);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(this.dragger_, _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_9__["default"].POINTERDOWN, this.handleDraggerStart_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(this.dragger_, _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_9__["default"].POINTERMOVE, this.handleDraggerDrag_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(this.dragger_, _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_9__["default"].POINTERUP, this.handleDraggerEnd_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(containerElement, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].CLICK, this.handleContainerClick_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(thumbElement, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].CLICK, _events_event_js__WEBPACK_IMPORTED_MODULE_6__["default"].stopPropagation);

  var render = options.render ? options.render : _ol_control_ZoomSlider_.render;

  _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, {
    element: containerElement,
    render: render
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_control_ZoomSlider_, _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @inheritDoc
 */


_ol_control_ZoomSlider_.prototype.disposeInternal = function () {
  this.dragger_.dispose();

  _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.disposeInternal.call(this);
};
/**
 * The enum for available directions.
 *
 * @enum {number}
 * @private
 */


_ol_control_ZoomSlider_.Direction_ = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
/**
 * @inheritDoc
 */

_ol_control_ZoomSlider_.prototype.setMap = function (map) {
  _control_control_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.setMap.call(this, map);

  if (map) {
    map.render();
  }
};
/**
 * Initializes the slider element. This will determine and set this controls
 * direction_ and also constrain the dragging of the thumb to always be within
 * the bounds of the container.
 *
 * @private
 */


_ol_control_ZoomSlider_.prototype.initSlider_ = function () {
  var container = this.element;
  var containerSize = {
    width: container.offsetWidth,
    height: container.offsetHeight
  };
  var thumb = container.firstElementChild;
  var computedStyle = getComputedStyle(thumb);
  var thumbWidth = thumb.offsetWidth + parseFloat(computedStyle['marginRight']) + parseFloat(computedStyle['marginLeft']);
  var thumbHeight = thumb.offsetHeight + parseFloat(computedStyle['marginTop']) + parseFloat(computedStyle['marginBottom']);
  this.thumbSize_ = [thumbWidth, thumbHeight];

  if (containerSize.width > containerSize.height) {
    this.direction_ = _ol_control_ZoomSlider_.Direction_.HORIZONTAL;
    this.widthLimit_ = containerSize.width - thumbWidth;
  } else {
    this.direction_ = _ol_control_ZoomSlider_.Direction_.VERTICAL;
    this.heightLimit_ = containerSize.height - thumbHeight;
  }

  this.sliderInitialized_ = true;
};
/**
 * Update the zoomslider element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.ZoomSlider}
 * @api
 */


_ol_control_ZoomSlider_.render = function (mapEvent) {
  if (!mapEvent.frameState) {
    return;
  }

  if (!this.sliderInitialized_) {
    this.initSlider_();
  }

  var res = mapEvent.frameState.viewState.resolution;

  if (res !== this.currentResolution_) {
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
};
/**
 * @param {Event} event The browser event to handle.
 * @private
 */


_ol_control_ZoomSlider_.prototype.handleContainerClick_ = function (event) {
  var view = this.getMap().getView();
  var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
  var resolution = this.getResolutionForPosition_(relativePosition);
  view.animate({
    resolution: view.constrainResolution(resolution),
    duration: this.duration_,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__["default"].easeOut
  });
};
/**
 * Handle dragger start events.
 * @param {ol.pointer.PointerEvent} event The drag event.
 * @private
 */


_ol_control_ZoomSlider_.prototype.handleDraggerStart_ = function (event) {
  if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {
    this.getMap().getView().setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    this.previousX_ = event.clientX;
    this.previousY_ = event.clientY;
    this.dragging_ = true;
  }
};
/**
 * Handle dragger drag events.
 *
 * @param {ol.pointer.PointerEvent|Event} event The drag event.
 * @private
 */


_ol_control_ZoomSlider_.prototype.handleDraggerDrag_ = function (event) {
  if (this.dragging_) {
    var element = this.element.firstElementChild;
    var deltaX = event.clientX - this.previousX_ + parseInt(element.style.left, 10);
    var deltaY = event.clientY - this.previousY_ + parseInt(element.style.top, 10);
    var relativePosition = this.getRelativePosition_(deltaX, deltaY);
    this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
    this.getMap().getView().setResolution(this.currentResolution_);
    this.setThumbPosition_(this.currentResolution_);
    this.previousX_ = event.clientX;
    this.previousY_ = event.clientY;
  }
};
/**
 * Handle dragger end events.
 * @param {ol.pointer.PointerEvent|Event} event The drag event.
 * @private
 */


_ol_control_ZoomSlider_.prototype.handleDraggerEnd_ = function (event) {
  if (this.dragging_) {
    var view = this.getMap().getView();
    view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    view.animate({
      resolution: view.constrainResolution(this.currentResolution_),
      duration: this.duration_,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__["default"].easeOut
    });
    this.dragging_ = false;
    this.previousX_ = undefined;
    this.previousY_ = undefined;
  }
};
/**
 * Positions the thumb inside its container according to the given resolution.
 *
 * @param {number} res The res.
 * @private
 */


_ol_control_ZoomSlider_.prototype.setThumbPosition_ = function (res) {
  var position = this.getPositionForResolution_(res);
  var thumb = this.element.firstElementChild;

  if (this.direction_ == _ol_control_ZoomSlider_.Direction_.HORIZONTAL) {
    thumb.style.left = this.widthLimit_ * position + 'px';
  } else {
    thumb.style.top = this.heightLimit_ * position + 'px';
  }
};
/**
 * Calculates the relative position of the thumb given x and y offsets.  The
 * relative position scales from 0 to 1.  The x and y offsets are assumed to be
 * in pixel units within the dragger limits.
 *
 * @param {number} x Pixel position relative to the left of the slider.
 * @param {number} y Pixel position relative to the top of the slider.
 * @return {number} The relative position of the thumb.
 * @private
 */


_ol_control_ZoomSlider_.prototype.getRelativePosition_ = function (x, y) {
  var amount;

  if (this.direction_ === _ol_control_ZoomSlider_.Direction_.HORIZONTAL) {
    amount = x / this.widthLimit_;
  } else {
    amount = y / this.heightLimit_;
  }

  return _math_js__WEBPACK_IMPORTED_MODULE_8__["default"].clamp(amount, 0, 1);
};
/**
 * Calculates the corresponding resolution of the thumb given its relative
 * position (where 0 is the minimum and 1 is the maximum).
 *
 * @param {number} position The relative position of the thumb.
 * @return {number} The corresponding resolution.
 * @private
 */


_ol_control_ZoomSlider_.prototype.getResolutionForPosition_ = function (position) {
  var fn = this.getMap().getView().getResolutionForValueFunction();
  return fn(1 - position);
};
/**
 * Determines the relative position of the slider for the given resolution.  A
 * relative position of 0 corresponds to the minimum view resolution.  A
 * relative position of 1 corresponds to the maximum view resolution.
 *
 * @param {number} res The resolution.
 * @return {number} The relative position value (between 0 and 1).
 * @private
 */


_ol_control_ZoomSlider_.prototype.getPositionForResolution_ = function (res) {
  var fn = this.getMap().getView().getValueForResolutionFunction();
  return 1 - fn(res);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_control_ZoomSlider_);

/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");


var _ol_coordinate_ = {};
/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} The input coordinate adjusted by the given delta.
 * @api
 */

_ol_coordinate_.add = function (coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
};
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {ol.geom.Circle} circle The circle.
 * @return {ol.Coordinate} Closest point on the circumference
 */


_ol_coordinate_.closestOnCircle = function (coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x, y;
  x = x0 + r * dx / d;
  y = y0 + r * dy / d;
  return [x, y];
};
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.
 * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to
 *     the segment.
 */


_ol_coordinate_.closestOnSegment = function (coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
};
/**
 * Returns a {@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {ol.CoordinateFormatType} Coordinate format.
 * @api
 */


_ol_coordinate_.createStringXY = function (opt_fractionDigits) {
  return (
    /**
     * @param {ol.Coordinate|undefined} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return _ol_coordinate_.toStringXY(coordinate, opt_fractionDigits);
    }
  );
};
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */


_ol_coordinate_.degreesToStringHDMS = function (hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(min, 2) + '\u2032 ' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
};
/**
 * Transforms the given {@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */


_ol_coordinate_.format = function (coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
};
/**
 * @param {ol.Coordinate} coordinate1 First coordinate.
 * @param {ol.Coordinate} coordinate2 Second coordinate.
 * @return {boolean} Whether the passed coordinates are equal.
 */


_ol_coordinate_.equals = function (coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
};
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_coordinate_.rotate = function (coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
};
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     ol.coordinate.scale(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_coordinate_.scale = function (coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
};
/**
 * Subtract `delta` to `coordinate`. `coordinate` is modified in place and
 * returned by the function.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_coordinate_.sub = function (coordinate, delta) {
  coordinate[0] -= delta[0];
  coordinate[1] -= delta[1];
  return coordinate;
};
/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */


_ol_coordinate_.squaredDistance = function (coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
};
/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */


_ol_coordinate_.distance = function (coord1, coord2) {
  return Math.sqrt(_ol_coordinate_.squaredDistance(coord1, coord2));
};
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {ol.Coordinate} coordinate Coordinate of the point.
 * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */


_ol_coordinate_.squaredDistanceToSegment = function (coordinate, segment) {
  return _ol_coordinate_.squaredDistance(coordinate, _ol_coordinate_.closestOnSegment(coordinate, segment));
};
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */


_ol_coordinate_.toStringHDMS = function (coordinate, opt_fractionDigits) {
  if (coordinate) {
    return _ol_coordinate_.degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + _ol_coordinate_.degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
};
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */


_ol_coordinate_.toStringXY = function (coordinate, opt_fractionDigits) {
  return _ol_coordinate_.format(coordinate, '{x}, {y}', opt_fractionDigits);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_coordinate_);

/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_css_ = {};
/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_CONTROL = 'ol-control';
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object.<string>} The font families (or null if the input spec is invalid).
 */

_ol_css_.getFontFamilies = function () {
  var style;
  var cache = {};
  return function (font) {
    if (!style) {
      style = document.createElement('div').style;
    }

    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';

      if (!family) {
        return null;
      }

      cache[font] = family.split(/,\s?/);
    }

    return cache[font];
  };
}();

/* harmony default export */ __webpack_exports__["default"] = (_ol_css_);

/***/ }),

/***/ "./node_modules/ol/disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/disposable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */

var _ol_Disposable_ = function () {};
/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */


_ol_Disposable_.prototype.disposed_ = false;
/**
 * Clean up.
 */

_ol_Disposable_.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};
/**
 * Extension point for disposable objects.
 * @protected
 */


_ol_Disposable_.prototype.disposeInternal = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/* harmony default export */ __webpack_exports__["default"] = (_ol_Disposable_);

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_dom_ = {};
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */

_ol_dom_.createCanvasContext2D = function (opt_width, opt_height) {
  var canvas = document.createElement('CANVAS');

  if (opt_width) {
    canvas.width = opt_width;
  }

  if (opt_height) {
    canvas.height = opt_height;
  }

  return canvas.getContext('2d');
};
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */


_ol_dom_.outerWidth = function (element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
};
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */


_ol_dom_.outerHeight = function (element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
};
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */


_ol_dom_.replaceNode = function (newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};
/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */


_ol_dom_.removeNode = function (node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};
/**
 * @param {Node} node The node to remove the children from.
 */


_ol_dom_.removeChildren = function (node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_dom_);

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_easing_ = {};
/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

_ol_easing_.easeIn = function (t) {
  return Math.pow(t, 3);
};
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.easeOut = function (t) {
  return 1 - _ol_easing_.easeIn(1 - t);
};
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.inAndOut = function (t) {
  return 3 * t * t - 2 * t * t * t;
};
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.linear = function (t) {
  return t;
};
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.upAndDown = function (t) {
  if (t < 0.5) {
    return _ol_easing_.inAndOut(2 * t);
  } else {
    return 1 - _ol_easing_.inAndOut(2 * (t - 0.5));
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_easing_);

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

var _ol_events_ = {};
/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */

_ol_events_.bindListener_ = function (listenerObj) {
  var boundListener = function (evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;

    if (listenerObj.callOnce) {
      _ol_events_.unlistenByKey(listenerObj);
    }

    return listener.call(bindTo, evt);
  };

  listenerObj.boundListener = boundListener;
  return boundListener;
};
/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */


_ol_events_.findListener_ = function (listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;

  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];

    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }

      return listenerObj;
    }
  }

  return undefined;
};
/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */


_ol_events_.getListeners = function (target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};
/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */


_ol_events_.getListenerMap_ = function (target) {
  var listenerMap = target.ol_lm;

  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }

  return listenerMap;
};
/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */


_ol_events_.removeListeners_ = function (target, type) {
  var listeners = _ol_events_.getListeners(target, type);

  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);

      _obj_js__WEBPACK_IMPORTED_MODULE_0__["default"].clear(listeners[i]);
    }

    listeners.length = 0;
    var listenerMap = target.ol_lm;

    if (listenerMap) {
      delete listenerMap[type];

      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};
/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */


_ol_events_.listen = function (target, type, listener, opt_this, opt_once) {
  var listenerMap = _ol_events_.getListenerMap_(target);

  var listeners = listenerMap[type];

  if (!listeners) {
    listeners = listenerMap[type] = [];
  }

  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, false);

  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj =
    /** @type {ol.EventsKey} */
    {
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
};
/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */


_ol_events_.listenOnce = function (target, type, listener, opt_this) {
  return _ol_events_.listen(target, type, listener, opt_this, true);
};
/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */


_ol_events_.unlisten = function (target, type, listener, opt_this) {
  var listeners = _ol_events_.getListeners(target, type);

  if (listeners) {
    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, true);

    if (listenerObj) {
      _ol_events_.unlistenByKey(listenerObj);
    }
  }
};
/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */


_ol_events_.unlistenByKey = function (key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);

    var listeners = _ol_events_.getListeners(key.target, key.type);

    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);

      if (i !== -1) {
        listeners.splice(i, 1);
      }

      if (listeners.length === 0) {
        _ol_events_.removeListeners_(key.target, key.type);
      }
    }

    _obj_js__WEBPACK_IMPORTED_MODULE_0__["default"].clear(key);
  }
};
/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */


_ol_events_.unlistenAll = function (target) {
  var listenerMap = _ol_events_.getListenerMap_(target);

  for (var type in listenerMap) {
    _ol_events_.removeListeners_(target, type);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_events_);

/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mapbrowsereventtype.js */ "./node_modules/ol/mapbrowsereventtype.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");




var _ol_events_condition_ = {};
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */

_ol_events_condition_.altKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */


_ol_events_condition_.altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return always true.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */


_ol_events_condition_.always = _functions_js__WEBPACK_IMPORTED_MODULE_2__["default"].TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

_ol_events_condition_.click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */


_ol_events_condition_.mouseActionButton = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].WEBKIT && _has_js__WEBPACK_IMPORTED_MODULE_3__["default"].MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */


_ol_events_condition_.never = _functions_js__WEBPACK_IMPORTED_MODULE_2__["default"].FALSE;
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

_ol_events_condition_.pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */


_ol_events_condition_.singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_0__["default"].SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */


_ol_events_condition_.doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */


_ol_events_condition_.noModifierKeys = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */


_ol_events_condition_.platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */


_ol_events_condition_.shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */


_ol_events_condition_.targetNotEditable = function (mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */


_ol_events_condition_.mouseOnly = function (mapBrowserEvent) {
  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType


  return (
    /** @type {ol.MapBrowserEvent} */
    mapBrowserEvent.pointerEvent.pointerType == 'mouse'
  );
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */


_ol_events_condition_.primaryAction = function (mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_events_condition_);

/***/ }),

/***/ "./node_modules/ol/events/event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */
var _ol_events_Event_ = function (type) {
  /**
   * @type {boolean}
   */
  this.propagationStopped;
  /**
   * The event type.
   * @type {string}
   * @api
   */

  this.type = type;
  /**
   * The event target.
   * @type {Object}
   * @api
   */

  this.target = null;
};
/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */


_ol_events_Event_.prototype.preventDefault =
/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};
/**
 * @param {Event|ol.events.Event} evt Event
 */


_ol_events_Event_.stopPropagation = function (evt) {
  evt.stopPropagation();
};
/**
 * @param {Event|ol.events.Event} evt Event
 */


_ol_events_Event_.preventDefault = function (evt) {
  evt.preventDefault();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_events_Event_);

/***/ }),

/***/ "./node_modules/ol/events/eventtarget.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/events/eventtarget.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../disposable.js */ "./node_modules/ol/disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");




/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */

var _ol_events_EventTarget_ = function () {
  _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @private
   * @type {!Object.<string, number>}
   */


  this.pendingRemovals_ = {};
  /**
   * @private
   * @type {!Object.<string, number>}
   */

  this.dispatching_ = {};
  /**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */

  this.listeners_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_events_EventTarget_, _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */


_ol_events_EventTarget_.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];

  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }

  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};
/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */


_ol_events_EventTarget_.prototype.dispatchEvent = function (event) {
  var evt = typeof event === 'string' ? new _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"](event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;

  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }

    ++this.dispatching_[type];

    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }

    --this.dispatching_[type];

    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];

      while (pendingRemovals--) {
        this.removeEventListener(type, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction);
      }

      delete this.dispatching_[type];
    }

    return propagate;
  }
};
/**
 * @inheritDoc
 */


_ol_events_EventTarget_.prototype.disposeInternal = function () {
  _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].unlistenAll(this);
};
/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */


_ol_events_EventTarget_.prototype.getListeners = function (type) {
  return this.listeners_[type];
};
/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */


_ol_events_EventTarget_.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};
/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */


_ol_events_EventTarget_.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];

  if (listeners) {
    var index = listeners.indexOf(listener);

    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);

      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_events_EventTarget_);

/***/ }),

/***/ "./node_modules/ol/events/eventtype.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/eventtype.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 * @const
 */
var _ol_events_EventType_ = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */
  CHANGE: 'change',
  CLEAR: 'clear',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_events_EventType_);

/***/ }),

/***/ "./node_modules/ol/events/keycode.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/events/keycode.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {number}
 * @const
 */
var _ol_events_KeyCode_ = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_events_KeyCode_);

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/corner.js */ "./node_modules/ol/extent/corner.js");
/* harmony import */ var _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/relationship.js */ "./node_modules/ol/extent/relationship.js");



var _ol_extent_ = {};
/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Bounding extent.
 * @api
 */

_ol_extent_.boundingExtent = function (coordinates) {
  var extent = _ol_extent_.createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }

  return extent;
};
/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @private
 * @return {ol.Extent} Extent.
 */


_ol_extent_.boundingExtentXYs_ = function (xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Return extent increased by the provided value.
 * @param {ol.Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_extent_.buffer = function (extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
};
/**
 * Creates a clone of an extent.
 *
 * @param {ol.Extent} extent Extent to clone.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} The clone.
 */


_ol_extent_.clone = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */


_ol_extent_.closestSquaredDistanceXY = function (extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
};
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */


_ol_extent_.containsCoordinate = function (extent, coordinate) {
  return _ol_extent_.containsXY(extent, coordinate[0], coordinate[1]);
};
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */


_ol_extent_.containsExtent = function (extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
};
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */


_ol_extent_.containsXY = function (extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
};
/**
 * Get the relationship between a coordinate and extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} coordinate The coordinate.
 * @return {number} The relationship (bitwise compare with
 *     ol.extent.Relationship).
 */


_ol_extent_.coordinateRelationship = function (extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN;

  if (x < minX) {
    relationship = relationship | _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT;
  }

  if (y < minY) {
    relationship = relationship | _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE;
  }

  if (relationship === _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN) {
    relationship = _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING;
  }

  return relationship;
};
/**
 * Create an empty extent.
 * @return {ol.Extent} Empty extent.
 * @api
 */


_ol_extent_.createEmpty = function () {
  return [Infinity, Infinity, -Infinity, -Infinity];
};
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdate = function (minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
};
/**
 * Create a new empty extent or make the provided one empty.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateEmpty = function (opt_extent) {
  return _ol_extent_.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromCoordinate = function (coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return _ol_extent_.createOrUpdate(x, y, x, y, opt_extent);
};
/**
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromCoordinates = function (coordinates, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendCoordinates(extent, coordinates);
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromFlatCoordinates = function (flatCoordinates, offset, end, stride, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
};
/**
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromRings = function (rings, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendRings(extent, rings);
};
/**
 * Determine if two extents are equivalent.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */


_ol_extent_.equals = function (extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
};
/**
 * Modify an extent to include another extent.
 * @param {ol.Extent} extent1 The extent to be modified.
 * @param {ol.Extent} extent2 The extent that will be included in the first.
 * @return {ol.Extent} A reference to the first (extended) extent.
 * @api
 */


_ol_extent_.extend = function (extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 */


_ol_extent_.extendCoordinate = function (extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendCoordinates = function (extent, coordinates) {
  var i, ii;

  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendFlatCoordinates = function (extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    _ol_extent_.extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendRings = function (extent, rings) {
  var i, ii;

  for (i = 0, ii = rings.length; i < ii; ++i) {
    _ol_extent_.extendCoordinates(extent, rings[i]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */


_ol_extent_.extendXY = function (extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
};
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {ol.Extent} extent Extent.
 * @param {function(this:T, ol.Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */


_ol_extent_.forEachCorner = function (extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, _ol_extent_.getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
};
/**
 * Get the size of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Area.
 * @api
 */


_ol_extent_.getArea = function (extent) {
  var area = 0;

  if (!_ol_extent_.isEmpty(extent)) {
    area = _ol_extent_.getWidth(extent) * _ol_extent_.getHeight(extent);
  }

  return area;
};
/**
 * Get the bottom left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom left coordinate.
 * @api
 */


_ol_extent_.getBottomLeft = function (extent) {
  return [extent[0], extent[1]];
};
/**
 * Get the bottom right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom right coordinate.
 * @api
 */


_ol_extent_.getBottomRight = function (extent) {
  return [extent[2], extent[1]];
};
/**
 * Get the center coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Center.
 * @api
 */


_ol_extent_.getCenter = function (extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
};
/**
 * Get a corner coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.extent.Corner} corner Corner.
 * @return {ol.Coordinate} Corner coordinate.
 */


_ol_extent_.getCorner = function (extent, corner) {
  var coordinate;

  if (corner === _extent_corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = _ol_extent_.getBottomLeft(extent);
  } else if (corner === _extent_corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = _ol_extent_.getBottomRight(extent);
  } else if (corner === _extent_corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = _ol_extent_.getTopLeft(extent);
  } else if (corner === _extent_corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = _ol_extent_.getTopRight(extent);
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(false, 13); // Invalid corner

  }

  return (
    /** @type {!ol.Coordinate} */
    coordinate
  );
};
/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */


_ol_extent_.getEnlargedArea = function (extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
};
/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.getForViewAndSize = function (center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return _ol_extent_.createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
};
/**
 * Get the height of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Height.
 * @api
 */


_ol_extent_.getHeight = function (extent) {
  return extent[3] - extent[1];
};
/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */


_ol_extent_.getIntersectionArea = function (extent1, extent2) {
  var intersection = _ol_extent_.getIntersection(extent1, extent2);

  return _ol_extent_.getArea(intersection);
};
/**
 * Get the intersection of two extents.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.
 * @return {ol.Extent} Intersecting extent.
 * @api
 */


_ol_extent_.getIntersection = function (extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : _ol_extent_.createEmpty();

  if (_ol_extent_.intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }

  return intersection;
};
/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Margin.
 */


_ol_extent_.getMargin = function (extent) {
  return _ol_extent_.getWidth(extent) + _ol_extent_.getHeight(extent);
};
/**
 * Get the size (width, height) of an extent.
 * @param {ol.Extent} extent The extent.
 * @return {ol.Size} The extent size.
 * @api
 */


_ol_extent_.getSize = function (extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
};
/**
 * Get the top left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top left coordinate.
 * @api
 */


_ol_extent_.getTopLeft = function (extent) {
  return [extent[0], extent[3]];
};
/**
 * Get the top right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top right coordinate.
 * @api
 */


_ol_extent_.getTopRight = function (extent) {
  return [extent[2], extent[3]];
};
/**
 * Get the width of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Width.
 * @api
 */


_ol_extent_.getWidth = function (extent) {
  return extent[2] - extent[0];
};
/**
 * Determine if one extent intersects another.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */


_ol_extent_.intersects = function (extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
};
/**
 * Determine if an extent is empty.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */


_ol_extent_.isEmpty = function (extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.returnOrUpdate = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} value Value.
 */


_ol_extent_.scaleFromCenter = function (extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
};
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} start Segment start coordinate.
 * @param {ol.Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */


_ol_extent_.intersectsSegment = function (extent, start, end) {
  var intersects = false;

  var startRel = _ol_extent_.coordinateRelationship(extent, start);

  var endRel = _ol_extent_.coordinateRelationship(extent, end);

  if (startRel === _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING || endRel === _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;

    if (!!(endRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE) && !(startRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) && !(startRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW) && !(startRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) && !(startRel & _extent_relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
};
/**
 * Apply a transform function to the extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.TransformFunction} transformFn Transform function.  Called with
 * [minX, minY, maxX, maxY] extent coordinates.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_extent_.applyTransform = function (extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _ol_extent_.boundingExtentXYs_(xs, ys, opt_extent);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_extent_);

/***/ }),

/***/ "./node_modules/ol/extent/corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/corner.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Extent corner.
 * @enum {string}
 */
var _ol_extent_Corner_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_extent_Corner_);

/***/ }),

/***/ "./node_modules/ol/extent/relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/relationship.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Relationship to an extent.
 * @enum {number}
 */
var _ol_extent_Relationship_ = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_extent_Relationship_);

/***/ }),

/***/ "./node_modules/ol/feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/feature.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _geom_geometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geom/geometry.js */ "./node_modules/ol/geom/geometry.js");
/* harmony import */ var _style_style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style/style.js */ "./node_modules/ol/style/style.js");







/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @constructor
 * @extends {ol.Object}
 * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * @api
 */

var _ol_Feature_ = function (opt_geometryOrProperties) {
  _object_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
  /**
   * @private
   * @type {number|string|undefined}
   */


  this.id_ = undefined;
  /**
   * @type {string}
   * @private
   */

  this.geometryName_ = 'geometry';
  /**
   * User provided style.
   * @private
   * @type {ol.style.Style|Array.<ol.style.Style>|
   *     ol.FeatureStyleFunction}
   */

  this.style_ = null;
  /**
   * @private
   * @type {ol.FeatureStyleFunction|undefined}
   */

  this.styleFunction_ = undefined;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.geometryChangeKey_ = null;

  _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_4__["default"].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  if (opt_geometryOrProperties !== undefined) {
    if (opt_geometryOrProperties instanceof _geom_geometry_js__WEBPACK_IMPORTED_MODULE_5__["default"] || !opt_geometryOrProperties) {
      var geometry = opt_geometryOrProperties;
      this.setGeometry(geometry);
    } else {
      /** @type {Object.<string, *>} */
      var properties = opt_geometryOrProperties;
      this.setProperties(properties);
    }
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].inherits(_ol_Feature_, _object_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * @return {ol.Feature} The clone.
 * @api
 */


_ol_Feature_.prototype.clone = function () {
  var clone = new _ol_Feature_(this.getProperties());
  clone.setGeometryName(this.getGeometryName());
  var geometry = this.getGeometry();

  if (geometry) {
    clone.setGeometry(geometry.clone());
  }

  var style = this.getStyle();

  if (style) {
    clone.setStyle(style);
  }

  return clone;
};
/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {@link ol.Feature#setGeometry}.
 * @return {ol.geom.Geometry|undefined} The default geometry for the feature.
 * @api
 * @observable
 */


_ol_Feature_.prototype.getGeometry = function () {
  return (
    /** @type {ol.geom.Geometry|undefined} */
    this.get(this.geometryName_)
  );
};
/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {@link ol.Feature#setId}.
 * @return {number|string|undefined} Id.
 * @api
 */


_ol_Feature_.prototype.getId = function () {
  return this.id_;
};
/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 * @return {string} Get the property name associated with the default geometry
 *     for this feature.
 * @api
 */


_ol_Feature_.prototype.getGeometryName = function () {
  return this.geometryName_;
};
/**
 * Get the feature's style. Will return what was provided to the
 * {@link ol.Feature#setStyle} method.
 * @return {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.
 * @api
 */


_ol_Feature_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Get the feature's style function.
 * @return {ol.FeatureStyleFunction|undefined} Return a function
 * representing the current style of this feature.
 * @api
 */


_ol_Feature_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};
/**
 * @private
 */


_ol_Feature_.prototype.handleGeometryChange_ = function () {
  this.changed();
};
/**
 * @private
 */


_ol_Feature_.prototype.handleGeometryChanged_ = function () {
  if (this.geometryChangeKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlistenByKey(this.geometryChangeKey_);

    this.geometryChangeKey_ = null;
  }

  var geometry = this.getGeometry();

  if (geometry) {
    this.geometryChangeKey_ = _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(geometry, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleGeometryChange_, this);
  }

  this.changed();
};
/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {@link ol.Feature#getGeometryName}.
 * @param {ol.geom.Geometry|undefined} geometry The new geometry.
 * @api
 * @observable
 */


_ol_Feature_.prototype.setGeometry = function (geometry) {
  this.set(this.geometryName_, geometry);
};
/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 * @param {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.
 * @api
 * @fires ol.events.Event#event:change
 */


_ol_Feature_.prototype.setStyle = function (style) {
  this.style_ = style;
  this.styleFunction_ = !style ? undefined : _ol_Feature_.createStyleFunction(style);
  this.changed();
};
/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {@link ol.source.Vector#getFeatureById}
 * method.
 * @param {number|string|undefined} id The feature id.
 * @api
 * @fires ol.events.Event#event:change
 */


_ol_Feature_.prototype.setId = function (id) {
  this.id_ = id;
  this.changed();
};
/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * @param {string} name The property name of the default geometry.
 * @api
 */


_ol_Feature_.prototype.setGeometryName = function (name) {
  _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlisten(this, _object_js__WEBPACK_IMPORTED_MODULE_4__["default"].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  this.geometryName_ = name;

  _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_4__["default"].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  this.handleGeometryChanged_();
};
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of ol.style.Style or single style objects wrapped
 * in a new feature style function.
 * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {ol.FeatureStyleFunction} A style function.
 */


_ol_Feature_.createStyleFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    if (obj.length == 2) {
      styleFunction = function (resolution) {
        return (
          /** @type {ol.StyleFunction} */
          obj(this, resolution)
        );
      };
    } else {
      styleFunction = obj;
    }
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(obj instanceof _style_style_js__WEBPACK_IMPORTED_MODULE_6__["default"], 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`


      styles = [obj];
    }

    styleFunction = function () {
      return styles;
    };
  }

  return styleFunction;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Feature_);

/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/formattype.js */ "./node_modules/ol/format/formattype.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xml.js */ "./node_modules/ol/xml.js");



var _ol_featureloader_ = {};
/**
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection, ol.Extent)|function(this:ol.source.Vector, Array.<ol.Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {ol.FeatureLoader} The feature loader.
 */

_ol_featureloader_.loadFeaturesXhr = function (url, format, success, failure) {
  return (
    /**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {ol.proj.Projection} projection Projection.
     * @this {ol.source.Vector|ol.VectorTile}
     */
    function (extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

      if (format.getType() == _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */


      xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */

          var source;

          if (type == _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__["default"].JSON || type == _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT) {
            source = xhr.responseText;
          } else if (type == _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML) {
            source = xhr.responseXML;

            if (!source) {
              source = _xml_js__WEBPACK_IMPORTED_MODULE_2__["default"].parse(xhr.responseText);
            }
          } else if (type == _format_formattype_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
            source =
            /** @type {ArrayBuffer} */
            xhr.response;
          }

          if (source) {
            success.call(this, format.readFeatures(source, {
              featureProjection: projection
            }), format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */


      xhr.onerror = function () {
        failure.call(this);
      }.bind(this);

      xhr.send();
    }
  );
};
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @return {ol.FeatureLoader} The feature loader.
 * @api
 */


_ol_featureloader_.xhr = function (url, format) {
  return _ol_featureloader_.loadFeaturesXhr(url, format,
  /**
   * @param {Array.<ol.Feature>} features The loaded features.
   * @param {ol.proj.Projection} dataProjection Data projection.
   * @this {ol.source.Vector}
   */
  function (features, dataProjection) {
    this.addFeatures(features);
  },
  /* FIXME handle error */
  _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_featureloader_);

/***/ }),

/***/ "./node_modules/ol/format/feature.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/feature.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geom_geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/geometry.js */ "./node_modules/ol/geom/geometry.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {ol.format.Feature} subclasses provide the ability to decode and encode
 * {@link ol.Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @constructor
 * @abstract
 * @api
 */

var _ol_format_Feature_ = function () {
  /**
   * @protected
   * @type {ol.proj.Projection}
   */
  this.defaultDataProjection = null;
  /**
   * @protected
   * @type {ol.proj.Projection}
   */

  this.defaultFeatureProjection = null;
};
/**
 * Adds the data projection to the read options.
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {olx.format.ReadOptions|undefined} Options.
 * @protected
 */


_ol_format_Feature_.prototype.getReadOptions = function (source, opt_options) {
  var options;

  if (opt_options) {
    options = {
      dataProjection: opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source),
      featureProjection: opt_options.featureProjection
    };
  }

  return this.adaptOptions(options);
};
/**
 * Sets the `defaultDataProjection` on the options, if no `dataProjection`
 * is set.
 * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options
 *     Options.
 * @protected
 * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}
 *     Updated options.
 */


_ol_format_Feature_.prototype.adaptOptions = function (options) {
  return _obj_js__WEBPACK_IMPORTED_MODULE_1__["default"].assign({
    dataProjection: this.defaultDataProjection,
    featureProjection: this.defaultFeatureProjection
  }, options);
};
/**
 * Get the extent from the source of the last {@link readFeatures} call.
 * @return {ol.Extent} Tile extent.
 */


_ol_format_Feature_.prototype.getLastExtent = function () {
  return null;
};
/**
 * @abstract
 * @return {ol.format.FormatType} Format.
 */


_ol_format_Feature_.prototype.getType = function () {};
/**
 * Read a single feature from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 */


_ol_format_Feature_.prototype.readFeature = function (source, opt_options) {};
/**
 * Read all features from a source.
 *
 * @abstract
 * @param {Document|Node|ArrayBuffer|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 */


_ol_format_Feature_.prototype.readFeatures = function (source, opt_options) {};
/**
 * Read a single geometry from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_Feature_.prototype.readGeometry = function (source, opt_options) {};
/**
 * Read the projection from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 */


_ol_format_Feature_.prototype.readProjection = function (source) {};
/**
 * Encode a feature in this format.
 *
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */


_ol_format_Feature_.prototype.writeFeature = function (feature, opt_options) {};
/**
 * Encode an array of features in this format.
 *
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */


_ol_format_Feature_.prototype.writeFeatures = function (features, opt_options) {};
/**
 * Write a single geometry in this format.
 *
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */


_ol_format_Feature_.prototype.writeGeometry = function (geometry, opt_options) {};
/**
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options
 *     Options.
 * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.
 * @protected
 */


_ol_format_Feature_.transformWithOptions = function (geometry, write, opt_options) {
  var featureProjection = opt_options ? _proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? _proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].get(opt_options.dataProjection) : null;
  /**
   * @type {ol.geom.Geometry|ol.Extent}
   */

  var transformed;

  if (featureProjection && dataProjection && !_proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].equivalent(featureProjection, dataProjection)) {
    if (geometry instanceof _geom_geometry_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    } else {
      // FIXME this is necessary because ol.format.GML treats extents
      // as geometries
      transformed = _proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].transformExtent(geometry, dataProjection, featureProjection);
    }
  } else {
    transformed = geometry;
  }

  if (write && opt_options && opt_options.decimals !== undefined) {
    var power = Math.pow(10, opt_options.decimals); // if decimals option on write, round each coordinate appropriately

    /**
     * @param {Array.<number>} coordinates Coordinates.
     * @return {Array.<number>} Transformed coordinates.
     */

    var transform = function (coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }

      return coordinates;
    };

    if (transformed === geometry) {
      transformed = transformed.clone();
    }

    transformed.applyTransform(transform);
  }

  return transformed;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_Feature_);

/***/ }),

/***/ "./node_modules/ol/format/formattype.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/formattype.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_format_FormatType_ = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_format_FormatType_);

/***/ }),

/***/ "./node_modules/ol/format/geojson.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/geojson.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../feature.js */ "./node_modules/ol/feature.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_jsonfeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/jsonfeature.js */ "./node_modules/ol/format/jsonfeature.js");
/* harmony import */ var _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/geometrycollection.js */ "./node_modules/ol/geom/geometrycollection.js");
/* harmony import */ var _geom_linestring_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/linestring.js */ "./node_modules/ol/geom/linestring.js");
/* harmony import */ var _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/multilinestring.js */ "./node_modules/ol/geom/multilinestring.js");
/* harmony import */ var _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/multipoint.js */ "./node_modules/ol/geom/multipoint.js");
/* harmony import */ var _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/multipolygon.js */ "./node_modules/ol/geom/multipolygon.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
// TODO: serialize dataProjection as crs member when writing
// see https://github.com/openlayers/openlayers/issues/2078














/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @constructor
 * @extends {ol.format.JSONFeature}
 * @param {olx.format.GeoJSONOptions=} opt_options Options.
 * @api
 */

var _ol_format_GeoJSON_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _format_jsonfeature_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
  /**
   * @inheritDoc
   */


  this.defaultDataProjection = _proj_js__WEBPACK_IMPORTED_MODULE_13__["default"].get(options.defaultDataProjection ? options.defaultDataProjection : 'EPSG:4326');

  if (options.featureProjection) {
    this.defaultFeatureProjection = _proj_js__WEBPACK_IMPORTED_MODULE_13__["default"].get(options.featureProjection);
  }
  /**
   * Name of the geometry attribute for features.
   * @type {string|undefined}
   * @private
   */


  this.geometryName_ = options.geometryName;
  /**
   * Look for the geometry name in the feature GeoJSON
   * @type {boolean|undefined}
   * @private
   */

  this.extractGeometryName_ = options.extractGeometryName;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_GeoJSON_, _format_jsonfeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_GeoJSON_.readGeometry_ = function (object, opt_options) {
  if (!object) {
    return null;
  }

  var geometryReader = _ol_format_GeoJSON_.GEOMETRY_READERS_[object.type];
  return (
    /** @type {ol.geom.Geometry} */
    _format_feature_js__WEBPACK_IMPORTED_MODULE_3__["default"].transformWithOptions(geometryReader(object), false, opt_options)
  );
};
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.GeometryCollection} Geometry collection.
 */


_ol_format_GeoJSON_.readGeometryCollectionGeometry_ = function (object, opt_options) {
  var geometries = object.geometries.map(
  /**
   * @param {GeoJSONGeometry} geometry Geometry.
   * @return {ol.geom.Geometry} geometry Geometry.
   */
  function (geometry) {
    return _ol_format_GeoJSON_.readGeometry_(geometry, opt_options);
  });
  return new _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_5__["default"](geometries);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 */


_ol_format_GeoJSON_.readPointGeometry_ = function (object) {
  return new _geom_point_js__WEBPACK_IMPORTED_MODULE_10__["default"](object.coordinates);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.LineString} LineString.
 */


_ol_format_GeoJSON_.readLineStringGeometry_ = function (object) {
  return new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_6__["default"](object.coordinates);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiLineString} MultiLineString.
 */


_ol_format_GeoJSON_.readMultiLineStringGeometry_ = function (object) {
  return new _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_7__["default"](object.coordinates);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPoint} MultiPoint.
 */


_ol_format_GeoJSON_.readMultiPointGeometry_ = function (object) {
  return new _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_8__["default"](object.coordinates);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPolygon} MultiPolygon.
 */


_ol_format_GeoJSON_.readMultiPolygonGeometry_ = function (object) {
  return new _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_9__["default"](object.coordinates);
};
/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Polygon} Polygon.
 */


_ol_format_GeoJSON_.readPolygonGeometry_ = function (object) {
  return new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_11__["default"](object.coordinates);
};
/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writeGeometry_ = function (geometry, opt_options) {
  var geometryWriter = _ol_format_GeoJSON_.GEOMETRY_WRITERS_[geometry.getType()];

  return geometryWriter(
  /** @type {ol.geom.Geometry} */
  _format_feature_js__WEBPACK_IMPORTED_MODULE_3__["default"].transformWithOptions(geometry, true, opt_options), opt_options);
};
/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @private
 * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.
 */


_ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_ = function (geometry) {
  return (
    /** @type {GeoJSONGeometryCollection} */
    {
      type: 'GeometryCollection',
      geometries: []
    }
  );
};
/**
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */


_ol_format_GeoJSON_.writeGeometryCollectionGeometry_ = function (geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function (geometry) {
    var options = _obj_js__WEBPACK_IMPORTED_MODULE_12__["default"].assign({}, opt_options);

    delete options.featureProjection;
    return _ol_format_GeoJSON_.writeGeometry_(geometry, options);
  });
  return (
    /** @type {GeoJSONGeometryCollection} */
    {
      type: 'GeometryCollection',
      geometries: geometries
    }
  );
};
/**
 * @param {ol.geom.LineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writeLineStringGeometry_ = function (geometry, opt_options) {
  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'LineString',
      coordinates: geometry.getCoordinates()
    }
  );
};
/**
 * @param {ol.geom.MultiLineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writeMultiLineStringGeometry_ = function (geometry, opt_options) {
  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'MultiLineString',
      coordinates: geometry.getCoordinates()
    }
  );
};
/**
 * @param {ol.geom.MultiPoint} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writeMultiPointGeometry_ = function (geometry, opt_options) {
  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'MultiPoint',
      coordinates: geometry.getCoordinates()
    }
  );
};
/**
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writeMultiPolygonGeometry_ = function (geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'MultiPolygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};
/**
 * @param {ol.geom.Point} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writePointGeometry_ = function (geometry, opt_options) {
  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'Point',
      coordinates: geometry.getCoordinates()
    }
  );
};
/**
 * @param {ol.geom.Polygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


_ol_format_GeoJSON_.writePolygonGeometry_ = function (geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return (
    /** @type {GeoJSONGeometry} */
    {
      type: 'Polygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};
/**
 * @const
 * @private
 * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}
 */


_ol_format_GeoJSON_.GEOMETRY_READERS_ = {
  'Point': _ol_format_GeoJSON_.readPointGeometry_,
  'LineString': _ol_format_GeoJSON_.readLineStringGeometry_,
  'Polygon': _ol_format_GeoJSON_.readPolygonGeometry_,
  'MultiPoint': _ol_format_GeoJSON_.readMultiPointGeometry_,
  'MultiLineString': _ol_format_GeoJSON_.readMultiLineStringGeometry_,
  'MultiPolygon': _ol_format_GeoJSON_.readMultiPolygonGeometry_,
  'GeometryCollection': _ol_format_GeoJSON_.readGeometryCollectionGeometry_
};
/**
 * @const
 * @private
 * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}
 */

_ol_format_GeoJSON_.GEOMETRY_WRITERS_ = {
  'Point': _ol_format_GeoJSON_.writePointGeometry_,
  'LineString': _ol_format_GeoJSON_.writeLineStringGeometry_,
  'Polygon': _ol_format_GeoJSON_.writePolygonGeometry_,
  'MultiPoint': _ol_format_GeoJSON_.writeMultiPointGeometry_,
  'MultiLineString': _ol_format_GeoJSON_.writeMultiLineStringGeometry_,
  'MultiPolygon': _ol_format_GeoJSON_.writeMultiPolygonGeometry_,
  'GeometryCollection': _ol_format_GeoJSON_.writeGeometryCollectionGeometry_,
  'Circle': _ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_
};
/**
 * Read a feature from a GeoJSON Feature source.  Only works for Feature or
 * geometry types.  Use {@link ol.format.GeoJSON#readFeatures} to read
 * FeatureCollection source. If feature at source has an id, it will be used
 * as Feature id by calling {@link ol.Feature#setId} internally.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 * @api
 */

_ol_format_GeoJSON_.prototype.readFeature;
/**
 * Read all features from a GeoJSON source.  Works for all GeoJSON types.
 * If the source includes only geometries, features will be created with those
 * geometries.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */

_ol_format_GeoJSON_.prototype.readFeatures;
/**
 * @inheritDoc
 */

_ol_format_GeoJSON_.prototype.readFeatureFromObject = function (object, opt_options) {
  /**
   * @type {GeoJSONFeature}
   */
  var geoJSONFeature = null;

  if (object.type === 'Feature') {
    geoJSONFeature =
    /** @type {GeoJSONFeature} */
    object;
  } else {
    geoJSONFeature =
    /** @type {GeoJSONFeature} */
    {
      type: 'Feature',
      geometry:
      /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */
      object
    };
  }

  var geometry = _ol_format_GeoJSON_.readGeometry_(geoJSONFeature.geometry, opt_options);

  var feature = new _feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]();

  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  } else if (this.extractGeometryName_ && geoJSONFeature.geometry_name !== undefined) {
    feature.setGeometryName(geoJSONFeature.geometry_name);
  }

  feature.setGeometry(geometry);

  if (geoJSONFeature.id !== undefined) {
    feature.setId(geoJSONFeature.id);
  }

  if (geoJSONFeature.properties) {
    feature.setProperties(geoJSONFeature.properties);
  }

  return feature;
};
/**
 * @inheritDoc
 */


_ol_format_GeoJSON_.prototype.readFeaturesFromObject = function (object, opt_options) {
  var geoJSONObject =
  /** @type {GeoJSONObject} */
  object;
  /** @type {Array.<ol.Feature>} */

  var features = null;

  if (geoJSONObject.type === 'FeatureCollection') {
    var geoJSONFeatureCollection =
    /** @type {GeoJSONFeatureCollection} */
    object;
    features = [];
    var geoJSONFeatures = geoJSONFeatureCollection.features;
    var i, ii;

    for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
      features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
    }
  } else {
    features = [this.readFeatureFromObject(object, opt_options)];
  }

  return features;
};
/**
 * Read a geometry from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 * @api
 */


_ol_format_GeoJSON_.prototype.readGeometry;
/**
 * @inheritDoc
 */

_ol_format_GeoJSON_.prototype.readGeometryFromObject = function (object, opt_options) {
  return _ol_format_GeoJSON_.readGeometry_(
  /** @type {GeoJSONGeometry} */
  object, opt_options);
};
/**
 * Read the projection from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */


_ol_format_GeoJSON_.prototype.readProjection;
/**
 * @inheritDoc
 */

_ol_format_GeoJSON_.prototype.readProjectionFromObject = function (object) {
  var geoJSONObject =
  /** @type {GeoJSONObject} */
  object;
  var crs = geoJSONObject.crs;
  var projection;

  if (crs) {
    if (crs.type == 'name') {
      projection = _proj_js__WEBPACK_IMPORTED_MODULE_13__["default"].get(crs.properties.name);
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(false, 36); // Unknown SRS type

    }
  } else {
    projection = this.defaultDataProjection;
  }

  return (
    /** @type {ol.proj.Projection} */
    projection
  );
};
/**
 * Encode a feature as a GeoJSON Feature string.
 *
 * @function
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @override
 * @api
 */


_ol_format_GeoJSON_.prototype.writeFeature;
/**
 * Encode a feature as a GeoJSON Feature object.
 *
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeature} Object.
 * @override
 * @api
 */

_ol_format_GeoJSON_.prototype.writeFeatureObject = function (feature, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var object =
  /** @type {GeoJSONFeature} */
  {
    'type': 'Feature'
  };
  var id = feature.getId();

  if (id !== undefined) {
    object.id = id;
  }

  var geometry = feature.getGeometry();

  if (geometry) {
    object.geometry = _ol_format_GeoJSON_.writeGeometry_(geometry, opt_options);
  } else {
    object.geometry = null;
  }

  var properties = feature.getProperties();
  delete properties[feature.getGeometryName()];

  if (!_obj_js__WEBPACK_IMPORTED_MODULE_12__["default"].isEmpty(properties)) {
    object.properties = properties;
  } else {
    object.properties = null;
  }

  return object;
};
/**
 * Encode an array of features as GeoJSON.
 *
 * @function
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */


_ol_format_GeoJSON_.prototype.writeFeatures;
/**
 * Encode an array of features as a GeoJSON object.
 *
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeatureCollection} GeoJSON Object.
 * @override
 * @api
 */

_ol_format_GeoJSON_.prototype.writeFeaturesObject = function (features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var objects = [];
  var i, ii;

  for (i = 0, ii = features.length; i < ii; ++i) {
    objects.push(this.writeFeatureObject(features[i], opt_options));
  }

  return (
    /** @type {GeoJSONFeatureCollection} */
    {
      type: 'FeatureCollection',
      features: objects
    }
  );
};
/**
 * Encode a geometry as a GeoJSON string.
 *
 * @function
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */


_ol_format_GeoJSON_.prototype.writeGeometry;
/**
 * Encode a geometry as a GeoJSON object.
 *
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
 * @override
 * @api
 */

_ol_format_GeoJSON_.prototype.writeGeometryObject = function (geometry, opt_options) {
  return _ol_format_GeoJSON_.writeGeometry_(geometry, this.adaptOptions(opt_options));
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_GeoJSON_);

/***/ }),

/***/ "./node_modules/ol/format/gml2.js":
/*!****************************************!*\
  !*** ./node_modules/ol/format/gml2.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/gmlbase.js */ "./node_modules/ol/format/gmlbase.js");
/* harmony import */ var _format_xsd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _geom_geometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/geometry.js */ "./node_modules/ol/geom/geometry.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");









/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @constructor
 * @param {olx.format.GMLOptions=} opt_options Optional configuration object.
 * @extends {ol.format.GMLBase}
 * @api
 */

var _ol_format_GML2_ = function (opt_options) {
  var options =
  /** @type {olx.format.GMLOptions} */
  opt_options ? opt_options : {};

  _format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, options);

  this.FEATURE_COLLECTION_PARSERS[_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].GMLNS]['featureMember'] = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeArrayPusher(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readFeaturesInternal);
  /**
   * @inheritDoc
   */

  this.schemaLocation = options.schemaLocation ? options.schemaLocation : _ol_format_GML2_.schemaLocation_;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_GML2_, _format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @const
 * @type {string}
 * @private
 */


_ol_format_GML2_.schemaLocation_ = _format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<number>|undefined} Flat coordinates.
 */

_ol_format_GML2_.prototype.readFlatCoordinates_ = function (node, objectStack) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].getAllTextContent(node, false).replace(/^\s*|\s*$/g, '');

  var context =
  /** @type {ol.XmlNodeStackItem} */
  objectStack[0];
  var containerSrs = context['srsName'];
  var axisOrientation = 'enu';

  if (containerSrs) {
    var proj = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].get(containerSrs);

    if (proj) {
      axisOrientation = proj.getAxisOrientation();
    }
  }

  var coordsGroups = s.trim().split(/\s+/);
  var x, y, z;
  var flatCoordinates = [];

  for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
    var coords = coordsGroups[i].split(/,+/);
    x = parseFloat(coords[0]);
    y = parseFloat(coords[1]);
    z = coords.length === 3 ? parseFloat(coords[2]) : 0;

    if (axisOrientation.substr(0, 2) === 'en') {
      flatCoordinates.push(x, y, z);
    } else {
      flatCoordinates.push(y, x, z);
    }
  }

  return flatCoordinates;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.Extent|undefined} Envelope.
 */


_ol_format_GML2_.prototype.readBox_ = function (node, objectStack) {
  /** @type {Array.<number>} */
  var flatCoordinates = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);

  return _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_GML2_.prototype.innerBoundaryIsParser_ = function (node, objectStack) {
  /** @type {Array.<number>|undefined} */
  var flatLinearRing = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);

  if (flatLinearRing) {
    var flatLinearRings =
    /** @type {Array.<Array.<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings.push(flatLinearRing);
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_GML2_.prototype.outerBoundaryIsParser_ = function (node, objectStack) {
  /** @type {Array.<number>|undefined} */
  var flatLinearRing = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);

  if (flatLinearRing) {
    var flatLinearRings =
    /** @type {Array.<Array.<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */


_ol_format_GML2_.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'coordinates': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_ol_format_GML2_.prototype.readFlatCoordinates_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GML2_.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'innerBoundaryIs': _ol_format_GML2_.prototype.innerBoundaryIsParser_,
    'outerBoundaryIs': _ol_format_GML2_.prototype.outerBoundaryIsParser_
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GML2_.prototype.BOX_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'coordinates': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeArrayPusher(_ol_format_GML2_.prototype.readFlatCoordinates_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GML2_.prototype.GEOMETRY_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'Point': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPoint),
    'MultiPoint': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiPoint),
    'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLineString),
    'MultiLineString': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiLineString),
    'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLinearRing),
    'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPolygon),
    'MultiPolygon': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_format_gmlbase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiPolygon),
    'Box': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeReplacer(_ol_format_GML2_.prototype.readBox_)
  }
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node|undefined} Node.
 * @private
 */

_ol_format_GML2_.prototype.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var multiSurface = context['multiSurface'];
  var surface = context['surface'];
  var multiCurve = context['multiCurve'];
  var nodeName;

  if (!Array.isArray(value)) {
    nodeName =
    /** @type {ol.geom.Geometry} */
    value.getType();

    if (nodeName === 'MultiPolygon' && multiSurface === true) {
      nodeName = 'MultiSurface';
    } else if (nodeName === 'Polygon' && surface === true) {
      nodeName = 'Surface';
    } else if (nodeName === 'MultiLineString' && multiCurve === true) {
      nodeName = 'MultiCurve';
    }
  } else {
    nodeName = 'Envelope';
  }

  return _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS('http://www.opengis.net/gml', nodeName);
};
/**
 * @param {Node} node Node.
 * @param {ol.Feature} feature Feature.
 * @param {Array.<*>} objectStack Node stack.
 */


_ol_format_GML2_.prototype.writeFeatureElement = function (node, feature, objectStack) {
  var fid = feature.getId();

  if (fid) {
    node.setAttribute('fid', fid);
  }

  var context =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var featureNS = context['featureNS'];
  var geometryName = feature.getGeometryName();

  if (!context.serializers) {
    context.serializers = {};
    context.serializers[featureNS] = {};
  }

  var properties = feature.getProperties();
  var keys = [],
      values = [];

  for (var key in properties) {
    var value = properties[key];

    if (value !== null) {
      keys.push(key);
      values.push(value);

      if (key == geometryName || value instanceof _geom_geometry_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(this.writeGeometryElement, this);
        }
      } else {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["default"].writeStringTextNode);
        }
      }
    }
  }

  var item = _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign({}, context);

  item.node = node;

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop(
  /** @type {ol.XmlNodeStackItem} */
  item, context.serializers, _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {Array.<*>} objectStack Node stack.
 */


_ol_format_GML2_.prototype.writeGeometryElement = function (node, geometry, objectStack) {
  var context =
  /** @type {olx.format.WriteOptions} */
  objectStack[objectStack.length - 1];

  var item = _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign({}, context);

  item.node = node;
  var value;

  if (Array.isArray(geometry)) {
    if (context.dataProjection) {
      value = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].transformExtent(geometry, context.featureProjection, context.dataProjection);
    } else {
      value = geometry;
    }
  } else {
    value = _format_feature_js__WEBPACK_IMPORTED_MODULE_2__["default"].transformWithOptions(
    /** @type {ol.geom.Geometry} */
    geometry, true, context);
  }

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop(
  /** @type {ol.XmlNodeStackItem} */
  item, _ol_format_GML2_.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LineString} geometry LineString geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeCurveOrLineString_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context['srsName'];

  if (node.nodeName !== 'LineStringSegment' && srsName) {
    node.setAttribute('srsName', srsName);
  }

  if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    this.writeCoordinates_(coordinates, geometry, objectStack);
  } else if (node.nodeName === 'Curve') {
    var segments = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'segments');

    node.appendChild(segments);
    this.writeCurveSegments_(segments, geometry, objectStack);
  }
};
/**
 * @param {string} namespaceURI XML namespace.
 * @returns {Node} coordinates node.
 * @private
 */


_ol_format_GML2_.prototype.createCoordinatesNode_ = function (namespaceURI) {
  var coordinates = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(namespaceURI, 'coordinates');

  coordinates.setAttribute('decimal', '.');
  coordinates.setAttribute('cs', ',');
  coordinates.setAttribute('ts', ' ');
  return coordinates;
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LineString|ol.geom.LinearRing} value Geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeCoordinates_ = function (node, value, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName']; // only 2d for simple features profile

  var points = value.getCoordinates();
  var len = points.length;
  var parts = new Array(len);
  var point;

  for (var i = 0; i < len; ++i) {
    point = points[i];
    parts[i] = this.getCoords_(point, srsName, hasZ);
  }

  _format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["default"].writeStringTextNode(node, parts.join(' '));
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LineString} line LineString geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeCurveSegments_ = function (node, line, objectStack) {
  var child = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'LineStringSegment');

  node.appendChild(child);
  this.writeCurveOrLineString_(child, line, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Polygon} geometry Polygon geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeSurfaceOrPolygon_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName'];

  if (node.nodeName !== 'PolygonPatch' && srsName) {
    node.setAttribute('srsName', srsName);
  }

  if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
    var rings = geometry.getLinearRings();

    _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop({
      node: node,
      hasZ: hasZ,
      srsName: srsName
    }, _ol_format_GML2_.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
  } else if (node.nodeName === 'Surface') {
    var patches = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'patches');

    node.appendChild(patches);
    this.writeSurfacePatches_(patches, geometry, objectStack);
  }
};
/**
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node} Node.
 * @private
 */


_ol_format_GML2_.prototype.RING_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var exteriorWritten = context['exteriorWritten'];

  if (exteriorWritten === undefined) {
    context['exteriorWritten'] = true;
  }

  return _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeSurfacePatches_ = function (node, polygon, objectStack) {
  var child = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'PolygonPatch');

  node.appendChild(child);
  this.writeSurfaceOrPolygon_(child, polygon, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LinearRing} ring LinearRing geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeRing_ = function (node, ring, objectStack) {
  var linearRing = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'LinearRing');

  node.appendChild(linearRing);
  this.writeLinearRing_(linearRing, ring, objectStack);
};
/**
 * @param {Array.<number>} point Point geometry.
 * @param {string=} opt_srsName Optional srsName
 * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.
 * @return {string} The coords string.
 * @private
 */


_ol_format_GML2_.prototype.getCoords_ = function (point, opt_srsName, opt_hasZ) {
  var axisOrientation = 'enu';

  if (opt_srsName) {
    axisOrientation = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].get(opt_srsName).getAxisOrientation();
  }

  var coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];

  if (opt_hasZ) {
    // For newly created points, Z can be undefined.
    var z = point[2] || 0;
    coords += ',' + z;
  }

  return coords;
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.MultiLineString} geometry MultiLineString geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeMultiCurveOrLineString_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName'];
  var curve = context['curve'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var lines = geometry.getLineStrings();

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop({
    node: node,
    hasZ: hasZ,
    srsName: srsName,
    curve: curve
  }, _ol_format_GML2_.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Point} geometry Point geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writePoint_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var coordinates = this.createCoordinatesNode_(node.namespaceURI);
  node.appendChild(coordinates);
  var point = geometry.getCoordinates();
  var coord = this.getCoords_(point, srsName, hasZ);

  _format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["default"].writeStringTextNode(coordinates, coord);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.MultiPoint} geometry MultiPoint geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeMultiPoint_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var points = geometry.getPoints();

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop({
    node: node,
    hasZ: hasZ,
    srsName: srsName
  }, _ol_format_GML2_.POINTMEMBER_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Point} point Point geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writePointMember_ = function (node, point, objectStack) {
  var child = _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS(node.namespaceURI, 'Point');

  node.appendChild(child);
  this.writePoint_(child, point, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LineString} line LineString geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeLineStringOrCurveMember_ = function (node, line, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);

  if (child) {
    node.appendChild(child);
    this.writeCurveOrLineString_(child, line, objectStack);
  }
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LinearRing} geometry LinearRing geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeLinearRing_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context['srsName'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var coordinates = this.createCoordinatesNode_(node.namespaceURI);
  node.appendChild(coordinates);
  this.writeCoordinates_(coordinates, geometry, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeMultiSurfaceOrPolygon_ = function (node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context['hasZ'];
  var srsName = context['srsName'];
  var surface = context['surface'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var polygons = geometry.getPolygons();

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop({
    node: node,
    hasZ: hasZ,
    srsName: srsName,
    surface: surface
  }, _ol_format_GML2_.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeSurfaceOrPolygonMember_ = function (node, polygon, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);

  if (child) {
    node.appendChild(child);
    this.writeSurfaceOrPolygon_(child, polygon, objectStack);
  }
};
/**
 * @param {Node} node Node.
 * @param {ol.Extent} extent Extent.
 * @param {Array.<*>} objectStack Node stack.
 * @private
 */


_ol_format_GML2_.prototype.writeEnvelope = function (node, extent, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context['srsName'];

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  var keys = ['lowerCorner', 'upperCorner'];
  var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];

  _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].pushSerializeAndPop(
  /** @type {ol.XmlNodeStackItem} */
  {
    node: node
  }, _ol_format_GML2_.ENVELOPE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */


_ol_format_GML2_.GEOMETRY_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'Curve': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeCurveOrLineString_),
    'MultiCurve': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeMultiCurveOrLineString_),
    'Point': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writePoint_),
    'MultiPoint': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeMultiPoint_),
    'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeCurveOrLineString_),
    'MultiLineString': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeMultiCurveOrLineString_),
    'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeLinearRing_),
    'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeSurfaceOrPolygon_),
    'MultiPolygon': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeMultiSurfaceOrPolygon_),
    'Surface': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeSurfaceOrPolygon_),
    'MultiSurface': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeMultiSurfaceOrPolygon_),
    'Envelope': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeEnvelope)
  }
};
/**
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_GML2_.RING_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'outerBoundaryIs': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeRing_),
    'innerBoundaryIs': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeRing_)
  }
};
/**
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_GML2_.POINTMEMBER_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'pointMember': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writePointMember_)
  }
};
/**
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_GML2_.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'lineStringMember': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeLineStringOrCurveMember_),
    'curveMember': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeLineStringOrCurveMember_)
  }
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node|undefined} Node.
 * @private
 */

_ol_format_GML2_.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].createElementNS('http://www.opengis.net/gml', _ol_format_GML2_.MULTIGEOMETRY_TO_MEMBER_NODENAME_[parentNode.nodeName]);
};
/**
 * @const
 * @type {Object.<string, string>}
 * @private
 */


_ol_format_GML2_.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {
  'MultiLineString': 'lineStringMember',
  'MultiCurve': 'curveMember',
  'MultiPolygon': 'polygonMember',
  'MultiSurface': 'surfaceMember'
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_GML2_.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'surfaceMember': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeSurfaceOrPolygonMember_),
    'polygonMember': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_ol_format_GML2_.prototype.writeSurfaceOrPolygonMember_)
  }
};
/**
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_GML2_.ENVELOPE_SERIALIZERS_ = {
  'http://www.opengis.net/gml': {
    'lowerCorner': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["default"].writeStringTextNode),
    'upperCorner': _xml_js__WEBPACK_IMPORTED_MODULE_8__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["default"].writeStringTextNode)
  }
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_format_GML2_);

/***/ }),

/***/ "./node_modules/ol/format/gmlbase.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/gmlbase.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../feature.js */ "./node_modules/ol/feature.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/xmlfeature.js */ "./node_modules/ol/format/xmlfeature.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_linestring_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/linestring.js */ "./node_modules/ol/geom/linestring.js");
/* harmony import */ var _geom_linearring_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/linearring.js */ "./node_modules/ol/geom/linearring.js");
/* harmony import */ var _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/multilinestring.js */ "./node_modules/ol/geom/multilinestring.js");
/* harmony import */ var _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/multipoint.js */ "./node_modules/ol/geom/multipoint.js");
/* harmony import */ var _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/multipolygon.js */ "./node_modules/ol/geom/multipolygon.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part
// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect
// envelopes/extents, only geometries!
















/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes ol.format.GML2 and
 * ol.format.GML3.
 *
 * @constructor
 * @abstract
 * @param {olx.format.GMLOptions=} opt_options
 *     Optional configuration object.
 * @extends {ol.format.XMLFeature}
 */

var _ol_format_GMLBase_ = function (opt_options) {
  var options =
  /** @type {olx.format.GMLOptions} */
  opt_options ? opt_options : {};
  /**
   * @protected
   * @type {Array.<string>|string|undefined}
   */

  this.featureType = options.featureType;
  /**
   * @protected
   * @type {Object.<string, string>|string|undefined}
   */

  this.featureNS = options.featureNS;
  /**
   * @protected
   * @type {string}
   */

  this.srsName = options.srsName;
  /**
   * @protected
   * @type {string}
   */

  this.schemaLocation = '';
  /**
   * @type {Object.<string, Object.<string, Object>>}
   */

  this.FEATURE_COLLECTION_PARSERS = {};
  this.FEATURE_COLLECTION_PARSERS[_ol_format_GMLBase_.GMLNS] = {
    'featureMember': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeReplacer(_ol_format_GMLBase_.prototype.readFeaturesInternal),
    'featureMembers': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeReplacer(_ol_format_GMLBase_.prototype.readFeaturesInternal)
  };

  _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_GMLBase_, _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @const
 * @type {string}
 */


_ol_format_GMLBase_.GMLNS = 'http://www.opengis.net/gml';
/**
 * A regular expression that matches if a string only contains whitespace
 * characters. It will e.g. match `''`, `' '`, `'\n'` etc. The non-breaking
 * space (0xa0) is explicitly included as IE doesn't include it in its
 * definition of `\s`.
 *
 * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160
 *
 * @const
 * @type {RegExp}
 * @private
 */

_ol_format_GMLBase_.ONLY_WHITESPACE_RE_ = /^[\s\xa0]*$/;
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Array.<ol.Feature> | undefined} Features.
 */

_ol_format_GMLBase_.prototype.readFeaturesInternal = function (node, objectStack) {
  var localName = node.localName;
  var features = null;

  if (localName == 'FeatureCollection') {
    if (node.namespaceURI === 'http://www.opengis.net/wfs') {
      features = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    } else {
      features = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop(null, this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    }
  } else if (localName == 'featureMembers' || localName == 'featureMember') {
    var context = objectStack[0];
    var featureType = context['featureType'];
    var featureNS = context['featureNS'];
    var i,
        ii,
        prefix = 'p',
        defaultPrefix = 'p0';

    if (!featureType && node.childNodes) {
      featureType = [], featureNS = {};

      for (i = 0, ii = node.childNodes.length; i < ii; ++i) {
        var child = node.childNodes[i];

        if (child.nodeType === 1) {
          var ft = child.nodeName.split(':').pop();

          if (featureType.indexOf(ft) === -1) {
            var key = '';
            var count = 0;
            var uri = child.namespaceURI;

            for (var candidate in featureNS) {
              if (featureNS[candidate] === uri) {
                key = candidate;
                break;
              }

              ++count;
            }

            if (!key) {
              key = prefix + count;
              featureNS[key] = uri;
            }

            featureType.push(key + ':' + ft);
          }
        }
      }

      if (localName != 'featureMember') {
        // recheck featureType for each featureMember
        context['featureType'] = featureType;
        context['featureNS'] = featureNS;
      }
    }

    if (typeof featureNS === 'string') {
      var ns = featureNS;
      featureNS = {};
      featureNS[defaultPrefix] = ns;
    }

    var parsersNS = {};
    var featureTypes = Array.isArray(featureType) ? featureType : [featureType];

    for (var p in featureNS) {
      var parsers = {};

      for (i = 0, ii = featureTypes.length; i < ii; ++i) {
        var featurePrefix = featureTypes[i].indexOf(':') === -1 ? defaultPrefix : featureTypes[i].split(':')[0];

        if (featurePrefix === p) {
          parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(this.readFeatureElement, this) : _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeReplacer(this.readFeatureElement, this);
        }
      }

      parsersNS[featureNS[p]] = parsers;
    }

    if (localName == 'featureMember') {
      features = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop(undefined, parsersNS, node, objectStack);
    } else {
      features = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([], parsersNS, node, objectStack);
    }
  }

  if (features === null) {
    features = [];
  }

  return features;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.Geometry|undefined} Geometry.
 */


_ol_format_GMLBase_.prototype.readGeometryElement = function (node, objectStack) {
  var context =
  /** @type {Object} */
  objectStack[0];
  context['srsName'] = node.firstElementChild.getAttribute('srsName');
  context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
  /** @type {ol.geom.Geometry} */

  var geometry = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop(null, this.GEOMETRY_PARSERS_, node, objectStack, this);

  if (geometry) {
    return (
      /** @type {ol.geom.Geometry} */
      _format_feature_js__WEBPACK_IMPORTED_MODULE_3__["default"].transformWithOptions(geometry, false, context)
    );
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.Feature} Feature.
 */


_ol_format_GMLBase_.prototype.readFeatureElement = function (node, objectStack) {
  var n;

  var fid = node.getAttribute('fid') || _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAttributeNS(node, _ol_format_GMLBase_.GMLNS, 'id');

  var values = {},
      geometryName;

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName; // Assume attribute elements have one child node and that the child
    // is a text or CDATA node (to be treated as text).
    // Otherwise assume it is a geometry node.

    if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
      var value = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAllTextContent(n, false);

      if (_ol_format_GMLBase_.ONLY_WHITESPACE_RE_.test(value)) {
        value = undefined;
      }

      values[localName] = value;
    } else {
      // boundedBy is an extent and must not be considered as a geometry
      if (localName !== 'boundedBy') {
        geometryName = localName;
      }

      values[localName] = this.readGeometryElement(n, objectStack);
    }
  }

  var feature = new _feature_js__WEBPACK_IMPORTED_MODULE_2__["default"](values);

  if (geometryName) {
    feature.setGeometryName(geometryName);
  }

  if (fid) {
    feature.setId(fid);
  }

  return feature;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.Point|undefined} Point.
 */


_ol_format_GMLBase_.prototype.readPoint = function (node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var point = new _geom_point_js__WEBPACK_IMPORTED_MODULE_11__["default"](null);
    point.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ, flatCoordinates);
    return point;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.MultiPoint|undefined} MultiPoint.
 */


_ol_format_GMLBase_.prototype.readMultiPoint = function (node, objectStack) {
  /** @type {Array.<Array.<number>>} */
  var coordinates = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([], this.MULTIPOINT_PARSERS_, node, objectStack, this);

  if (coordinates) {
    return new _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_9__["default"](coordinates);
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.MultiLineString|undefined} MultiLineString.
 */


_ol_format_GMLBase_.prototype.readMultiLineString = function (node, objectStack) {
  /** @type {Array.<ol.geom.LineString>} */
  var lineStrings = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([], this.MULTILINESTRING_PARSERS_, node, objectStack, this);

  if (lineStrings) {
    var multiLineString = new _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_8__["default"](null);
    multiLineString.setLineStrings(lineStrings);
    return multiLineString;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.MultiPolygon|undefined} MultiPolygon.
 */


_ol_format_GMLBase_.prototype.readMultiPolygon = function (node, objectStack) {
  /** @type {Array.<ol.geom.Polygon>} */
  var polygons = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, node, objectStack, this);

  if (polygons) {
    var multiPolygon = new _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](null);
    multiPolygon.setPolygons(polygons);
    return multiPolygon;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_GMLBase_.prototype.pointMemberParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].parseNode(this.POINTMEMBER_PARSERS_, node, objectStack, this);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_GMLBase_.prototype.lineStringMemberParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].parseNode(this.LINESTRINGMEMBER_PARSERS_, node, objectStack, this);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_GMLBase_.prototype.polygonMemberParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].parseNode(this.POLYGONMEMBER_PARSERS_, node, objectStack, this);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.LineString|undefined} LineString.
 */


_ol_format_GMLBase_.prototype.readLineString = function (node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var lineString = new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_6__["default"](null);
    lineString.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ, flatCoordinates);
    return lineString;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<number>|undefined} LinearRing flat coordinates.
 */


_ol_format_GMLBase_.prototype.readFlatLinearRing_ = function (node, objectStack) {
  var ring = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);

  if (ring) {
    return ring;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.LinearRing|undefined} LinearRing.
 */


_ol_format_GMLBase_.prototype.readLinearRing = function (node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var ring = new _geom_linearring_js__WEBPACK_IMPORTED_MODULE_7__["default"](null);
    ring.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ, flatCoordinates);
    return ring;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.geom.Polygon|undefined} Polygon.
 */


_ol_format_GMLBase_.prototype.readPolygon = function (node, objectStack) {
  /** @type {Array.<Array.<number>>} */
  var flatLinearRings = _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);

  if (flatLinearRings && flatLinearRings[0]) {
    var polygon = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](null);
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    var i, ii;

    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(flatCoordinates, flatLinearRings[i]);

      ends.push(flatCoordinates.length);
    }

    polygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ, flatCoordinates, ends);
    return polygon;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<number>} Flat coordinates.
 */


_ol_format_GMLBase_.prototype.readFlatCoordinatesFromNode_ = function (node, objectStack) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */


_ol_format_GMLBase_.prototype.MULTIPOINT_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'pointMember': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.pointMemberParser_),
    'pointMembers': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.pointMemberParser_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GMLBase_.prototype.MULTILINESTRING_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'lineStringMember': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.lineStringMemberParser_),
    'lineStringMembers': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.lineStringMemberParser_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GMLBase_.prototype.MULTIPOLYGON_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'polygonMember': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.polygonMemberParser_),
    'polygonMembers': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.polygonMemberParser_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GMLBase_.prototype.POINTMEMBER_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'Point': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.readFlatCoordinatesFromNode_)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GMLBase_.prototype.LINESTRINGMEMBER_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.readLineString)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_GMLBase_.prototype.POLYGONMEMBER_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeArrayPusher(_ol_format_GMLBase_.prototype.readPolygon)
  }
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @protected
 */

_ol_format_GMLBase_.prototype.RING_PARSERS = {
  'http://www.opengis.net/gml': {
    'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_15__["default"].makeReplacer(_ol_format_GMLBase_.prototype.readFlatLinearRing_)
  }
};
/**
 * @inheritDoc
 */

_ol_format_GMLBase_.prototype.readGeometryFromNode = function (node, opt_options) {
  var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);
  return geometry ? geometry : null;
};
/**
 * Read all features from a GML FeatureCollection.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_format_GMLBase_.prototype.readFeatures;
/**
 * @inheritDoc
 */

_ol_format_GMLBase_.prototype.readFeaturesFromNode = function (node, opt_options) {
  var options = {
    featureType: this.featureType,
    featureNS: this.featureNS
  };

  if (opt_options) {
    _obj_js__WEBPACK_IMPORTED_MODULE_13__["default"].assign(options, this.getReadOptions(node, opt_options));
  }

  var features = this.readFeaturesInternal(node, [options]);
  return features || [];
};
/**
 * @inheritDoc
 */


_ol_format_GMLBase_.prototype.readProjectionFromNode = function (node) {
  return _proj_js__WEBPACK_IMPORTED_MODULE_14__["default"].get(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_GMLBase_);

/***/ }),

/***/ "./node_modules/ol/format/jsonfeature.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/format/jsonfeature.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_formattype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../format/formattype.js */ "./node_modules/ol/format/formattype.js");



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 */

var _ol_format_JSONFeature_ = function () {
  _format_feature_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_JSONFeature_, _format_feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {Document|Node|Object|string} source Source.
 * @private
 * @return {Object} Object.
 */


_ol_format_JSONFeature_.prototype.getObject_ = function (source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ?
    /** @type {Object} */
    object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.getType = function () {
  return _format_formattype_js__WEBPACK_IMPORTED_MODULE_2__["default"].JSON;
};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.readFeature = function (source, opt_options) {
  return this.readFeatureFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.readFeatures = function (source, opt_options) {
  return this.readFeaturesFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.Feature} Feature.
 */


_ol_format_JSONFeature_.prototype.readFeatureFromObject = function (object, opt_options) {};
/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */


_ol_format_JSONFeature_.prototype.readFeaturesFromObject = function (object, opt_options) {};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.readGeometry = function (source, opt_options) {
  return this.readGeometryFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_JSONFeature_.prototype.readGeometryFromObject = function (object, opt_options) {};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.readProjection = function (source) {
  return this.readProjectionFromObject(this.getObject_(source));
};
/**
 * @abstract
 * @param {Object} object Object.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */


_ol_format_JSONFeature_.prototype.readProjectionFromObject = function (object) {};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.writeFeature = function (feature, opt_options) {
  return JSON.stringify(this.writeFeatureObject(feature, opt_options));
};
/**
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */


_ol_format_JSONFeature_.prototype.writeFeatureObject = function (feature, opt_options) {};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.writeFeatures = function (features, opt_options) {
  return JSON.stringify(this.writeFeaturesObject(features, opt_options));
};
/**
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */


_ol_format_JSONFeature_.prototype.writeFeaturesObject = function (features, opt_options) {};
/**
 * @inheritDoc
 */


_ol_format_JSONFeature_.prototype.writeGeometry = function (geometry, opt_options) {
  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
};
/**
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */


_ol_format_JSONFeature_.prototype.writeGeometryObject = function (geometry, opt_options) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_JSONFeature_);

/***/ }),

/***/ "./node_modules/ol/format/kml.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/kml.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../feature.js */ "./node_modules/ol/feature.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../format/xmlfeature.js */ "./node_modules/ol/format/xmlfeature.js");
/* harmony import */ var _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../format/xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/geometrycollection.js */ "./node_modules/ol/geom/geometrycollection.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_linestring_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/linestring.js */ "./node_modules/ol/geom/linestring.js");
/* harmony import */ var _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/multilinestring.js */ "./node_modules/ol/geom/multilinestring.js");
/* harmony import */ var _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/multipoint.js */ "./node_modules/ol/geom/multipoint.js");
/* harmony import */ var _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/multipolygon.js */ "./node_modules/ol/geom/multipolygon.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _style_fill_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../style/fill.js */ "./node_modules/ol/style/fill.js");
/* harmony import */ var _style_icon_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../style/icon.js */ "./node_modules/ol/style/icon.js");
/* harmony import */ var _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../style/iconanchorunits.js */ "./node_modules/ol/style/iconanchorunits.js");
/* harmony import */ var _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../style/iconorigin.js */ "./node_modules/ol/style/iconorigin.js");
/* harmony import */ var _style_stroke_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../style/stroke.js */ "./node_modules/ol/style/stroke.js");
/* harmony import */ var _style_style_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../style/style.js */ "./node_modules/ol/style/style.js");
/* harmony import */ var _style_text_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../style/text.js */ "./node_modules/ol/style/text.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
// FIXME http://earth.google.com/kml/1.0 namespace?
// FIXME why does node.getAttribute return an unknown type?
// FIXME serialize arbitrary feature properties
// FIXME don't parse style if extractStyles is false



























/**
 * @classdesc
 * Feature format for reading and writing data in the KML format.
 *
 * Note that the KML format uses the URL() constructor. Older browsers such as IE
 * which do not support this will need a URL polyfill to be loaded before use.
 *
 * @constructor
 * @extends {ol.format.XMLFeature}
 * @param {olx.format.KMLOptions=} opt_options Options.
 * @api
 */

var _ol_format_KML_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this);

  if (!_ol_format_KML_.DEFAULT_STYLE_ARRAY_) {
    _ol_format_KML_.createStyleDefaults_();
  }
  /**
   * @inheritDoc
   */


  this.defaultDataProjection = _proj_js__WEBPACK_IMPORTED_MODULE_18__["default"].get('EPSG:4326');
  /**
   * @private
   * @type {Array.<ol.style.Style>}
   */

  this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : _ol_format_KML_.DEFAULT_STYLE_ARRAY_;
  /**
   * @private
   * @type {boolean}
   */

  this.extractStyles_ = options.extractStyles !== undefined ? options.extractStyles : true;
  /**
   * @private
   * @type {boolean}
   */

  this.writeStyles_ = options.writeStyles !== undefined ? options.writeStyles : true;
  /**
   * @private
   * @type {Object.<string, (Array.<ol.style.Style>|string)>}
   */

  this.sharedStyles_ = {};
  /**
   * @private
   * @type {boolean}
   */

  this.showPointNames_ = options.showPointNames !== undefined ? options.showPointNames : true;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_KML_, _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * @const
 * @type {Array.<string>}
 * @private
 */


_ol_format_KML_.GX_NAMESPACE_URIS_ = ['http://www.google.com/kml/ext/2.2'];
/**
 * @const
 * @type {Array.<string>}
 * @private
 */

_ol_format_KML_.NAMESPACE_URIS_ = [null, 'http://earth.google.com/kml/2.0', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.2', 'http://www.opengis.net/kml/2.2'];
/**
 * @const
 * @type {string}
 * @private
 */

_ol_format_KML_.SCHEMA_LOCATION_ = 'http://www.opengis.net/kml/2.2 ' + 'https://developers.google.com/kml/schema/kml22gx.xsd';
/**
 * @return {Array.<ol.style.Style>} Default style.
 * @private
 */

_ol_format_KML_.createStyleDefaults_ = function () {
  /**
   * @const
   * @type {ol.Color}
   * @private
   */
  _ol_format_KML_.DEFAULT_COLOR_ = [255, 255, 255, 1];
  /**
   * @const
   * @type {ol.style.Fill}
   * @private
   */

  _ol_format_KML_.DEFAULT_FILL_STYLE_ = new _style_fill_js__WEBPACK_IMPORTED_MODULE_19__["default"]({
    color: _ol_format_KML_.DEFAULT_COLOR_
  });
  /**
   * @const
   * @type {ol.Size}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_ = [20, 2]; // FIXME maybe [8, 32] ?

  /**
   * @const
   * @type {ol.style.IconAnchorUnits}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_ = _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS;
  /**
   * @const
   * @type {ol.style.IconAnchorUnits}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_ = _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS;
  /**
   * @const
   * @type {ol.Size}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_SIZE_ = [64, 64];
  /**
   * @const
   * @type {string}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_SRC_ = 'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';
  /**
   * @const
   * @type {number}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_SCALE_MULTIPLIER_ = 0.5;
  /**
   * @const
   * @type {ol.style.Image}
   * @private
   */

  _ol_format_KML_.DEFAULT_IMAGE_STYLE_ = new _style_icon_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
    anchor: _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_,
    anchorOrigin: _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].BOTTOM_LEFT,
    anchorXUnits: _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_,
    anchorYUnits: _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_,
    crossOrigin: 'anonymous',
    rotation: 0,
    scale: _ol_format_KML_.DEFAULT_IMAGE_SCALE_MULTIPLIER_,
    size: _ol_format_KML_.DEFAULT_IMAGE_STYLE_SIZE_,
    src: _ol_format_KML_.DEFAULT_IMAGE_STYLE_SRC_
  });
  /**
   * @const
   * @type {string}
   * @private
   */

  _ol_format_KML_.DEFAULT_NO_IMAGE_STYLE_ = 'NO_IMAGE';
  /**
   * @const
   * @type {ol.style.Stroke}
   * @private
   */

  _ol_format_KML_.DEFAULT_STROKE_STYLE_ = new _style_stroke_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
    color: _ol_format_KML_.DEFAULT_COLOR_,
    width: 1
  });
  /**
   * @const
   * @type {ol.style.Stroke}
   * @private
   */

  _ol_format_KML_.DEFAULT_TEXT_STROKE_STYLE_ = new _style_stroke_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
    color: [51, 51, 51, 1],
    width: 2
  });
  /**
   * @const
   * @type {ol.style.Text}
   * @private
   */

  _ol_format_KML_.DEFAULT_TEXT_STYLE_ = new _style_text_js__WEBPACK_IMPORTED_MODULE_25__["default"]({
    font: 'bold 16px Helvetica',
    fill: _ol_format_KML_.DEFAULT_FILL_STYLE_,
    stroke: _ol_format_KML_.DEFAULT_TEXT_STROKE_STYLE_,
    scale: 0.8
  });
  /**
   * @const
   * @type {ol.style.Style}
   * @private
   */

  _ol_format_KML_.DEFAULT_STYLE_ = new _style_style_js__WEBPACK_IMPORTED_MODULE_24__["default"]({
    fill: _ol_format_KML_.DEFAULT_FILL_STYLE_,
    image: _ol_format_KML_.DEFAULT_IMAGE_STYLE_,
    text: _ol_format_KML_.DEFAULT_TEXT_STYLE_,
    stroke: _ol_format_KML_.DEFAULT_STROKE_STYLE_,
    zIndex: 0
  });
  /**
   * @const
   * @type {Array.<ol.style.Style>}
   * @private
   */

  _ol_format_KML_.DEFAULT_STYLE_ARRAY_ = [_ol_format_KML_.DEFAULT_STYLE_];
  return _ol_format_KML_.DEFAULT_STYLE_ARRAY_;
};
/**
 * @const
 * @type {Object.<string, ol.style.IconAnchorUnits>}
 * @private
 */


_ol_format_KML_.ICON_ANCHOR_UNITS_MAP_ = {
  'fraction': _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].FRACTION,
  'pixels': _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS,
  'insetPixels': _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS
};
/**
 * @param {ol.style.Style|undefined} foundStyle Style.
 * @param {string} name Name.
 * @return {ol.style.Style} style Style.
 * @private
 */

_ol_format_KML_.createNameStyleFunction_ = function (foundStyle, name) {
  var textStyle = null;
  var textOffset = [0, 0];
  var textAlign = 'start';

  if (foundStyle.getImage()) {
    var imageSize = foundStyle.getImage().getImageSize();

    if (imageSize === null) {
      imageSize = _ol_format_KML_.DEFAULT_IMAGE_STYLE_SIZE_;
    }

    if (imageSize.length == 2) {
      var imageScale = foundStyle.getImage().getScale(); // Offset the label to be centered to the right of the icon, if there is
      // one.

      textOffset[0] = imageScale * imageSize[0] / 2;
      textOffset[1] = -imageScale * imageSize[1] / 2;
      textAlign = 'left';
    }
  }

  if (foundStyle.getText() !== null) {
    // clone the text style, customizing it with name, alignments and offset.
    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
    var foundText = foundStyle.getText();
    textStyle = foundText.clone();
    textStyle.setFont(foundText.getFont() || _ol_format_KML_.DEFAULT_TEXT_STYLE_.getFont());
    textStyle.setScale(foundText.getScale() || _ol_format_KML_.DEFAULT_TEXT_STYLE_.getScale());
    textStyle.setFill(foundText.getFill() || _ol_format_KML_.DEFAULT_TEXT_STYLE_.getFill());
    textStyle.setStroke(foundText.getStroke() || _ol_format_KML_.DEFAULT_TEXT_STROKE_STYLE_);
  } else {
    textStyle = _ol_format_KML_.DEFAULT_TEXT_STYLE_.clone();
  }

  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);
  var nameStyle = new _style_style_js__WEBPACK_IMPORTED_MODULE_24__["default"]({
    text: textStyle
  });
  return nameStyle;
};
/**
 * @param {Array.<ol.style.Style>|undefined} style Style.
 * @param {string} styleUrl Style URL.
 * @param {Array.<ol.style.Style>} defaultStyle Default style.
 * @param {Object.<string, (Array.<ol.style.Style>|string)>} sharedStyles Shared
 *          styles.
 * @param {boolean|undefined} showPointNames true to show names for point
 *          placemarks.
 * @return {ol.FeatureStyleFunction} Feature style function.
 * @private
 */


_ol_format_KML_.createFeatureStyleFunction_ = function (style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return (
    /**
         * @param {number} resolution Resolution.
         * @return {Array.<ol.style.Style>} Style.
         * @this {ol.Feature}
         */
    function (resolution) {
      var drawName = showPointNames;
      /** @type {ol.style.Style|undefined} */

      var nameStyle;
      var name = '';

      if (drawName) {
        if (this.getGeometry()) {
          drawName = this.getGeometry().getType() === _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].POINT;
        }
      }

      if (drawName) {
        name =
        /** @type {string} */
        this.get('name');
        drawName = drawName && name;
      }

      if (style) {
        if (drawName) {
          nameStyle = _ol_format_KML_.createNameStyleFunction_(style[0], name);
          return style.concat(nameStyle);
        }

        return style;
      }

      if (styleUrl) {
        var foundStyle = _ol_format_KML_.findStyle_(styleUrl, defaultStyle, sharedStyles);

        if (drawName) {
          nameStyle = _ol_format_KML_.createNameStyleFunction_(foundStyle[0], name);
          return foundStyle.concat(nameStyle);
        }

        return foundStyle;
      }

      if (drawName) {
        nameStyle = _ol_format_KML_.createNameStyleFunction_(defaultStyle[0], name);
        return defaultStyle.concat(nameStyle);
      }

      return defaultStyle;
    }
  );
};
/**
 * @param {Array.<ol.style.Style>|string|undefined} styleValue Style value.
 * @param {Array.<ol.style.Style>} defaultStyle Default style.
 * @param {Object.<string, (Array.<ol.style.Style>|string)>} sharedStyles
 * Shared styles.
 * @return {Array.<ol.style.Style>} Style.
 * @private
 */


_ol_format_KML_.findStyle_ = function (styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === 'string') {
    // KML files in the wild occasionally forget the leading `#` on styleUrls
    // defined in the same document.  Add a leading `#` if it enables to find
    // a style.
    if (!(styleValue in sharedStyles) && '#' + styleValue in sharedStyles) {
      styleValue = '#' + styleValue;
    }

    return _ol_format_KML_.findStyle_(sharedStyles[styleValue], defaultStyle, sharedStyles);
  } else {
    return defaultStyle;
  }
};
/**
 * @param {Node} node Node.
 * @private
 * @return {ol.Color|undefined} Color.
 */


_ol_format_KML_.readColor_ = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].getAllTextContent(node, false); // The KML specification states that colors should not include a leading `#`
  // but we tolerate them.


  var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);

  if (m) {
    var hexColor = m[1];
    return [parseInt(hexColor.substr(6, 2), 16), parseInt(hexColor.substr(4, 2), 16), parseInt(hexColor.substr(2, 2), 16), parseInt(hexColor.substr(0, 2), 16) / 255];
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @private
 * @return {Array.<number>|undefined} Flat coordinates.
 */


_ol_format_KML_.readFlatCoordinates_ = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].getAllTextContent(node, false);

  var flatCoordinates = []; // The KML specification states that coordinate tuples should not include
  // spaces, but we tolerate them.

  var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;
  var m;

  while (m = re.exec(s)) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }

  if (s !== '') {
    return undefined;
  }

  return flatCoordinates;
};
/**
 * @param {Node} node Node.
 * @private
 * @return {string} URI.
 */


_ol_format_KML_.readURI_ = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].getAllTextContent(node, false).trim();

  var baseURI = node.baseURI;

  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }

  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
};
/**
 * @param {Node} node Node.
 * @private
 * @return {ol.KMLVec2_} Vec2.
 */


_ol_format_KML_.readVec2_ = function (node) {
  var xunits = node.getAttribute('xunits');
  var yunits = node.getAttribute('yunits');
  var origin;

  if (xunits !== 'insetPixels') {
    if (yunits !== 'insetPixels') {
      origin = _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].BOTTOM_LEFT;
    } else {
      origin = _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].TOP_LEFT;
    }
  } else {
    if (yunits !== 'insetPixels') {
      origin = _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].BOTTOM_RIGHT;
    } else {
      origin = _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].TOP_RIGHT;
    }
  }

  return {
    x: parseFloat(node.getAttribute('x')),
    xunits: _ol_format_KML_.ICON_ANCHOR_UNITS_MAP_[xunits],
    y: parseFloat(node.getAttribute('y')),
    yunits: _ol_format_KML_.ICON_ANCHOR_UNITS_MAP_[yunits],
    origin: origin
  };
};
/**
 * @param {Node} node Node.
 * @private
 * @return {number|undefined} Scale.
 */


_ol_format_KML_.readScale_ = function (node) {
  return _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal(node);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<ol.style.Style>|string|undefined} StyleMap.
 */


_ol_format_KML_.readStyleMapValue_ = function (node, objectStack) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(undefined, _ol_format_KML_.STYLE_MAP_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.IconStyleParser_ = function (node, objectStack) {
  // FIXME refreshMode
  // FIXME refreshInterval
  // FIXME viewRefreshTime
  // FIXME viewBoundScale
  // FIXME viewFormat
  // FIXME httpQuery
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.ICON_STYLE_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var IconObject = 'Icon' in object ? object['Icon'] : {};
  var drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;
  var src;
  var href =
  /** @type {string|undefined} */
  IconObject['href'];

  if (href) {
    src = href;
  } else if (drawIcon) {
    src = _ol_format_KML_.DEFAULT_IMAGE_STYLE_SRC_;
  }

  var anchor, anchorXUnits, anchorYUnits;
  var anchorOrigin = _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].BOTTOM_LEFT;
  var hotSpot =
  /** @type {ol.KMLVec2_|undefined} */
  object['hotSpot'];

  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (src === _ol_format_KML_.DEFAULT_IMAGE_STYLE_SRC_) {
    anchor = _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_;
    anchorXUnits = _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_;
    anchorYUnits = _ol_format_KML_.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_;
  } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    anchor = [0.5, 0];
    anchorXUnits = _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].FRACTION;
    anchorYUnits = _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].FRACTION;
  }

  var offset;
  var x =
  /** @type {number|undefined} */
  IconObject['x'];
  var y =
  /** @type {number|undefined} */
  IconObject['y'];

  if (x !== undefined && y !== undefined) {
    offset = [x, y];
  }

  var size;
  var w =
  /** @type {number|undefined} */
  IconObject['w'];
  var h =
  /** @type {number|undefined} */
  IconObject['h'];

  if (w !== undefined && h !== undefined) {
    size = [w, h];
  }

  var rotation;
  var heading =
  /** @type {number} */
  object['heading'];

  if (heading !== undefined) {
    rotation = _math_js__WEBPACK_IMPORTED_MODULE_17__["default"].toRadians(heading);
  }

  var scale =
  /** @type {number|undefined} */
  object['scale'];

  if (drawIcon) {
    if (src == _ol_format_KML_.DEFAULT_IMAGE_STYLE_SRC_) {
      size = _ol_format_KML_.DEFAULT_IMAGE_STYLE_SIZE_;

      if (scale === undefined) {
        scale = _ol_format_KML_.DEFAULT_IMAGE_SCALE_MULTIPLIER_;
      }
    }

    var imageStyle = new _style_icon_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
      anchor: anchor,
      anchorOrigin: anchorOrigin,
      anchorXUnits: anchorXUnits,
      anchorYUnits: anchorYUnits,
      crossOrigin: 'anonymous',
      // FIXME should this be configurable?
      offset: offset,
      offsetOrigin: _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_22__["default"].BOTTOM_LEFT,
      rotation: rotation,
      scale: scale,
      size: size,
      src: src
    });
    styleObject['imageStyle'] = imageStyle;
  } else {
    // handle the case when we explicitly want to draw no icon.
    styleObject['imageStyle'] = _ol_format_KML_.DEFAULT_NO_IMAGE_STYLE_;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.LabelStyleParser_ = function (node, objectStack) {
  // FIXME colorMode
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.LABEL_STYLE_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var textStyle = new _style_text_js__WEBPACK_IMPORTED_MODULE_25__["default"]({
    fill: new _style_fill_js__WEBPACK_IMPORTED_MODULE_19__["default"]({
      color:
      /** @type {ol.Color} */
      'color' in object ? object['color'] : _ol_format_KML_.DEFAULT_COLOR_
    }),
    scale:
    /** @type {number|undefined} */
    object['scale']
  });
  styleObject['textStyle'] = textStyle;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.LineStyleParser_ = function (node, objectStack) {
  // FIXME colorMode
  // FIXME gx:outerColor
  // FIXME gx:outerWidth
  // FIXME gx:physicalWidth
  // FIXME gx:labelVisibility
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.LINE_STYLE_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var strokeStyle = new _style_stroke_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
    color:
    /** @type {ol.Color} */
    'color' in object ? object['color'] : _ol_format_KML_.DEFAULT_COLOR_,
    width:
    /** @type {number} */
    'width' in object ? object['width'] : 1
  });
  styleObject['strokeStyle'] = strokeStyle;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.PolyStyleParser_ = function (node, objectStack) {
  // FIXME colorMode
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.POLY_STYLE_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var fillStyle = new _style_fill_js__WEBPACK_IMPORTED_MODULE_19__["default"]({
    color:
    /** @type {ol.Color} */
    'color' in object ? object['color'] : _ol_format_KML_.DEFAULT_COLOR_
  });
  styleObject['fillStyle'] = fillStyle;
  var fill =
  /** @type {boolean|undefined} */
  object['fill'];

  if (fill !== undefined) {
    styleObject['fill'] = fill;
  }

  var outline =
  /** @type {boolean|undefined} */
  object['outline'];

  if (outline !== undefined) {
    styleObject['outline'] = outline;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<number>} LinearRing flat coordinates.
 */


_ol_format_KML_.readFlatLinearRing_ = function (node, objectStack) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(null, _ol_format_KML_.FLAT_LINEAR_RING_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.gxCoordParser_ = function (node, objectStack) {
  var gxTrackObject =
  /** @type {ol.KMLGxTrackObject_} */
  objectStack[objectStack.length - 1];
  var flatCoordinates = gxTrackObject.flatCoordinates;

  var s = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].getAllTextContent(node, false);

  var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  var m = re.exec(s);

  if (m) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = parseFloat(m[3]);
    flatCoordinates.push(x, y, z, 0);
  } else {
    flatCoordinates.push(0, 0, 0, 0);
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.MultiLineString|undefined} MultiLineString.
 */


_ol_format_KML_.readGxMultiTrack_ = function (node, objectStack) {
  var lineStrings = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop([], _ol_format_KML_.GX_MULTITRACK_GEOMETRY_PARSERS_, node, objectStack);

  if (!lineStrings) {
    return undefined;
  }

  var multiLineString = new _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_12__["default"](null);
  multiLineString.setLineStrings(lineStrings);
  return multiLineString;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.LineString|undefined} LineString.
 */


_ol_format_KML_.readGxTrack_ = function (node, objectStack) {
  var gxTrackObject = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(
  /** @type {ol.KMLGxTrackObject_} */
  {
    flatCoordinates: [],
    whens: []
  }, _ol_format_KML_.GX_TRACK_PARSERS_, node, objectStack);

  if (!gxTrackObject) {
    return undefined;
  }

  var flatCoordinates = gxTrackObject.flatCoordinates;
  var whens = gxTrackObject.whens;
  var i, ii;

  for (i = 0, ii = Math.min(flatCoordinates.length, whens.length); i < ii; ++i) {
    flatCoordinates[4 * i + 3] = whens[i];
  }

  var lineString = new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_11__["default"](null);
  lineString.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZM, flatCoordinates);
  return lineString;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object} Icon object.
 */


_ol_format_KML_.readIcon_ = function (node, objectStack) {
  var iconObject = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.ICON_PARSERS_, node, objectStack);

  if (iconObject) {
    return iconObject;
  } else {
    return null;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<number>} Flat coordinates.
 */


_ol_format_KML_.readFlatCoordinatesFromNode_ = function (node, objectStack) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(null, _ol_format_KML_.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.LineString|undefined} LineString.
 */


_ol_format_KML_.readLineString_ = function (node, objectStack) {
  var properties = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);

  var flatCoordinates = _ol_format_KML_.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var lineString = new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_11__["default"](null);
    lineString.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZ, flatCoordinates);
    lineString.setProperties(properties);
    return lineString;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.Polygon|undefined} Polygon.
 */


_ol_format_KML_.readLinearRing_ = function (node, objectStack) {
  var properties = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);

  var flatCoordinates = _ol_format_KML_.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var polygon = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_16__["default"](null);
    polygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZ, flatCoordinates, [flatCoordinates.length]);
    polygon.setProperties(properties);
    return polygon;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_KML_.readMultiGeometry_ = function (node, objectStack) {
  var geometries = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop([], _ol_format_KML_.MULTI_GEOMETRY_PARSERS_, node, objectStack);

  if (!geometries) {
    return null;
  }

  if (geometries.length === 0) {
    return new _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
  }
  /** @type {ol.geom.Geometry} */


  var multiGeometry;
  var homogeneous = true;
  var type = geometries[0].getType();
  var geometry, i, ii;

  for (i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];

    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }

  if (homogeneous) {
    var layout;
    var flatCoordinates;

    if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].POINT) {
      var point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();

      for (i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];

        _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(flatCoordinates, geometry.getFlatCoordinates());
      }

      multiGeometry = new _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_13__["default"](null);
      multiGeometry.setFlatCoordinates(layout, flatCoordinates);

      _ol_format_KML_.setCommonGeometryProperties_(multiGeometry, geometries);
    } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].LINE_STRING) {
      multiGeometry = new _geom_multilinestring_js__WEBPACK_IMPORTED_MODULE_12__["default"](null);
      multiGeometry.setLineStrings(geometries);

      _ol_format_KML_.setCommonGeometryProperties_(multiGeometry, geometries);
    } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].POLYGON) {
      multiGeometry = new _geom_multipolygon_js__WEBPACK_IMPORTED_MODULE_14__["default"](null);
      multiGeometry.setPolygons(geometries);

      _ol_format_KML_.setCommonGeometryProperties_(multiGeometry, geometries);
    } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].GEOMETRY_COLLECTION) {
      multiGeometry = new _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_3__["default"].assert(false, 37); // Unknown geometry type found

    }
  } else {
    multiGeometry = new _geom_geometrycollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
  }

  return (
    /** @type {ol.geom.Geometry} */
    multiGeometry
  );
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.Point|undefined} Point.
 */


_ol_format_KML_.readPoint_ = function (node, objectStack) {
  var properties = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);

  var flatCoordinates = _ol_format_KML_.readFlatCoordinatesFromNode_(node, objectStack);

  if (flatCoordinates) {
    var point = new _geom_point_js__WEBPACK_IMPORTED_MODULE_15__["default"](null);
    point.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZ, flatCoordinates);
    point.setProperties(properties);
    return point;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.geom.Polygon|undefined} Polygon.
 */


_ol_format_KML_.readPolygon_ = function (node, objectStack) {
  var properties = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(
  /** @type {Object<string,*>} */
  {}, _ol_format_KML_.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);

  var flatLinearRings = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop([null], _ol_format_KML_.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack);

  if (flatLinearRings && flatLinearRings[0]) {
    var polygon = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_16__["default"](null);
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    var i, ii;

    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(flatCoordinates, flatLinearRings[i]);

      ends.push(flatCoordinates.length);
    }

    polygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZ, flatCoordinates, ends);
    polygon.setProperties(properties);
    return polygon;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<ol.style.Style>} Style.
 */


_ol_format_KML_.readStyle_ = function (node, objectStack) {
  var styleObject = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.STYLE_PARSERS_, node, objectStack);

  if (!styleObject) {
    return null;
  }

  var fillStyle =
  /** @type {ol.style.Fill} */
  'fillStyle' in styleObject ? styleObject['fillStyle'] : _ol_format_KML_.DEFAULT_FILL_STYLE_;
  var fill =
  /** @type {boolean|undefined} */
  styleObject['fill'];

  if (fill !== undefined && !fill) {
    fillStyle = null;
  }

  var imageStyle =
  /** @type {ol.style.Image} */
  'imageStyle' in styleObject ? styleObject['imageStyle'] : _ol_format_KML_.DEFAULT_IMAGE_STYLE_;

  if (imageStyle == _ol_format_KML_.DEFAULT_NO_IMAGE_STYLE_) {
    imageStyle = undefined;
  }

  var textStyle =
  /** @type {ol.style.Text} */
  'textStyle' in styleObject ? styleObject['textStyle'] : _ol_format_KML_.DEFAULT_TEXT_STYLE_;
  var strokeStyle =
  /** @type {ol.style.Stroke} */
  'strokeStyle' in styleObject ? styleObject['strokeStyle'] : _ol_format_KML_.DEFAULT_STROKE_STYLE_;
  var outline =
  /** @type {boolean|undefined} */
  styleObject['outline'];

  if (outline !== undefined && !outline) {
    strokeStyle = null;
  }

  return [new _style_style_js__WEBPACK_IMPORTED_MODULE_24__["default"]({
    fill: fillStyle,
    image: imageStyle,
    stroke: strokeStyle,
    text: textStyle,
    zIndex: undefined // FIXME

  })];
};
/**
 * Reads an array of geometries and creates arrays for common geometry
 * properties. Then sets them to the multi geometry.
 * @param {ol.geom.MultiPoint|ol.geom.MultiLineString|ol.geom.MultiPolygon}
 *     multiGeometry A multi-geometry.
 * @param {Array.<ol.geom.Geometry>} geometries List of geometries.
 * @private
 */


_ol_format_KML_.setCommonGeometryProperties_ = function (multiGeometry, geometries) {
  var ii = geometries.length;
  var extrudes = new Array(geometries.length);
  var tessellates = new Array(geometries.length);
  var altitudeModes = new Array(geometries.length);
  var geometry, i, hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = hasTessellate = hasAltitudeMode = false;

  for (i = 0; i < ii; ++i) {
    geometry = geometries[i];
    extrudes[i] = geometry.get('extrude');
    tessellates[i] = geometry.get('tessellate');
    altitudeModes[i] = geometry.get('altitudeMode');
    hasExtrude = hasExtrude || extrudes[i] !== undefined;
    hasTessellate = hasTessellate || tessellates[i] !== undefined;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }

  if (hasExtrude) {
    multiGeometry.set('extrude', extrudes);
  }

  if (hasTessellate) {
    multiGeometry.set('tessellate', tessellates);
  }

  if (hasAltitudeMode) {
    multiGeometry.set('altitudeMode', altitudeModes);
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.DataParser_ = function (node, objectStack) {
  var name = node.getAttribute('name');

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parseNode(_ol_format_KML_.DATA_PARSERS_, node, objectStack);

  var featureObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];

  if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }

  delete featureObject['value'];
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.ExtendedDataParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parseNode(_ol_format_KML_.EXTENDED_DATA_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.RegionParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parseNode(_ol_format_KML_.REGION_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.PairDataParser_ = function (node, objectStack) {
  var pairObject = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.PAIR_PARSERS_, node, objectStack);

  if (!pairObject) {
    return;
  }

  var key =
  /** @type {string|undefined} */
  pairObject['key'];

  if (key && key == 'normal') {
    var styleUrl =
    /** @type {string|undefined} */
    pairObject['styleUrl'];

    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }

    var Style =
    /** @type {ol.style.Style} */
    pairObject['Style'];

    if (Style) {
      objectStack[objectStack.length - 1] = Style;
    }
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.PlacemarkStyleMapParser_ = function (node, objectStack) {
  var styleMapValue = _ol_format_KML_.readStyleMapValue_(node, objectStack);

  if (!styleMapValue) {
    return;
  }

  var placemarkObject = objectStack[objectStack.length - 1];

  if (Array.isArray(styleMapValue)) {
    placemarkObject['Style'] = styleMapValue;
  } else if (typeof styleMapValue === 'string') {
    placemarkObject['styleUrl'] = styleMapValue;
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_3__["default"].assert(false, 38); // `styleMapValue` has an unknown type

  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.SchemaDataParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parseNode(_ol_format_KML_.SCHEMA_DATA_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.SimpleDataParser_ = function (node, objectStack) {
  var name = node.getAttribute('name');

  if (name !== null) {
    var data = _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString(node);

    var featureObject =
    /** @type {Object} */
    objectStack[objectStack.length - 1];
    featureObject[name] = data;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.LatLonAltBoxParser_ = function (node, objectStack) {
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.LAT_LON_ALT_BOX_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var regionObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var extent = [parseFloat(object['west']), parseFloat(object['south']), parseFloat(object['east']), parseFloat(object['north'])];
  regionObject['extent'] = extent;
  regionObject['altitudeMode'] = object['altitudeMode'];
  regionObject['minAltitude'] = parseFloat(object['minAltitude']);
  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.LodParser_ = function (node, objectStack) {
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.LOD_PARSERS_, node, objectStack);

  if (!object) {
    return;
  }

  var lodObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.innerBoundaryIsParser_ = function (node, objectStack) {
  /** @type {Array.<number>|undefined} */
  var flatLinearRing = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(undefined, _ol_format_KML_.INNER_BOUNDARY_IS_PARSERS_, node, objectStack);

  if (flatLinearRing) {
    var flatLinearRings =
    /** @type {Array.<Array.<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings.push(flatLinearRing);
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.outerBoundaryIsParser_ = function (node, objectStack) {
  /** @type {Array.<number>|undefined} */
  var flatLinearRing = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop(undefined, _ol_format_KML_.OUTER_BOUNDARY_IS_PARSERS_, node, objectStack);

  if (flatLinearRing) {
    var flatLinearRings =
    /** @type {Array.<Array.<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.LinkParser_ = function (node, objectStack) {
  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parseNode(_ol_format_KML_.LINK_PARSERS_, node, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.whenParser_ = function (node, objectStack) {
  var gxTrackObject =
  /** @type {ol.KMLGxTrackObject_} */
  objectStack[objectStack.length - 1];
  var whens = gxTrackObject.whens;

  var s = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].getAllTextContent(node, false);

  var when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
};
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */


_ol_format_KML_.DATA_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'displayName': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'value': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.EXTENDED_DATA_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Data': _ol_format_KML_.DataParser_,
  'SchemaData': _ol_format_KML_.SchemaDataParser_
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.REGION_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LatLonAltBox': _ol_format_KML_.LatLonAltBoxParser_,
  'Lod': _ol_format_KML_.LodParser_
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.LAT_LON_ALT_BOX_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'altitudeMode': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'minAltitude': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'maxAltitude': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'north': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'south': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'east': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'west': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.LOD_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'minLodPixels': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'maxLodPixels': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'minFadeExtent': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'maxFadeExtent': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'extrude': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean),
  'tessellate': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean),
  'altitudeMode': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.FLAT_LINEAR_RING_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'coordinates': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeReplacer(_ol_format_KML_.readFlatCoordinates_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.FLAT_LINEAR_RINGS_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'innerBoundaryIs': _ol_format_KML_.innerBoundaryIsParser_,
  'outerBoundaryIs': _ol_format_KML_.outerBoundaryIsParser_
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.GX_TRACK_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'when': _ol_format_KML_.whenParser_
}, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, {
  'coord': _ol_format_KML_.gxCoordParser_
}));
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.GEOMETRY_FLAT_COORDINATES_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'coordinates': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeReplacer(_ol_format_KML_.readFlatCoordinates_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.ICON_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'href': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readURI_)
}, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, {
  'x': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'y': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'w': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'h': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal)
}));
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.ICON_STYLE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Icon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readIcon_),
  'heading': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal),
  'hotSpot': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readVec2_),
  'scale': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readScale_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.INNER_BOUNDARY_IS_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeReplacer(_ol_format_KML_.readFlatLinearRing_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.LABEL_STYLE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readColor_),
  'scale': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readScale_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.LINE_STYLE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readColor_),
  'width': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readDecimal)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.MULTI_GEOMETRY_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readLineString_),
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readLinearRing_),
  'MultiGeometry': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readMultiGeometry_),
  'Point': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readPoint_),
  'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readPolygon_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.GX_MULTITRACK_GEOMETRY_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, {
  'Track': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(_ol_format_KML_.readGxTrack_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.NETWORK_LINK_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'ExtendedData': _ol_format_KML_.ExtendedDataParser_,
  'Region': _ol_format_KML_.RegionParser_,
  'Link': _ol_format_KML_.LinkParser_,
  'address': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'description': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'name': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'open': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean),
  'phoneNumber': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'visibility': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.LINK_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'href': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readURI_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.OUTER_BOUNDARY_IS_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeReplacer(_ol_format_KML_.readFlatLinearRing_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.PAIR_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Style': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readStyle_),
  'key': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'styleUrl': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readURI_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.PLACEMARK_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'ExtendedData': _ol_format_KML_.ExtendedDataParser_,
  'Region': _ol_format_KML_.RegionParser_,
  'MultiGeometry': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readMultiGeometry_, 'geometry'),
  'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readLineString_, 'geometry'),
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readLinearRing_, 'geometry'),
  'Point': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readPoint_, 'geometry'),
  'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readPolygon_, 'geometry'),
  'Style': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readStyle_),
  'StyleMap': _ol_format_KML_.PlacemarkStyleMapParser_,
  'address': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'description': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'name': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'open': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean),
  'phoneNumber': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString),
  'styleUrl': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readURI_),
  'visibility': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean)
}, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, {
  'MultiTrack': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readGxMultiTrack_, 'geometry'),
  'Track': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readGxTrack_, 'geometry')
}));
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.POLY_STYLE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_ol_format_KML_.readColor_),
  'fill': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean),
  'outline': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeObjectPropertySetter(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readBoolean)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.SCHEMA_DATA_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'SimpleData': _ol_format_KML_.SimpleDataParser_
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.STYLE_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'IconStyle': _ol_format_KML_.IconStyleParser_,
  'LabelStyle': _ol_format_KML_.LabelStyleParser_,
  'LineStyle': _ol_format_KML_.LineStyleParser_,
  'PolyStyle': _ol_format_KML_.PolyStyleParser_
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlParser>>}
 * @private
 */

_ol_format_KML_.STYLE_MAP_PARSERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Pair': _ol_format_KML_.PairDataParser_
});
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<ol.Feature>|undefined} Features.
 */

_ol_format_KML_.prototype.readDocumentOrFolder_ = function (node, objectStack) {
  // FIXME use scope somehow
  var parsersNS = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
    'Document': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayExtender(this.readDocumentOrFolder_, this),
    'Folder': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayExtender(this.readDocumentOrFolder_, this),
    'Placemark': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeArrayPusher(this.readPlacemark_, this),
    'Style': this.readSharedStyle_.bind(this),
    'StyleMap': this.readSharedStyleMap_.bind(this)
  });
  /** @type {Array.<ol.Feature>} */


  var features = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop([], parsersNS, node, objectStack, this);

  if (features) {
    return features;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {ol.Feature|undefined} Feature.
 */


_ol_format_KML_.prototype.readPlacemark_ = function (node, objectStack) {
  var object = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({
    'geometry': null
  }, _ol_format_KML_.PLACEMARK_PARSERS_, node, objectStack);

  if (!object) {
    return undefined;
  }

  var feature = new _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  var id = node.getAttribute('id');

  if (id !== null) {
    feature.setId(id);
  }

  var options =
  /** @type {olx.format.ReadOptions} */
  objectStack[0];
  var geometry = object['geometry'];

  if (geometry) {
    _format_feature_js__WEBPACK_IMPORTED_MODULE_5__["default"].transformWithOptions(geometry, false, options);
  }

  feature.setGeometry(geometry);
  delete object['geometry'];

  if (this.extractStyles_) {
    var style = object['Style'];
    var styleUrl = object['styleUrl'];

    var styleFunction = _ol_format_KML_.createFeatureStyleFunction_(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);

    feature.setStyle(styleFunction);
  }

  delete object['Style']; // we do not remove the styleUrl property from the object, so it
  // gets stored on feature when setProperties is called

  feature.setProperties(object);
  return feature;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.prototype.readSharedStyle_ = function (node, objectStack) {
  var id = node.getAttribute('id');

  if (id !== null) {
    var style = _ol_format_KML_.readStyle_(node, objectStack);

    if (style) {
      var styleUri;
      var baseURI = node.baseURI;

      if (!baseURI || baseURI == 'about:blank') {
        baseURI = window.location.href;
      }

      if (baseURI) {
        var url = new URL('#' + id, baseURI);
        styleUri = url.href;
      } else {
        styleUri = '#' + id;
      }

      this.sharedStyles_[styleUri] = style;
    }
  }
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.prototype.readSharedStyleMap_ = function (node, objectStack) {
  var id = node.getAttribute('id');

  if (id === null) {
    return;
  }

  var styleMapValue = _ol_format_KML_.readStyleMapValue_(node, objectStack);

  if (!styleMapValue) {
    return;
  }

  var styleUri;
  var baseURI = node.baseURI;

  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }

  if (baseURI) {
    var url = new URL('#' + id, baseURI);
    styleUri = url.href;
  } else {
    styleUri = '#' + id;
  }

  this.sharedStyles_[styleUri] = styleMapValue;
};
/**
 * Read the first feature from a KML source. MultiGeometries are converted into
 * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
 * MultiLineString/MultiPolygon if they are all of the same type.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 * @api
 */


_ol_format_KML_.prototype.readFeature;
/**
 * @inheritDoc
 */

_ol_format_KML_.prototype.readFeatureFromNode = function (node, opt_options) {
  if (!_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, node.namespaceURI)) {
    return null;
  }

  var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);

  if (feature) {
    return feature;
  } else {
    return null;
  }
};
/**
 * Read all features from a KML source. MultiGeometries are converted into
 * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
 * MultiLineString/MultiPolygon if they are all of the same type.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_format_KML_.prototype.readFeatures;
/**
 * @inheritDoc
 */

_ol_format_KML_.prototype.readFeaturesFromNode = function (node, opt_options) {
  if (!_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, node.namespaceURI)) {
    return [];
  }

  var features;
  var localName = node.localName;

  if (localName == 'Document' || localName == 'Folder') {
    features = this.readDocumentOrFolder_(node, [this.getReadOptions(node, opt_options)]);

    if (features) {
      return features;
    } else {
      return [];
    }
  } else if (localName == 'Placemark') {
    var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);

    if (feature) {
      return [feature];
    } else {
      return [];
    }
  } else if (localName == 'kml') {
    features = [];
    var n;

    for (n = node.firstElementChild; n; n = n.nextElementSibling) {
      var fs = this.readFeaturesFromNode(n, opt_options);

      if (fs) {
        _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(features, fs);
      }
    }

    return features;
  } else {
    return [];
  }
};
/**
 * Read the name of the KML.
 *
 * @param {Document|Node|string} source Souce.
 * @return {string|undefined} Name.
 * @api
 */


_ol_format_KML_.prototype.readName = function (source) {
  if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isDocument(source)) {
    return this.readNameFromDocument(
    /** @type {Document} */
    source);
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isNode(source)) {
    return this.readNameFromNode(
    /** @type {Node} */
    source);
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parse(source);

    return this.readNameFromDocument(doc);
  } else {
    return undefined;
  }
};
/**
 * @param {Document} doc Document.
 * @return {string|undefined} Name.
 */


_ol_format_KML_.prototype.readNameFromDocument = function (doc) {
  var n;

  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      var name = this.readNameFromNode(n);

      if (name) {
        return name;
      }
    }
  }

  return undefined;
};
/**
 * @param {Node} node Node.
 * @return {string|undefined} Name.
 */


_ol_format_KML_.prototype.readNameFromNode = function (node) {
  var n;

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && n.localName == 'name') {
      return _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].readString(n);
    }
  }

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;

    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'Placemark' || localName == 'kml')) {
      var name = this.readNameFromNode(n);

      if (name) {
        return name;
      }
    }
  }

  return undefined;
};
/**
 * Read the network links of the KML.
 *
 * @param {Document|Node|string} source Source.
 * @return {Array.<Object>} Network links.
 * @api
 */


_ol_format_KML_.prototype.readNetworkLinks = function (source) {
  var networkLinks = [];

  if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isDocument(source)) {
    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(networkLinks, this.readNetworkLinksFromDocument(
    /** @type {Document} */
    source));
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isNode(source)) {
    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(networkLinks, this.readNetworkLinksFromNode(
    /** @type {Node} */
    source));
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parse(source);

    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(networkLinks, this.readNetworkLinksFromDocument(doc));
  }

  return networkLinks;
};
/**
 * @param {Document} doc Document.
 * @return {Array.<Object>} Network links.
 */


_ol_format_KML_.prototype.readNetworkLinksFromDocument = function (doc) {
  var n,
      networkLinks = [];

  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(networkLinks, this.readNetworkLinksFromNode(n));
    }
  }

  return networkLinks;
};
/**
 * @param {Node} node Node.
 * @return {Array.<Object>} Network links.
 */


_ol_format_KML_.prototype.readNetworkLinksFromNode = function (node) {
  var n,
      networkLinks = [];

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && n.localName == 'NetworkLink') {
      var obj = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.NETWORK_LINK_PARSERS_, n, []);

      networkLinks.push(obj);
    }
  }

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;

    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
      _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(networkLinks, this.readNetworkLinksFromNode(n));
    }
  }

  return networkLinks;
};
/**
 * Read the regions of the KML.
 *
 * @param {Document|Node|string} source Source.
 * @return {Array.<Object>} Regions.
 * @api
 */


_ol_format_KML_.prototype.readRegion = function (source) {
  var regions = [];

  if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isDocument(source)) {
    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(regions, this.readRegionFromDocument(
    /** @type {Document} */
    source));
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].isNode(source)) {
    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(regions, this.readRegionFromNode(
    /** @type {Node} */
    source));
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].parse(source);

    _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(regions, this.readRegionFromDocument(doc));
  }

  return regions;
};
/**
 * @param {Document} doc Document.
 * @return {Array.<Object>} Region.
 */


_ol_format_KML_.prototype.readRegionFromDocument = function (doc) {
  var n,
      regions = [];

  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(regions, this.readRegionFromNode(n));
    }
  }

  return regions;
};
/**
 * @param {Node} node Node.
 * @return {Array.<Object>} Region.
 * @api
 */


_ol_format_KML_.prototype.readRegionFromNode = function (node) {
  var n,
      regions = [];

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && n.localName == 'Region') {
      var obj = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushParseAndPop({}, _ol_format_KML_.REGION_PARSERS_, n, []);

      regions.push(obj);
    }
  }

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;

    if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_ol_format_KML_.NAMESPACE_URIS_, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
      _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(regions, this.readRegionFromNode(n));
    }
  }

  return regions;
};
/**
 * Read the projection from a KML source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */


_ol_format_KML_.prototype.readProjection;
/**
 * @param {Node} node Node to append a TextNode with the color to.
 * @param {ol.Color|string} color Color.
 * @private
 */

_ol_format_KML_.writeColorTextNode_ = function (node, color) {
  var rgba = _color_js__WEBPACK_IMPORTED_MODULE_4__["default"].asArray(color);

  var opacity = rgba.length == 4 ? rgba[3] : 1;
  var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
  var i;

  for (i = 0; i < 4; ++i) {
    var hex = parseInt(abgr[i], 10).toString(16);
    abgr[i] = hex.length == 1 ? '0' + hex : hex;
  }

  _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode(node, abgr.join(''));
};
/**
 * @param {Node} node Node to append a TextNode with the coordinates to.
 * @param {Array.<number>} coordinates Coordinates.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeCoordinatesTextNode_ = function (node, coordinates, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var layout = context['layout'];
  var stride = context['stride'];
  var dimension;

  if (layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY || layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYM) {
    dimension = 2;
  } else if (layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZ || layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYZM) {
    dimension = 3;
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_3__["default"].assert(false, 34); // Invalid geometry layout

  }

  var d, i;
  var ii = coordinates.length;
  var text = '';

  if (ii > 0) {
    text += coordinates[0];

    for (d = 1; d < dimension; ++d) {
      text += ',' + coordinates[d];
    }

    for (i = stride; i < ii; i += stride) {
      text += ' ' + coordinates[i];

      for (d = 1; d < dimension; ++d) {
        text += ',' + coordinates[i + d];
      }
    }
  }

  _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode(node, text);
};
/**
 * @param {Node} node Node.
 * @param {{name: *, value: *}} pair Name value pair.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeDataNode_ = function (node, pair, objectStack) {
  node.setAttribute('name', pair.name);
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var value = pair.value;

  if (typeof value == 'object') {
    if (value !== null && value.displayName) {
      _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.EXTENDEDDATA_NODE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);
    }

    if (value !== null && value.value) {
      _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.EXTENDEDDATA_NODE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);
    }
  } else {
    _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.EXTENDEDDATA_NODE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);
  }
};
/**
 * @param {Node} node Node to append a TextNode with the name to.
 * @param {string} name DisplayName.
 * @private
 */


_ol_format_KML_.writeDataNodeName_ = function (node, name) {
  _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeCDATASection(node, name);
};
/**
 * @param {Node} node Node to append a CDATA Section with the value to.
 * @param {string} value Value.
 * @private
 */


_ol_format_KML_.writeDataNodeValue_ = function (node, value) {
  _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode(node, value);
};
/**
 * @param {Node} node Node.
 * @param {Array.<ol.Feature>} features Features.
 * @param {Array.<*>} objectStack Object stack.
 * @this {ol.format.KML}
 * @private
 */


_ol_format_KML_.writeDocument_ = function (node, features, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.DOCUMENT_SERIALIZERS_, _ol_format_KML_.DOCUMENT_NODE_FACTORY_, features, objectStack, undefined, this);
};
/**
 * @param {Node} node Node.
 * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeExtendedData_ = function (node, namesAndValues, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var names = namesAndValues.names,
      values = namesAndValues.values;
  var length = names.length;

  for (var i = 0; i < length; i++) {
    _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.EXTENDEDDATA_NODE_SERIALIZERS_, _ol_format_KML_.DATA_NODE_FACTORY_, [{
      name: names[i],
      value: values[i]
    }], objectStack);
  }
};
/**
 * @param {Node} node Node.
 * @param {Object} icon Icon object.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeIcon_ = function (node, icon, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.ICON_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(icon, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.ICON_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);

  orderedKeys = _ol_format_KML_.ICON_SEQUENCE_[_ol_format_KML_.GX_NAMESPACE_URIS_[0]];
  values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(icon, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.ICON_SERIALIZERS_, _ol_format_KML_.GX_NODE_FACTORY_, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node.
 * @param {ol.style.Icon} style Icon style.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeIconStyle_ = function (node, style, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var properties = {};
  var src = style.getSrc();
  var size = style.getSize();
  var iconImageSize = style.getImageSize();
  var iconProperties = {
    'href': src
  };

  if (size) {
    iconProperties['w'] = size[0];
    iconProperties['h'] = size[1];
    var anchor = style.getAnchor(); // top-left

    var origin = style.getOrigin(); // top-left

    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
      iconProperties['x'] = origin[0];
      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);
    }

    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      var
      /** @type {ol.KMLVec2_} */
      hotSpot = {
        x: anchor[0],
        xunits: _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS,
        y: size[1] - anchor[1],
        yunits: _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_21__["default"].PIXELS
      };
      properties['hotSpot'] = hotSpot;
    }
  }

  properties['Icon'] = iconProperties;
  var scale = style.getScale();

  if (scale !== 1) {
    properties['scale'] = scale;
  }

  var rotation = style.getRotation();

  if (rotation !== 0) {
    properties['heading'] = rotation; // 0-360
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.ICON_STYLE_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.ICON_STYLE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node.
 * @param {ol.style.Text} style style.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeLabelStyle_ = function (node, style, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var properties = {};
  var fill = style.getFill();

  if (fill) {
    properties['color'] = fill.getColor();
  }

  var scale = style.getScale();

  if (scale && scale !== 1) {
    properties['scale'] = scale;
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.LABEL_STYLE_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.LABEL_STYLE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node.
 * @param {ol.style.Stroke} style style.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeLineStyle_ = function (node, style, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var properties = {
    'color': style.getColor(),
    'width': style.getWidth()
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.LINE_STYLE_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.LINE_STYLE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeMultiGeometry_ = function (node, geometry, objectStack) {
  /** @type {ol.XmlNodeStackItem} */
  var context = {
    node: node
  };
  var type = geometry.getType();
  /** @type {Array.<ol.geom.Geometry>} */

  var geometries;
  /** @type {function(*, Array.<*>, string=): (Node|undefined)} */

  var factory;

  if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].GEOMETRY_COLLECTION) {
    geometries =
    /** @type {ol.geom.GeometryCollection} */
    geometry.getGeometries();
    factory = _ol_format_KML_.GEOMETRY_NODE_FACTORY_;
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].MULTI_POINT) {
    geometries =
    /** @type {ol.geom.MultiPoint} */
    geometry.getPoints();
    factory = _ol_format_KML_.POINT_NODE_FACTORY_;
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].MULTI_LINE_STRING) {
    geometries =
    /** @type {ol.geom.MultiLineString} */
    geometry.getLineStrings();
    factory = _ol_format_KML_.LINE_STRING_NODE_FACTORY_;
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_10__["default"].MULTI_POLYGON) {
    geometries =
    /** @type {ol.geom.MultiPolygon} */
    geometry.getPolygons();
    factory = _ol_format_KML_.POLYGON_NODE_FACTORY_;
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_3__["default"].assert(false, 39); // Unknown geometry type

  }

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.MULTI_GEOMETRY_SERIALIZERS_, factory, geometries, objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeBoundaryIs_ = function (node, linearRing, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.BOUNDARY_IS_SERIALIZERS_, _ol_format_KML_.LINEAR_RING_NODE_FACTORY_, [linearRing], objectStack);
};
/**
 * FIXME currently we do serialize arbitrary/custom feature properties
 * (ExtendedData).
 * @param {Node} node Node.
 * @param {ol.Feature} feature Feature.
 * @param {Array.<*>} objectStack Object stack.
 * @this {ol.format.KML}
 * @private
 */


_ol_format_KML_.writePlacemark_ = function (node, feature, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  }; // set id

  if (feature.getId()) {
    node.setAttribute('id', feature.getId());
  } // serialize properties (properties unknown to KML are not serialized)


  var properties = feature.getProperties(); // don't export these to ExtendedData

  var filter = {
    'address': 1,
    'description': 1,
    'name': 1,
    'open': 1,
    'phoneNumber': 1,
    'styleUrl': 1,
    'visibility': 1
  };
  filter[feature.getGeometryName()] = 1;
  var keys = Object.keys(properties || {}).sort().filter(function (v) {
    return !filter[v];
  });

  if (keys.length > 0) {
    var sequence = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, keys);

    var namesAndValues = {
      names: keys,
      values: sequence
    };

    _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.PLACEMARK_SERIALIZERS_, _ol_format_KML_.EXTENDEDDATA_NODE_FACTORY_, [namesAndValues], objectStack);
  }

  var styleFunction = feature.getStyleFunction();

  if (styleFunction) {
    // FIXME the styles returned by the style function are supposed to be
    // resolution-independent here
    var styles = styleFunction.call(feature, 0);

    if (styles) {
      var style = Array.isArray(styles) ? styles[0] : styles;

      if (this.writeStyles_) {
        properties['Style'] = style;
      }

      var textStyle = style.getText();

      if (textStyle) {
        properties['name'] = textStyle.getText();
      }
    }
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.PLACEMARK_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.PLACEMARK_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys); // serialize geometry


  var options =
  /** @type {olx.format.WriteOptions} */
  objectStack[0];
  var geometry = feature.getGeometry();

  if (geometry) {
    geometry = _format_feature_js__WEBPACK_IMPORTED_MODULE_5__["default"].transformWithOptions(geometry, true, options);
  }

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.PLACEMARK_SERIALIZERS_, _ol_format_KML_.GEOMETRY_NODE_FACTORY_, [geometry], objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.SimpleGeometry} geometry Geometry.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writePrimitiveGeometry_ = function (node, geometry, objectStack) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  context['layout'] = geometry.getLayout();
  context['stride'] = geometry.getStride(); // serialize properties (properties unknown to KML are not serialized)

  var properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.PRIMITIVE_GEOMETRY_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.PRIMITIVE_GEOMETRY_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node.
 * @param {ol.geom.Polygon} polygon Polygon.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writePolygon_ = function (node, polygon, objectStack) {
  var linearRings = polygon.getLinearRings();
  var outerRing = linearRings.shift();
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  }; // inner rings

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.POLYGON_SERIALIZERS_, _ol_format_KML_.INNER_BOUNDARY_NODE_FACTORY_, linearRings, objectStack); // outer ring


  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.POLYGON_SERIALIZERS_, _ol_format_KML_.OUTER_BOUNDARY_NODE_FACTORY_, [outerRing], objectStack);
};
/**
 * @param {Node} node Node.
 * @param {ol.style.Fill} style Style.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writePolyStyle_ = function (node, style, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.POLY_STYLE_SERIALIZERS_, _ol_format_KML_.COLOR_NODE_FACTORY_, [style.getColor()], objectStack);
};
/**
 * @param {Node} node Node to append a TextNode with the scale to.
 * @param {number|undefined} scale Scale.
 * @private
 */


_ol_format_KML_.writeScaleTextNode_ = function (node, scale) {
  // the Math is to remove any excess decimals created by float arithmetic
  _format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
};
/**
 * @param {Node} node Node.
 * @param {ol.style.Style} style Style.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 */


_ol_format_KML_.writeStyle_ = function (node, style, objectStack) {
  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: node
  };
  var properties = {};
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  var imageStyle = style.getImage();
  var textStyle = style.getText();

  if (imageStyle instanceof _style_icon_js__WEBPACK_IMPORTED_MODULE_20__["default"]) {
    properties['IconStyle'] = imageStyle;
  }

  if (textStyle) {
    properties['LabelStyle'] = textStyle;
  }

  if (strokeStyle) {
    properties['LineStyle'] = strokeStyle;
  }

  if (fillStyle) {
    properties['PolyStyle'] = fillStyle;
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = _ol_format_KML_.STYLE_SEQUENCE_[parentNode.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.STYLE_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
/**
 * @param {Node} node Node to append a TextNode with the Vec2 to.
 * @param {ol.KMLVec2_} vec2 Vec2.
 * @private
 */


_ol_format_KML_.writeVec2_ = function (node, vec2) {
  node.setAttribute('x', vec2.x);
  node.setAttribute('y', vec2.y);
  node.setAttribute('xunits', vec2.xunits);
  node.setAttribute('yunits', vec2.yunits);
};
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */


_ol_format_KML_.KML_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['Document', 'Placemark']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.KML_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Document': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeDocument_),
  'Placemark': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePlacemark_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.DOCUMENT_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Placemark': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePlacemark_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.EXTENDEDDATA_NODE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Data': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeDataNode_),
  'value': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeDataNodeValue_),
  'displayName': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeDataNodeName_)
});
/**
 * @const
 * @type {Object.<string, string>}
 * @private
 */

_ol_format_KML_.GEOMETRY_TYPE_TO_NODENAME_ = {
  'Point': 'Point',
  'LineString': 'LineString',
  'LinearRing': 'LinearRing',
  'Polygon': 'Polygon',
  'MultiPoint': 'MultiGeometry',
  'MultiLineString': 'MultiGeometry',
  'MultiPolygon': 'MultiGeometry',
  'GeometryCollection': 'MultiGeometry'
};
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.ICON_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['href'], _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, ['x', 'y', 'w', 'h']));
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.ICON_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'href': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode)
}, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.GX_NAMESPACE_URIS_, {
  'x': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode),
  'y': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode),
  'w': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode),
  'h': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode)
}));
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.ICON_STYLE_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['scale', 'heading', 'Icon', 'hotSpot']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.ICON_STYLE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'Icon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeIcon_),
  'heading': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode),
  'hotSpot': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeVec2_),
  'scale': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeScaleTextNode_)
});
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.LABEL_STYLE_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['color', 'scale']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.LABEL_STYLE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeColorTextNode_),
  'scale': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeScaleTextNode_)
});
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.LINE_STYLE_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['color', 'width']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.LINE_STYLE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeColorTextNode_),
  'width': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeDecimalTextNode)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.BOUNDARY_IS_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.MULTI_GEOMETRY_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_),
  'Point': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_),
  'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePolygon_),
  'GeometryCollection': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeMultiGeometry_)
});
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.PLACEMARK_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['name', 'open', 'visibility', 'address', 'phoneNumber', 'description', 'styleUrl', 'Style']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.PLACEMARK_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'ExtendedData': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeExtendedData_),
  'MultiGeometry': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeMultiGeometry_),
  'LineString': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_),
  'LinearRing': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_),
  'Point': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePrimitiveGeometry_),
  'Polygon': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePolygon_),
  'Style': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeStyle_),
  'address': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'description': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'name': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'open': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeBooleanTextNode),
  'phoneNumber': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'styleUrl': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'visibility': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeBooleanTextNode)
});
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.PRIMITIVE_GEOMETRY_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['extrude', 'tessellate', 'altitudeMode', 'coordinates']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.PRIMITIVE_GEOMETRY_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'extrude': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeBooleanTextNode),
  'tessellate': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeBooleanTextNode),
  'altitudeMode': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_format_xsd_js__WEBPACK_IMPORTED_MODULE_7__["default"].writeStringTextNode),
  'coordinates': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeCoordinatesTextNode_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.POLYGON_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'outerBoundaryIs': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeBoundaryIs_),
  'innerBoundaryIs': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeBoundaryIs_)
});
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.POLY_STYLE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'color': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeColorTextNode_)
});
/**
 * @const
 * @type {Object.<string, Array.<string>>}
 * @private
 */

_ol_format_KML_.STYLE_SEQUENCE_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, ['IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle']);
/**
 * @const
 * @type {Object.<string, Object.<string, ol.XmlSerializer>>}
 * @private
 */

_ol_format_KML_.STYLE_SERIALIZERS_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeStructureNS(_ol_format_KML_.NAMESPACE_URIS_, {
  'IconStyle': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeIconStyle_),
  'LabelStyle': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeLabelStyle_),
  'LineStyle': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writeLineStyle_),
  'PolyStyle': _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeChildAppender(_ol_format_KML_.writePolyStyle_)
});
/**
 * @const
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node|undefined} Node.
 * @private
 */

_ol_format_KML_.GX_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].createElementNS(_ol_format_KML_.GX_NAMESPACE_URIS_[0], 'gx:' + opt_nodeName);
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node|undefined} Node.
 * @private
 */


_ol_format_KML_.DOCUMENT_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].createElementNS(parentNode.namespaceURI, 'Placemark');
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array.<*>} objectStack Object stack.
 * @param {string=} opt_nodeName Node name.
 * @return {Node|undefined} Node.
 * @private
 */


_ol_format_KML_.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
  if (value) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].createElementNS(parentNode.namespaceURI, _ol_format_KML_.GEOMETRY_TYPE_TO_NODENAME_[
    /** @type {ol.geom.Geometry} */
    value.getType()]);
  }
};
/**
 * A factory for creating coordinates nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */


_ol_format_KML_.COLOR_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('color');
/**
 * A factory for creating Data nodes.
 * @const
 * @type {function(*, Array.<*>): (Node|undefined)}
 * @private
 */

_ol_format_KML_.DATA_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('Data');
/**
 * A factory for creating ExtendedData nodes.
 * @const
 * @type {function(*, Array.<*>): (Node|undefined)}
 * @private
 */

_ol_format_KML_.EXTENDEDDATA_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('ExtendedData');
/**
 * A factory for creating innerBoundaryIs nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.INNER_BOUNDARY_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('innerBoundaryIs');
/**
 * A factory for creating Point nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.POINT_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('Point');
/**
 * A factory for creating LineString nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.LINE_STRING_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('LineString');
/**
 * A factory for creating LinearRing nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.LINEAR_RING_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('LinearRing');
/**
 * A factory for creating Polygon nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.POLYGON_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('Polygon');
/**
 * A factory for creating outerBoundaryIs nodes.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 * @private
 */

_ol_format_KML_.OUTER_BOUNDARY_NODE_FACTORY_ = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSimpleNodeFactory('outerBoundaryIs');
/**
 * Encode an array of features in the KML format. GeometryCollections, MultiPoints,
 * MultiLineStrings, and MultiPolygons are output as MultiGeometries.
 *
 * @function
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Options.
 * @return {string} Result.
 * @api
 */

_ol_format_KML_.prototype.writeFeatures;
/**
 * Encode an array of features in the KML format as an XML node. GeometryCollections,
 * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
 *
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Options.
 * @return {Node} Node.
 * @override
 * @api
 */

_ol_format_KML_.prototype.writeFeaturesNode = function (features, opt_options) {
  opt_options = this.adaptOptions(opt_options);

  var kml = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].createElementNS(_ol_format_KML_.NAMESPACE_URIS_[4], 'kml');

  var xmlnsUri = 'http://www.w3.org/2000/xmlns/';
  var xmlSchemaInstanceUri = 'http://www.w3.org/2001/XMLSchema-instance';

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].setAttributeNS(kml, xmlnsUri, 'xmlns:gx', _ol_format_KML_.GX_NAMESPACE_URIS_[0]);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].setAttributeNS(kml, xmlnsUri, 'xmlns:xsi', xmlSchemaInstanceUri);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].setAttributeNS(kml, xmlSchemaInstanceUri, 'xsi:schemaLocation', _ol_format_KML_.SCHEMA_LOCATION_);

  var
  /** @type {ol.XmlNodeStackItem} */
  context = {
    node: kml
  };
  var properties = {};

  if (features.length > 1) {
    properties['Document'] = features;
  } else if (features.length == 1) {
    properties['Placemark'] = features[0];
  }

  var orderedKeys = _ol_format_KML_.KML_SEQUENCE_[kml.namespaceURI];

  var values = _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].makeSequence(properties, orderedKeys);

  _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].pushSerializeAndPop(context, _ol_format_KML_.KML_SERIALIZERS_, _xml_js__WEBPACK_IMPORTED_MODULE_26__["default"].OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);

  return kml;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_KML_);

/***/ }),

/***/ "./node_modules/ol/format/wmsgetfeatureinfo.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/wmsgetfeatureinfo.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _format_gml2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../format/gml2.js */ "./node_modules/ol/format/gml2.js");
/* harmony import */ var _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/xmlfeature.js */ "./node_modules/ol/format/xmlfeature.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");






/**
 * @classdesc
 * Format for reading WMSGetFeatureInfo format. It uses
 * {@link ol.format.GML2} to read features.
 *
 * @constructor
 * @extends {ol.format.XMLFeature}
 * @param {olx.format.WMSGetFeatureInfoOptions=} opt_options Options.
 * @api
 */

var _ol_format_WMSGetFeatureInfo_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {string}
   */

  this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';
  /**
   * @private
   * @type {ol.format.GML2}
   */

  this.gmlFormat_ = new _format_gml2_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
  /**
   * @private
   * @type {Array.<string>}
   */

  this.layers_ = options.layers ? options.layers : null;

  _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_WMSGetFeatureInfo_, _format_xmlfeature_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @const
 * @type {string}
 * @private
 */


_ol_format_WMSGetFeatureInfo_.featureIdentifier_ = '_feature';
/**
 * @const
 * @type {string}
 * @private
 */

_ol_format_WMSGetFeatureInfo_.layerIdentifier_ = '_layer';
/**
 * @return {Array.<string>} layers
 */

_ol_format_WMSGetFeatureInfo_.prototype.getLayers = function () {
  return this.layers_;
};
/**
 * @param {Array.<string>} layers Layers to parse.
 */


_ol_format_WMSGetFeatureInfo_.prototype.setLayers = function (layers) {
  this.layers_ = layers;
};
/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Array.<ol.Feature>} Features.
 * @private
 */


_ol_format_WMSGetFeatureInfo_.prototype.readFeatures_ = function (node, objectStack) {
  node.setAttribute('namespaceURI', this.featureNS_);
  var localName = node.localName;
  /** @type {Array.<ol.Feature>} */

  var features = [];

  if (node.childNodes.length === 0) {
    return features;
  }

  if (localName == 'msGMLOutput') {
    for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
      var layer = node.childNodes[i];

      if (layer.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }

      var context = objectStack[0];
      var toRemove = _ol_format_WMSGetFeatureInfo_.layerIdentifier_;
      var layerName = layer.localName.replace(toRemove, '');

      if (this.layers_ && !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].includes(this.layers_, layerName)) {
        continue;
      }

      var featureType = layerName + _ol_format_WMSGetFeatureInfo_.featureIdentifier_;
      context['featureType'] = featureType;
      context['featureNS'] = this.featureNS_;
      var parsers = {};
      parsers[featureType] = _xml_js__WEBPACK_IMPORTED_MODULE_5__["default"].makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);

      var parsersNS = _xml_js__WEBPACK_IMPORTED_MODULE_5__["default"].makeStructureNS([context['featureNS'], null], parsers);

      layer.setAttribute('namespaceURI', this.featureNS_);

      var layerFeatures = _xml_js__WEBPACK_IMPORTED_MODULE_5__["default"].pushParseAndPop([], parsersNS, layer, objectStack, this.gmlFormat_);

      if (layerFeatures) {
        _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(features, layerFeatures);
      }
    }
  }

  if (localName == 'FeatureCollection') {
    var gmlFeatures = _xml_js__WEBPACK_IMPORTED_MODULE_5__["default"].pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);

    if (gmlFeatures) {
      features = gmlFeatures;
    }
  }

  return features;
};
/**
 * Read all features from a WMSGetFeatureInfo response.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_format_WMSGetFeatureInfo_.prototype.readFeatures;
/**
 * @inheritDoc
 */

_ol_format_WMSGetFeatureInfo_.prototype.readFeaturesFromNode = function (node, opt_options) {
  var options = {};

  if (opt_options) {
    _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign(options, this.getReadOptions(node, opt_options));
  }

  return this.readFeatures_(node, [options]);
};
/**
 * Not implemented.
 * @inheritDoc
 */


_ol_format_WMSGetFeatureInfo_.prototype.writeFeatureNode = function (feature, opt_options) {};
/**
 * Not implemented.
 * @inheritDoc
 */


_ol_format_WMSGetFeatureInfo_.prototype.writeFeaturesNode = function (features, opt_options) {};
/**
 * Not implemented.
 * @inheritDoc
 */


_ol_format_WMSGetFeatureInfo_.prototype.writeGeometryNode = function (geometry, opt_options) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_WMSGetFeatureInfo_);

/***/ }),

/***/ "./node_modules/ol/format/xmlfeature.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/xmlfeature.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _format_feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../format/feature.js */ "./node_modules/ol/format/feature.js");
/* harmony import */ var _format_formattype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/formattype.js */ "./node_modules/ol/format/formattype.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 */

var _ol_format_XMLFeature_ = function () {
  /**
   * @type {XMLSerializer}
   * @private
   */
  this.xmlSerializer_ = new XMLSerializer();

  _format_feature_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_format_XMLFeature_, _format_feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.getType = function () {
  return _format_formattype_js__WEBPACK_IMPORTED_MODULE_3__["default"].XML;
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.readFeature = function (source, opt_options) {
  if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isDocument(source)) {
    return this.readFeatureFromDocument(
    /** @type {Document} */
    source, opt_options);
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isNode(source)) {
    return this.readFeatureFromNode(
    /** @type {Node} */
    source, opt_options);
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);

    return this.readFeatureFromDocument(doc, opt_options);
  } else {
    return null;
  }
};
/**
 * @param {Document} doc Document.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {ol.Feature} Feature.
 */


_ol_format_XMLFeature_.prototype.readFeatureFromDocument = function (doc, opt_options) {
  var features = this.readFeaturesFromDocument(doc, opt_options);

  if (features.length > 0) {
    return features[0];
  } else {
    return null;
  }
};
/**
 * @param {Node} node Node.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {ol.Feature} Feature.
 */


_ol_format_XMLFeature_.prototype.readFeatureFromNode = function (node, opt_options) {
  return null; // not implemented
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.readFeatures = function (source, opt_options) {
  if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isDocument(source)) {
    return this.readFeaturesFromDocument(
    /** @type {Document} */
    source, opt_options);
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isNode(source)) {
    return this.readFeaturesFromNode(
    /** @type {Node} */
    source, opt_options);
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);

    return this.readFeaturesFromDocument(doc, opt_options);
  } else {
    return [];
  }
};
/**
 * @param {Document} doc Document.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */


_ol_format_XMLFeature_.prototype.readFeaturesFromDocument = function (doc, opt_options) {
  /** @type {Array.<ol.Feature>} */
  var features = [];
  var n;

  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(features, this.readFeaturesFromNode(n, opt_options));
    }
  }

  return features;
};
/**
 * @abstract
 * @param {Node} node Node.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */


_ol_format_XMLFeature_.prototype.readFeaturesFromNode = function (node, opt_options) {};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.readGeometry = function (source, opt_options) {
  if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isDocument(source)) {
    return this.readGeometryFromDocument(
    /** @type {Document} */
    source, opt_options);
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isNode(source)) {
    return this.readGeometryFromNode(
    /** @type {Node} */
    source, opt_options);
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);

    return this.readGeometryFromDocument(doc, opt_options);
  } else {
    return null;
  }
};
/**
 * @param {Document} doc Document.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_XMLFeature_.prototype.readGeometryFromDocument = function (doc, opt_options) {
  return null; // not implemented
};
/**
 * @param {Node} node Node.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */


_ol_format_XMLFeature_.prototype.readGeometryFromNode = function (node, opt_options) {
  return null; // not implemented
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.readProjection = function (source) {
  if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isDocument(source)) {
    return this.readProjectionFromDocument(
    /** @type {Document} */
    source);
  } else if (_xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].isNode(source)) {
    return this.readProjectionFromNode(
    /** @type {Node} */
    source);
  } else if (typeof source === 'string') {
    var doc = _xml_js__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);

    return this.readProjectionFromDocument(doc);
  } else {
    return null;
  }
};
/**
 * @param {Document} doc Document.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */


_ol_format_XMLFeature_.prototype.readProjectionFromDocument = function (doc) {
  return this.defaultDataProjection;
};
/**
 * @param {Node} node Node.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */


_ol_format_XMLFeature_.prototype.readProjectionFromNode = function (node) {
  return this.defaultDataProjection;
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.writeFeature = function (feature, opt_options) {
  var node = this.writeFeatureNode(feature, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Options.
 * @protected
 * @return {Node} Node.
 */


_ol_format_XMLFeature_.prototype.writeFeatureNode = function (feature, opt_options) {
  return null; // not implemented
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.writeFeatures = function (features, opt_options) {
  var node = this.writeFeaturesNode(features, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
/**
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Options.
 * @return {Node} Node.
 */


_ol_format_XMLFeature_.prototype.writeFeaturesNode = function (features, opt_options) {
  return null; // not implemented
};
/**
 * @inheritDoc
 */


_ol_format_XMLFeature_.prototype.writeGeometry = function (geometry, opt_options) {
  var node = this.writeGeometryNode(geometry, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Options.
 * @return {Node} Node.
 */


_ol_format_XMLFeature_.prototype.writeGeometryNode = function (geometry, opt_options) {
  return null; // not implemented
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_XMLFeature_);

/***/ }),

/***/ "./node_modules/ol/format/xsd.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/xsd.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");


var _ol_format_XSD_ = {};
/**
 * @const
 * @type {string}
 */

_ol_format_XSD_.NAMESPACE_URI = 'http://www.w3.org/2001/XMLSchema';
/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */

_ol_format_XSD_.readBoolean = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].getAllTextContent(node, false);

  return _ol_format_XSD_.readBooleanString(s);
};
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */


_ol_format_XSD_.readBooleanString = function (string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);

  if (m) {
    return m[1] !== undefined || false;
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */


_ol_format_XSD_.readDateTime = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].getAllTextContent(node, false);

  var dateTime = Date.parse(s);
  return isNaN(dateTime) ? undefined : dateTime / 1000;
};
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */


_ol_format_XSD_.readDecimal = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].getAllTextContent(node, false);

  return _ol_format_XSD_.readDecimalString(s);
};
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */


_ol_format_XSD_.readDecimalString = function (string) {
  // FIXME check spec
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);

  if (m) {
    return parseFloat(m[1]);
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */


_ol_format_XSD_.readNonNegativeInteger = function (node) {
  var s = _xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].getAllTextContent(node, false);

  return _ol_format_XSD_.readNonNegativeIntegerString(s);
};
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */


_ol_format_XSD_.readNonNegativeIntegerString = function (string) {
  var m = /^\s*(\d+)\s*$/.exec(string);

  if (m) {
    return parseInt(m[1], 10);
  } else {
    return undefined;
  }
};
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */


_ol_format_XSD_.readString = function (node) {
  return _xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].getAllTextContent(node, false).trim();
};
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */


_ol_format_XSD_.writeBooleanTextNode = function (node, bool) {
  _ol_format_XSD_.writeStringTextNode(node, bool ? '1' : '0');
};
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */


_ol_format_XSD_.writeCDATASection = function (node, string) {
  node.appendChild(_xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].DOCUMENT.createCDATASection(string));
};
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */


_ol_format_XSD_.writeDateTimeTextNode = function (node, dateTime) {
  var date = new Date(dateTime * 1000);
  var string = date.getUTCFullYear() + '-' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(date.getUTCMonth() + 1, 2) + '-' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(date.getUTCDate(), 2) + 'T' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(date.getUTCHours(), 2) + ':' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(date.getUTCMinutes(), 2) + ':' + _string_js__WEBPACK_IMPORTED_MODULE_1__["default"].padNumber(date.getUTCSeconds(), 2) + 'Z';
  node.appendChild(_xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].DOCUMENT.createTextNode(string));
};
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */


_ol_format_XSD_.writeDecimalTextNode = function (node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild(_xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].DOCUMENT.createTextNode(string));
};
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */


_ol_format_XSD_.writeNonNegativeIntegerTextNode = function (node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild(_xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].DOCUMENT.createTextNode(string));
};
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */


_ol_format_XSD_.writeStringTextNode = function (node, string) {
  node.appendChild(_xml_js__WEBPACK_IMPORTED_MODULE_0__["default"].DOCUMENT.createTextNode(string));
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_format_XSD_);

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_functions_ = {};
/**
 * Always returns true.
 * @returns {boolean} true.
 */

_ol_functions_.TRUE = function () {
  return true;
};
/**
 * Always returns false.
 * @returns {boolean} false.
 */


_ol_functions_.FALSE = function () {
  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_functions_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_area_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

_ol_geom_flat_area_.linearRing = function (flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


_ol_geom_flat_area_.linearRings = function (flatCoordinates, offset, ends, stride) {
  var area = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += _ol_geom_flat_area_.linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


_ol_geom_flat_area_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var area = 0;
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += _ol_geom_flat_area_.linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_area_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");

var _ol_geom_flat_center_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array.<number>} Flat centers.
 */

_ol_geom_flat_center_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var i, ii;

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmpty();

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = _extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }

  return flatCenters;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_center_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");

var _ol_geom_flat_closest_ = {};
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */

_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var i, offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }

  closestPoint.length = stride;
};
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    var squaredDelta = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredDistance(x1, y1, x2, y2);

    if (squaredDelta > maxSquaredDelta) {
      maxSquaredDelta = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);
    offset = end;
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);
    offset = ends[ends.length - 1];
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);

    squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);

    squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_closest_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");

var _ol_geom_flat_contains_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Contains extent.
 */

_ol_geom_flat_contains_.linearRingContainsExtent = function (flatCoordinates, offset, end, stride, extent) {
  var outside = _extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEachCorner(extent,
  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });

  return !outside;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingContainsXY = function (flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingsContainsXY = function (flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  var i, ii;

  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingssContainsXY = function (flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_contains_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_deflate_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */

_ol_geom_flat_deflate_.coordinate = function (flatCoordinates, offset, coordinate, stride) {
  var i, ii;

  for (i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */


_ol_geom_flat_deflate_.coordinates = function (flatCoordinates, offset, coordinates, stride) {
  var i, ii;

  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    var j;

    for (j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */


_ol_geom_flat_deflate_.coordinatess = function (flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = _ol_geom_flat_deflate_.coordinates(flatCoordinates, offset, coordinatess[j], stride);

    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */


_ol_geom_flat_deflate_.coordinatesss = function (flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = _ol_geom_flat_deflate_.coordinatess(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);

    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_deflate_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_inflate_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<ol.Coordinate>} Coordinates.
 */

_ol_geom_flat_inflate_.coordinates = function (flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  var j;

  for (j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.
 */


_ol_geom_flat_inflate_.coordinatess = function (flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = _ol_geom_flat_inflate_.coordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.
 */


_ol_geom_flat_inflate_.coordinatesss = function (flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = _ol_geom_flat_inflate_.coordinatess(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_inflate_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");


var _ol_geom_flat_interiorpoint_ = {};
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

_ol_geom_flat_interiorpoint_.linearRings = function (flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array.<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"].numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */


_ol_geom_flat_interiorpoint_.linearRingss = function (flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = _ol_geom_flat_interiorpoint_.linearRings(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_interiorpoint_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");


var _ol_geom_flat_interpolate_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */

_ol_geom_flat_interpolate_.lineString = function (flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;

  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    var i;

    for (i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }

    var target = fraction * length;

    var index = _array_js__WEBPACK_IMPORTED_MODULE_0__["default"].binarySearch(cumulativeLengths, target);

    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].lerp(flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }

  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function (flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }

  var coordinate;

  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } // FIXME use O(1) search


  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }

  var lo = offset / stride;
  var hi = end / stride;

  while (lo < hi) {
    var mid = lo + hi >> 1;

    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  var m0 = flatCoordinates[lo * stride - 1];

  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }

  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  var i;

  for (i = 0; i < stride - 1; ++i) {
    coordinate.push(_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }

  coordinate.push(m);
  return coordinate;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function (flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }

  var coordinate;

  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    if (offset == end) {
      continue;
    }

    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }

    offset = end;
  }

  return null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_interpolate_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");



var _ol_geom_flat_intersectsextent_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

_ol_geom_flat_intersectsextent_.lineString = function (flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = _extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].extendFlatCoordinates(_extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmpty(), flatCoordinates, offset, end, stride);

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].intersects(extent, coordinatesExtent)) {
    return false;
  }

  if (_extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].containsExtent(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return _flat_segments_js__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(flatCoordinates, offset, end, stride,
  /**
   * @param {ol.Coordinate} point1 Start point.
   * @param {ol.Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return _extent_js__WEBPACK_IMPORTED_MODULE_0__["default"].intersectsSegment(extent, point1, point2);
  });
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.lineStrings = function (flatCoordinates, offset, ends, stride, extent) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRing = function (flatCoordinates, offset, end, stride, extent) {
  if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRings = function (flatCoordinates, offset, ends, stride, extent) {
  if (!_ol_geom_flat_intersectsextent_.linearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  var i, ii;

  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"].linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRingss = function (flatCoordinates, offset, endss, stride, extent) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (_ol_geom_flat_intersectsextent_.linearRings(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_intersectsextent_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_length_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */

_ol_geom_flat_length_.lineString = function (flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  var i;

  for (i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */


_ol_geom_flat_length_.linearRing = function (flatCoordinates, offset, end, stride) {
  var perimeter = _ol_geom_flat_length_.lineString(flatCoordinates, offset, end, stride);

  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_length_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _flat_reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flat/reverse.js */ "./node_modules/ol/geom/flat/reverse.js");

var _ol_geom_flat_orient_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */

_ol_geom_flat_orient_.linearRingIsClockwise = function (flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge > 0;
};
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


_ol_geom_flat_orient_.linearRingsAreOriented = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
};
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


_ol_geom_flat_orient_.linearRingssAreOriented = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    if (!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }

  return true;
};
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


_ol_geom_flat_orient_.orientLinearRings = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);

    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      _flat_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"].coordinates(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
};
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


_ol_geom_flat_orient_.orientLinearRingss = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }

  return offset;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_orient_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_reverse_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */

_ol_geom_flat_reverse_.coordinates = function (flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    var i;

    for (i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_reverse_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_segments_ = {};
/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */

_ol_geom_flat_segments_.forEach = function (flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;

  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);

    if (ret) {
      return ret;
    }

    point1[0] = point2[0];
    point1[1] = point2[1];
  }

  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_segments_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

var _ol_geom_flat_simplify_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */

_ol_geom_flat_simplify_.lineString = function (flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeucker = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array.<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array.<number>} */

  var stack = [offset, end - stride];
  var index = 0;
  var i;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      var squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredSegmentDistance(x, y, x1, y1, x2, y2);

      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeuckers = function (flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeuckerss = function (flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.radialDistance = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if (_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
};
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */


_ol_geom_flat_simplify_.snap = function (value, tolerance) {
  return tolerance * Math.round(value / tolerance);
};
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantize = function (flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);

  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);

  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    var x3, y3; // snap the next coordinate (P3)

    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantizes = function (flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantizess = function (flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_simplify_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/straightchunk.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_straightchunk_ = {};
/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array.<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */

_ol_geom_flat_straightchunk_.lineString = function (maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_straightchunk_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/textpath.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");

var _ol_geom_flat_textpath_ = {};
/**
 * @param {Array.<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */

_ol_geom_flat_textpath_.lineString = function (flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = []; // Keep text upright

  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
  var numChars = text.length;
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;

  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;

    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    var interpolate = segmentPos / segmentLength;

    var x = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].lerp(x1, x2, interpolate);

    var y = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].lerp(y1, y2, interpolate);

    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }

      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];

      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }

      previousAngle = angle;
    }

    startM += charLength;
  }

  return result;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_textpath_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/topology.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/topology.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flat/area.js */ "./node_modules/ol/geom/flat/area.js");

var _ol_geom_flat_topology_ = {};
/**
 * Check if the linestring is a boundary.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */

_ol_geom_flat_topology_.lineStringIsClosed = function (flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;

  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!_flat_area_js__WEBPACK_IMPORTED_MODULE_0__["default"].linearRing(flatCoordinates, offset, end, stride);
  }

  return false;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_topology_);

/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_geom_flat_transform_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */

_ol_geom_flat_transform_.transform2D = function (flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j;

  for (j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.rotate = function (flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.scale = function (flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.translate = function (flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j, k;

  for (j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_flat_transform_);

/***/ }),

/***/ "./node_modules/ol/geom/geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj/units.js */ "./node_modules/ol/proj/units.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");








/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @api
 */

var _ol_geom_Geometry_ = function () {
  _object_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @private
   * @type {ol.Extent}
   */


  this.extent_ = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createEmpty();
  /**
   * @private
   * @type {number}
   */

  this.extentRevision_ = -1;
  /**
   * @protected
   * @type {Object.<string, ol.geom.Geometry>}
   */

  this.simplifiedGeometryCache = {};
  /**
   * @protected
   * @type {number}
   */

  this.simplifiedGeometryMaxMinSquaredTolerance = 0;
  /**
   * @protected
   * @type {number}
   */

  this.simplifiedGeometryRevision = 0;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_Geometry_, _object_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Make a complete copy of the geometry.
 * @abstract
 * @return {!ol.geom.Geometry} Clone.
 */


_ol_geom_Geometry_.prototype.clone = function () {};
/**
 * @abstract
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.Coordinate} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @return {number} Minimum squared distance.
 */


_ol_geom_Geometry_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {};
/**
 * Return the closest point of the geometry to the passed point as
 * {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} point Point.
 * @param {ol.Coordinate=} opt_closestPoint Closest point.
 * @return {ol.Coordinate} Closest point.
 * @api
 */


_ol_geom_Geometry_.prototype.getClosestPoint = function (point, opt_closestPoint) {
  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
  this.closestPointXY(point[0], point[1], closestPoint, Infinity);
  return closestPoint;
};
/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} Contains coordinate.
 * @api
 */


_ol_geom_Geometry_.prototype.intersectsCoordinate = function (coordinate) {
  return this.containsXY(coordinate[0], coordinate[1]);
};
/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @protected
 * @return {ol.Extent} extent Extent.
 */


_ol_geom_Geometry_.prototype.computeExtent = function (extent) {};
/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_Geometry_.prototype.containsXY = _functions_js__WEBPACK_IMPORTED_MODULE_3__["default"].FALSE;
/**
 * Get the extent of the geometry.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} extent Extent.
 * @api
 */

_ol_geom_Geometry_.prototype.getExtent = function (opt_extent) {
  if (this.extentRevision_ != this.getRevision()) {
    this.extent_ = this.computeExtent(this.extent_);
    this.extentRevision_ = this.getRevision();
  }

  return _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].returnOrUpdate(this.extent_, opt_extent);
};
/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} angle Rotation angle in radians.
 * @param {ol.Coordinate} anchor The rotation center.
 * @api
 */


_ol_geom_Geometry_.prototype.rotate = function (angle, anchor) {};
/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} sx The scaling factor in the x-direction.
 * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
 *     sx).
 * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center
 *     of the geometry extent).
 * @api
 */


_ol_geom_Geometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {};
/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 * @function
 * @param {number} tolerance The tolerance distance for simplification.
 * @return {ol.geom.Geometry} A new, simplified version of the original
 *     geometry.
 * @api
 */


_ol_geom_Geometry_.prototype.simplify = function (tolerance) {
  return this.getSimplifiedGeometry(tolerance * tolerance);
};
/**
 * Create a simplified version of this geometry using the Douglas Peucker
 * algorithm.
 * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * @abstract
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.Geometry} Simplified geometry.
 */


_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {};
/**
 * Get the type of this geometry.
 * @abstract
 * @return {ol.geom.GeometryType} Geometry type.
 */


_ol_geom_Geometry_.prototype.getType = function () {};
/**
 * Apply a transform function to each coordinate of the geometry.
 * The geometry is modified in place.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * @abstract
 * @param {ol.TransformFunction} transformFn Transform.
 */


_ol_geom_Geometry_.prototype.applyTransform = function (transformFn) {};
/**
 * Test if the geometry and the passed extent intersect.
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @return {boolean} `true` if the geometry and the extent intersect.
 */


_ol_geom_Geometry_.prototype.intersectsExtent = function (extent) {};
/**
 * Translate the geometry.  This modifies the geometry coordinates in place.  If
 * instead you want a new geometry, first `clone()` this geometry.
 * @abstract
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 */


_ol_geom_Geometry_.prototype.translate = function (deltaX, deltaY) {};
/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 *
 * @param {ol.ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @param {ol.ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @return {ol.geom.Geometry} This geometry.  Note that original geometry is
 *     modified in place.
 * @api
 */


_ol_geom_Geometry_.prototype.transform = function (source, destination) {
  var tmpTransform = this.tmpTransform_;
  source = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(source);
  var transformFn = source.getUnits() == _proj_units_js__WEBPACK_IMPORTED_MODULE_6__["default"].TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
    var pixelExtent = source.getExtent();
    var projectedExtent = source.getWorldExtent();

    var scale = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHeight(projectedExtent) / _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHeight(pixelExtent);

    _transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);

    _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["default"].transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);

    return _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].getTransform(source, destination)(inCoordinates, outCoordinates, stride);
  } : _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].getTransform(source, destination);
  this.applyTransform(transformFn);
  return this;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_Geometry_);

/***/ }),

/***/ "./node_modules/ol/geom/geometrycollection.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/geometrycollection.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometry.js */ "./node_modules/ol/geom/geometry.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");







/**
 * @classdesc
 * An array of {@link ol.geom.Geometry} objects.
 *
 * @constructor
 * @extends {ol.geom.Geometry}
 * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.
 * @api
 */

var _ol_geom_GeometryCollection_ = function (opt_geometries) {
  _geom_geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
  /**
   * @private
   * @type {Array.<ol.geom.Geometry>}
   */


  this.geometries_ = opt_geometries ? opt_geometries : null;
  this.listenGeometriesChange_();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_GeometryCollection_, _geom_geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @private
 * @return {Array.<ol.geom.Geometry>} Cloned geometries.
 */


_ol_geom_GeometryCollection_.cloneGeometries_ = function (geometries) {
  var clonedGeometries = [];
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }

  return clonedGeometries;
};
/**
 * @private
 */


_ol_geom_GeometryCollection_.prototype.unlistenGeometriesChange_ = function () {
  var i, ii;

  if (!this.geometries_) {
    return;
  }

  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlisten(this.geometries_[i], _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.changed, this);
  }
};
/**
 * @private
 */


_ol_geom_GeometryCollection_.prototype.listenGeometriesChange_ = function () {
  var i, ii;

  if (!this.geometries_) {
    return;
  }

  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this.geometries_[i], _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.changed, this);
  }
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.GeometryCollection} Clone.
 * @override
 * @api
 */


_ol_geom_GeometryCollection_.prototype.clone = function () {
  var geometryCollection = new _ol_geom_GeometryCollection_(null);
  geometryCollection.setGeometries(this.geometries_);
  return geometryCollection;
};
/**
 * @inheritDoc
 */


_ol_geom_GeometryCollection_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  var geometries = this.geometries_;
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
  }

  return minSquaredDistance;
};
/**
 * @inheritDoc
 */


_ol_geom_GeometryCollection_.prototype.containsXY = function (x, y) {
  var geometries = this.geometries_;
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].containsXY(x, y)) {
      return true;
    }
  }

  return false;
};
/**
 * @inheritDoc
 */


_ol_geom_GeometryCollection_.prototype.computeExtent = function (extent) {
  _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createOrUpdateEmpty(extent);

  var geometries = this.geometries_;

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extend(extent, geometries[i].getExtent());
  }

  return extent;
};
/**
 * Return the geometries that make up this geometry collection.
 * @return {Array.<ol.geom.Geometry>} Geometries.
 * @api
 */


_ol_geom_GeometryCollection_.prototype.getGeometries = function () {
  return _ol_geom_GeometryCollection_.cloneGeometries_(this.geometries_);
};
/**
 * @return {Array.<ol.geom.Geometry>} Geometries.
 */


_ol_geom_GeometryCollection_.prototype.getGeometriesArray = function () {
  return this.geometries_;
};
/**
 * @inheritDoc
 */


_ol_geom_GeometryCollection_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].clear(this.simplifiedGeometryCache);

    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }

  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }

  var key = squaredTolerance.toString();

  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    var i, ii;

    for (i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);

      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }

    if (simplified) {
      var simplifiedGeometryCollection = new _ol_geom_GeometryCollection_(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_GeometryCollection_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].GEOMETRY_COLLECTION;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_GeometryCollection_.prototype.intersectsExtent = function (extent) {
  var geometries = this.geometries_;
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].intersectsExtent(extent)) {
      return true;
    }
  }

  return false;
};
/**
 * @return {boolean} Is empty.
 */


_ol_geom_GeometryCollection_.prototype.isEmpty = function () {
  return this.geometries_.length === 0;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_GeometryCollection_.prototype.rotate = function (angle, anchor) {
  var geometries = this.geometries_;

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].rotate(angle, anchor);
  }

  this.changed();
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_GeometryCollection_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var anchor = opt_anchor;

  if (!anchor) {
    anchor = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].getCenter(this.getExtent());
  }

  var geometries = this.geometries_;

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].scale(sx, opt_sy, anchor);
  }

  this.changed();
};
/**
 * Set the geometries that make up this geometry collection.
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @api
 */


_ol_geom_GeometryCollection_.prototype.setGeometries = function (geometries) {
  this.setGeometriesArray(_ol_geom_GeometryCollection_.cloneGeometries_(geometries));
};
/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 */


_ol_geom_GeometryCollection_.prototype.setGeometriesArray = function (geometries) {
  this.unlistenGeometriesChange_();
  this.geometries_ = geometries;
  this.listenGeometriesChange_();
  this.changed();
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_GeometryCollection_.prototype.applyTransform = function (transformFn) {
  var geometries = this.geometries_;
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].applyTransform(transformFn);
  }

  this.changed();
};
/**
 * Translate the geometry.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @override
 * @api
 */


_ol_geom_GeometryCollection_.prototype.translate = function (deltaX, deltaY) {
  var geometries = this.geometries_;
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].translate(deltaX, deltaY);
  }

  this.changed();
};
/**
 * @inheritDoc
 */


_ol_geom_GeometryCollection_.prototype.disposeInternal = function () {
  this.unlistenGeometriesChange_();

  _geom_geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.disposeInternal.call(this);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_GeometryCollection_);

/***/ }),

/***/ "./node_modules/ol/geom/geometrylayout.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/geometrylayout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _ol_geom_GeometryLayout_ = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_GeometryLayout_);

/***/ }),

/***/ "./node_modules/ol/geom/geometrytype.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/geometrytype.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _ol_geom_GeometryType_ = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_GeometryType_);

/***/ }),

/***/ "./node_modules/ol/geom/linearring.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/linearring.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");










/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_LinearRing_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
  /**
   * @private
   * @type {number}
   */


  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_LinearRing_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LinearRing} Clone.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.clone = function () {
  var linearRing = new _ol_geom_LinearRing_(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return linearRing;
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["default"].getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["default"].getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
/**
 * Return the area of the linear ring on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */


_ol_geom_LinearRing_.prototype.getArea = function () {
  return _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_5__["default"].linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * Return the coordinates of the linear ring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.getCoordinates = function () {
  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["default"].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_9__["default"].douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLinearRing = new _ol_geom_LinearRing_(null);
  simplifiedLinearRing.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedFlatCoordinates);
  return simplifiedLinearRing;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_LinearRing_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINEAR_RING;
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.intersectsExtent = function (extent) {};
/**
 * Set the coordinates of the linear ring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["default"].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_LinearRing_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_LinearRing_);

/***/ }),

/***/ "./node_modules/ol/geom/linestring.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/linestring.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");














/**
 * @classdesc
 * Linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_LineString_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this);
  /**
   * @private
   * @type {ol.Coordinate}
   */


  this.flatMidpoint_ = null;
  /**
   * @private
   * @type {number}
   */

  this.flatMidpointRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_LineString_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * Append the passed coordinate to the coordinates of the linestring.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @api
 */


_ol_geom_LineString_.prototype.appendCoordinate = function (coordinate) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = coordinate.slice();
  } else {
    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.flatCoordinates, coordinate);
  }

  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LineString} Clone.
 * @override
 * @api
 */


_ol_geom_LineString_.prototype.clone = function () {
  var lineString = new _ol_geom_LineString_(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return lineString;
};
/**
 * @inheritDoc
 */


_ol_geom_LineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["default"].getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["default"].getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};
/**
 * Iterate over each segment, calling the provided callback.
 * If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 *
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 * @api
 */


_ol_geom_LineString_.prototype.forEachSegment = function (callback, opt_this) {
  return _geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_12__["default"].forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback, opt_this);
};
/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_geom_LineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
  if (this.layout != _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM && this.layout != _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM) {
    return null;
  }

  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  return _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["default"].lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
};
/**
 * Return the coordinates of the linestring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */


_ol_geom_LineString_.prototype.getCoordinates = function () {
  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["default"].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * Return the coordinate at the provided fraction along the linestring.
 * The `fraction` is a number between 0 and 1, where 0 is the start of the
 * linestring and 1 is the end.
 * @param {number} fraction Fraction.
 * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will
 *     be modified. If not provided, a new coordinate will be returned.
 * @return {ol.Coordinate} Coordinate of the interpolated point.
 * @api
 */


_ol_geom_LineString_.prototype.getCoordinateAt = function (fraction, opt_dest) {
  return _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["default"].lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);
};
/**
 * Return the length of the linestring on projected plane.
 * @return {number} Length (on projected plane).
 * @api
 */


_ol_geom_LineString_.prototype.getLength = function () {
  return _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_11__["default"].lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * @return {Array.<number>} Flat midpoint.
 */


_ol_geom_LineString_.prototype.getFlatMidpoint = function () {
  if (this.flatMidpointRevision_ != this.getRevision()) {
    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
    this.flatMidpointRevision_ = this.getRevision();
  }

  return this.flatMidpoint_;
};
/**
 * @inheritDoc
 */


_ol_geom_LineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_13__["default"].douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLineString = new _ol_geom_LineString_(null);
  simplifiedLineString.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, simplifiedFlatCoordinates);
  return simplifiedLineString;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_LineString_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_LineString_.prototype.intersectsExtent = function (extent) {
  return _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__["default"].lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};
/**
 * Set the coordinates of the linestring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_LineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["default"].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_LineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_LineString_);

/***/ }),

/***/ "./node_modules/ol/geom/multilinestring.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/multilinestring.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_linestring_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/linestring.js */ "./node_modules/ol/geom/linestring.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");













/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_MultiLineString_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this);
  /**
   * @type {Array.<number>}
   * @private
   */


  this.ends_ = [];
  /**
   * @private
   * @type {number}
   */

  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_MultiLineString_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * Append the passed linestring to the multilinestring.
 * @param {ol.geom.LineString} lineString LineString.
 * @api
 */


_ol_geom_MultiLineString_.prototype.appendLineString = function (lineString) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = lineString.getFlatCoordinates().slice();
  } else {
    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
  }

  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiLineString} Clone.
 * @override
 * @api
 */


_ol_geom_MultiLineString_.prototype.clone = function () {
  var multiLineString = new _ol_geom_MultiLineString_(null);
  multiLineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return multiLineString;
};
/**
 * @inheritDoc
 */


_ol_geom_MultiLineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_7__["default"].getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_7__["default"].getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};
/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * `opt_interpolate` controls interpolation between consecutive LineStrings
 * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
 * will be linearly interpolated between the last coordinate of one LineString
 * and the first coordinate of the next LineString.  If `opt_interpolate` is
 * `false` then the function will return `null` for Ms falling between
 * LineStrings.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_geom_MultiLineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
  if (this.layout != _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM && this.layout != _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM || this.flatCoordinates.length === 0) {
    return null;
  }

  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
  return _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__["default"].lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
};
/**
 * Return the coordinates of the multilinestring.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */


_ol_geom_MultiLineString_.prototype.getCoordinates = function () {
  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__["default"].coordinatess(this.flatCoordinates, 0, this.ends_, this.stride);
};
/**
 * @return {Array.<number>} Ends.
 */


_ol_geom_MultiLineString_.prototype.getEnds = function () {
  return this.ends_;
};
/**
 * Return the linestring at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.LineString} LineString.
 * @api
 */


_ol_geom_MultiLineString_.prototype.getLineString = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }

  var lineString = new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return lineString;
};
/**
 * Return the linestrings of this multilinestring.
 * @return {Array.<ol.geom.LineString>} LineStrings.
 * @api
 */


_ol_geom_MultiLineString_.prototype.getLineStrings = function () {
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var layout = this.layout;
  /** @type {Array.<ol.geom.LineString>} */

  var lineStrings = [];
  var offset = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var lineString = new _geom_linestring_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    lineStrings.push(lineString);
    offset = end;
  }

  return lineStrings;
};
/**
 * @return {Array.<number>} Flat midpoints.
 */


_ol_geom_MultiLineString_.prototype.getFlatMidpoints = function () {
  var midpoints = [];
  var flatCoordinates = this.flatCoordinates;
  var offset = 0;
  var ends = this.ends_;
  var stride = this.stride;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    var midpoint = _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__["default"].lineString(flatCoordinates, offset, end, stride, 0.5);

    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(midpoints, midpoint);

    offset = end;
  }

  return midpoints;
};
/**
 * @inheritDoc
 */


_ol_geom_MultiLineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__["default"].douglasPeuckers(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedMultiLineString = new _ol_geom_MultiLineString_(null);
  simplifiedMultiLineString.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedMultiLineString;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiLineString_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_LINE_STRING;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiLineString_.prototype.intersectsExtent = function (extent) {
  return _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__["default"].lineStrings(this.flatCoordinates, 0, this.ends_, this.stride, extent);
};
/**
 * Set the coordinates of the multilinestring.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_MultiLineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_8__["default"].coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);

    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */


_ol_geom_MultiLineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};
/**
 * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.
 */


_ol_geom_MultiLineString_.prototype.setLineStrings = function (lineStrings) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var ends = [];
  var i, ii;

  for (i = 0, ii = lineStrings.length; i < ii; ++i) {
    var lineString = lineStrings[i];

    if (i === 0) {
      layout = lineString.getLayout();
    }

    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(flatCoordinates, lineString.getFlatCoordinates());

    ends.push(flatCoordinates.length);
  }

  this.setFlatCoordinates(layout, flatCoordinates, ends);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_MultiLineString_);

/***/ }),

/***/ "./node_modules/ol/geom/multipoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/multipoint.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");










/**
 * @classdesc
 * Multi-point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_MultiPoint_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this);

  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_MultiPoint_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * Append the passed point to this multipoint.
 * @param {ol.geom.Point} point Point.
 * @api
 */


_ol_geom_MultiPoint_.prototype.appendPoint = function (point) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = point.getFlatCoordinates().slice();
  } else {
    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.flatCoordinates, point.getFlatCoordinates());
  }

  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPoint} Clone.
 * @override
 * @api
 */


_ol_geom_MultiPoint_.prototype.clone = function () {
  var multiPoint = new _ol_geom_MultiPoint_(null);
  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return multiPoint;
};
/**
 * @inheritDoc
 */


_ol_geom_MultiPoint_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, j;

  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_9__["default"].squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (j = 0; j < stride; ++j) {
        closestPoint[j] = flatCoordinates[i + j];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
};
/**
 * Return the coordinates of the multipoint.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */


_ol_geom_MultiPoint_.prototype.getCoordinates = function () {
  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["default"].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * Return the point at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Point} Point.
 * @api
 */


_ol_geom_MultiPoint_.prototype.getPoint = function (index) {
  var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;

  if (index < 0 || n <= index) {
    return null;
  }

  var point = new _geom_point_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride));
  return point;
};
/**
 * Return the points of this multipoint.
 * @return {Array.<ol.geom.Point>} Points.
 * @api
 */


_ol_geom_MultiPoint_.prototype.getPoints = function () {
  var flatCoordinates = this.flatCoordinates;
  var layout = this.layout;
  var stride = this.stride;
  /** @type {Array.<ol.geom.Point>} */

  var points = [];
  var i, ii;

  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var point = new _geom_point_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));
    points.push(point);
  }

  return points;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiPoint_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POINT;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiPoint_.prototype.intersectsExtent = function (extent) {
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, x, y;

  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    x = flatCoordinates[i];
    y = flatCoordinates[i + 1];

    if (_extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].containsXY(extent, x, y)) {
      return true;
    }
  }

  return false;
};
/**
 * Set the coordinates of the multipoint.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_MultiPoint_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["default"].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_MultiPoint_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_MultiPoint_);

/***/ }),

/***/ "./node_modules/ol/geom/multipolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/multipolygon.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/multipoint.js */ "./node_modules/ol/geom/multipoint.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");


















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_MultiPolygon_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this);
  /**
   * @type {Array.<Array.<number>>}
   * @private
   */


  this.endss_ = [];
  /**
   * @private
   * @type {number}
   */

  this.flatInteriorPointsRevision_ = -1;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.flatInteriorPoints_ = null;
  /**
   * @private
   * @type {number}
   */

  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.orientedRevision_ = -1;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.orientedFlatCoordinates_ = null;
  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_MultiPolygon_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Append the passed polygon to this multipolygon.
 * @param {ol.geom.Polygon} polygon Polygon.
 * @api
 */


_ol_geom_MultiPolygon_.prototype.appendPolygon = function (polygon) {
  /** @type {Array.<number>} */
  var ends;

  if (!this.flatCoordinates) {
    this.flatCoordinates = polygon.getFlatCoordinates().slice();
    ends = polygon.getEnds().slice();
    this.endss_.push();
  } else {
    var offset = this.flatCoordinates.length;

    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.flatCoordinates, polygon.getFlatCoordinates());

    ends = polygon.getEnds().slice();
    var i, ii;

    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] += offset;
    }
  }

  this.endss_.push(ends);
  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPolygon} Clone.
 * @override
 * @api
 */


_ol_geom_MultiPolygon_.prototype.clone = function () {
  var multiPolygon = new _ol_geom_MultiPolygon_(null);
  var len = this.endss_.length;
  var newEndss = new Array(len);

  for (var i = 0; i < len; ++i) {
    newEndss[i] = this.endss_[i].slice();
  }

  multiPolygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), newEndss);
  return multiPolygon;
};
/**
 * @inheritDoc
 */


_ol_geom_MultiPolygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_10__["default"].getssMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_10__["default"].getssClosestPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
/**
 * @inheritDoc
 */


_ol_geom_MultiPolygon_.prototype.containsXY = function (x, y) {
  return _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"].linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
};
/**
 * Return the area of the multipolygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getArea = function () {
  return _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__["default"].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
};
/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for multi-polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.
 * @override
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;

  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();

    _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_16__["default"].orientLinearRingss(flatCoordinates, 0, this.endss_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_13__["default"].coordinatesss(flatCoordinates, 0, this.endss_, this.stride);
};
/**
 * @return {Array.<Array.<number>>} Endss.
 */


_ol_geom_MultiPolygon_.prototype.getEndss = function () {
  return this.endss_;
};
/**
 * @return {Array.<number>} Flat interior points.
 */


_ol_geom_MultiPolygon_.prototype.getFlatInteriorPoints = function () {
  if (this.flatInteriorPointsRevision_ != this.getRevision()) {
    var flatCenters = _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_9__["default"].linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);

    this.flatInteriorPoints_ = _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_14__["default"].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
    this.flatInteriorPointsRevision_ = this.getRevision();
  }

  return this.flatInteriorPoints_;
};
/**
 * Return the interior points as {@link ol.geom.MultiPoint multipoint}.
 * @return {ol.geom.MultiPoint} Interior points as XYM coordinates, where M is
 * the length of the horizontal intersection that the point belongs to.
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getInteriorPoints = function () {
  var interiorPoints = new _geom_multipoint_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
  interiorPoints.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM, this.getFlatInteriorPoints().slice());
  return interiorPoints;
};
/**
 * @return {Array.<number>} Oriented flat coordinates.
 */


_ol_geom_MultiPolygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;

    if (_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_16__["default"].linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_16__["default"].orientLinearRingss(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
    }

    this.orientedRevision_ = this.getRevision();
  }

  return this.orientedFlatCoordinates_;
};
/**
 * @inheritDoc
 */


_ol_geom_MultiPolygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEndss = [];
  simplifiedFlatCoordinates.length = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_17__["default"].quantizess(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
  var simplifiedMultiPolygon = new _ol_geom_MultiPolygon_(null);
  simplifiedMultiPolygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, simplifiedFlatCoordinates, simplifiedEndss);
  return simplifiedMultiPolygon;
};
/**
 * Return the polygon at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Polygon} Polygon.
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getPolygon = function (index) {
  if (index < 0 || this.endss_.length <= index) {
    return null;
  }

  var offset;

  if (index === 0) {
    offset = 0;
  } else {
    var prevEnds = this.endss_[index - 1];
    offset = prevEnds[prevEnds.length - 1];
  }

  var ends = this.endss_[index].slice();
  var end = ends[ends.length - 1];

  if (offset !== 0) {
    var i, ii;

    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] -= offset;
    }
  }

  var polygon = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(offset, end), ends);
  return polygon;
};
/**
 * Return the polygons of this multipolygon.
 * @return {Array.<ol.geom.Polygon>} Polygons.
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getPolygons = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var endss = this.endss_;
  var polygons = [];
  var offset = 0;
  var i, ii, j, jj;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i].slice();
    var end = ends[ends.length - 1];

    if (offset !== 0) {
      for (j = 0, jj = ends.length; j < jj; ++j) {
        ends[j] -= offset;
      }
    }

    var polygon = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](null);
    polygon.setFlatCoordinates(layout, flatCoordinates.slice(offset, end), ends);
    polygons.push(polygon);
    offset = end;
  }

  return polygons;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiPolygon_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POLYGON;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_MultiPolygon_.prototype.intersectsExtent = function (extent) {
  return _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_15__["default"].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
};
/**
 * Set the coordinates of the multipolygon.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_MultiPolygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, null, this.endss_);
  } else {
    this.setLayout(opt_layout, coordinates, 3);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var endss = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_12__["default"].coordinatesss(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);

    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }

    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} endss Endss.
 */


_ol_geom_MultiPolygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, endss) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.endss_ = endss;
  this.changed();
};
/**
 * @param {Array.<ol.geom.Polygon>} polygons Polygons.
 */


_ol_geom_MultiPolygon_.prototype.setPolygons = function (polygons) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var endss = [];
  var i, ii, ends;

  for (i = 0, ii = polygons.length; i < ii; ++i) {
    var polygon = polygons[i];

    if (i === 0) {
      layout = polygon.getLayout();
    }

    var offset = flatCoordinates.length;
    ends = polygon.getEnds();
    var j, jj;

    for (j = 0, jj = ends.length; j < jj; ++j) {
      ends[j] += offset;
    }

    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(flatCoordinates, polygon.getFlatCoordinates());

    endss.push(ends);
  }

  this.setFlatCoordinates(layout, flatCoordinates, endss);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_MultiPolygon_);

/***/ }),

/***/ "./node_modules/ol/geom/point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/point.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");







/**
 * @classdesc
 * Point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_Point_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);

  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_Point_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Point} Clone.
 * @override
 * @api
 */


_ol_geom_Point_.prototype.clone = function () {
  var point = new _ol_geom_Point_(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return point;
};
/**
 * @inheritDoc
 */


_ol_geom_Point_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;

  var squaredDistance = _math_js__WEBPACK_IMPORTED_MODULE_6__["default"].squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);

  if (squaredDistance < minSquaredDistance) {
    var stride = this.stride;
    var i;

    for (i = 0; i < stride; ++i) {
      closestPoint[i] = flatCoordinates[i];
    }

    closestPoint.length = stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};
/**
 * Return the coordinate of the point.
 * @return {ol.Coordinate} Coordinates.
 * @override
 * @api
 */


_ol_geom_Point_.prototype.getCoordinates = function () {
  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
};
/**
 * @inheritDoc
 */


_ol_geom_Point_.prototype.computeExtent = function (extent) {
  return _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].createOrUpdateFromCoordinate(this.flatCoordinates, extent);
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.intersectsExtent = function (extent) {
  return _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__["default"].coordinate(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_Point_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_Point_);

/***/ }),

/***/ "./node_modules/ol/geom/polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/polygon.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_linearring_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/linearring.js */ "./node_modules/ol/geom/linearring.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");


















/**
 * @classdesc
 * Polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear
 *     rings that define the polygon. The first linear ring of the array
 *     defines the outer-boundary or surface of the polygon. Each subsequent
 *     linear ring defines a hole in the surface of the polygon. A linear ring
 *     is an array of vertices' coordinates where the first coordinate and the
 *     last are equivalent.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */

var _ol_geom_Polygon_ = function (coordinates, opt_layout) {
  _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this);
  /**
   * @type {Array.<number>}
   * @private
   */


  this.ends_ = [];
  /**
   * @private
   * @type {number}
   */

  this.flatInteriorPointRevision_ = -1;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.flatInteriorPoint_ = null;
  /**
   * @private
   * @type {number}
   */

  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.orientedRevision_ = -1;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.orientedFlatCoordinates_ = null;
  this.setCoordinates(coordinates, opt_layout);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_Polygon_, _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Append the passed linear ring to this polygon.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @api
 */


_ol_geom_Polygon_.prototype.appendLinearRing = function (linearRing) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = linearRing.getFlatCoordinates().slice();
  } else {
    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(this.flatCoordinates, linearRing.getFlatCoordinates());
  }

  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Polygon} Clone.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.clone = function () {
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return polygon;
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["default"].getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["default"].getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.containsXY = function (x, y) {
  return _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"].linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
};
/**
 * Return the area of the polygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */


_ol_geom_Polygon_.prototype.getArea = function () {
  return _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__["default"].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
};
/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;

  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();

    _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["default"].orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["default"].coordinatess(flatCoordinates, 0, this.ends_, this.stride);
};
/**
 * @return {Array.<number>} Ends.
 */


_ol_geom_Polygon_.prototype.getEnds = function () {
  return this.ends_;
};
/**
 * @return {Array.<number>} Interior point.
 */


_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function () {
  if (this.flatInteriorPointRevision_ != this.getRevision()) {
    var flatCenter = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenter(this.getExtent());

    this.flatInteriorPoint_ = _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["default"].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
    this.flatInteriorPointRevision_ = this.getRevision();
  }

  return this.flatInteriorPoint_;
};
/**
 * Return an interior point of the polygon.
 * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 * @api
 */


_ol_geom_Polygon_.prototype.getInteriorPoint = function () {
  return new _geom_point_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.getFlatInteriorPoint(), _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM);
};
/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 *
 * @return {number} Number of rings.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRingCount = function () {
  return this.ends_.length;
};
/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 *
 * @param {number} index Index.
 * @return {ol.geom.LinearRing} Linear ring.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRing = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }

  var linearRing = new _geom_linearring_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return linearRing;
};
/**
 * Return the linear rings of the polygon.
 * @return {Array.<ol.geom.LinearRing>} Linear rings.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRings = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var linearRings = [];
  var offset = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var linearRing = new _geom_linearring_js__WEBPACK_IMPORTED_MODULE_5__["default"](null);
    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    linearRings.push(linearRing);
    offset = end;
  }

  return linearRings;
};
/**
 * @return {Array.<number>} Oriented flat coordinates.
 */


_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;

    if (_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["default"].linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["default"].orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
    }

    this.orientedRevision_ = this.getRevision();
  }

  return this.orientedFlatCoordinates_;
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["default"].quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedPolygon = new _ol_geom_Polygon_(null);
  simplifiedPolygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedPolygon;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Polygon_.prototype.getType = function () {
  return _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Polygon_.prototype.intersectsExtent = function (extent) {
  return _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["default"].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
};
/**
 * Set the coordinates of the polygon.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["default"].coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);

    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */


_ol_geom_Polygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {ol.Sphere} sphere The sphere.
 * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @return {ol.geom.Polygon} The "circular" polygon.
 * @api
 */


_ol_geom_Polygon_.circular = function (sphere, center, radius, opt_n) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array.<number>} */

  var flatCoordinates = [];
  var i;

  for (i = 0; i < n; ++i) {
    _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {ol.Extent} extent The extent.
 * @return {ol.geom.Polygon} The polygon.
 * @api
 */


_ol_geom_Polygon_.fromExtent = function (extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
/**
 * Create a regular polygon from a circle.
 * @param {ol.geom.Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {ol.geom.Polygon} Polygon geometry.
 * @api
 */


_ol_geom_Polygon_.fromCircle = function (circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var polygon = new _ol_geom_Polygon_(null, layout);
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i++) {
    flatCoordinates[i] = 0;
  }

  var ends = [flatCoordinates.length];
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);

  _ol_geom_Polygon_.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);

  return polygon;
};
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {ol.Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */


_ol_geom_Polygon_.makeRegular = function (polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var layout = polygon.getLayout();
  var stride = polygon.getStride();
  var ends = polygon.getEnds();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  var angle, offset;

  for (var i = 0; i <= sides; ++i) {
    offset = i * stride;
    angle = startAngle + _math_js__WEBPACK_IMPORTED_MODULE_17__["default"].modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }

  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_Polygon_);

/***/ }),

/***/ "./node_modules/ol/geom/simplegeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/simplegeometry.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/geometry.js */ "./node_modules/ol/geom/geometry.js");
/* harmony import */ var _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/geometrylayout.js */ "./node_modules/ol/geom/geometrylayout.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @constructor
 * @abstract
 * @extends {ol.geom.Geometry}
 * @api
 */

var _ol_geom_SimpleGeometry_ = function () {
  _geom_geometry_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this);
  /**
   * @protected
   * @type {ol.geom.GeometryLayout}
   */


  this.layout = _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY;
  /**
   * @protected
   * @type {number}
   */

  this.stride = 2;
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.flatCoordinates = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_geom_SimpleGeometry_, _geom_geometry_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {number} stride Stride.
 * @private
 * @return {ol.geom.GeometryLayout} layout Layout.
 */


_ol_geom_SimpleGeometry_.getLayoutForStride_ = function (stride) {
  var layout;

  if (stride == 2) {
    layout = _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY;
  } else if (stride == 3) {
    layout = _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYZ;
  } else if (stride == 4) {
    layout = _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYZM;
  }

  return (
    /** @type {ol.geom.GeometryLayout} */
    layout
  );
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @return {number} Stride.
 */


_ol_geom_SimpleGeometry_.getStrideForLayout = function (layout) {
  var stride;

  if (layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY) {
    stride = 2;
  } else if (layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYZ || layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYM) {
    stride = 3;
  } else if (layout == _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYZM) {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
};
/**
 * @inheritDoc
 */


_ol_geom_SimpleGeometry_.prototype.containsXY = _functions_js__WEBPACK_IMPORTED_MODULE_1__["default"].FALSE;
/**
 * @inheritDoc
 */

_ol_geom_SimpleGeometry_.prototype.computeExtent = function (extent) {
  return _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};
/**
 * @abstract
 * @return {Array} Coordinates.
 */


_ol_geom_SimpleGeometry_.prototype.getCoordinates = function () {};
/**
 * Return the first coordinate of the geometry.
 * @return {ol.Coordinate} First coordinate.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate = function () {
  return this.flatCoordinates.slice(0, this.stride);
};
/**
 * @return {Array.<number>} Flat coordinates.
 */


_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates = function () {
  return this.flatCoordinates;
};
/**
 * Return the last coordinate of the geometry.
 * @return {ol.Coordinate} Last point.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getLastCoordinate = function () {
  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
};
/**
 * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
 * @return {ol.geom.GeometryLayout} Layout.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getLayout = function () {
  return this.layout;
};
/**
 * @inheritDoc
 */


_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].clear(this.simplifiedGeometryCache);

    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  } // If squaredTolerance is negative or if we know that simplification will not
  // have any effect then just return this.


  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }

  var key = squaredTolerance.toString();

  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      this.simplifiedGeometryCache[key] = simplifiedGeometry;
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};
/**
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.SimpleGeometry} Simplified geometry.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  return this;
};
/**
 * @return {number} Stride.
 */


_ol_geom_SimpleGeometry_.prototype.getStride = function () {
  return this.stride;
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal = function (layout, flatCoordinates) {
  this.stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  this.layout = layout;
  this.flatCoordinates = flatCoordinates;
};
/**
 * @abstract
 * @param {Array} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 */


_ol_geom_SimpleGeometry_.prototype.setCoordinates = function (coordinates, opt_layout) {};
/**
 * @param {ol.geom.GeometryLayout|undefined} layout Layout.
 * @param {Array} coordinates Coordinates.
 * @param {number} nesting Nesting.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.setLayout = function (layout, coordinates, nesting) {
  /** @type {number} */
  var stride;

  if (layout) {
    stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  } else {
    var i;

    for (i = 0; i < nesting; ++i) {
      if (coordinates.length === 0) {
        this.layout = _geom_geometrylayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY;
        this.stride = 2;
        return;
      } else {
        coordinates =
        /** @type {Array} */
        coordinates[0];
      }
    }

    stride = coordinates.length;
    layout = _ol_geom_SimpleGeometry_.getLayoutForStride_(stride);
  }

  this.layout = layout;
  this.stride = stride;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.applyTransform = function (transformFn) {
  if (this.flatCoordinates) {
    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.rotate = function (angle, anchor) {
  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);

    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var sy = opt_sy;

  if (sy === undefined) {
    sy = sx;
  }

  var anchor = opt_anchor;

  if (!anchor) {
    anchor = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenter(this.getExtent());
  }

  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);

    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.translate = function (deltaX, deltaY) {
  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);

    this.changed();
  }
};
/**
 * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */


_ol_geom_SimpleGeometry_.transform2D = function (simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_geom_SimpleGeometry_);

/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");


var _ol_has_ = {};
var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

_ol_has_.MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

_ol_has_.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;
/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */

_ol_has_.CANVAS_LINE_DASH = false;
/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.CANVAS = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_CANVAS &&
/**
 * @return {boolean} Canvas supported.
 */
function () {
  if (!('HTMLCanvasElement' in window)) {
    return false;
  }

  try {
    var context = document.createElement('CANVAS').getContext('2d');

    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        _ol_has_.CANVAS_LINE_DASH = true;
      }

      return true;
    }
  } catch (e) {
    return false;
  }
}();
/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */


_ol_has_.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;
/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.GEOLOCATION = 'geolocation' in navigator;
/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.TOUCH = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ASSUME_TOUCH || 'ontouchstart' in window;
/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */

_ol_has_.POINTER = 'PointerEvent' in window;
/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */

_ol_has_.MSPOINTER = !!navigator.msPointerEnabled;
/**
 * True if both OpenLayers and browser support WebGL.  Always `false`
 * if `ol.ENABLE_WEBGL` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.WEBGL;

(function () {
  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_WEBGL) {
    var hasWebGL = false;
    var textureSize;
    var
    /** @type {Array.<string>} */
    extensions = [];

    if ('WebGLRenderingContext' in window) {
      try {
        var canvas =
        /** @type {HTMLCanvasElement} */
        document.createElement('CANVAS');

        var gl = _webgl_js__WEBPACK_IMPORTED_MODULE_1__["default"].getContext(canvas, {
          failIfMajorPerformanceCaveat: true
        });

        if (gl) {
          hasWebGL = true;
          textureSize =
          /** @type {number} */
          gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {// pass
      }
    }

    _ol_has_.WEBGL = hasWebGL;
    _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_EXTENSIONS = extensions;
    _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();

/* harmony default export */ __webpack_exports__["default"] = (_ol_has_);

/***/ }),

/***/ "./node_modules/ol/image.js":
/*!**********************************!*\
  !*** ./node_modules/ol/image.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagebase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagebase.js */ "./node_modules/ol/imagebase.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");






/**
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.Extent} extent Extent.
 * @param {number|undefined} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.
 */

var _ol_Image_ = function (extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
  _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, extent, resolution, pixelRatio, _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);
  /**
   * @private
   * @type {string}
   */


  this.src_ = src;
  /**
   * @private
   * @type {HTMLCanvasElement|Image|HTMLVideoElement}
   */

  this.image_ = new Image();

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */


  this.imageListenerKeys_ = null;
  /**
   * @protected
   * @type {ol.ImageState}
   */

  this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;
  /**
   * @private
   * @type {ol.ImageLoadFunctionType}
   */

  this.imageLoadFunction_ = imageLoadFunction;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Image_, _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 * @api
 */


_ol_Image_.prototype.getImage = function () {
  return this.image_;
};
/**
 * Tracks loading or read errors.
 *
 * @private
 */


_ol_Image_.prototype.handleImageError_ = function () {
  this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
  this.unlistenImage_();
  this.changed();
};
/**
 * Tracks successful image load.
 *
 * @private
 */


_ol_Image_.prototype.handleImageLoad_ = function () {
  if (this.resolution === undefined) {
    this.resolution = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(this.extent) / this.image_.height;
  }

  this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  this.unlistenImage_();
  this.changed();
};
/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @override
 * @api
 */


_ol_Image_.prototype.load = function () {
  if (this.state == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || this.state == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
    this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();
    this.imageListenerKeys_ = [_events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR, this.handleImageError_, this), _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD, this.handleImageLoad_, this)];
    this.imageLoadFunction_(this, this.src_);
  }
};
/**
 * @param {HTMLCanvasElement|Image|HTMLVideoElement} image Image.
 */


_ol_Image_.prototype.setImage = function (image) {
  this.image_ = image;
};
/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */


_ol_Image_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["default"].unlistenByKey);
  this.imageListenerKeys_ = null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Image_);

/***/ }),

/***/ "./node_modules/ol/imagebase.js":
/*!**************************************!*\
  !*** ./node_modules/ol/imagebase.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");



/**
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.Extent} extent Extent.
 * @param {number|undefined} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.ImageState} state State.
 */

var _ol_ImageBase_ = function (extent, resolution, pixelRatio, state) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @protected
   * @type {ol.Extent}
   */


  this.extent = extent;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.resolution = resolution;
  /**
   * @protected
   * @type {ol.ImageState}
   */

  this.state = state;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_ImageBase_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @protected
 */


_ol_ImageBase_.prototype.changed = function () {
  this.dispatchEvent(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
};
/**
 * @return {ol.Extent} Extent.
 */


_ol_ImageBase_.prototype.getExtent = function () {
  return this.extent;
};
/**
 * @abstract
 * @return {HTMLCanvasElement|Image|HTMLVideoElement} Image.
 */


_ol_ImageBase_.prototype.getImage = function () {};
/**
 * @return {number} PixelRatio.
 */


_ol_ImageBase_.prototype.getPixelRatio = function () {
  return this.pixelRatio_;
};
/**
 * @return {number} Resolution.
 */


_ol_ImageBase_.prototype.getResolution = function () {
  return (
    /** @type {number} */
    this.resolution
  );
};
/**
 * @return {ol.ImageState} State.
 */


_ol_ImageBase_.prototype.getState = function () {
  return this.state;
};
/**
 * Load not yet loaded URI.
 * @abstract
 */


_ol_ImageBase_.prototype.load = function () {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_ImageBase_);

/***/ }),

/***/ "./node_modules/ol/imagecanvas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/imagecanvas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagebase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagebase.js */ "./node_modules/ol/imagebase.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imagestate.js */ "./node_modules/ol/imagestate.js");



/**
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {ol.ImageCanvasLoader=} opt_loader Optional loader function to
 *     support asynchronous canvas drawing.
 */

var _ol_ImageCanvas_ = function (extent, resolution, pixelRatio, canvas, opt_loader) {
  /**
   * Optional canvas loader function.
   * @type {?ol.ImageCanvasLoader}
   * @private
   */
  this.loader_ = opt_loader !== undefined ? opt_loader : null;
  var state = opt_loader !== undefined ? _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE : _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;

  _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, extent, resolution, pixelRatio, state);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ = canvas;
  /**
   * @private
   * @type {Error}
   */

  this.error_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_ImageCanvas_, _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Get any error associated with asynchronous rendering.
 * @return {Error} Any error that occurred during rendering.
 */


_ol_ImageCanvas_.prototype.getError = function () {
  return this.error_;
};
/**
 * Handle async drawing complete.
 * @param {Error} err Any error during drawing.
 * @private
 */


_ol_ImageCanvas_.prototype.handleLoad_ = function (err) {
  if (err) {
    this.error_ = err;
    this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
  } else {
    this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  this.changed();
};
/**
 * @inheritDoc
 */


_ol_ImageCanvas_.prototype.load = function () {
  if (this.state == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();
    this.loader_(this.handleLoad_.bind(this));
  }
};
/**
 * @inheritDoc
 */


_ol_ImageCanvas_.prototype.getImage = function () {
  return this.canvas_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_ImageCanvas_);

/***/ }),

/***/ "./node_modules/ol/imagestate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/imagestate.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {number}
 */
var _ol_ImageState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_ImageState_);

/***/ }),

/***/ "./node_modules/ol/imagetile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/imagetile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");






/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @param {olx.TileOptions=} opt_options Tile options.
 */

var _ol_ImageTile_ = function (tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, state, opt_options);
  /**
   * @private
   * @type {?string}
   */


  this.crossOrigin_ = crossOrigin;
  /**
   * Image URI
   *
   * @private
   * @type {string}
   */

  this.src_ = src;
  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */

  this.image_ = new Image();

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */


  this.imageListenerKeys_ = null;
  /**
   * @private
   * @type {ol.TileLoadFunctionType}
   */

  this.tileLoadFunction_ = tileLoadFunction;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_ImageTile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_ImageTile_.prototype.disposeInternal = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
    this.unlistenImage_();
    this.image_ = _ol_ImageTile_.getBlankImage();
  }

  if (this.interimTile) {
    this.interimTile.dispose();
  }

  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT;
  this.changed();

  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.disposeInternal.call(this);
};
/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 * @api
 */


_ol_ImageTile_.prototype.getImage = function () {
  return this.image_;
};
/**
 * @inheritDoc
 */


_ol_ImageTile_.prototype.getKey = function () {
  return this.src_;
};
/**
 * Tracks loading or read errors.
 *
 * @private
 */


_ol_ImageTile_.prototype.handleImageError_ = function () {
  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
  this.unlistenImage_();
  this.image_ = _ol_ImageTile_.getBlankImage();
  this.changed();
};
/**
 * Tracks successful image load.
 *
 * @private
 */


_ol_ImageTile_.prototype.handleImageLoad_ = function () {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  } else {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
  }

  this.unlistenImage_();
  this.changed();
};
/**
 * @inheritDoc
 * @api
 */


_ol_ImageTile_.prototype.load = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;
    this.image_ = new Image();

    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }

  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();
    this.imageListenerKeys_ = [_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERROR, this.handleImageError_, this), _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};
/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */


_ol_ImageTile_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
  this.imageListenerKeys_ = null;
};
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */


_ol_ImageTile_.getBlankImage = function () {
  var ctx = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(1, 1);

  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_ImageTile_);

/***/ }),

/***/ "./node_modules/ol/index.js":
/*!**********************************!*\
  !*** ./node_modules/ol/index.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_ = {};
/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 */

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */

_ol_.ASSUME_TOUCH = false;
/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */

_ol_.DEFAULT_MAX_ZOOM = 42;
/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */

_ol_.DEFAULT_MIN_ZOOM = 0;
/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */

_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;
/**
 * @define {number} Default tile size.
 */

_ol_.DEFAULT_TILE_SIZE = 256;
/**
 * @define {string} Default WMS version.
 */

_ol_.DEFAULT_WMS_VERSION = '1.3.0';
/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */

_ol_.ENABLE_CANVAS = true;
/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */

_ol_.ENABLE_PROJ4JS = true;
/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */

_ol_.ENABLE_RASTER_REPROJECTION = true;
/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */

_ol_.ENABLE_WEBGL = true;
/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */

_ol_.DEBUG_WEBGL = true;
/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */

_ol_.INITIAL_ATLAS_SIZE = 256;
/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */

_ol_.MAX_ATLAS_SIZE = -1;
/**
 * @define {number} Maximum mouse wheel delta.
 */

_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;
/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */

_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;
/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */

_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;
/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */

_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;
/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */

_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;
/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */

_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */

_ol_.SIMPLIFY_TOLERANCE = 0.5;
/**
 * @define {number} Texture cache high water mark.
 */

_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;
/**
 * @define {string} OpenLayers version.
 */

_ol_.VERSION = 'v4.6.5';
/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @const
 * @type {number|undefined}
 */

_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`

/**
 * List of supported WebGL extensions.
 * @const
 * @type {Array.<string>}
 */

_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */

_ol_.inherits = function (childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */


_ol_.nullFunction = function () {};
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */


_ol_.getUid = function (obj) {
  return obj.ol_uid || (obj.ol_uid = ++_ol_.uidCounter_);
};
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */


_ol_.uidCounter_ = 0;
/* harmony default export */ __webpack_exports__["default"] = (_ol_);

/***/ }),

/***/ "./node_modules/ol/interaction.js":
/*!****************************************!*\
  !*** ./node_modules/ol/interaction.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collection.js */ "./node_modules/ol/collection.js");
/* harmony import */ var _kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kinetic.js */ "./node_modules/ol/kinetic.js");
/* harmony import */ var _interaction_doubleclickzoom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/doubleclickzoom.js */ "./node_modules/ol/interaction/doubleclickzoom.js");
/* harmony import */ var _interaction_dragpan_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/dragpan.js */ "./node_modules/ol/interaction/dragpan.js");
/* harmony import */ var _interaction_dragrotate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/dragrotate.js */ "./node_modules/ol/interaction/dragrotate.js");
/* harmony import */ var _interaction_dragzoom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/dragzoom.js */ "./node_modules/ol/interaction/dragzoom.js");
/* harmony import */ var _interaction_keyboardpan_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/keyboardpan.js */ "./node_modules/ol/interaction/keyboardpan.js");
/* harmony import */ var _interaction_keyboardzoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/keyboardzoom.js */ "./node_modules/ol/interaction/keyboardzoom.js");
/* harmony import */ var _interaction_mousewheelzoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/mousewheelzoom.js */ "./node_modules/ol/interaction/mousewheelzoom.js");
/* harmony import */ var _interaction_pinchrotate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/pinchrotate.js */ "./node_modules/ol/interaction/pinchrotate.js");
/* harmony import */ var _interaction_pinchzoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/pinchzoom.js */ "./node_modules/ol/interaction/pinchzoom.js");











var _ol_interaction_ = {};
/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link ol.interaction.Interaction} instances and insert them into a
 * {@link ol.Collection} in the order you want before creating your
 * {@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {@link ol.interaction.DragRotate}
 * * {@link ol.interaction.DoubleClickZoom}
 * * {@link ol.interaction.DragPan}
 * * {@link ol.interaction.PinchRotate}
 * * {@link ol.interaction.PinchZoom}
 * * {@link ol.interaction.KeyboardPan}
 * * {@link ol.interaction.KeyboardZoom}
 * * {@link ol.interaction.MouseWheelZoom}
 * * {@link ol.interaction.DragZoom}
 *
 * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.interaction.Interaction>} A collection of
 * interactions to be used with the ol.Map constructor's interactions option.
 * @api
 */

_ol_interaction_.defaults = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new _collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var kinetic = new _kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new _interaction_dragrotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new _interaction_doubleclickzoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new _interaction_dragpan_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new _interaction_pinchrotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new _interaction_pinchzoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new _interaction_keyboardpan_js__WEBPACK_IMPORTED_MODULE_6__["default"]());
    interactions.push(new _interaction_keyboardzoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new _interaction_mousewheelzoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new _interaction_dragzoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      duration: options.zoomDuration
    }));
  }

  return interactions;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_);

/***/ }),

/***/ "./node_modules/ol/interaction/doubleclickzoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/doubleclickzoom.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mapbrowsereventtype.js */ "./node_modules/ol/mapbrowsereventtype.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");



/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DoubleClickZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {number}
   */

  this.delta_ = options.delta ? options.delta : 1;

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, {
    handleEvent: _ol_interaction_DoubleClickZoom_.handleEvent
  });
  /**
   * @private
   * @type {number}
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_DoubleClickZoom_, _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.DoubleClickZoom}
 * @api
 */


_ol_interaction_DoubleClickZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;

  if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();

    _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"].zoomByDelta(view, delta, anchor, this.duration_);

    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }

  return !stopEvent;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DoubleClickZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/dragbox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/dragbox.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");
/* harmony import */ var _render_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/box.js */ "./node_modules/ol/render/box.js");
// FIXME draw drag box





/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link ol.interaction.DragZoom} and
 * {@link ol.interaction.DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.DragBox.Event
 * @param {olx.interaction.DragBoxOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DragBox_ = function (opt_options) {
  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @type {ol.render.Box}
   * @private
   */

  this.box_ = new _render_box_js__WEBPACK_IMPORTED_MODULE_4__["default"](options.className || 'ol-dragbox');
  /**
   * @type {number}
   * @private
   */

  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
  /**
   * @type {ol.Pixel}
   * @private
   */

  this.startPixel_ = null;
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].always;
  /**
   * @private
   * @type {ol.DragBoxEndConditionType}
   */

  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;
};

_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(_ol_interaction_DragBox_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {ol.Pixel} startPixel The starting pixel of the box.
 * @param {ol.Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {ol.interaction.DragBox}
 */


_ol_interaction_DragBox_.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */


_ol_interaction_DragBox_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].mouseOnly(mapBrowserEvent)) {
    return;
  }

  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
  this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
};
/**
 * Returns geometry of last drawn box.
 * @return {ol.geom.Polygon} Geometry.
 * @api
 */


_ol_interaction_DragBox_.prototype.getGeometry = function () {
  return this.box_.getGeometry();
};
/**
 * To be overridden by child classes.
 * FIXME: use constructor option instead of relying on overriding.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @protected
 */


_ol_interaction_DragBox_.prototype.onBoxEnd = _index_js__WEBPACK_IMPORTED_MODULE_1__["default"].nullFunction;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */

_ol_interaction_DragBox_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].mouseOnly(mapBrowserEvent)) {
    return true;
  }

  this.box_.setMap(null);

  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd(mapBrowserEvent);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
  }

  return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */


_ol_interaction_DragBox_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_interaction_DragBox_.EventType_ = {
  /**
   * Triggered upon drag box start.
   * @event ol.interaction.DragBox.Event#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event ol.interaction.DragBox.Event#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event ol.interaction.DragBox.Event#boxend
   * @api
   */
  BOXEND: 'boxend'
};
/**
 * @classdesc
 * Events emitted by {@link ol.interaction.DragBox} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {ol.Coordinate} coordinate The event coordinate.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.
 * @extends {ol.events.Event}
 * @constructor
 * @implements {oli.DragBoxEvent}
 */

_ol_interaction_DragBox_.Event = function (type, coordinate, mapBrowserEvent) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, type);
  /**
   * The coordinate of the drag event.
   * @const
   * @type {ol.Coordinate}
   * @api
   */


  this.coordinate = coordinate;
  /**
   * @const
   * @type {ol.MapBrowserEvent}
   * @api
   */

  this.mapBrowserEvent = mapBrowserEvent;
};

_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(_ol_interaction_DragBox_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DragBox_);

/***/ }),

/***/ "./node_modules/ol/interaction/dragpan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/dragpan.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");







/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragPanOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DragPan_ = function (opt_options) {
  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    handleDownEvent: _ol_interaction_DragPan_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragPan_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragPan_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {ol.Kinetic|undefined}
   */

  this.kinetic_ = options.kinetic;
  /**
   * @type {ol.Pixel}
   */

  this.lastCentroid = null;
  /**
   * @type {number}
   */

  this.lastPointersCount_;
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_4__["default"].noModifierKeys;
  /**
   * @private
   * @type {boolean}
   */

  this.noKinetic_ = false;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_DragPan_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleDragEvent_ = function (mapBrowserEvent) {
  var targetPointers = this.targetPointers;

  var centroid = _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"].centroid(targetPointers);

  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }

    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var viewState = view.getState();
      var center = [deltaX, deltaY];

      _coordinate_js__WEBPACK_IMPORTED_MODULE_2__["default"].scale(center, viewState.resolution);

      _coordinate_js__WEBPACK_IMPORTED_MODULE_2__["default"].rotate(center, viewState.rotation);

      _coordinate_js__WEBPACK_IMPORTED_MODULE_2__["default"].add(center, viewState.center);

      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else if (this.kinetic_) {
    // reset so we don't overestimate the kinetic energy after
    // after one finger down, tiny drag, second finger down
    this.kinetic_.begin();
  }

  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleUpEvent_ = function (mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center =
      /** @type {!ol.Coordinate} */
      view.getCenter();
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
      view.animate({
        center: view.constrainCenter(dest),
        duration: 500,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__["default"].easeOut
      });
    }

    view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }

    this.lastCentroid = null;
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;

    if (!this.handlingDownUpSequence) {
      view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    } // stop any current animation


    if (view.getAnimating()) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }

    if (this.kinetic_) {
      this.kinetic_.begin();
    } // No kinetic as soon as more than one pointer on the screen is
    // detected. This is to prevent nasty pans after pinch.


    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_DragPan_.prototype.shouldStopEvent = _functions_js__WEBPACK_IMPORTED_MODULE_5__["default"].FALSE;
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DragPan_);

/***/ }),

/***/ "./node_modules/ol/interaction/dragrotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/dragrotate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");







/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DragRotate_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    handleDownEvent: _ol_interaction_DragRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragRotate_.handleUpEvent_
  });
  /**
   * @private
   * @type {ol.EventsConditionType}
   */


  this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].altShiftKeysOnly;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastAngle_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_DragRotate_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__["default"].disable) {
    return;
  }

  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var rotation = view.getRotation();

    _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotateWithoutConstraints(view, rotation - delta);
  }

  this.lastAngle_ = theta;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING, -1);
  var rotation = view.getRotation();

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotate(view, rotation, undefined, this.duration_);

  return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_DragRotate_.prototype.shouldStopEvent = _functions_js__WEBPACK_IMPORTED_MODULE_4__["default"].FALSE;
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DragRotate_);

/***/ }),

/***/ "./node_modules/ol/interaction/dragrotateandzoom.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/interaction/dragrotateandzoom.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");






/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateAndZoomOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DragRotateAndZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    handleDownEvent: _ol_interaction_DragRotateAndZoom_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragRotateAndZoom_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragRotateAndZoom_.handleUpEvent_
  });
  /**
   * @private
   * @type {ol.EventsConditionType}
   */


  this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].shiftKeyOnly;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastAngle_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastMagnitude_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.lastScaleDelta_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 400;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_DragRotateAndZoom_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotateAndZoom}
 * @private
 */


_ol_interaction_DragRotateAndZoom_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var deltaX = offset[0] - size[0] / 2;
  var deltaY = size[1] / 2 - offset[1];
  var theta = Math.atan2(deltaY, deltaX);
  var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  var view = map.getView();

  if (view.getConstraints().rotation !== _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__["default"].disable && this.lastAngle_ !== undefined) {
    var angleDelta = theta - this.lastAngle_;

    _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].rotateWithoutConstraints(view, view.getRotation() - angleDelta);
  }

  this.lastAngle_ = theta;

  if (this.lastMagnitude_ !== undefined) {
    var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);

    _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].zoomWithoutConstraints(view, resolution);
  }

  if (this.lastMagnitude_ !== undefined) {
    this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
  }

  this.lastMagnitude_ = magnitude;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotateAndZoom}
 * @private
 */


_ol_interaction_DragRotateAndZoom_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING, -1);
  var direction = this.lastScaleDelta_ - 1;

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].rotate(view, view.getRotation());

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].zoom(view, view.getResolution(), undefined, this.duration_, direction);

  this.lastScaleDelta_ = 0;
  return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotateAndZoom}
 * @private
 */


_ol_interaction_DragRotateAndZoom_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["default"].mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (this.condition_(mapBrowserEvent)) {
    mapBrowserEvent.map.getView().setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING, 1);
    this.lastAngle_ = undefined;
    this.lastMagnitude_ = undefined;
    return true;
  } else {
    return false;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DragRotateAndZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/dragzoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/dragzoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _interaction_dragbox_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/dragbox.js */ "./node_modules/ol/interaction/dragbox.js");





/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_DragZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].shiftKeyOnly;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 200;
  /**
   * @private
   * @type {boolean}
   */

  this.out_ = options.out !== undefined ? options.out : false;

  _interaction_dragbox_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, {
    condition: condition,
    className: options.className || 'ol-dragzoom'
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_DragZoom_, _interaction_dragbox_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @inheritDoc
 */


_ol_interaction_DragZoom_.prototype.onBoxEnd = function () {
  var map = this.getMap();
  var view =
  /** @type {!ol.View} */
  map.getView();
  var size =
  /** @type {!ol.Size} */
  map.getSize();
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);

    var boxPixelExtent = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createOrUpdateFromCoordinates([map.getPixelFromCoordinate(_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].getBottomLeft(extent)), map.getPixelFromCoordinate(_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTopRight(extent))]);

    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].scaleFromCenter(mapExtent, 1 / factor);

    extent = mapExtent;
  }

  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));

  var center = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].getCenter(extent);

  center = view.constrainCenter(center);
  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["default"].easeOut
  });
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_DragZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/interaction.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _interaction_property_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/property.js */ "./node_modules/ol/interaction/property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
// FIXME factor out key precondition (shift et. al)





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as
 * {@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 *
 * @constructor
 * @param {olx.interaction.InteractionOptions} options Options.
 * @extends {ol.Object}
 * @api
 */

var _ol_interaction_Interaction_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @private
   * @type {ol.PluggableMap}
   */


  this.map_ = null;
  this.setActive(true);
  /**
   * @type {function(ol.MapBrowserEvent):boolean}
   */

  this.handleEvent = options.handleEvent;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_Interaction_, _object_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Return whether the interaction is currently active.
 * @return {boolean} `true` if the interaction is active, `false` otherwise.
 * @observable
 * @api
 */


_ol_interaction_Interaction_.prototype.getActive = function () {
  return (
    /** @type {boolean} */
    this.get(_interaction_property_js__WEBPACK_IMPORTED_MODULE_3__["default"].ACTIVE)
  );
};
/**
 * Get the map associated with this interaction.
 * @return {ol.PluggableMap} Map.
 * @api
 */


_ol_interaction_Interaction_.prototype.getMap = function () {
  return this.map_;
};
/**
 * Activate or deactivate the interaction.
 * @param {boolean} active Active.
 * @observable
 * @api
 */


_ol_interaction_Interaction_.prototype.setActive = function (active) {
  this.set(_interaction_property_js__WEBPACK_IMPORTED_MODULE_3__["default"].ACTIVE, active);
};
/**
 * Remove the interaction from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 */


_ol_interaction_Interaction_.prototype.setMap = function (map) {
  this.map_ = map;
};
/**
 * @param {ol.View} view View.
 * @param {ol.Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.pan = function (view, delta, opt_duration) {
  var currentCenter = view.getCenter();

  if (currentCenter) {
    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);

    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].linear,
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.rotate = function (view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);

  _ol_interaction_Interaction_.rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.rotateWithoutConstraints = function (view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();

    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeOut
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */


_ol_interaction_Interaction_.zoom = function (view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);

  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.zoomByDelta = function (view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = _math_js__WEBPACK_IMPORTED_MODULE_4__["default"].clamp(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);
  } // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor


  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);
    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];
  }

  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.zoomWithoutConstraints = function (view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();

    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeOut
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }

      view.setResolution(resolution);
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_Interaction_);

/***/ }),

/***/ "./node_modules/ol/interaction/keyboardpan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/keyboardpan.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/keycode.js */ "./node_modules/ol/events/keycode.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");






/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardZoom}.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_KeyboardPan_ = function (opt_options) {
  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    handleEvent: _ol_interaction_KeyboardPan_.handleEvent
  });

  var options = opt_options || {};
  /**
   * @private
   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.
   * @return {boolean} Combined condition result.
   */

  this.defaultCondition_ = function (mapBrowserEvent) {
    return _events_condition_js__WEBPACK_IMPORTED_MODULE_4__["default"].noModifierKeys(mapBrowserEvent) && _events_condition_js__WEBPACK_IMPORTED_MODULE_4__["default"].targetNotEditable(mapBrowserEvent);
  };
  /**
   * @private
   * @type {ol.EventsConditionType}
   */


  this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 100;
  /**
   * @private
   * @type {number}
   */

  this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_KeyboardPan_, _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardPan}
 * @api
 */


_ol_interaction_KeyboardPan_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _events_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;

    if (this.condition_(mapBrowserEvent) && (keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN || keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT || keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT || keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0,
          deltaY = 0;

      if (keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _events_keycode_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }

      var delta = [deltaX, deltaY];

      _coordinate_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotate(delta, view.getRotation());

      _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].pan(view, delta, this.duration_);

      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_KeyboardPan_);

/***/ }),

/***/ "./node_modules/ol/interaction/keyboardzoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/keyboardzoom.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");




/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardPan}.
 *
 * @constructor
 * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */

var _ol_interaction_KeyboardZoom_ = function (opt_options) {
  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    handleEvent: _ol_interaction_KeyboardZoom_.handleEvent
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["default"].targetNotEditable;
  /**
   * @private
   * @type {number}
   */

  this.delta_ = options.delta ? options.delta : 1;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 100;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_KeyboardZoom_, _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardZoom}
 * @api
 */


_ol_interaction_KeyboardZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN || mapBrowserEvent.type == _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;

    if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();

      _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].zoomByDelta(view, delta, undefined, this.duration_);

      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_KeyboardZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/mousewheelzoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/mousewheelzoom.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");







/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_MouseWheelZoom_ = function (opt_options) {
  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    handleEvent: _ol_interaction_MouseWheelZoom_.handleEvent
  });

  var options = opt_options || {};
  /**
   * @private
   * @type {number}
   */

  this.delta_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
  /**
   * @private
   * @type {number}
   */

  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
  /**
   * @private
   * @type {boolean}
   */

  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
  /**
   * @private
   * @type {boolean}
   */

  this.constrainResolution_ = options.constrainResolution || false;
  /**
   * @private
   * @type {?ol.Coordinate}
   */

  this.lastAnchor_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.startTime_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.timeoutId_ = undefined;
  /**
   * @private
   * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}
   */

  this.mode_ = undefined;
  /**
   * Trackpad events separated by this delay will be considered separate
   * interactions.
   * @type {number}
   */

  this.trackpadEventGap_ = 400;
  /**
   * @type {number|undefined}
   */

  this.trackpadTimeoutId_ = undefined;
  /**
   * The number of delta values per zoom level
   * @private
   * @type {number}
   */

  this.trackpadDeltaPerZoom_ = 300;
  /**
   * The zoom factor by which scroll zooming is allowed to exceed the limits.
   * @private
   * @type {number}
   */

  this.trackpadZoomBuffer_ = 1.5;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_MouseWheelZoom_, _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {ol.interaction.MouseWheelZoom}
 * @api
 */


_ol_interaction_MouseWheelZoom_.handleEvent = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;

  if (type !== _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL && type !== _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
    return true;
  }

  mapBrowserEvent.preventDefault();
  var map = mapBrowserEvent.map;
  var wheelEvent =
  /** @type {WheelEvent} */
  mapBrowserEvent.originalEvent;

  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  } // Delta normalisation inspired by
  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


  var delta;

  if (mapBrowserEvent.type == _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL) {
    delta = wheelEvent.deltaY;

    if (_has_js__WEBPACK_IMPORTED_MODULE_4__["default"].FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= _has_js__WEBPACK_IMPORTED_MODULE_4__["default"].DEVICE_PIXEL_RATIO;
    }

    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else if (mapBrowserEvent.type == _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
    delta = -wheelEvent.wheelDeltaY;

    if (_has_js__WEBPACK_IMPORTED_MODULE_4__["default"].SAFARI) {
      delta /= 3;
    }
  }

  if (delta === 0) {
    return false;
  }

  var now = Date.now();

  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }

  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ? _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD : _ol_interaction_MouseWheelZoom_.Mode_.WHEEL;
  }

  if (this.mode_ === _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD) {
    var view = map.getView();

    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    }

    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;

    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else if (resolution > maxResolution) {
      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
      rebound = -1;
    }

    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }

    view.setResolution(resolution);

    if (rebound === 0 && this.constrainResolution_) {
      view.animate({
        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeOut,
        anchor: this.lastAnchor_,
        duration: this.duration_
      });
    }

    if (rebound > 0) {
      view.animate({
        resolution: minResolution,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    } else if (rebound < 0) {
      view.animate({
        resolution: maxResolution,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    }

    this.startTime_ = now;
    return false;
  }

  this.delta_ += delta;
  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
  return false;
};
/**
 * @private
 */


_ol_interaction_MouseWheelZoom_.prototype.decrementInteractingHint_ = function () {
  this.trackpadTimeoutId_ = undefined;
  var view = this.getMap().getView();
  view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
};
/**
 * @private
 * @param {ol.PluggableMap} map Map.
 */


_ol_interaction_MouseWheelZoom_.prototype.handleWheelZoom_ = function (map) {
  var view = map.getView();

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  var maxDelta = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSEWHEELZOOM_MAXDELTA;

  var delta = _math_js__WEBPACK_IMPORTED_MODULE_6__["default"].clamp(this.delta_, -maxDelta, maxDelta);

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"].zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);

  this.mode_ = undefined;
  this.delta_ = 0;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
};
/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * @param {boolean} useAnchor true to zoom to the mouse's location, false
 * to zoom to the center of the map
 * @api
 */


_ol_interaction_MouseWheelZoom_.prototype.setMouseAnchor = function (useAnchor) {
  this.useAnchor_ = useAnchor;

  if (!useAnchor) {
    this.lastAnchor_ = null;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_interaction_MouseWheelZoom_.Mode_ = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_MouseWheelZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/pinchrotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/pinchrotate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");






/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchRotateOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_PinchRotate_ = function (opt_options) {
  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, {
    handleDownEvent: _ol_interaction_PinchRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchRotate_.handleUpEvent_
  });

  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastAngle_ = undefined;
  /**
   * @private
   * @type {boolean}
   */

  this.rotating_ = false;
  /**
   * @private
   * @type {number}
   */

  this.rotationDelta_ = 0.0;
  /**
   * @private
   * @type {number}
   */

  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_PinchRotate_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  var rotationDelta = 0.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1]; // angle between touches

  var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;

    if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }

    rotationDelta = delta;
  }

  this.lastAngle_ = angle;
  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_5__["default"].disable) {
    return;
  } // rotate anchor point.
  // FIXME: should be the intersection point between the lines:
  //     touch0,touch1 and previousTouch0,previousTouch1


  var viewportPosition = map.getViewport().getBoundingClientRect();

  var centroid = _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"].centroid(this.targetPointers);

  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid); // rotate

  if (this.rotating_) {
    var rotation = view.getRotation();
    map.render();

    _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);

    if (this.rotating_) {
      var rotation = view.getRotation();

      _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotate(view, rotation, this.anchor_, this.duration_);
    }

    return false;
  } else {
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;

    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    }

    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_PinchRotate_.prototype.shouldStopEvent = _functions_js__WEBPACK_IMPORTED_MODULE_2__["default"].FALSE;
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_PinchRotate_);

/***/ }),

/***/ "./node_modules/ol/interaction/pinchzoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/pinchzoom.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/pointer.js */ "./node_modules/ol/interaction/pointer.js");





/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchZoomOptions=} opt_options Options.
 * @api
 */

var _ol_interaction_PinchZoom_ = function (opt_options) {
  _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, {
    handleDownEvent: _ol_interaction_PinchZoom_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchZoom_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchZoom_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {boolean}
   */

  this.constrainResolution_ = options.constrainResolution || false;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 400;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastDistance_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.lastScaleDelta_ = 1;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_PinchZoom_, _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleDragEvent_ = function (mapBrowserEvent) {
  var scaleDelta = 1.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY; // distance between touches

  var distance = Math.sqrt(dx * dx + dy * dy);

  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }

  this.lastDistance_ = distance;
  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;

  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else if (newResolution < minResolution) {
    scaleDelta = minResolution / resolution;
    newResolution = minResolution;
  }

  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  } // scale anchor point.


  var viewportPosition = map.getViewport().getBoundingClientRect();

  var centroid = _interaction_pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"].centroid(this.targetPointers);

  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid); // scale, bypass the resolution constraint

  map.render();

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].zoomWithoutConstraints(view, newResolution, this.anchor_);
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    var resolution = view.getResolution();

    if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {
      // Zoom to final resolution, with an animation, and provide a
      // direction not to zoom out/in if user was pinching in/out.
      // Direction is > 0 if pinching out, and < 0 if pinching in.
      var direction = this.lastScaleDelta_ - 1;

      _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"].zoom(view, resolution, this.anchor_, this.duration_, direction);
    }

    return false;
  } else {
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;

    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    }

    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_PinchZoom_.prototype.shouldStopEvent = _functions_js__WEBPACK_IMPORTED_MODULE_2__["default"].FALSE;
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_PinchZoom_);

/***/ }),

/***/ "./node_modules/ol/interaction/pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/pointer.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mapbrowsereventtype.js */ "./node_modules/ol/mapbrowsereventtype.js");
/* harmony import */ var _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mapbrowserpointerevent.js */ "./node_modules/ol/mapbrowserpointerevent.js");
/* harmony import */ var _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/interaction.js */ "./node_modules/ol/interaction/interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");






/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 *
 * @constructor
 * @param {olx.interaction.PointerOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */

var _ol_interaction_Pointer_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var handleEvent = options.handleEvent ? options.handleEvent : _ol_interaction_Pointer_.handleEvent;

  _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, {
    handleEvent: handleEvent
  });
  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */


  this.handleDownEvent_ = options.handleDownEvent ? options.handleDownEvent : _ol_interaction_Pointer_.handleDownEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */

  this.handleDragEvent_ = options.handleDragEvent ? options.handleDragEvent : _ol_interaction_Pointer_.handleDragEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */

  this.handleMoveEvent_ = options.handleMoveEvent ? options.handleMoveEvent : _ol_interaction_Pointer_.handleMoveEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */

  this.handleUpEvent_ = options.handleUpEvent ? options.handleUpEvent : _ol_interaction_Pointer_.handleUpEvent;
  /**
   * @type {boolean}
   * @protected
   */

  this.handlingDownUpSequence = false;
  /**
   * @type {Object.<string, ol.pointer.PointerEvent>}
   * @private
   */

  this.trackedPointers_ = {};
  /**
   * @type {Array.<ol.pointer.PointerEvent>}
   * @protected
   */

  this.targetPointers = [];
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_interaction_Pointer_, _interaction_interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.
 * @return {ol.Pixel} Centroid pixel.
 */


_ol_interaction_Pointer_.centroid = function (pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 * @private
 */


_ol_interaction_Pointer_.prototype.isPointerDraggingEvent_ = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN || type === _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG || type === _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @private
 */


_ol_interaction_Pointer_.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
  if (this.isPointerDraggingEvent_(mapBrowserEvent)) {
    var event = mapBrowserEvent.pointerEvent;
    var id = event.pointerId.toString();

    if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP) {
      delete this.trackedPointers_[id];
    } else if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
      this.trackedPointers_[id] = event;
    } else if (id in this.trackedPointers_) {
      // update only when there was a pointerdown event for this pointer
      this.trackedPointers_[id] = event;
    }

    this.targetPointers = _obj_js__WEBPACK_IMPORTED_MODULE_5__["default"].getValues(this.trackedPointers_);
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */


_ol_interaction_Pointer_.handleDragEvent = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleUpEvent = _functions_js__WEBPACK_IMPORTED_MODULE_1__["default"].FALSE;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_1__["default"].FALSE;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleMoveEvent = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Pointer}
 * @api
 */

_ol_interaction_Pointer_.handleEvent = function (mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])) {
    return true;
  }

  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);

  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP) {
      var handledUp = this.handleUpEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
    }
  } else {
    if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.shouldStopEvent(handled);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE) {
      this.handleMoveEvent_(mapBrowserEvent);
    }
  }

  return !stopEvent;
};
/**
 * This method is used to determine if "down" events should be propagated to
 * other interactions or should be stopped.
 *
 * The method receives the return code of the "handleDownEvent" function.
 *
 * By default this function is the "identity" function. It's overidden in
 * child classes.
 *
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the event be stopped?
 * @protected
 */


_ol_interaction_Pointer_.prototype.shouldStopEvent = function (handled) {
  return handled;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_Pointer_);

/***/ }),

/***/ "./node_modules/ol/interaction/property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/property.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_interaction_Property_ = {
  ACTIVE: 'active'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_Property_);

/***/ }),

/***/ "./node_modules/ol/kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/kinetic.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @constructor
 * @param {number} decay Rate of decay (must be negative).
 * @param {number} minVelocity Minimum velocity (pixels/millisecond).
 * @param {number} delay Delay to consider to calculate the kinetic
 *     initial values (milliseconds).
 * @struct
 * @api
 */
var _ol_Kinetic_ = function (decay, minVelocity, delay) {
  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;
  /**
   * @private
   * @type {number}
   */

  this.minVelocity_ = minVelocity;
  /**
   * @private
   * @type {number}
   */

  this.delay_ = delay;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.points_ = [];
  /**
   * @private
   * @type {number}
   */

  this.angle_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.initialVelocity_ = 0;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_Kinetic_.prototype.begin = function () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};
/**
 * @param {number} x X.
 * @param {number} y Y.
 */


_ol_Kinetic_.prototype.update = function (x, y) {
  this.points_.push(x, y, Date.now());
};
/**
 * @return {boolean} Whether we should do kinetic animation.
 */


_ol_Kinetic_.prototype.end = function () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }

  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;

  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  } // get the first point which still falls into the delay time


  var firstIndex = lastIndex - 3;

  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values

  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};
/**
 * @return {number} Total distance travelled (pixels).
 */


_ol_Kinetic_.prototype.getDistance = function () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};
/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */


_ol_Kinetic_.prototype.getAngle = function () {
  return this.angle_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Kinetic_);

/***/ }),

/***/ "./node_modules/ol/layer/base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/base.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _layer_property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/property.js */ "./node_modules/ol/layer/property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {olx.layer.BaseOptions} options Layer options.
 * @api
 */

var _ol_layer_Base_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @type {Object.<string, *>}
   */


  var properties = _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign({}, options);

  properties[_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY] = options.opacity !== undefined ? options.opacity : 1;
  properties[_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE] = options.visible !== undefined ? options.visible : true;
  properties[_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX] = options.zIndex !== undefined ? options.zIndex : 0;
  properties[_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
  properties[_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
  this.setProperties(properties);
  /**
   * @type {ol.LayerState}
   * @private
   */

  this.state_ =
  /** @type {ol.LayerState} */
  {
    layer:
    /** @type {ol.layer.Layer} */
    this,
    managed: true
  };
  /**
   * The layer type.
   * @type {ol.LayerType}
   * @protected;
   */

  this.type;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_Base_, _object_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Get the layer type (used when creating a layer renderer).
 * @return {ol.LayerType} The layer type.
 */


_ol_layer_Base_.prototype.getType = function () {
  return this.type;
};
/**
 * @return {ol.LayerState} Layer state.
 */


_ol_layer_Base_.prototype.getLayerState = function () {
  this.state_.opacity = _math_js__WEBPACK_IMPORTED_MODULE_3__["default"].clamp(this.getOpacity(), 0, 1);
  this.state_.sourceState = this.getSourceState();
  this.state_.visible = this.getVisible();
  this.state_.extent = this.getExtent();
  this.state_.zIndex = this.getZIndex();
  this.state_.maxResolution = this.getMaxResolution();
  this.state_.minResolution = Math.max(this.getMinResolution(), 0);
  return this.state_;
};
/**
 * @abstract
 * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be
 *     modified in place).
 * @return {Array.<ol.layer.Layer>} Array of layers.
 */


_ol_layer_Base_.prototype.getLayersArray = function (opt_array) {};
/**
 * @abstract
 * @param {Array.<ol.LayerState>=} opt_states Optional list of layer
 *     states (to be modified in place).
 * @return {Array.<ol.LayerState>} List of layer states.
 */


_ol_layer_Base_.prototype.getLayerStatesArray = function (opt_states) {};
/**
 * Return the {@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * @return {ol.Extent|undefined} The layer extent.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getExtent = function () {
  return (
    /** @type {ol.Extent|undefined} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT)
  );
};
/**
 * Return the maximum resolution of the layer.
 * @return {number} The maximum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getMaxResolution = function () {
  return (
    /** @type {number} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION)
  );
};
/**
 * Return the minimum resolution of the layer.
 * @return {number} The minimum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getMinResolution = function () {
  return (
    /** @type {number} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION)
  );
};
/**
 * Return the opacity of the layer (between 0 and 1).
 * @return {number} The opacity of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getOpacity = function () {
  return (
    /** @type {number} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY)
  );
};
/**
 * @abstract
 * @return {ol.source.State} Source state.
 */


_ol_layer_Base_.prototype.getSourceState = function () {};
/**
 * Return the visibility of the layer (`true` or `false`).
 * @return {boolean} The visibility of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getVisible = function () {
  return (
    /** @type {boolean} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE)
  );
};
/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * @return {number} The Z-index of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getZIndex = function () {
  return (
    /** @type {number} */
    this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX)
  );
};
/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * @param {ol.Extent|undefined} extent The extent of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setExtent = function (extent) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT, extent);
};
/**
 * Set the maximum resolution at which the layer is visible.
 * @param {number} maxResolution The maximum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setMaxResolution = function (maxResolution) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION, maxResolution);
};
/**
 * Set the minimum resolution at which the layer is visible.
 * @param {number} minResolution The minimum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setMinResolution = function (minResolution) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION, minResolution);
};
/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * @param {number} opacity The opacity of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setOpacity = function (opacity) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY, opacity);
};
/**
 * Set the visibility of the layer (`true` or `false`).
 * @param {boolean} visible The visibility of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setVisible = function (visible) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE, visible);
};
/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * @param {number} zindex The z-index of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setZIndex = function (zindex) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX, zindex);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Base_);

/***/ }),

/***/ "./node_modules/ol/layer/group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/group.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection.js */ "./node_modules/ol/collection.js");
/* harmony import */ var _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collectioneventtype.js */ "./node_modules/ol/collectioneventtype.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _objecteventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objecteventtype.js */ "./node_modules/ol/objecteventtype.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/base.js */ "./node_modules/ol/layer/base.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");












/**
 * @classdesc
 * A {@link ol.Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @constructor
 * @extends {ol.layer.Base}
 * @param {olx.layer.GroupOptions=} opt_options Layer options.
 * @api
 */

var _ol_layer_Group_ = function (opt_options) {
  var options = opt_options || {};

  var baseOptions =
  /** @type {olx.layer.GroupOptions} */
  _obj_js__WEBPACK_IMPORTED_MODULE_10__["default"].assign({}, options);

  delete baseOptions.layers;
  var layers = options.layers;

  _layer_base_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this, baseOptions);
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */


  this.layersListenerKeys_ = [];
  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */

  this.listenerKeys_ = {};

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_3__["default"].getChangeEventType(_ol_layer_Group_.Property_.LAYERS), this.handleLayersChanged_, this);

  if (layers) {
    if (Array.isArray(layers)) {
      layers = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](layers.slice(), {
        unique: true
      });
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_5__["default"].assert(layers instanceof _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"], 43); // Expected `layers` to be an array or an `ol.Collection`


      layers = layers;
    }
  } else {
    layers = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, {
      unique: true
    });
  }

  this.setLayers(layers);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_Group_, _layer_base_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * @private
 */


_ol_layer_Group_.prototype.handleLayerChange_ = function () {
  this.changed();
};
/**
 * @param {ol.events.Event} event Event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersChanged_ = function (event) {
  this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey);
  this.layersListenerKeys_.length = 0;
  var layers = this.getLayers();
  this.layersListenerKeys_.push(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layers, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, this.handleLayersAdd_, this), _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layers, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, this.handleLayersRemove_, this));

  for (var id in this.listenerKeys_) {
    this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey);
  }

  _obj_js__WEBPACK_IMPORTED_MODULE_10__["default"].clear(this.listenerKeys_);

  var layersArray = layers.getArray();
  var i, ii, layer;

  for (i = 0, ii = layersArray.length; i < ii; i++) {
    layer = layersArray[i];
    this.listenerKeys_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString()] = [_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layer, _objecteventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this), _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layer, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)];
  }

  this.changed();
};
/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersAdd_ = function (collectionEvent) {
  var layer =
  /** @type {ol.layer.Base} */
  collectionEvent.element;

  var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString();

  this.listenerKeys_[key] = [_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layer, _objecteventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this), _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(layer, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)];
  this.changed();
};
/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersRemove_ = function (collectionEvent) {
  var layer =
  /** @type {ol.layer.Base} */
  collectionEvent.element;

  var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString();

  this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey);
  delete this.listenerKeys_[key];
  this.changed();
};
/**
 * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @return {!ol.Collection.<ol.layer.Base>} Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */


_ol_layer_Group_.prototype.getLayers = function () {
  return (
    /** @type {!ol.Collection.<ol.layer.Base>} */
    this.get(_ol_layer_Group_.Property_.LAYERS)
  );
};
/**
 * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @param {!ol.Collection.<ol.layer.Base>} layers Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */


_ol_layer_Group_.prototype.setLayers = function (layers) {
  this.set(_ol_layer_Group_.Property_.LAYERS, layers);
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array !== undefined ? opt_array : [];
  this.getLayers().forEach(function (layer) {
    layer.getLayersArray(array);
  });
  return array;
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states !== undefined ? opt_states : [];
  var pos = states.length;
  this.getLayers().forEach(function (layer) {
    layer.getLayerStatesArray(states);
  });
  var ownLayerState = this.getLayerState();
  var i, ii, layerState;

  for (i = pos, ii = states.length; i < ii; i++) {
    layerState = states[i];
    layerState.opacity *= ownLayerState.opacity;
    layerState.visible = layerState.visible && ownLayerState.visible;
    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);

    if (ownLayerState.extent !== undefined) {
      if (layerState.extent !== undefined) {
        layerState.extent = _extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getIntersection(layerState.extent, ownLayerState.extent);
      } else {
        layerState.extent = ownLayerState.extent;
      }
    }
  }

  return states;
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getSourceState = function () {
  return _source_state_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
};
/**
 * @enum {string}
 * @private
 */


_ol_layer_Group_.Property_ = {
  LAYERS: 'layers'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Group_);

/***/ }),

/***/ "./node_modules/ol/layer/heatmap.js":
/*!******************************************!*\
  !*** ./node_modules/ol/layer/heatmap.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/vector.js */ "./node_modules/ol/layer/vector.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _style_icon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/icon.js */ "./node_modules/ol/style/icon.js");
/* harmony import */ var _style_style_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/style.js */ "./node_modules/ol/style/style.js");










/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @fires ol.render.Event
 * @param {olx.layer.HeatmapOptions=} opt_options Options.
 * @api
 */

var _ol_layer_Heatmap_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  var baseOptions = _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign({}, options);

  delete baseOptions.gradient;
  delete baseOptions.radius;
  delete baseOptions.blur;
  delete baseOptions.shadow;
  delete baseOptions.weight;

  _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this,
  /** @type {olx.layer.VectorOptions} */
  baseOptions);
  /**
   * @private
   * @type {Uint8ClampedArray}
   */


  this.gradient_ = null;
  /**
   * @private
   * @type {number}
   */

  this.shadow_ = options.shadow !== undefined ? options.shadow : 250;
  /**
   * @private
   * @type {string|undefined}
   */

  this.circleImage_ = undefined;
  /**
   * @private
   * @type {Array.<Array.<ol.style.Style>>}
   */

  this.styleCache_ = null;

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_layer_Heatmap_.Property_.GRADIENT), this.handleGradientChanged_, this);

  this.setGradient(options.gradient ? options.gradient : _ol_layer_Heatmap_.DEFAULT_GRADIENT);
  this.setBlur(options.blur !== undefined ? options.blur : 15);
  this.setRadius(options.radius !== undefined ? options.radius : 8);

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_layer_Heatmap_.Property_.BLUR), this.handleStyleChanged_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_layer_Heatmap_.Property_.RADIUS), this.handleStyleChanged_, this);

  this.handleStyleChanged_();
  var weight = options.weight ? options.weight : 'weight';
  var weightFunction;

  if (typeof weight === 'string') {
    weightFunction = function (feature) {
      return feature.get(weight);
    };
  } else {
    weightFunction = weight;
  }

  this.setStyle(function (feature, resolution) {
    var weight = weightFunction(feature);
    var opacity = weight !== undefined ? _math_js__WEBPACK_IMPORTED_MODULE_5__["default"].clamp(weight, 0, 1) : 1; // cast to 8 bits

    var index = 255 * opacity | 0;
    var style = this.styleCache_[index];

    if (!style) {
      style = [new _style_style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
        image: new _style_icon_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
          opacity: opacity,
          src: this.circleImage_
        })
      })];
      this.styleCache_[index] = style;
    }

    return style;
  }.bind(this)); // For performance reasons, don't sort the features before rendering.
  // The render order is not relevant for a heatmap representation.

  this.setRenderOrder(null);

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].RENDER, this.handleRender_, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(_ol_layer_Heatmap_, _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @const
 * @type {Array.<string>}
 */


_ol_layer_Heatmap_.DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];
/**
 * @param {Array.<string>} colors A list of colored.
 * @return {Uint8ClampedArray} An array.
 * @private
 */

_ol_layer_Heatmap_.createGradient_ = function (colors) {
  var width = 1;
  var height = 256;

  var context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(width, height);

  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);

  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }

  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.getImageData(0, 0, width, height).data;
};
/**
 * @return {string} Data URL for a circle.
 * @private
 */


_ol_layer_Heatmap_.prototype.createCircle_ = function () {
  var radius = this.getRadius();
  var blur = this.getBlur();
  var halfSize = radius + blur + 1;
  var size = 2 * halfSize;

  var context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(size, size);

  context.shadowOffsetX = context.shadowOffsetY = this.shadow_;
  context.shadowBlur = blur;
  context.shadowColor = '#000';
  context.beginPath();
  var center = halfSize - this.shadow_;
  context.arc(center, center, radius, 0, Math.PI * 2, true);
  context.fill();
  return context.canvas.toDataURL();
};
/**
 * Return the blur size in pixels.
 * @return {number} Blur size in pixels.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.getBlur = function () {
  return (
    /** @type {number} */
    this.get(_ol_layer_Heatmap_.Property_.BLUR)
  );
};
/**
 * Return the gradient colors as array of strings.
 * @return {Array.<string>} Colors.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.getGradient = function () {
  return (
    /** @type {Array.<string>} */
    this.get(_ol_layer_Heatmap_.Property_.GRADIENT)
  );
};
/**
 * Return the size of the radius in pixels.
 * @return {number} Radius size in pixel.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.getRadius = function () {
  return (
    /** @type {number} */
    this.get(_ol_layer_Heatmap_.Property_.RADIUS)
  );
};
/**
 * @private
 */


_ol_layer_Heatmap_.prototype.handleGradientChanged_ = function () {
  this.gradient_ = _ol_layer_Heatmap_.createGradient_(this.getGradient());
};
/**
 * @private
 */


_ol_layer_Heatmap_.prototype.handleStyleChanged_ = function () {
  this.circleImage_ = this.createCircle_();
  this.styleCache_ = new Array(256);
  this.changed();
};
/**
 * @param {ol.render.Event} event Post compose event
 * @private
 */


_ol_layer_Heatmap_.prototype.handleRender_ = function (event) {
  var context = event.context;
  var canvas = context.canvas;
  var image = context.getImageData(0, 0, canvas.width, canvas.height);
  var view8 = image.data;
  var i, ii, alpha;

  for (i = 0, ii = view8.length; i < ii; i += 4) {
    alpha = view8[i + 3] * 4;

    if (alpha) {
      view8[i] = this.gradient_[alpha];
      view8[i + 1] = this.gradient_[alpha + 1];
      view8[i + 2] = this.gradient_[alpha + 2];
    }
  }

  context.putImageData(image, 0, 0);
};
/**
 * Set the blur size in pixels.
 * @param {number} blur Blur size in pixels.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.setBlur = function (blur) {
  this.set(_ol_layer_Heatmap_.Property_.BLUR, blur);
};
/**
 * Set the gradient colors as array of strings.
 * @param {Array.<string>} colors Gradient.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.setGradient = function (colors) {
  this.set(_ol_layer_Heatmap_.Property_.GRADIENT, colors);
};
/**
 * Set the size of the radius in pixels.
 * @param {number} radius Radius size in pixel.
 * @api
 * @observable
 */


_ol_layer_Heatmap_.prototype.setRadius = function (radius) {
  this.set(_ol_layer_Heatmap_.Property_.RADIUS, radius);
};
/**
 * @enum {string}
 * @private
 */


_ol_layer_Heatmap_.Property_ = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Heatmap_);

/***/ }),

/***/ "./node_modules/ol/layer/image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/layer.js */ "./node_modules/ol/layer/layer.js");



/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.ImageOptions=} opt_options Layer options.
 * @api
 */

var _ol_layer_Image_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this,
  /** @type {olx.layer.LayerOptions} */
  options);
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */


  this.type = _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_Image_, _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Return the associated {@link ol.source.Image source} of the image layer.
 * @function
 * @return {ol.source.Image} Source.
 * @api
 */


_ol_layer_Image_.prototype.getSource;
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Image_);

/***/ }),

/***/ "./node_modules/ol/layer/layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/layer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _layer_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/base.js */ "./node_modules/ol/layer/base.js");
/* harmony import */ var _layer_property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/property.js */ "./node_modules/ol/layer/property.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");









/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link ol.Map#addLayer}. Components
 * like {@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {@link ol.layer.Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.layer.Base}
 * @fires ol.render.Event
 * @param {olx.layer.LayerOptions} options Layer options.
 * @api
 */

var _ol_layer_Layer_ = function (options) {
  var baseOptions = _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign({}, options);

  delete baseOptions.source;

  _layer_base_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this,
  /** @type {olx.layer.BaseOptions} */
  baseOptions);
  /**
   * @private
   * @type {?ol.EventsKey}
   */


  this.mapPrecomposeKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.mapRenderKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.sourceChangeKey_ = null;

  if (options.map) {
    this.setMap(options.map);
  }

  _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_3__["default"].getChangeEventType(_layer_property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE), this.handleSourcePropertyChange_, this);

  var source = options.source ? options.source : null;
  this.setSource(source);
};

_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].inherits(_ol_layer_Layer_, _layer_base_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */


_ol_layer_Layer_.visibleAtResolution = function (layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;
};
/**
 * @inheritDoc
 */


_ol_layer_Layer_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array ? opt_array : [];
  array.push(this);
  return array;
};
/**
 * @inheritDoc
 */


_ol_layer_Layer_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states ? opt_states : [];
  states.push(this.getLayerState());
  return states;
};
/**
 * Get the layer source.
 * @return {ol.source.Source} The layer source (or `null` if not yet set).
 * @observable
 * @api
 */


_ol_layer_Layer_.prototype.getSource = function () {
  var source = this.get(_layer_property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE);
  return (
    /** @type {ol.source.Source} */
    source || null
  );
};
/**
  * @inheritDoc
  */


_ol_layer_Layer_.prototype.getSourceState = function () {
  var source = this.getSource();
  return !source ? _source_state_js__WEBPACK_IMPORTED_MODULE_8__["default"].UNDEFINED : source.getState();
};
/**
 * @private
 */


_ol_layer_Layer_.prototype.handleSourceChange_ = function () {
  this.changed();
};
/**
 * @private
 */


_ol_layer_Layer_.prototype.handleSourcePropertyChange_ = function () {
  if (this.sourceChangeKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].unlistenByKey(this.sourceChangeKey_);

    this.sourceChangeKey_ = null;
  }

  var source = this.getSource();

  if (source) {
    this.sourceChangeKey_ = _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(source, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleSourceChange_, this);
  }

  this.changed();
};
/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 *
 * To add the layer to a map and have it managed by the map, use
 * {@link ol.Map#addLayer} instead.
 * @param {ol.PluggableMap} map Map.
 * @api
 */


_ol_layer_Layer_.prototype.setMap = function (map) {
  if (this.mapPrecomposeKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].unlistenByKey(this.mapPrecomposeKey_);

    this.mapPrecomposeKey_ = null;
  }

  if (!map) {
    this.changed();
  }

  if (this.mapRenderKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].unlistenByKey(this.mapRenderKey_);

    this.mapRenderKey_ = null;
  }

  if (map) {
    this.mapPrecomposeKey_ = _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(map, _render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, function (evt) {
      var layerState = this.getLayerState();
      layerState.managed = false;
      layerState.zIndex = Infinity;
      evt.frameState.layerStatesArray.push(layerState);
      evt.frameState.layerStates[_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].getUid(this)] = layerState;
    }, this);
    this.mapRenderKey_ = _events_js__WEBPACK_IMPORTED_MODULE_0__["default"].listen(this, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, map.render, map);
    this.changed();
  }
};
/**
 * Set the layer source.
 * @param {ol.source.Source} source The layer source.
 * @observable
 * @api
 */


_ol_layer_Layer_.prototype.setSource = function (source) {
  this.set(_layer_property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE, source);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Layer_);

/***/ }),

/***/ "./node_modules/ol/layer/property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/property.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_layer_Property_ = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Property_);

/***/ }),

/***/ "./node_modules/ol/layer/tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/tile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer/tileproperty.js */ "./node_modules/ol/layer/tileproperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");





/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.TileOptions=} opt_options Tile layer options.
 * @api
 */

var _ol_layer_Tile_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  var baseOptions = _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign({}, options);

  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;

  _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this,
  /** @type {olx.layer.LayerOptions} */
  baseOptions);

  this.setPreload(options.preload !== undefined ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */

  this.type = _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_Tile_, _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */


_ol_layer_Tile_.prototype.getPreload = function () {
  return (
    /** @type {number} */
    this.get(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRELOAD)
  );
};
/**
 * Return the associated {@link ol.source.Tile tilesource} of the layer.
 * @function
 * @return {ol.source.Tile} Source.
 * @api
 */


_ol_layer_Tile_.prototype.getSource;
/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */

_ol_layer_Tile_.prototype.setPreload = function (preload) {
  this.set(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRELOAD, preload);
};
/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */


_ol_layer_Tile_.prototype.getUseInterimTilesOnError = function () {
  return (
    /** @type {boolean} */
    this.get(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].USE_INTERIM_TILES_ON_ERROR)
  );
};
/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */


_ol_layer_Tile_.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
  this.set(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Tile_);

/***/ }),

/***/ "./node_modules/ol/layer/tileproperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/tileproperty.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_layer_TileProperty_ = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_TileProperty_);

/***/ }),

/***/ "./node_modules/ol/layer/vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/vector.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _layer_vectorrendertype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer/vectorrendertype.js */ "./node_modules/ol/layer/vectorrendertype.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/style.js */ "./node_modules/ol/style/style.js");






/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.VectorOptions=} opt_options Options.
 * @api
 */

var _ol_layer_Vector_ = function (opt_options) {
  var options = opt_options ? opt_options :
  /** @type {olx.layer.VectorOptions} */
  {};

  var baseOptions = _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign({}, options);

  delete baseOptions.style;
  delete baseOptions.renderBuffer;
  delete baseOptions.updateWhileAnimating;
  delete baseOptions.updateWhileInteracting;

  _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this,
  /** @type {olx.layer.LayerOptions} */
  baseOptions);
  /**
   * @private
   * @type {boolean}
   */


  this.declutter_ = options.declutter !== undefined ? options.declutter : false;
  /**
   * @type {number}
   * @private
   */

  this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
  /**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */

  this.style_ = null;
  /**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */

  this.styleFunction_ = undefined;
  this.setStyle(options.style);
  /**
   * @type {boolean}
   * @private
   */

  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
  /**
   * @type {boolean}
   * @private
   */

  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
  /**
   * @private
   * @type {ol.layer.VectorTileRenderType|string}
   */

  this.renderMode_ = options.renderMode || _layer_vectorrendertype_js__WEBPACK_IMPORTED_MODULE_3__["default"].VECTOR;
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */

  this.type = _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_Vector_, _layer_layer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @return {boolean} Declutter.
 */


_ol_layer_Vector_.prototype.getDeclutter = function () {
  return this.declutter_;
};
/**
 * @param {boolean} declutter Declutter.
 */


_ol_layer_Vector_.prototype.setDeclutter = function (declutter) {
  this.declutter_ = declutter;
};
/**
 * @return {number|undefined} Render buffer.
 */


_ol_layer_Vector_.prototype.getRenderBuffer = function () {
  return this.renderBuffer_;
};
/**
 * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render
 *     order.
 */


_ol_layer_Vector_.prototype.getRenderOrder = function () {
  return (
    /** @type {ol.RenderOrderFunction|null|undefined} */
    this.get(_ol_layer_Vector_.Property_.RENDER_ORDER)
  );
};
/**
 * Return the associated {@link ol.source.Vector vectorsource} of the layer.
 * @function
 * @return {ol.source.Vector} Source.
 * @api
 */


_ol_layer_Vector_.prototype.getSource;
/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */

_ol_layer_Vector_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */


_ol_layer_Vector_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};
/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     animating.
 */


_ol_layer_Vector_.prototype.getUpdateWhileAnimating = function () {
  return this.updateWhileAnimating_;
};
/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     interacting.
 */


_ol_layer_Vector_.prototype.getUpdateWhileInteracting = function () {
  return this.updateWhileInteracting_;
};
/**
 * @param {ol.RenderOrderFunction|null|undefined} renderOrder
 *     Render order.
 */


_ol_layer_Vector_.prototype.setRenderOrder = function (renderOrder) {
  this.set(_ol_layer_Vector_.Property_.RENDER_ORDER, renderOrder);
};
/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}
 *     style Layer style.
 * @api
 */


_ol_layer_Vector_.prototype.setStyle = function (style) {
  this.style_ = style !== undefined ? style : _style_style_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultFunction;
  this.styleFunction_ = style === null ? undefined : _style_style_js__WEBPACK_IMPORTED_MODULE_5__["default"].createFunction(this.style_);
  this.changed();
};
/**
 * @return {ol.layer.VectorRenderType|string} The render mode.
 */


_ol_layer_Vector_.prototype.getRenderMode = function () {
  return this.renderMode_;
};
/**
 * @enum {string}
 * @private
 */


_ol_layer_Vector_.Property_ = {
  RENDER_ORDER: 'renderOrder'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Vector_);

/***/ }),

/***/ "./node_modules/ol/layer/vectorrendertype.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/layer/vectorrendertype.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
var _ol_layer_VectorRenderType_ = {
  IMAGE: 'image',
  VECTOR: 'vector'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_VectorRenderType_);

/***/ }),

/***/ "./node_modules/ol/layer/vectortile.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/layer/vectortile.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer/tileproperty.js */ "./node_modules/ol/layer/tileproperty.js");
/* harmony import */ var _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/vector.js */ "./node_modules/ol/layer/vector.js");
/* harmony import */ var _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/vectortilerendertype.js */ "./node_modules/ol/layer/vectortilerendertype.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");







/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param {olx.layer.VectorTileOptions=} opt_options Options.
 * @api
 */

var _ol_layer_VectorTile_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var renderMode = options.renderMode || _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].HYBRID;

  _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(renderMode == undefined || renderMode == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].IMAGE || renderMode == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].HYBRID || renderMode == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].VECTOR, 28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`


  if (options.declutter && renderMode == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].IMAGE) {
    renderMode = _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_5__["default"].HYBRID;
  }

  options.renderMode = renderMode;

  var baseOptions = _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign({}, options);

  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;

  _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this,
  /** @type {olx.layer.VectorOptions} */
  baseOptions);

  this.setPreload(options.preload ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError ? options.useInterimTilesOnError : true);
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */

  this.type = _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR_TILE;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_layer_VectorTile_, _layer_vector_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */


_ol_layer_VectorTile_.prototype.getPreload = function () {
  return (
    /** @type {number} */
    this.get(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRELOAD)
  );
};
/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */


_ol_layer_VectorTile_.prototype.getUseInterimTilesOnError = function () {
  return (
    /** @type {boolean} */
    this.get(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].USE_INTERIM_TILES_ON_ERROR)
  );
};
/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */


_ol_layer_VectorTile_.prototype.setPreload = function (preload) {
  this.set(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRELOAD, preload);
};
/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */


_ol_layer_VectorTile_.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
  this.set(_layer_tileproperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
/**
 * Return the associated {@link ol.source.VectorTile vectortilesource} of the layer.
 * @function
 * @return {ol.source.VectorTile} Source.
 * @api
 */


_ol_layer_VectorTile_.prototype.getSource;
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_VectorTile_);

/***/ }),

/***/ "./node_modules/ol/layer/vectortilerendertype.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/layer/vectortilerendertype.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
var _ol_layer_VectorTileRenderType_ = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_VectorTileRenderType_);

/***/ }),

/***/ "./node_modules/ol/layertype.js":
/*!**************************************!*\
  !*** ./node_modules/ol/layertype.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
var _ol_LayerType_ = {
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_LayerType_);

/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_loadingstrategy_ = {};
/**
 * Strategy function for loading all features with a single request.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */

_ol_loadingstrategy_.all = function (extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
};
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */


_ol_loadingstrategy_.bbox = function (extent, resolution) {
  return [extent];
};
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.
 * @api
 */


_ol_loadingstrategy_.tile = function (tileGrid) {
  return (
    /**
         * @param {ol.Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @return {Array.<ol.Extent>} Extents.
         */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array.<ol.Extent>} */

      var extents = [];
      /** @type {ol.TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }

      return extents;
    }
  );
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_loadingstrategy_);

/***/ }),

/***/ "./node_modules/ol/map.js":
/*!********************************!*\
  !*** ./node_modules/ol/map.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _pluggablemap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluggablemap.js */ "./node_modules/ol/pluggablemap.js");
/* harmony import */ var _plugintype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugintype.js */ "./node_modules/ol/plugintype.js");
/* harmony import */ var _control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control.js */ "./node_modules/ol/control.js");
/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction.js */ "./node_modules/ol/interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _plugins_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins.js */ "./node_modules/ol/plugins.js");
/* harmony import */ var _renderer_canvas_imagelayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderer/canvas/imagelayer.js */ "./node_modules/ol/renderer/canvas/imagelayer.js");
/* harmony import */ var _renderer_canvas_map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer/canvas/map.js */ "./node_modules/ol/renderer/canvas/map.js");
/* harmony import */ var _renderer_canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./renderer/canvas/tilelayer.js */ "./node_modules/ol/renderer/canvas/tilelayer.js");
/* harmony import */ var _renderer_canvas_vectorlayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./renderer/canvas/vectorlayer.js */ "./node_modules/ol/renderer/canvas/vectorlayer.js");
/* harmony import */ var _renderer_canvas_vectortilelayer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./renderer/canvas/vectortilelayer.js */ "./node_modules/ol/renderer/canvas/vectortilelayer.js");
/* harmony import */ var _renderer_webgl_imagelayer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./renderer/webgl/imagelayer.js */ "./node_modules/ol/renderer/webgl/imagelayer.js");
/* harmony import */ var _renderer_webgl_map_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./renderer/webgl/map.js */ "./node_modules/ol/renderer/webgl/map.js");
/* harmony import */ var _renderer_webgl_tilelayer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./renderer/webgl/tilelayer.js */ "./node_modules/ol/renderer/webgl/tilelayer.js");
/* harmony import */ var _renderer_webgl_vectorlayer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./renderer/webgl/vectorlayer.js */ "./node_modules/ol/renderer/webgl/vectorlayer.js");

















if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_CANVAS) {
  _plugins_js__WEBPACK_IMPORTED_MODULE_6__["default"].register(_plugintype_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAP_RENDERER, _renderer_canvas_map_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

  _plugins_js__WEBPACK_IMPORTED_MODULE_6__["default"].registerMultiple(_plugintype_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_RENDERER, [_renderer_canvas_imagelayer_js__WEBPACK_IMPORTED_MODULE_7__["default"], _renderer_canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_9__["default"], _renderer_canvas_vectorlayer_js__WEBPACK_IMPORTED_MODULE_10__["default"], _renderer_canvas_vectortilelayer_js__WEBPACK_IMPORTED_MODULE_11__["default"]]);
}

if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_WEBGL) {
  _plugins_js__WEBPACK_IMPORTED_MODULE_6__["default"].register(_plugintype_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAP_RENDERER, _renderer_webgl_map_js__WEBPACK_IMPORTED_MODULE_13__["default"]);

  _plugins_js__WEBPACK_IMPORTED_MODULE_6__["default"].registerMultiple(_plugintype_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_RENDERER, [_renderer_webgl_imagelayer_js__WEBPACK_IMPORTED_MODULE_12__["default"], _renderer_webgl_tilelayer_js__WEBPACK_IMPORTED_MODULE_14__["default"], _renderer_webgl_vectorlayer_js__WEBPACK_IMPORTED_MODULE_15__["default"]]);
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link ol.layer.Tile} to display
 * {@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport.
 *
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 *
 * @constructor
 * @extends {ol.PluggableMap}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */


var _ol_Map_ = function (options) {
  options = _obj_js__WEBPACK_IMPORTED_MODULE_5__["default"].assign({}, options);

  if (!options.controls) {
    options.controls = _control_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaults();
  }

  if (!options.interactions) {
    options.interactions = _interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].defaults();
  }

  _pluggablemap_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, options);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Map_, _pluggablemap_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_Map_);

/***/ }),

/***/ "./node_modules/ol/mapbrowserevent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/mapbrowserevent.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _mapevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapevent.js */ "./node_modules/ol/mapevent.js");


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link ol.Map} for which events trigger a map browser event.
 *
 * @constructor
 * @extends {ol.MapEvent}
 * @implements {oli.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {Event} browserEvent Browser event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */

var _ol_MapBrowserEvent_ = function (type, map, browserEvent, opt_dragging, opt_frameState) {
  _mapevent_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, type, map, opt_frameState);
  /**
   * The original browser event.
   * @const
   * @type {Event}
   * @api
   */


  this.originalEvent = browserEvent;
  /**
   * The map pixel relative to the viewport corresponding to the original browser event.
   * @type {ol.Pixel}
   * @api
   */

  this.pixel = map.getEventPixel(browserEvent);
  /**
   * The coordinate in view projection corresponding to the original browser event.
   * @type {ol.Coordinate}
   * @api
   */

  this.coordinate = map.getCoordinateFromPixel(this.pixel);
  /**
   * Indicates if the map is currently being dragged. Only set for
   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
   *
   * @type {boolean}
   * @api
   */

  this.dragging = opt_dragging !== undefined ? opt_dragging : false;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_MapBrowserEvent_, _mapevent_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Prevents the default browser action.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault
 * @override
 * @api
 */


_ol_MapBrowserEvent_.prototype.preventDefault = function () {
  _mapevent_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.preventDefault.call(this);

  this.originalEvent.preventDefault();
};
/**
 * Prevents further propagation of the current event.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation
 * @override
 * @api
 */


_ol_MapBrowserEvent_.prototype.stopPropagation = function () {
  _mapevent_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.stopPropagation.call(this);

  this.originalEvent.stopPropagation();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_MapBrowserEvent_);

/***/ }),

/***/ "./node_modules/ol/mapbrowsereventhandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/mapbrowsereventhandler.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mapbrowsereventtype.js */ "./node_modules/ol/mapbrowsereventtype.js");
/* harmony import */ var _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mapbrowserpointerevent.js */ "./node_modules/ol/mapbrowserpointerevent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer/eventtype.js */ "./node_modules/ol/pointer/eventtype.js");
/* harmony import */ var _pointer_pointereventhandler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointer/pointereventhandler.js */ "./node_modules/ol/pointer/pointereventhandler.js");








/**
 * @param {ol.PluggableMap} map The map with the viewport to listen to events on.
 * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.
 * @constructor
 * @extends {ol.events.EventTarget}
 */

var _ol_MapBrowserEventHandler_ = function (map, moveTolerance) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this);
  /**
   * This is the element that we will listen to the real events on.
   * @type {ol.PluggableMap}
   * @private
   */


  this.map_ = map;
  /**
   * @type {number}
   * @private
   */

  this.clickTimeoutId_ = 0;
  /**
   * @type {boolean}
   * @private
   */

  this.dragging_ = false;
  /**
   * @type {!Array.<ol.EventsKey>}
   * @private
   */

  this.dragListenerKeys_ = [];
  /**
   * @type {number}
   * @private
   */

  this.moveTolerance_ = moveTolerance ? moveTolerance * _has_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEVICE_PIXEL_RATIO : _has_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEVICE_PIXEL_RATIO;
  /**
   * The most recent "down" type event (or null if none have occurred).
   * Set on pointerdown.
   * @type {ol.pointer.PointerEvent}
   * @private
   */

  this.down_ = null;
  var element = this.map_.getViewport();
  /**
   * @type {number}
   * @private
   */

  this.activePointers_ = 0;
  /**
   * @type {!Object.<number, boolean>}
   * @private
   */

  this.trackedTouches_ = {};
  /**
   * Event handler which generates pointer events for
   * the viewport element.
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */

  this.pointerEventHandler_ = new _pointer_pointereventhandler_js__WEBPACK_IMPORTED_MODULE_7__["default"](element);
  /**
   * Event handler which generates pointer events for
   * the document (used when dragging).
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */

  this.documentPointerEventHandler_ = null;
  /**
   * @type {?ol.EventsKey}
   * @private
   */

  this.pointerdownListenerKey_ = _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.pointerEventHandler_, _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDOWN, this.handlePointerDown_, this);
  /**
   * @type {?ol.EventsKey}
   * @private
   */

  this.relayedListenerKey_ = _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.pointerEventHandler_, _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE, this.relayEvent_, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_MapBrowserEventHandler_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.emulateClick_ = function (pointerEvent) {
  var newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  if (this.clickTimeoutId_ !== 0) {
    // double-click
    clearTimeout(this.clickTimeoutId_);
    this.clickTimeoutId_ = 0;
    newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].DBLCLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
  } else {
    // click
    this.clickTimeoutId_ = setTimeout(function () {
      this.clickTimeoutId_ = 0;
      var newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].SINGLECLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    }.bind(this), 250);
  }
};
/**
 * Keeps track on how many pointers are currently active.
 *
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function (pointerEvent) {
  var event = pointerEvent;

  if (event.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP || event.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERCANCEL) {
    delete this.trackedTouches_[event.pointerId];
  } else if (event.type == _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
    this.trackedTouches_[event.pointerId] = true;
  }

  this.activePointers_ = Object.keys(this.trackedTouches_).length;
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP, this.map_, pointerEvent);
  this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
  // contact. isMouseActionButton returns true in these cases (evt.button is set
  // to 0).
  // See http://www.w3.org/TR/pointerevents/#button-states
  // We only fire click, singleclick, and doubleclick if nobody has called
  // event.stopPropagation() or event.preventDefault().

  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
    this.emulateClick_(this.down_);
  }

  if (this.activePointers_ === 0) {
    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.dragging_ = false;
    this.down_ = null;
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} If the left mouse button was pressed.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function (pointerEvent) {
  return pointerEvent.button === 0;
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  this.down_ = pointerEvent;

  if (this.dragListenerKeys_.length === 0) {
    /* Set up a pointer event handler on the `document`,
     * which is required when the pointer is moved outside
     * the viewport when dragging.
     */
    this.documentPointerEventHandler_ = new _pointer_pointereventhandler_js__WEBPACK_IMPORTED_MODULE_7__["default"](document);
    this.dragListenerKeys_.push(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.documentPointerEventHandler_, _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE, this.handlePointerMove_, this), _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.documentPointerEventHandler_, _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERUP, this.handlePointerUp_, this),
    /* Note that the listener for `pointercancel is set up on
    * `pointerEventHandler_` and not `documentPointerEventHandler_` like
    * the `pointerup` and `pointermove` listeners.
    *
    * The reason for this is the following: `TouchSource.vacuumTouches_()`
    * issues `pointercancel` events, when there was no `touchend` for a
    * `touchstart`. Now, let's say a first `touchstart` is registered on
    * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
    * But `documentPointerEventHandler_` doesn't know about the first
    * `touchstart`. If there is no `touchend` for the `touchstart`, we can
    * only receive a `touchcancel` from `pointerEventHandler_`, because it is
    * only registered there.
    */
    _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.pointerEventHandler_, _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERCANCEL, this.handlePointerUp_, this));
  }
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function (pointerEvent) {
  // Between pointerdown and pointerup, pointermove events are triggered.
  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
  // moved a significant distance.
  if (this.isMoving_(pointerEvent)) {
    this.dragging_ = true;
    var newEvent = new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](_mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG, this.map_, pointerEvent, this.dragging_);
    this.dispatchEvent(newEvent);
  } // Some native android browser triggers mousemove events during small period
  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
  // https://code.google.com/p/android/issues/detail?id=19827
  // ex: Galaxy Tab P3110 + Android 4.1.1


  pointerEvent.preventDefault();
};
/**
 * Wrap and relay a pointer event.  Note that this requires that the type
 * string for the MapBrowserPointerEvent matches the PointerEvent type.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.relayEvent_ = function (pointerEvent) {
  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
  this.dispatchEvent(new _mapbrowserpointerevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](pointerEvent.type, this.map_, pointerEvent, dragging));
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} Is moving.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.isMoving_ = function (pointerEvent) {
  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
};
/**
 * @inheritDoc
 */


_ol_MapBrowserEventHandler_.prototype.disposeInternal = function () {
  if (this.relayedListenerKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey(this.relayedListenerKey_);

    this.relayedListenerKey_ = null;
  }

  if (this.pointerdownListenerKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey(this.pointerdownListenerKey_);

    this.pointerdownListenerKey_ = null;
  }

  this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
  this.dragListenerKeys_.length = 0;

  if (this.documentPointerEventHandler_) {
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }

  if (this.pointerEventHandler_) {
    this.pointerEventHandler_.dispose();
    this.pointerEventHandler_ = null;
  }

  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.disposeInternal.call(this);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_MapBrowserEventHandler_);

/***/ }),

/***/ "./node_modules/ol/mapbrowsereventtype.js":
/*!************************************************!*\
  !*** ./node_modules/ol/mapbrowsereventtype.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");

/**
 * Constants for event names.
 * @enum {string}
 */

var _ol_MapBrowserEventType_ = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event ol.MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event ol.MapBrowserEvent#click
   * @api
   */
  CLICK: _events_eventtype_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event ol.MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_eventtype_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event ol.MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event ol.MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_MapBrowserEventType_);

/***/ }),

/***/ "./node_modules/ol/mapbrowserpointerevent.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/mapbrowserpointerevent.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _mapbrowserevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapbrowserevent.js */ "./node_modules/ol/mapbrowserevent.js");


/**
 * @constructor
 * @extends {ol.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */

var _ol_MapBrowserPointerEvent_ = function (type, map, pointerEvent, opt_dragging, opt_frameState) {
  _mapbrowserevent_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);
  /**
   * @const
   * @type {ol.pointer.PointerEvent}
   */


  this.pointerEvent = pointerEvent;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_MapBrowserPointerEvent_, _mapbrowserevent_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_MapBrowserPointerEvent_);

/***/ }),

/***/ "./node_modules/ol/mapevent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/mapevent.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/event.js */ "./node_modules/ol/events/event.js");


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link ol.Map} for which events trigger a map event.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.MapEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */

var _ol_MapEvent_ = function (type, map, opt_frameState) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, type);
  /**
   * The map where the event occurred.
   * @type {ol.PluggableMap}
   * @api
   */


  this.map = map;
  /**
   * The frame state at the time of the event.
   * @type {?olx.FrameState}
   * @api
   */

  this.frameState = opt_frameState !== undefined ? opt_frameState : null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_MapEvent_, _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_MapEvent_);

/***/ }),

/***/ "./node_modules/ol/mapeventtype.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/mapeventtype.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_MapEventType_ = {
  /**
   * Triggered after a map frame is rendered.
   * @event ol.MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event ol.MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event ol.MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_MapEventType_);

/***/ }),

/***/ "./node_modules/ol/mapproperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/mapproperty.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_MapProperty_ = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_MapProperty_);

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _ol_math_ = {};
/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */

_ol_math_.clamp = function (value, min, max) {
  return Math.min(Math.max(value, min), max);
};
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */


_ol_math_.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;

  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function (x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }

  return cosh;
}();
/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */


_ol_math_.roundUpToPowerOfTwo = function (x) {
  _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(0 < x, 29); // `x` must be greater than `0`


  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


_ol_math_.squaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return _ol_math_.squaredDistance(x, y, x1, y1);
};
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


_ol_math_.squaredDistance = function (x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */


_ol_math_.solveLinearSystem = function (mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
};
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */


_ol_math_.toDegrees = function (angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */


_ol_math_.toRadians = function (angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */


_ol_math_.modulo = function (a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */


_ol_math_.lerp = function (a, b, x) {
  return a + x * (b - a);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_math_);

/***/ }),

/***/ "./node_modules/ol/net.js":
/*!********************************!*\
  !*** ./node_modules/ol/net.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _ol_net_ = {};
/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {function()=} opt_errback Callback on error.
 * @param {string=} opt_callbackParam Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */

_ol_net_.jsonp = function (url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement('script');

  var key = 'olc_' + _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(callback);

  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }

  script.async = true;
  script.src = url + (url.indexOf('?') == -1 ? '?' : '&') + (opt_callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function () {
    cleanup();

    if (opt_errback) {
      opt_errback();
    }
  }, 10000);

  window[key] = function (data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };

  document.getElementsByTagName('head')[0].appendChild(script);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_net_);

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_obj_ = {};
/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */

_ol_obj_.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */

_ol_obj_.clear = function (object) {
  for (var property in object) {
    delete object[property];
  }
};
/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */


_ol_obj_.getValues = function (object) {
  var values = [];

  for (var property in object) {
    values.push(object[property]);
  }

  return values;
};
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */


_ol_obj_.isEmpty = function (object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_obj_);

/***/ }),

/***/ "./node_modules/ol/object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/object.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _objecteventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objecteventtype.js */ "./node_modules/ol/objecteventtype.js");
/* harmony import */ var _observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observable.js */ "./node_modules/ol/observable.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link ol.Object#getProperties object.getProperties()}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {ol.Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires ol.Object.Event
 * @api
 */

var _ol_Object_ = function (opt_values) {
  _observable_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this); // Call ol.getUid to ensure that the order of objects' ids is the same as
  // the order in which they were created.  This also helps to ensure that
  // object properties are always added in the same order, which helps many
  // JavaScript engines generate faster code.


  _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this);
  /**
   * @private
   * @type {!Object.<string, *>}
   */


  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Object_, _observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @private
 * @type {Object.<string, string>}
 */


_ol_Object_.changeEventTypeCache_ = {};
/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */

_ol_Object_.getChangeEventType = function (key) {
  return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key) ? _ol_Object_.changeEventTypeCache_[key] : _ol_Object_.changeEventTypeCache_[key] = 'change:' + key;
};
/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */


_ol_Object_.prototype.get = function (key) {
  var value;

  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }

  return value;
};
/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */


_ol_Object_.prototype.getKeys = function () {
  return Object.keys(this.values_);
};
/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */


_ol_Object_.prototype.getProperties = function () {
  return _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign({}, this.values_);
};
/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */


_ol_Object_.prototype.notify = function (key, oldValue) {
  var eventType;
  eventType = _ol_Object_.getChangeEventType(key);
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
  eventType = _objecteventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].PROPERTYCHANGE;
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
};
/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */


_ol_Object_.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;

    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};
/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */


_ol_Object_.prototype.setProperties = function (values, opt_silent) {
  var key;

  for (key in values) {
    this.set(key, values[key], opt_silent);
  }
};
/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */


_ol_Object_.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];

    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};
/**
 * @classdesc
 * Events emitted by {@link ol.Object} instances are instances of this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {ol.events.Event}
 * @implements {oli.Object.Event}
 * @constructor
 */


_ol_Object_.Event = function (type, key, oldValue) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, type);
  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */


  this.key = key;
  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */

  this.oldValue = oldValue;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Object_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_Object_);

/***/ }),

/***/ "./node_modules/ol/objecteventtype.js":
/*!********************************************!*\
  !*** ./node_modules/ol/objecteventtype.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_ObjectEventType_ = {
  /**
   * Triggered when a property is changed.
   * @event ol.Object.Event#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_ObjectEventType_);

/***/ }),

/***/ "./node_modules/ol/observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/observable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link ol.Observable#changed}.
 *
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @api
 */

var _ol_Observable_ = function () {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @private
   * @type {number}
   */


  this.revision_ = 0;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Observable_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */


_ol_Observable_.unByKey = function (key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlistenByKey(key[i]);
    }
  } else {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlistenByKey(
    /** @type {ol.EventsKey} */
    key);
  }
};
/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */


_ol_Observable_.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
};
/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event object.
 * @function
 * @api
 */


_ol_Observable_.prototype.dispatchEvent;
/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */

_ol_Observable_.prototype.getRevision = function () {
  return this.revision_;
};
/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


_ol_Observable_.prototype.on = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);

    for (var i = 0; i < len; ++i) {
      keys[i] = _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this, type[i], listener, opt_this);
    }

    return keys;
  } else {
    return _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};
/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


_ol_Observable_.prototype.once = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);

    for (var i = 0; i < len; ++i) {
      keys[i] = _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listenOnce(this, type[i], listener, opt_this);
    }

    return keys;
  } else {
    return _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listenOnce(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};
/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object which was used as `this` by the
 * `listener`.
 * @api
 */


_ol_Observable_.prototype.un = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlisten(this, type[i], listener, opt_this);
    }

    return;
  } else {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlisten(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Observable_);

/***/ }),

/***/ "./node_modules/ol/ol.css":
/*!********************************!*\
  !*** ./node_modules/ol/ol.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../mini-css-extract-plugin/dist/loader.js!../css-loader??ref--5-2!../postcss-loader/src??postcss!./ol.css */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/ol/ol.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/ol/overlay.js":
/*!************************************!*\
  !*** ./node_modules/ol/overlay.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _mapeventtype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapeventtype.js */ "./node_modules/ol/mapeventtype.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlaypositioning.js */ "./node_modules/ol/overlaypositioning.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");








/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link ol.control.Control}, Overlays are visible widgets.
 * Unlike Controls, they are not in a fixed position on the screen, but are tied
 * to a geographical coordinate, so panning the map will move an Overlay but not
 * a Control.
 *
 * Example:
 *
 *     var popup = new ol.Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.OverlayOptions} options Overlay options.
 * @api
 */

var _ol_Overlay_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @protected
   * @type {olx.OverlayOptions}
   */


  this.options = options;
  /**
   * @protected
   * @type {number|string|undefined}
   */

  this.id = options.id;
  /**
   * @protected
   * @type {boolean}
   */

  this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
  /**
   * @protected
   * @type {boolean}
   */

  this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
  /**
   * @protected
   * @type {Element}
   */

  this.element = document.createElement('DIV');
  this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _css_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLASS_SELECTABLE;
  this.element.style.position = 'absolute';
  /**
   * @protected
   * @type {boolean}
   */

  this.autoPan = options.autoPan !== undefined ? options.autoPan : false;
  /**
   * @protected
   * @type {olx.OverlayPanOptions}
   */

  this.autoPanAnimation = options.autoPanAnimation ||
  /** @type {olx.OverlayPanOptions} */
  {};
  /**
   * @protected
   * @type {number}
   */

  this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;
  /**
   * @protected
   * @type {{bottom_: string,
   *         left_: string,
   *         right_: string,
   *         top_: string,
   *         visible: boolean}}
   */

  this.rendered = {
    bottom_: '',
    left_: '',
    right_: '',
    top_: '',
    visible: true
  };
  /**
   * @protected
   * @type {?ol.EventsKey}
   */

  this.mapPostrenderListenerKey = null;

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_Overlay_.Property.ELEMENT), this.handleElementChanged, this);

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_Overlay_.Property.MAP), this.handleMapChanged, this);

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_Overlay_.Property.OFFSET), this.handleOffsetChanged, this);

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_Overlay_.Property.POSITION), this.handlePositionChanged, this);

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].getChangeEventType(_ol_Overlay_.Property.POSITIONING), this.handlePositioningChanged, this);

  if (options.element !== undefined) {
    this.setElement(options.element);
  }

  this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
  this.setPositioning(options.positioning !== undefined ?
  /** @type {ol.OverlayPositioning} */
  options.positioning : _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT);

  if (options.position !== undefined) {
    this.setPosition(options.position);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Overlay_, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Get the DOM element of this overlay.
 * @return {Element|undefined} The Element containing the overlay.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getElement = function () {
  return (
    /** @type {Element|undefined} */
    this.get(_ol_Overlay_.Property.ELEMENT)
  );
};
/**
 * Get the overlay identifier which is set on constructor.
 * @return {number|string|undefined} Id.
 * @api
 */


_ol_Overlay_.prototype.getId = function () {
  return this.id;
};
/**
 * Get the map associated with this overlay.
 * @return {ol.PluggableMap|undefined} The map that the overlay is part of.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getMap = function () {
  return (
    /** @type {ol.PluggableMap|undefined} */
    this.get(_ol_Overlay_.Property.MAP)
  );
};
/**
 * Get the offset of this overlay.
 * @return {Array.<number>} The offset.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getOffset = function () {
  return (
    /** @type {Array.<number>} */
    this.get(_ol_Overlay_.Property.OFFSET)
  );
};
/**
 * Get the current position of this overlay.
 * @return {ol.Coordinate|undefined} The spatial point that the overlay is
 *     anchored at.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getPosition = function () {
  return (
    /** @type {ol.Coordinate|undefined} */
    this.get(_ol_Overlay_.Property.POSITION)
  );
};
/**
 * Get the current positioning of this overlay.
 * @return {ol.OverlayPositioning} How the overlay is positioned
 *     relative to its point on the map.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getPositioning = function () {
  return (
    /** @type {ol.OverlayPositioning} */
    this.get(_ol_Overlay_.Property.POSITIONING)
  );
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleElementChanged = function () {
  _dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].removeChildren(this.element);

  var element = this.getElement();

  if (element) {
    this.element.appendChild(element);
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleMapChanged = function () {
  if (this.mapPostrenderListenerKey) {
    _dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].removeNode(this.element);

    _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey(this.mapPostrenderListenerKey);

    this.mapPostrenderListenerKey = null;
  }

  var map = this.getMap();

  if (map) {
    this.mapPostrenderListenerKey = _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(map, _mapeventtype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSTRENDER, this.render, this);
    this.updatePixelPosition();
    var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

    if (this.insertFirst) {
      container.insertBefore(this.element, container.childNodes[0] || null);
    } else {
      container.appendChild(this.element);
    }
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.render = function () {
  this.updatePixelPosition();
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleOffsetChanged = function () {
  this.updatePixelPosition();
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handlePositionChanged = function () {
  this.updatePixelPosition();

  if (this.get(_ol_Overlay_.Property.POSITION) && this.autoPan) {
    this.panIntoView();
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handlePositioningChanged = function () {
  this.updatePixelPosition();
};
/**
 * Set the DOM element to be associated with this overlay.
 * @param {Element|undefined} element The Element containing the overlay.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setElement = function (element) {
  this.set(_ol_Overlay_.Property.ELEMENT, element);
};
/**
 * Set the map to be associated with this overlay.
 * @param {ol.PluggableMap|undefined} map The map that the overlay is part of.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setMap = function (map) {
  this.set(_ol_Overlay_.Property.MAP, map);
};
/**
 * Set the offset for this overlay.
 * @param {Array.<number>} offset Offset.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setOffset = function (offset) {
  this.set(_ol_Overlay_.Property.OFFSET, offset);
};
/**
 * Set the position for this overlay. If the position is `undefined` the
 * overlay is hidden.
 * @param {ol.Coordinate|undefined} position The spatial point that the overlay
 *     is anchored at.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setPosition = function (position) {
  this.set(_ol_Overlay_.Property.POSITION, position);
};
/**
 * Pan the map so that the overlay is entirely visible in the current viewport
 * (if necessary).
 * @protected
 */


_ol_Overlay_.prototype.panIntoView = function () {
  var map = this.getMap();

  if (!map || !map.getTargetElement()) {
    return;
  }

  var mapRect = this.getRect(map.getTargetElement(), map.getSize());
  var element =
  /** @type {!Element} */
  this.getElement();
  var overlayRect = this.getRect(element, [_dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].outerWidth(element), _dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].outerHeight(element)]);
  var margin = this.autoPanMargin;

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].containsExtent(mapRect, overlayRect)) {
    // the overlay is not completely inside the viewport, so pan the map
    var offsetLeft = overlayRect[0] - mapRect[0];
    var offsetRight = mapRect[2] - overlayRect[2];
    var offsetTop = overlayRect[1] - mapRect[1];
    var offsetBottom = mapRect[3] - overlayRect[3];
    var delta = [0, 0];

    if (offsetLeft < 0) {
      // move map to the left
      delta[0] = offsetLeft - margin;
    } else if (offsetRight < 0) {
      // move map to the right
      delta[0] = Math.abs(offsetRight) + margin;
    }

    if (offsetTop < 0) {
      // move map up
      delta[1] = offsetTop - margin;
    } else if (offsetBottom < 0) {
      // move map down
      delta[1] = Math.abs(offsetBottom) + margin;
    }

    if (delta[0] !== 0 || delta[1] !== 0) {
      var center =
      /** @type {ol.Coordinate} */
      map.getView().getCenter();
      var centerPx = map.getPixelFromCoordinate(center);
      var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
      map.getView().animate({
        center: map.getCoordinateFromPixel(newCenterPx),
        duration: this.autoPanAnimation.duration,
        easing: this.autoPanAnimation.easing
      });
    }
  }
};
/**
 * Get the extent of an element relative to the document
 * @param {Element|undefined} element The element.
 * @param {ol.Size|undefined} size The size of the element.
 * @return {ol.Extent} The extent.
 * @protected
 */


_ol_Overlay_.prototype.getRect = function (element, size) {
  var box = element.getBoundingClientRect();
  var offsetX = box.left + window.pageXOffset;
  var offsetY = box.top + window.pageYOffset;
  return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
};
/**
 * Set the positioning for this overlay.
 * @param {ol.OverlayPositioning} positioning how the overlay is
 *     positioned relative to its point on the map.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setPositioning = function (positioning) {
  this.set(_ol_Overlay_.Property.POSITIONING, positioning);
};
/**
 * Modify the visibility of the element.
 * @param {boolean} visible Element visibility.
 * @protected
 */


_ol_Overlay_.prototype.setVisible = function (visible) {
  if (this.rendered.visible !== visible) {
    this.element.style.display = visible ? '' : 'none';
    this.rendered.visible = visible;
  }
};
/**
 * Update pixel position.
 * @protected
 */


_ol_Overlay_.prototype.updatePixelPosition = function () {
  var map = this.getMap();
  var position = this.getPosition();

  if (!map || !map.isRendered() || !position) {
    this.setVisible(false);
    return;
  }

  var pixel = map.getPixelFromCoordinate(position);
  var mapSize = map.getSize();
  this.updateRenderedPosition(pixel, mapSize);
};
/**
 * @param {ol.Pixel} pixel The pixel location.
 * @param {ol.Size|undefined} mapSize The map size.
 * @protected
 */


_ol_Overlay_.prototype.updateRenderedPosition = function (pixel, mapSize) {
  var style = this.element.style;
  var offset = this.getOffset();
  var positioning = this.getPositioning();
  this.setVisible(true);
  var offsetX = offset[0];
  var offsetY = offset[1];

  if (positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].BOTTOM_RIGHT || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].CENTER_RIGHT || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_RIGHT) {
    if (this.rendered.left_ !== '') {
      this.rendered.left_ = style.left = '';
    }

    var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';

    if (this.rendered.right_ != right) {
      this.rendered.right_ = style.right = right;
    }
  } else {
    if (this.rendered.right_ !== '') {
      this.rendered.right_ = style.right = '';
    }

    if (positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].BOTTOM_CENTER || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].CENTER_CENTER || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_CENTER) {
      offsetX -= this.element.offsetWidth / 2;
    }

    var left = Math.round(pixel[0] + offsetX) + 'px';

    if (this.rendered.left_ != left) {
      this.rendered.left_ = style.left = left;
    }
  }

  if (positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].BOTTOM_LEFT || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].BOTTOM_CENTER || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].BOTTOM_RIGHT) {
    if (this.rendered.top_ !== '') {
      this.rendered.top_ = style.top = '';
    }

    var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';

    if (this.rendered.bottom_ != bottom) {
      this.rendered.bottom_ = style.bottom = bottom;
    }
  } else {
    if (this.rendered.bottom_ !== '') {
      this.rendered.bottom_ = style.bottom = '';
    }

    if (positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].CENTER_LEFT || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].CENTER_CENTER || positioning == _overlaypositioning_js__WEBPACK_IMPORTED_MODULE_3__["default"].CENTER_RIGHT) {
      offsetY -= this.element.offsetHeight / 2;
    }

    var top = Math.round(pixel[1] + offsetY) + 'px';

    if (this.rendered.top_ != top) {
      this.rendered.top_ = style.top = top;
    }
  }
};
/**
 * returns the options this Overlay has been created with
 * @public
 * @return {olx.OverlayOptions} overlay options
 */


_ol_Overlay_.prototype.getOptions = function () {
  return this.options;
};
/**
 * @enum {string}
 * @protected
 */


_ol_Overlay_.Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_Overlay_);

/***/ }),

/***/ "./node_modules/ol/overlaypositioning.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/overlaypositioning.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
var _ol_OverlayPositioning_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_OverlayPositioning_);

/***/ }),

/***/ "./node_modules/ol/pluggablemap.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/pluggablemap.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection.js */ "./node_modules/ol/collection.js");
/* harmony import */ var _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collectioneventtype.js */ "./node_modules/ol/collectioneventtype.js");
/* harmony import */ var _mapbrowserevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mapbrowserevent.js */ "./node_modules/ol/mapbrowserevent.js");
/* harmony import */ var _mapbrowsereventhandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapbrowsereventhandler.js */ "./node_modules/ol/mapbrowsereventhandler.js");
/* harmony import */ var _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mapbrowsereventtype.js */ "./node_modules/ol/mapbrowsereventtype.js");
/* harmony import */ var _mapevent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mapevent.js */ "./node_modules/ol/mapevent.js");
/* harmony import */ var _mapeventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mapeventtype.js */ "./node_modules/ol/mapeventtype.js");
/* harmony import */ var _mapproperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mapproperty.js */ "./node_modules/ol/mapproperty.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _objecteventtype_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./objecteventtype.js */ "./node_modules/ol/objecteventtype.js");
/* harmony import */ var _tilequeue_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tilequeue.js */ "./node_modules/ol/tilequeue.js");
/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./view.js */ "./node_modules/ol/view.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _layer_group_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./layer/group.js */ "./node_modules/ol/layer/group.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _plugins_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./plugins.js */ "./node_modules/ol/plugins.js");
/* harmony import */ var _renderer_type_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./renderer/type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./structs/priorityqueue.js */ "./node_modules/ol/structs/priorityqueue.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");





























/**
 * @constructor
 * @extends {ol.Object}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */

var _ol_PluggableMap_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this);

  var optionsInternal = _ol_PluggableMap_.createOptionsInternal(options);
  /**
   * @type {boolean}
   * @private
   */


  this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;
  /**
   * @type {boolean}
   * @private
   */

  this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has_js__WEBPACK_IMPORTED_MODULE_21__["default"].DEVICE_PIXEL_RATIO;
  /**
   * @private
   * @type {Object.<string, string>}
   */

  this.logos_ = optionsInternal.logos;
  /**
   * @private
   * @type {number|undefined}
   */

  this.animationDelayKey_;
  /**
   * @private
   */

  this.animationDelay_ = function () {
    this.animationDelayKey_ = undefined;
    this.renderFrame_.call(this, Date.now());
  }.bind(this);
  /**
   * @private
   * @type {ol.Transform}
   */


  this.coordinateToPixelTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_28__["default"].create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.pixelToCoordinateTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_28__["default"].create();
  /**
   * @private
   * @type {number}
   */

  this.frameIndex_ = 0;
  /**
   * @private
   * @type {?olx.FrameState}
   */

  this.frameState_ = null;
  /**
   * The extent at the previous 'moveend' event.
   * @private
   * @type {ol.Extent}
   */

  this.previousExtent_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.viewPropertyListenerKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.viewChangeListenerKey_ = null;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.layerGroupPropertyListenerKeys_ = null;
  /**
   * @private
   * @type {Element}
   */

  this.viewport_ = document.createElement('DIV');
  this.viewport_.className = 'ol-viewport' + (_has_js__WEBPACK_IMPORTED_MODULE_21__["default"].TOUCH ? ' ol-touch' : '');
  this.viewport_.style.position = 'relative';
  this.viewport_.style.overflow = 'hidden';
  this.viewport_.style.width = '100%';
  this.viewport_.style.height = '100%'; // prevent page zoom on IE >= 10 browsers

  this.viewport_.style.msTouchAction = 'none';
  this.viewport_.style.touchAction = 'none';
  /**
   * @private
   * @type {!Element}
   */

  this.overlayContainer_ = document.createElement('DIV');
  this.overlayContainer_.className = 'ol-overlaycontainer';
  this.viewport_.appendChild(this.overlayContainer_);
  /**
   * @private
   * @type {!Element}
   */

  this.overlayContainerStopEvent_ = document.createElement('DIV');
  this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
  var overlayEvents = [_events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].CLICK, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].DBLCLICK, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEDOWN, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].TOUCHSTART, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].MSPOINTERDOWN, _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL];

  for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
    _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.overlayContainerStopEvent_, overlayEvents[i], _events_event_js__WEBPACK_IMPORTED_MODULE_17__["default"].stopPropagation);
  }

  this.viewport_.appendChild(this.overlayContainerStopEvent_);
  /**
   * @private
   * @type {ol.MapBrowserEventHandler}
   */

  this.mapBrowserEventHandler_ = new _mapbrowsereventhandler_js__WEBPACK_IMPORTED_MODULE_4__["default"](this, options.moveTolerance);

  for (var key in _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
    _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.mapBrowserEventHandler_, _mapbrowsereventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"][key], this.handleMapBrowserEvent, this);
  }
  /**
   * @private
   * @type {Element|Document}
   */


  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.keyHandlerKeys_ = null;

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.viewport_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL, this.handleBrowserEvent, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.viewport_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);
  /**
   * @type {ol.Collection.<ol.control.Control>}
   * @protected
   */


  this.controls = optionsInternal.controls || new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  /**
   * @type {ol.Collection.<ol.interaction.Interaction>}
   * @protected
   */

  this.interactions = optionsInternal.interactions || new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  /**
   * @type {ol.Collection.<ol.Overlay>}
   * @private
   */

  this.overlays_ = optionsInternal.overlays;
  /**
   * A lookup of overlays by id.
   * @private
   * @type {Object.<string, ol.Overlay>}
   */

  this.overlayIdIndex_ = {};
  /**
   * @type {ol.renderer.Map}
   * @private
   */

  this.renderer_ = optionsInternal.mapRendererPlugin['create'](this.viewport_, this);
  /**
   * @type {function(Event)|undefined}
   * @private
   */

  this.handleResize_;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.focus_ = null;
  /**
   * @private
   * @type {Array.<ol.PostRenderFunction>}
   */

  this.postRenderFunctions_ = [];
  /**
   * @private
   * @type {ol.TileQueue}
   */

  this.tileQueue_ = new _tilequeue_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
  /**
   * Uids of features to skip at rendering time.
   * @type {Object.<string, boolean>}
   * @private
   */

  this.skippedFeatureUids_ = {};

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].getChangeEventType(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP), this.handleLayerGroupChanged_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].getChangeEventType(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW), this.handleViewChanged_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].getChangeEventType(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE), this.handleSizeChanged_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this, _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].getChangeEventType(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET), this.handleTargetChanged_, this); // setProperties will trigger the rendering of the map if the map
  // is "defined" already.


  this.setProperties(optionsInternal.values);
  this.controls.forEach(
  /**
   * @param {ol.control.Control} control Control.
   * @this {ol.PluggableMap}
   */
  function (control) {
    control.setMap(this);
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.controls, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.controls, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.interactions.forEach(
  /**
   * @param {ol.interaction.Interaction} interaction Interaction.
   * @this {ol.PluggableMap}
   */
  function (interaction) {
    interaction.setMap(this);
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.interactions, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.interactions, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.overlays_.forEach(this.addOverlayInternal_, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.overlays_, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    this.addOverlayInternal_(
    /** @type {ol.Overlay} */
    event.element);
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(this.overlays_, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    var overlay =
    /** @type {ol.Overlay} */
    event.element;
    var id = overlay.getId();

    if (id !== undefined) {
      delete this.overlayIdIndex_[id.toString()];
    }

    event.element.setMap(null);
  }, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_PluggableMap_, _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * Add the given control to the map.
 * @param {ol.control.Control} control Control.
 * @api
 */


_ol_PluggableMap_.prototype.addControl = function (control) {
  this.getControls().push(control);
};
/**
 * Add the given interaction to the map.
 * @param {ol.interaction.Interaction} interaction Interaction to add.
 * @api
 */


_ol_PluggableMap_.prototype.addInteraction = function (interaction) {
  this.getInteractions().push(interaction);
};
/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {@link ol.Collection}.
 * @param {ol.layer.Base} layer Layer.
 * @api
 */


_ol_PluggableMap_.prototype.addLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  layers.push(layer);
};
/**
 * Add the given overlay to the map.
 * @param {ol.Overlay} overlay Overlay.
 * @api
 */


_ol_PluggableMap_.prototype.addOverlay = function (overlay) {
  this.getOverlays().push(overlay);
};
/**
 * This deals with map's overlay collection changes.
 * @param {ol.Overlay} overlay Overlay.
 * @private
 */


_ol_PluggableMap_.prototype.addOverlayInternal_ = function (overlay) {
  var id = overlay.getId();

  if (id !== undefined) {
    this.overlayIdIndex_[id.toString()] = overlay;
  }

  overlay.setMap(this);
};
/**
 *
 * @inheritDoc
 */


_ol_PluggableMap_.prototype.disposeInternal = function () {
  this.mapBrowserEventHandler_.dispose();

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlisten(this.viewport_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL, this.handleBrowserEvent, this);

  _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlisten(this.viewport_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);

  if (this.handleResize_ !== undefined) {
    window.removeEventListener(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
    this.handleResize_ = undefined;
  }

  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
    this.animationDelayKey_ = undefined;
  }

  this.setTarget(null);

  _object_js__WEBPACK_IMPORTED_MODULE_9__["default"].prototype.disposeInternal.call(this);
};
/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through the `layerFilter` option in `opt_options`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {@link ol.Feature feature} or
 *     {@link ol.render.Feature render feature} at the pixel, the second is
 *     the {@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T
 * @api
 */


_ol_PluggableMap_.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
  if (!this.frameState_) {
    return;
  }

  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_20__["default"].TRUE;
  return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);
};
/**
 * Get all features that intersect a pixel on the viewport.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {Array.<ol.Feature|ol.render.Feature>} The detected features or
 * `null` if none were found.
 * @api
 */


_ol_PluggableMap_.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
  var features = null;
  this.forEachFeatureAtPixel(pixel, function (feature) {
    if (!features) {
      features = [];
    }

    features.push(feature);
  }, opt_options);
  return features;
};
/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback
 *     Layer callback. This callback will receive two arguments: first is the
 *     {@link ol.layer.Layer layer}, second argument is an array representing
 *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
 *     that do not currently support this argument. To stop detection, callback
 *     functions can return a truthy value.
 * @param {S=} opt_this Value to use as `this` when executing `callback`.
 * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer
 *     filter function. The filter function will receive one argument, the
 *     {@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T,U
 * @api
 */


_ol_PluggableMap_.prototype.forEachLayerAtPixel = function (pixel, callback, opt_this, opt_layerFilter, opt_this2) {
  if (!this.frameState_) {
    return;
  }

  var thisArg = opt_this !== undefined ? opt_this : null;
  var layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_20__["default"].TRUE;
  var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;
  return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, callback, thisArg, layerFilter, thisArg2);
};
/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {boolean} Is there a feature at the given pixel?
 * @template U
 * @api
 */


_ol_PluggableMap_.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
  if (!this.frameState_) {
    return false;
  }

  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_20__["default"].TRUE;
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);
};
/**
 * Returns the coordinate in view projection for a browser event.
 * @param {Event} event Event.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_PluggableMap_.prototype.getEventCoordinate = function (event) {
  return this.getCoordinateFromPixel(this.getEventPixel(event));
};
/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * @param {Event} event Event.
 * @return {ol.Pixel} Pixel.
 * @api
 */


_ol_PluggableMap_.prototype.getEventPixel = function (event) {
  var viewportPosition = this.viewport_.getBoundingClientRect();
  var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
  return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
};
/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 * @return {Element|string|undefined} The Element or id of the Element that the
 *     map is rendered in.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getTarget = function () {
  return (
    /** @type {Element|string|undefined} */
    this.get(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET)
  );
};
/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * @return {Element} The element that the map is rendered in.
 * @api
 */


_ol_PluggableMap_.prototype.getTargetElement = function () {
  var target = this.getTarget();

  if (target !== undefined) {
    return typeof target === 'string' ? document.getElementById(target) : target;
  } else {
    return null;
  }
};
/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * @param {ol.Pixel} pixel Pixel position in the map viewport.
 * @return {ol.Coordinate} The coordinate for the pixel position.
 * @api
 */


_ol_PluggableMap_.prototype.getCoordinateFromPixel = function (pixel) {
  var frameState = this.frameState_;

  if (!frameState) {
    return null;
  } else {
    return _transform_js__WEBPACK_IMPORTED_MODULE_28__["default"].apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
};
/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */


_ol_PluggableMap_.prototype.getControls = function () {
  return this.controls;
};
/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * @return {ol.Collection.<ol.Overlay>} Overlays.
 * @api
 */


_ol_PluggableMap_.prototype.getOverlays = function () {
  return this.overlays_;
};
/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * @param {string|number} id Overlay identifier.
 * @return {ol.Overlay} Overlay.
 * @api
 */


_ol_PluggableMap_.prototype.getOverlayById = function (id) {
  var overlay = this.overlayIdIndex_[id.toString()];
  return overlay !== undefined ? overlay : null;
};
/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 *
 * Interactions are used for e.g. pan, zoom and rotate.
 * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.
 * @api
 */


_ol_PluggableMap_.prototype.getInteractions = function () {
  return this.interactions;
};
/**
 * Get the layergroup associated with this map.
 * @return {ol.layer.Group} A layer group containing the layers in this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getLayerGroup = function () {
  return (
    /** @type {ol.layer.Group} */
    this.get(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP)
  );
};
/**
 * Get the collection of layers associated with this map.
 * @return {!ol.Collection.<ol.layer.Base>} Layers.
 * @api
 */


_ol_PluggableMap_.prototype.getLayers = function () {
  var layers = this.getLayerGroup().getLayers();
  return layers;
};
/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * @param {ol.Coordinate} coordinate A map coordinate.
 * @return {ol.Pixel} A pixel position in the map viewport.
 * @api
 */


_ol_PluggableMap_.prototype.getPixelFromCoordinate = function (coordinate) {
  var frameState = this.frameState_;

  if (!frameState) {
    return null;
  } else {
    return _transform_js__WEBPACK_IMPORTED_MODULE_28__["default"].apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
};
/**
 * Get the map renderer.
 * @return {ol.renderer.Map} Renderer
 */


_ol_PluggableMap_.prototype.getRenderer = function () {
  return this.renderer_;
};
/**
 * Get the size of this map.
 * @return {ol.Size|undefined} The size in pixels of the map in the DOM.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getSize = function () {
  return (
    /** @type {ol.Size|undefined} */
    this.get(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE)
  );
};
/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * @return {ol.View} The view that controls this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getView = function () {
  return (
    /** @type {ol.View} */
    this.get(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW)
  );
};
/**
 * Get the element that serves as the map viewport.
 * @return {Element} Viewport.
 * @api
 */


_ol_PluggableMap_.prototype.getViewport = function () {
  return this.viewport_;
};
/**
 * Get the element that serves as the container for overlays.  Elements added to
 * this container will let mousedown and touchstart events through to the map,
 * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}
 * events.
 * @return {!Element} The map's overlay container.
 */


_ol_PluggableMap_.prototype.getOverlayContainer = function () {
  return this.overlayContainer_;
};
/**
 * Get the element that serves as a container for overlays that don't allow
 * event propagation. Elements added to this container won't let mousedown and
 * touchstart events through to the map, so clicks and gestures on an overlay
 * don't trigger any {@link ol.MapBrowserEvent}.
 * @return {!Element} The map's overlay container that stops events.
 */


_ol_PluggableMap_.prototype.getOverlayContainerStopEvent = function () {
  return this.overlayContainerStopEvent_;
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {ol.Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */


_ol_PluggableMap_.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  var frameState = this.frameState_;

  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_27__["default"].DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_27__["default"].DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels
  // between the center of the tile and the focus.  The factor of 65536 means
  // that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var deltaX = tileCenter[0] - frameState.focus[0];
  var deltaY = tileCenter[1] - frameState.focus[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
};
/**
 * @param {Event} browserEvent Browser event.
 * @param {string=} opt_type Type.
 */


_ol_PluggableMap_.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
  var type = opt_type || browserEvent.type;
  var mapBrowserEvent = new _mapbrowserevent_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, this, browserEvent);
  this.handleMapBrowserEvent(mapBrowserEvent);
};
/**
 * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.
 */


_ol_PluggableMap_.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
  if (!this.frameState_) {
    // With no view defined, we cannot translate pixels into geographical
    // coordinates so interactions cannot be used.
    return;
  }

  this.focus_ = mapBrowserEvent.coordinate;
  mapBrowserEvent.frameState = this.frameState_;
  var interactionsArray = this.getInteractions().getArray();
  var i;

  if (this.dispatchEvent(mapBrowserEvent) !== false) {
    for (i = interactionsArray.length - 1; i >= 0; i--) {
      var interaction = interactionsArray[i];

      if (!interaction.getActive()) {
        continue;
      }

      var cont = interaction.handleEvent(mapBrowserEvent);

      if (!cont) {
        break;
      }
    }
  }
};
/**
 * @protected
 */


_ol_PluggableMap_.prototype.handlePostRender = function () {
  var frameState = this.frameState_; // Manage the tile queue
  // Image loads are expensive and a limited resource, so try to use them
  // efficiently:
  // * When the view is static we allow a large number of parallel tile loads
  //   to complete the frame as quickly as possible.
  // * When animating or interacting, image loads can cause janks, so we reduce
  //   the maximum number of loads per frame and limit the number of parallel
  //   tile loads to remain reactive to view changes and to reduce the chance of
  //   loading tiles that will quickly disappear from view.

  var tileQueue = this.tileQueue_;

  if (!tileQueue.isEmpty()) {
    var maxTotalLoading = 16;
    var maxNewLoads = maxTotalLoading;

    if (frameState) {
      var hints = frameState.viewHints;

      if (hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_13__["default"].ANIMATING]) {
        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
        maxNewLoads = 2;
      }

      if (hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_13__["default"].INTERACTING]) {
        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
        maxNewLoads = 2;
      }
    }

    if (tileQueue.getTilesLoading() < maxTotalLoading) {
      tileQueue.reprioritize(); // FIXME only call if view has changed

      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
    }
  }

  var postRenderFunctions = this.postRenderFunctions_;
  var i, ii;

  for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
    postRenderFunctions[i](this, frameState);
  }

  postRenderFunctions.length = 0;
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleSizeChanged_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleTargetChanged_ = function () {
  // target may be undefined, null, a string or an Element.
  // If it's a string we convert it to an Element before proceeding.
  // If it's not now an Element we remove the viewport from the DOM.
  // If it's an Element we append the viewport element to it.
  var targetElement;

  if (this.getTarget()) {
    targetElement = this.getTargetElement();
  }

  if (this.keyHandlerKeys_) {
    for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
      _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlistenByKey(this.keyHandlerKeys_[i]);
    }

    this.keyHandlerKeys_ = null;
  }

  if (!targetElement) {
    this.renderer_.removeLayerRenderers();

    _dom_js__WEBPACK_IMPORTED_MODULE_15__["default"].removeNode(this.viewport_);

    if (this.handleResize_ !== undefined) {
      window.removeEventListener(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
  } else {
    targetElement.appendChild(this.viewport_);
    var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
    this.keyHandlerKeys_ = [_events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(keyboardEventTarget, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].KEYDOWN, this.handleBrowserEvent, this), _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(keyboardEventTarget, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].KEYPRESS, this.handleBrowserEvent, this)];

    if (!this.handleResize_) {
      this.handleResize_ = this.updateSize.bind(this);
      window.addEventListener(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
    }
  }

  this.updateSize(); // updateSize calls setSize, so no need to call this.render
  // ourselves here.
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleTileChange_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleViewPropertyChanged_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleViewChanged_ = function () {
  if (this.viewPropertyListenerKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlistenByKey(this.viewPropertyListenerKey_);

    this.viewPropertyListenerKey_ = null;
  }

  if (this.viewChangeListenerKey_) {
    _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlistenByKey(this.viewChangeListenerKey_);

    this.viewChangeListenerKey_ = null;
  }

  var view = this.getView();

  if (view) {
    this.viewport_.setAttribute('data-view', _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(view));
    this.viewPropertyListenerKey_ = _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(view, _objecteventtype_js__WEBPACK_IMPORTED_MODULE_10__["default"].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
    this.viewChangeListenerKey_ = _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(view, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].CHANGE, this.handleViewPropertyChanged_, this);
  }

  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleLayerGroupChanged_ = function () {
  if (this.layerGroupPropertyListenerKeys_) {
    this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_16__["default"].unlistenByKey);
    this.layerGroupPropertyListenerKeys_ = null;
  }

  var layerGroup = this.getLayerGroup();

  if (layerGroup) {
    this.layerGroupPropertyListenerKeys_ = [_events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(layerGroup, _objecteventtype_js__WEBPACK_IMPORTED_MODULE_10__["default"].PROPERTYCHANGE, this.render, this), _events_js__WEBPACK_IMPORTED_MODULE_16__["default"].listen(layerGroup, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_18__["default"].CHANGE, this.render, this)];
  }

  this.render();
};
/**
 * @return {boolean} Is rendered.
 */


_ol_PluggableMap_.prototype.isRendered = function () {
  return !!this.frameState_;
};
/**
 * Requests an immediate render in a synchronous manner.
 * @api
 */


_ol_PluggableMap_.prototype.renderSync = function () {
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
  }

  this.animationDelay_();
};
/**
 * Request a map rendering (at the next animation frame).
 * @api
 */


_ol_PluggableMap_.prototype.render = function () {
  if (this.animationDelayKey_ === undefined) {
    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
  }
};
/**
 * Remove the given control from the map.
 * @param {ol.control.Control} control Control.
 * @return {ol.control.Control|undefined} The removed control (or undefined
 *     if the control was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeControl = function (control) {
  return this.getControls().remove(control);
};
/**
 * Remove the given interaction from the map.
 * @param {ol.interaction.Interaction} interaction Interaction to remove.
 * @return {ol.interaction.Interaction|undefined} The removed interaction (or
 *     undefined if the interaction was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeInteraction = function (interaction) {
  return this.getInteractions().remove(interaction);
};
/**
 * Removes the given layer from the map.
 * @param {ol.layer.Base} layer Layer.
 * @return {ol.layer.Base|undefined} The removed layer (or undefined if the
 *     layer was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  return layers.remove(layer);
};
/**
 * Remove the given overlay from the map.
 * @param {ol.Overlay} overlay Overlay.
 * @return {ol.Overlay|undefined} The removed overlay (or undefined
 *     if the overlay was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeOverlay = function (overlay) {
  return this.getOverlays().remove(overlay);
};
/**
 * @param {number} time Time.
 * @private
 */


_ol_PluggableMap_.prototype.renderFrame_ = function (time) {
  var i, ii, viewState;
  var size = this.getSize();
  var view = this.getView();

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].createEmpty();

  var previousFrameState = this.frameState_;
  /** @type {?olx.FrameState} */

  var frameState = null;

  if (size !== undefined && _size_js__WEBPACK_IMPORTED_MODULE_26__["default"].hasArea(size) && view && view.isDef()) {
    var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    var layerStates = {};

    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
    }

    viewState = view.getState();
    var center = viewState.center;
    var pixelResolution = viewState.resolution / this.pixelRatio_;
    center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;
    center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;
    frameState =
    /** @type {olx.FrameState} */
    {
      animate: false,
      coordinateToPixelTransform: this.coordinateToPixelTransform_,
      extent: extent,
      focus: !this.focus_ ? center : this.focus_,
      index: this.frameIndex_++,
      layerStates: layerStates,
      layerStatesArray: layerStatesArray,
      logos: _obj_js__WEBPACK_IMPORTED_MODULE_23__["default"].assign({}, this.logos_),
      pixelRatio: this.pixelRatio_,
      pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
      postRenderFunctions: [],
      size: size,
      skippedFeatureUids: this.skippedFeatureUids_,
      tileQueue: this.tileQueue_,
      time: time,
      usedTiles: {},
      viewState: viewState,
      viewHints: viewHints,
      wantedTiles: {}
    };
  }

  if (frameState) {
    frameState.extent = _extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);
  }

  this.frameState_ = frameState;
  this.renderer_.renderFrame(frameState);

  if (frameState) {
    if (frameState.animate) {
      this.render();
    }

    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

    if (previousFrameState) {
      var moveStart = !this.previousExtent_ || !_extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].isEmpty(this.previousExtent_) && !_extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].equals(frameState.extent, this.previousExtent_);

      if (moveStart) {
        this.dispatchEvent(new _mapevent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_mapeventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVESTART, this, previousFrameState));
        this.previousExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].createOrUpdateEmpty(this.previousExtent_);
      }
    }

    var idle = this.previousExtent_ && !frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_13__["default"].ANIMATING] && !frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_13__["default"].INTERACTING] && !_extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].equals(frameState.extent, this.previousExtent_);

    if (idle) {
      this.dispatchEvent(new _mapevent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_mapeventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVEEND, this, frameState));

      _extent_js__WEBPACK_IMPORTED_MODULE_19__["default"].clone(frameState.extent, this.previousExtent_);
    }
  }

  this.dispatchEvent(new _mapevent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_mapeventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, this, frameState));
  setTimeout(this.handlePostRender.bind(this), 0);
};
/**
 * Sets the layergroup of this map.
 * @param {ol.layer.Group} layerGroup A layer group containing the layers in
 *     this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setLayerGroup = function (layerGroup) {
  this.set(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP, layerGroup);
};
/**
 * Set the size of this map.
 * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setSize = function (size) {
  this.set(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE, size);
};
/**
 * Set the target element to render this map into.
 * @param {Element|string|undefined} target The Element or id of the Element
 *     that the map is rendered in.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setTarget = function (target) {
  this.set(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET, target);
};
/**
 * Set the view for this map.
 * @param {ol.View} view The view that controls this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setView = function (view) {
  this.set(_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW, view);
};
/**
 * @param {ol.Feature} feature Feature.
 */


_ol_PluggableMap_.prototype.skipFeature = function (feature) {
  var featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  this.skippedFeatureUids_[featureUid] = true;
  this.render();
};
/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * @api
 */


_ol_PluggableMap_.prototype.updateSize = function () {
  var targetElement = this.getTargetElement();

  if (!targetElement) {
    this.setSize(undefined);
  } else {
    var computedStyle = getComputedStyle(targetElement);
    this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
  }
};
/**
 * @param {ol.Feature} feature Feature.
 */


_ol_PluggableMap_.prototype.unskipFeature = function (feature) {
  var featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  delete this.skippedFeatureUids_[featureUid];
  this.render();
};
/**
 * @type {Array.<ol.renderer.Type>}
 * @const
 */


_ol_PluggableMap_.DEFAULT_RENDERER_TYPES = [_renderer_type_js__WEBPACK_IMPORTED_MODULE_25__["default"].CANVAS, _renderer_type_js__WEBPACK_IMPORTED_MODULE_25__["default"].WEBGL];
/**
 * @const
 * @type {string}
 */

_ol_PluggableMap_.LOGO_URL = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI' + 'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA' + 'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW' + 'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY' + 'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX' + 'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk' + 'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW' + '2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP' + 'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT' + 'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar' + 'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi' + 'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn' + 'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF' + 'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ' + 'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC' + 'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe' + '0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8' + 'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a' + 'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn' + 'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg' + 'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';
/**
 * @param {olx.MapOptions} options Map options.
 * @return {ol.MapOptionsInternal} Internal map options.
 */

_ol_PluggableMap_.createOptionsInternal = function (options) {
  /**
   * @type {Element|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object.<string, *>}
   */


  var values = {};
  var logos = {};

  if (options.logo === undefined || typeof options.logo === 'boolean' && options.logo) {
    logos[_ol_PluggableMap_.LOGO_URL] = 'https://openlayers.org/';
  } else {
    var logo = options.logo;

    if (typeof logo === 'string') {
      logos[logo] = '';
    } else if (logo instanceof HTMLElement) {
      logos[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(logo).toString()] = logo;
    } else if (logo) {
      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.


      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.


      logos[logo.src] = logo.href;
    }
  }

  var layerGroup = options.layers instanceof _layer_group_js__WEBPACK_IMPORTED_MODULE_22__["default"] ? options.layers : new _layer_group_js__WEBPACK_IMPORTED_MODULE_22__["default"]({
    layers: options.layers
  });
  values[_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP] = layerGroup;
  values[_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET] = options.target;
  values[_mapproperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW] = options.view !== undefined ? options.view : new _view_js__WEBPACK_IMPORTED_MODULE_12__["default"]();
  /**
   * @type {Array.<ol.renderer.Type>}
   */

  var rendererTypes;

  if (options.renderer !== undefined) {
    if (Array.isArray(options.renderer)) {
      rendererTypes = options.renderer;
    } else if (typeof options.renderer === 'string') {
      rendererTypes = [options.renderer];
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(false, 46); // Incorrect format for `renderer` option

    }

    if (rendererTypes.indexOf(
    /** @type {ol.renderer.Type} */
    'dom') >= 0) {
      rendererTypes = rendererTypes.concat(_ol_PluggableMap_.DEFAULT_RENDERER_TYPES);
    }
  } else {
    rendererTypes = _ol_PluggableMap_.DEFAULT_RENDERER_TYPES;
  }
  /**
   * @type {olx.MapRendererPlugin}
   */


  var mapRendererPlugin;

  var mapRendererPlugins = _plugins_js__WEBPACK_IMPORTED_MODULE_24__["default"].getMapRendererPlugins();

  outer: for (var i = 0, ii = rendererTypes.length; i < ii; ++i) {
    var rendererType = rendererTypes[i];

    for (var j = 0, jj = mapRendererPlugins.length; j < jj; ++j) {
      var candidate = mapRendererPlugins[j];

      if (candidate['handles'](rendererType)) {
        mapRendererPlugin = candidate;
        break outer;
      }
    }
  }

  if (!mapRendererPlugin) {
    throw new Error('Unable to create a map renderer for types: ' + rendererTypes.join(', '));
  }

  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.controls.slice());
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(options.controls instanceof _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"], 47); // Expected `controls` to be an array or an `ol.Collection`


      controls = options.controls;
    }
  }

  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.interactions.slice());
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(options.interactions instanceof _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"], 48); // Expected `interactions` to be an array or an `ol.Collection`


      interactions = options.interactions;
    }
  }

  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.overlays.slice());
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_14__["default"].assert(options.overlays instanceof _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"], 49); // Expected `overlays` to be an array or an `ol.Collection`


      overlays = options.overlays;
    }
  } else {
    overlays = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    logos: logos,
    overlays: overlays,
    mapRendererPlugin: mapRendererPlugin,
    values: values
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_PluggableMap_);

/***/ }),

/***/ "./node_modules/ol/plugins.js":
/*!************************************!*\
  !*** ./node_modules/ol/plugins.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _plugintype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugintype.js */ "./node_modules/ol/plugintype.js");

var _ol_plugins_ = {};
/**
 * The registry of map renderer plugins.
 * @type {Array<olx.MapRendererPlugin>}
 * @private
 */

_ol_plugins_.mapRendererPlugins_ = [];
/**
 * Get all registered map renderer plugins.
 * @return {Array<olx.MapRendererPlugin>} The registered map renderer plugins.
 */

_ol_plugins_.getMapRendererPlugins = function () {
  return _ol_plugins_.mapRendererPlugins_;
};
/**
 * The registry of layer renderer plugins.
 * @type {Array<olx.LayerRendererPlugin>}
 * @private
 */


_ol_plugins_.layerRendererPlugins_ = [];
/**
 * Get all registered layer renderer plugins.
 * @return {Array<olx.LayerRendererPlugin>} The registered layer renderer plugins.
 */

_ol_plugins_.getLayerRendererPlugins = function () {
  return _ol_plugins_.layerRendererPlugins_;
};
/**
 * Register a plugin.
 * @param {ol.PluginType} type The plugin type.
 * @param {*} plugin The plugin.
 */


_ol_plugins_.register = function (type, plugin) {
  var plugins;

  switch (type) {
    case _plugintype_js__WEBPACK_IMPORTED_MODULE_0__["default"].MAP_RENDERER:
      {
        plugins = _ol_plugins_.mapRendererPlugins_;
        plugins.push(
        /** @type {olx.MapRendererPlugin} */
        plugin);
        break;
      }

    case _plugintype_js__WEBPACK_IMPORTED_MODULE_0__["default"].LAYER_RENDERER:
      {
        plugins = _ol_plugins_.layerRendererPlugins_;
        plugins.push(
        /** @type {olx.LayerRendererPlugin} */
        plugin);
        break;
      }

    default:
      {
        throw new Error('Unsupported plugin type: ' + type);
      }
  }
};
/**
 * Register multiple plugins.
 * @param {ol.PluginType} type The plugin type.
 * @param {Array} plugins The plugins.
 */


_ol_plugins_.registerMultiple = function (type, plugins) {
  for (var i = 0, ii = plugins.length; i < ii; ++i) {
    _ol_plugins_.register(type, plugins[i]);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_plugins_);

/***/ }),

/***/ "./node_modules/ol/plugintype.js":
/*!***************************************!*\
  !*** ./node_modules/ol/plugintype.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A plugin type used when registering a plugin.  The supported plugin types are
 * 'MAP_RENDERER', and 'LAYER_RENDERER'.
 * @enum {string}
 */
var _ol_PluginType_ = {
  MAP_RENDERER: 'MAP_RENDERER',
  LAYER_RENDERER: 'LAYER_RENDERER'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_PluginType_);

/***/ }),

/***/ "./node_modules/ol/pointer/eventsource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/eventsource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @param {!Object.<string, function(Event)>} mapping Event
 *     mapping.
 * @constructor
 */
var _ol_pointer_EventSource_ = function (dispatcher, mapping) {
  /**
   * @type {ol.pointer.PointerEventHandler}
   */
  this.dispatcher = dispatcher;
  /**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */

  this.mapping_ = mapping;
};
/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */


_ol_pointer_EventSource_.prototype.getEvents = function () {
  return Object.keys(this.mapping_);
};
/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */


_ol_pointer_EventSource_.prototype.getHandlerForEvent = function (eventType) {
  return this.mapping_[eventType];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_EventSource_);

/***/ }),

/***/ "./node_modules/ol/pointer/eventtype.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/eventtype.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_pointer_EventType_ = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_EventType_);

/***/ }),

/***/ "./node_modules/ol/pointer/mousesource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/mousesource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pointer/eventsource.js */ "./node_modules/ol/pointer/eventsource.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */

var _ol_pointer_MouseSource_ = function (dispatcher) {
  var mapping = {
    'mousedown': this.mousedown,
    'mousemove': this.mousemove,
    'mouseup': this.mouseup,
    'mouseover': this.mouseover,
    'mouseout': this.mouseout
  };

  _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {Array.<ol.Pixel>}
   */

  this.lastTouches = [];
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_MouseSource_, _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {number}
 */


_ol_pointer_MouseSource_.POINTER_ID = 1;
/**
 * @const
 * @type {string}
 */

_ol_pointer_MouseSource_.POINTER_TYPE = 'mouse';
/**
 * Radius around touchend that swallows mouse events.
 *
 * @const
 * @type {number}
 */

_ol_pointer_MouseSource_.DEDUP_DIST = 25;
/**
 * Detect if a mouse event was simulated from a touch by
 * checking if previously there was a touch event at the
 * same position.
 *
 * FIXME - Known problem with the native Android browser on
 * Samsung GT-I9100 (Android 4.1.2):
 * In case the page is scrolled, this function does not work
 * correctly when a canvas is used (WebGL or canvas renderer).
 * Mouse listeners on canvas elements (for this browser), create
 * two mouse events: One 'good' and one 'bad' one (on other browsers or
 * when a div is used, there is only one event). For the 'bad' one,
 * clientX/clientY and also pageX/pageY are wrong when the page
 * is scrolled. Because of that, this function can not detect if
 * the events were simulated from a touch event. As result, a
 * pointer event at a wrong position is dispatched, which confuses
 * the map interactions.
 * It is unclear, how one can get the correct position for the event
 * or detect that the positions are invalid.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {boolean} True, if the event was generated by a touch.
 */

_ol_pointer_MouseSource_.prototype.isEventSimulatedFromTouch_ = function (inEvent) {
  var lts = this.lastTouches;
  var x = inEvent.clientX,
      y = inEvent.clientY;

  for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
    // simulated mouse events will be swallowed near a primary touchend
    var dx = Math.abs(x - t[0]),
        dy = Math.abs(y - t[1]);

    if (dx <= _ol_pointer_MouseSource_.DEDUP_DIST && dy <= _ol_pointer_MouseSource_.DEDUP_DIST) {
      return true;
    }
  }

  return false;
};
/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */


_ol_pointer_MouseSource_.prepareEvent = function (inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent); // forward mouse preventDefault

  var pd = e.preventDefault;

  e.preventDefault = function () {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = _ol_pointer_MouseSource_.POINTER_ID;
  e.isPrimary = true;
  e.pointerType = _ol_pointer_MouseSource_.POINTER_TYPE;
  return e;
};
/**
 * Handler for `mousedown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mousedown = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (_ol_pointer_MouseSource_.POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }

    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
};
/**
 * Handler for `mousemove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mousemove = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.move(e, inEvent);
  }
};
/**
 * Handler for `mouseup`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseup = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
};
/**
 * Handler for `mouseover`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseover = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.enterOver(e, inEvent);
  }
};
/**
 * Handler for `mouseout`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseout = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.leaveOut(e, inEvent);
  }
};
/**
 * Dispatches a `pointercancel` event.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.cancel = function (inEvent) {
  var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

  this.dispatcher.cancel(e, inEvent);
  this.cleanupMouse();
};
/**
 * Remove the mouse from the list of active pointers.
 */


_ol_pointer_MouseSource_.prototype.cleanupMouse = function () {
  delete this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_MouseSource_);

/***/ }),

/***/ "./node_modules/ol/pointer/mssource.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/pointer/mssource.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pointer/eventsource.js */ "./node_modules/ol/pointer/eventsource.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */

var _ol_pointer_MsSource_ = function (dispatcher) {
  var mapping = {
    'MSPointerDown': this.msPointerDown,
    'MSPointerMove': this.msPointerMove,
    'MSPointerUp': this.msPointerUp,
    'MSPointerOut': this.msPointerOut,
    'MSPointerOver': this.msPointerOver,
    'MSPointerCancel': this.msPointerCancel,
    'MSGotPointerCapture': this.msGotPointerCapture,
    'MSLostPointerCapture': this.msLostPointerCapture
  };

  _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {Array.<string>}
   */

  this.POINTER_TYPES = ['', 'unavailable', 'touch', 'pen', 'mouse'];
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_MsSource_, _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {Object} The copied event.
 */


_ol_pointer_MsSource_.prototype.prepareEvent_ = function (inEvent) {
  var e = inEvent;

  if (typeof inEvent.pointerType === 'number') {
    e = this.dispatcher.cloneEvent(inEvent, inEvent);
    e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
  }

  return e;
};
/**
 * Remove this pointer from the list of active pointers.
 * @param {number} pointerId Pointer identifier.
 */


_ol_pointer_MsSource_.prototype.cleanup = function (pointerId) {
  delete this.pointerMap[pointerId.toString()];
};
/**
 * Handler for `msPointerDown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerDown = function (inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
};
/**
 * Handler for `msPointerMove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerMove = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
};
/**
 * Handler for `msPointerUp`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerUp = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
/**
 * Handler for `msPointerOut`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerOut = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
};
/**
 * Handler for `msPointerOver`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerOver = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
};
/**
 * Handler for `msPointerCancel`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerCancel = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
/**
 * Handler for `msLostPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msLostPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
/**
 * Handler for `msGotPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msGotPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_MsSource_);

/***/ }),

/***/ "./node_modules/ol/pointer/nativesource.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/nativesource.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pointer/eventsource.js */ "./node_modules/ol/pointer/eventsource.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */

var _ol_pointer_NativeSource_ = function (dispatcher) {
  var mapping = {
    'pointerdown': this.pointerDown,
    'pointermove': this.pointerMove,
    'pointerup': this.pointerUp,
    'pointerout': this.pointerOut,
    'pointerover': this.pointerOver,
    'pointercancel': this.pointerCancel,
    'gotpointercapture': this.gotPointerCapture,
    'lostpointercapture': this.lostPointerCapture
  };

  _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, dispatcher, mapping);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_NativeSource_, _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Handler for `pointerdown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerDown = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointermove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerMove = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerup`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerUp = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerout`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerOut = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerover`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerOver = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointercancel`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerCancel = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `lostpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.lostPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `gotpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.gotPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_NativeSource_);

/***/ }),

/***/ "./node_modules/ol/pointer/pointerevent.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/pointerevent.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/**
 * A class for pointer events.
 *
 * This class is used as an abstraction for mouse events,
 * touch events and even native pointer events.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @param {string} type The type of the event to create.
 * @param {Event} originalEvent The event.
 * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of
 *    initial event properties.
 */

var _ol_pointer_PointerEvent_ = function (type, originalEvent, opt_eventDict) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, type);
  /**
   * @const
   * @type {Event}
   */


  this.originalEvent = originalEvent;
  var eventDict = opt_eventDict ? opt_eventDict : {};
  /**
   * @type {number}
   */

  this.buttons = this.getButtons_(eventDict);
  /**
   * @type {number}
   */

  this.pressure = this.getPressure_(eventDict, this.buttons); // MouseEvent related properties

  /**
   * @type {boolean}
   */

  this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;
  /**
   * @type {boolean}
   */

  this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;
  /**
   * @type {Object}
   */

  this.view = 'view' in eventDict ? eventDict['view'] : null;
  /**
   * @type {number}
   */

  this.detail = 'detail' in eventDict ? eventDict['detail'] : null;
  /**
   * @type {number}
   */

  this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;
  /**
   * @type {number}
   */

  this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;
  /**
   * @type {number}
   */

  this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;
  /**
   * @type {number}
   */

  this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;
  /**
   * @type {boolean}
   */

  this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;
  /**
   * @type {boolean}
   */

  this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;
  /**
   * @type {boolean}
   */

  this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;
  /**
   * @type {boolean}
   */

  this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;
  /**
   * @type {number}
   */

  this.button = 'button' in eventDict ? eventDict['button'] : 0;
  /**
   * @type {Node}
   */

  this.relatedTarget = 'relatedTarget' in eventDict ? eventDict['relatedTarget'] : null; // PointerEvent related properties

  /**
   * @const
   * @type {number}
   */

  this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;
  /**
   * @type {number}
   */

  this.width = 'width' in eventDict ? eventDict['width'] : 0;
  /**
   * @type {number}
   */

  this.height = 'height' in eventDict ? eventDict['height'] : 0;
  /**
   * @type {number}
   */

  this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;
  /**
   * @type {number}
   */

  this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;
  /**
   * @type {string}
   */

  this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';
  /**
   * @type {number}
   */

  this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;
  /**
   * @type {boolean}
   */

  this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false; // keep the semantics of preventDefault

  if (originalEvent.preventDefault) {
    this.preventDefault = function () {
      originalEvent.preventDefault();
    };
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_PointerEvent_, _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */


_ol_pointer_PointerEvent_.prototype.getButtons_ = function (eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;

  if (eventDict.buttons || _ol_pointer_PointerEvent_.HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1:
        buttons = 1;
        break;

      case 2:
        buttons = 4;
        break;

      case 3:
        buttons = 2;
        break;

      default:
        buttons = 0;
    }
  }

  return buttons;
};
/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */


_ol_pointer_PointerEvent_.prototype.getPressure_ = function (eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;

  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }

  return pressure;
};
/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */


_ol_pointer_PointerEvent_.HAS_BUTTONS = false;
/**
 * Checks if the `buttons` property is supported.
 */

(function () {
  try {
    var ev = new MouseEvent('click', {
      buttons: 1
    });
    _ol_pointer_PointerEvent_.HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {// pass
  }
})();

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_PointerEvent_);

/***/ }),

/***/ "./node_modules/ol/pointer/pointereventhandler.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/pointer/pointereventhandler.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pointer/eventtype.js */ "./node_modules/ol/pointer/eventtype.js");
/* harmony import */ var _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pointer/mousesource.js */ "./node_modules/ol/pointer/mousesource.js");
/* harmony import */ var _pointer_mssource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../pointer/mssource.js */ "./node_modules/ol/pointer/mssource.js");
/* harmony import */ var _pointer_nativesource_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pointer/nativesource.js */ "./node_modules/ol/pointer/nativesource.js");
/* harmony import */ var _pointer_pointerevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pointer/pointerevent.js */ "./node_modules/ol/pointer/pointerevent.js");
/* harmony import */ var _pointer_touchsource_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pointer/touchsource.js */ "./node_modules/ol/pointer/touchsource.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.










/**
 * @constructor
 * @extends {ol.events.EventTarget}
 * @param {Element|HTMLDocument} element Viewport element.
 */

var _ol_pointer_PointerEventHandler_ = function (element) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @const
   * @private
   * @type {Element|HTMLDocument}
   */


  this.element_ = element;
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */

  this.pointerMap = {};
  /**
   * @type {Object.<string, function(Event)>}
   * @private
   */

  this.eventMap_ = {};
  /**
   * @type {Array.<ol.pointer.EventSource>}
   * @private
   */

  this.eventSourceList_ = [];
  this.registerSources();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_PointerEventHandler_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Set up the event sources (mouse, touch and native pointers)
 * that generate pointer events.
 */


_ol_pointer_PointerEventHandler_.prototype.registerSources = function () {
  if (_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTER) {
    this.registerSource('native', new _pointer_nativesource_js__WEBPACK_IMPORTED_MODULE_7__["default"](this));
  } else if (_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].MSPOINTER) {
    this.registerSource('ms', new _pointer_mssource_js__WEBPACK_IMPORTED_MODULE_6__["default"](this));
  } else {
    var mouseSource = new _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    this.registerSource('mouse', mouseSource);

    if (_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOUCH) {
      this.registerSource('touch', new _pointer_touchsource_js__WEBPACK_IMPORTED_MODULE_9__["default"](this, mouseSource));
    }
  } // register events on the viewport element


  this.register_();
};
/**
 * Add a new event source that will generate pointer events.
 *
 * @param {string} name A name for the event source
 * @param {ol.pointer.EventSource} source The source event.
 */


_ol_pointer_PointerEventHandler_.prototype.registerSource = function (name, source) {
  var s = source;
  var newEvents = s.getEvents();

  if (newEvents) {
    newEvents.forEach(function (e) {
      var handler = s.getHandlerForEvent(e);

      if (handler) {
        this.eventMap_[e] = handler.bind(s);
      }
    }, this);
    this.eventSourceList_.push(s);
  }
};
/**
 * Set up the events for all registered event sources.
 * @private
 */


_ol_pointer_PointerEventHandler_.prototype.register_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;

  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.addEvents_(eventSource.getEvents());
  }
};
/**
 * Remove all registered events.
 * @private
 */


_ol_pointer_PointerEventHandler_.prototype.unregister_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;

  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.removeEvents_(eventSource.getEvents());
  }
};
/**
 * Calls the right handler for a new event.
 * @private
 * @param {Event} inEvent Browser event.
 */


_ol_pointer_PointerEventHandler_.prototype.eventHandler_ = function (inEvent) {
  var type = inEvent.type;
  var handler = this.eventMap_[type];

  if (handler) {
    handler(inEvent);
  }
};
/**
 * Setup listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */


_ol_pointer_PointerEventHandler_.prototype.addEvents_ = function (events) {
  events.forEach(function (eventName) {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].listen(this.element_, eventName, this.eventHandler_, this);
  }, this);
};
/**
 * Unregister listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */


_ol_pointer_PointerEventHandler_.prototype.removeEvents_ = function (events) {
  events.forEach(function (e) {
    _events_js__WEBPACK_IMPORTED_MODULE_1__["default"].unlisten(this.element_, e, this.eventHandler_, this);
  }, this);
};
/**
 * Returns a snapshot of inEvent, with writable properties.
 *
 * @param {Event} event Browser event.
 * @param {Event|Touch} inEvent An event that contains
 *    properties to copy.
 * @return {Object} An object containing shallow copies of
 *    `inEvent`'s properties.
 */


_ol_pointer_PointerEventHandler_.prototype.cloneEvent = function (event, inEvent) {
  var eventCopy = {},
      p;

  for (var i = 0, ii = _ol_pointer_PointerEventHandler_.CLONE_PROPS.length; i < ii; i++) {
    p = _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][0];
    eventCopy[p] = event[p] || inEvent[p] || _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][1];
  }

  return eventCopy;
}; // EVENTS

/**
 * Triggers a 'pointerdown' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.down = function (data, event) {
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERDOWN, data, event);
};
/**
 * Triggers a 'pointermove' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.move = function (data, event) {
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERMOVE, data, event);
};
/**
 * Triggers a 'pointerup' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.up = function (data, event) {
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERUP, data, event);
};
/**
 * Triggers a 'pointerenter' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.enter = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERENTER, data, event);
};
/**
 * Triggers a 'pointerleave' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.leave = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERLEAVE, data, event);
};
/**
 * Triggers a 'pointerover' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.over = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTEROVER, data, event);
};
/**
 * Triggers a 'pointerout' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.out = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTEROUT, data, event);
};
/**
 * Triggers a 'pointercancel' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.cancel = function (data, event) {
  this.fireEvent(_pointer_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERCANCEL, data, event);
};
/**
 * Triggers a combination of 'pointerout' and 'pointerleave' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.leaveOut = function (data, event) {
  this.out(data, event);

  if (!this.contains_(data.target, data.relatedTarget)) {
    this.leave(data, event);
  }
};
/**
 * Triggers a combination of 'pointerover' and 'pointerevents' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.enterOver = function (data, event) {
  this.over(data, event);

  if (!this.contains_(data.target, data.relatedTarget)) {
    this.enter(data, event);
  }
};
/**
 * @private
 * @param {Element} container The container element.
 * @param {Element} contained The contained element.
 * @return {boolean} Returns true if the container element
 *   contains the other element.
 */


_ol_pointer_PointerEventHandler_.prototype.contains_ = function (container, contained) {
  if (!container || !contained) {
    return false;
  }

  return container.contains(contained);
}; // EVENT CREATION AND TRACKING

/**
 * Creates a new Event of type `inType`, based on the information in
 * `data`.
 *
 * @param {string} inType A string representing the type of event to create.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.
 */


_ol_pointer_PointerEventHandler_.prototype.makeEvent = function (inType, data, event) {
  return new _pointer_pointerevent_js__WEBPACK_IMPORTED_MODULE_8__["default"](inType, event, data);
};
/**
 * Make and dispatch an event in one call.
 * @param {string} inType A string representing the type of event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.fireEvent = function (inType, data, event) {
  var e = this.makeEvent(inType, data, event);
  this.dispatchEvent(e);
};
/**
 * Creates a pointer event from a native pointer event
 * and dispatches this event.
 * @param {Event} event A platform event with a target.
 */


_ol_pointer_PointerEventHandler_.prototype.fireNativeEvent = function (event) {
  var e = this.makeEvent(event.type, event, event);
  this.dispatchEvent(e);
};
/**
 * Wrap a native mouse event into a pointer event.
 * This proxy method is required for the legacy IE support.
 * @param {string} eventType The pointer event type.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} The wrapped event.
 */


_ol_pointer_PointerEventHandler_.prototype.wrapMouseEvent = function (eventType, event) {
  var pointerEvent = this.makeEvent(eventType, _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_5__["default"].prepareEvent(event, this), event);
  return pointerEvent;
};
/**
 * @inheritDoc
 */


_ol_pointer_PointerEventHandler_.prototype.disposeInternal = function () {
  this.unregister_();

  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.disposeInternal.call(this);
};
/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */


_ol_pointer_PointerEventHandler_.CLONE_PROPS = [// MouseEvent
['bubbles', false], ['cancelable', false], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', false], ['altKey', false], ['shiftKey', false], ['metaKey', false], ['button', 0], ['relatedTarget', null], // DOM Level 3
['buttons', 0], // PointerEvent
['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', false], // event instance
['type', ''], ['target', null], ['currentTarget', null], ['which', 0]];
/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_PointerEventHandler_);

/***/ }),

/***/ "./node_modules/ol/pointer/touchsource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/touchsource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointer/eventsource.js */ "./node_modules/ol/pointer/eventsource.js");
/* harmony import */ var _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointer/mousesource.js */ "./node_modules/ol/pointer/mousesource.js");
// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @constructor
 * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.
 * @param {ol.pointer.MouseSource} mouseSource Mouse source.
 * @extends {ol.pointer.EventSource}
 */

var _ol_pointer_TouchSource_ = function (dispatcher, mouseSource) {
  var mapping = {
    'touchstart': this.touchstart,
    'touchmove': this.touchmove,
    'touchend': this.touchend,
    'touchcancel': this.touchcancel
  };

  _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {ol.pointer.MouseSource}
   */

  this.mouseSource = mouseSource;
  /**
   * @private
   * @type {number|undefined}
   */

  this.firstTouchId_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.clickCount_ = 0;
  /**
   * @private
   * @type {number|undefined}
   */

  this.resetId_ = undefined;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_pointer_TouchSource_, _pointer_eventsource_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Mouse event timeout: This should be long enough to
 * ignore compat mouse events made by touch.
 * @const
 * @type {number}
 */


_ol_pointer_TouchSource_.DEDUP_TIMEOUT = 2500;
/**
 * @const
 * @type {number}
 */

_ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT = 200;
/**
 * @const
 * @type {string}
 */

_ol_pointer_TouchSource_.POINTER_TYPE = 'touch';
/**
 * @private
 * @param {Touch} inTouch The in touch.
 * @return {boolean} True, if this is the primary touch.
 */

_ol_pointer_TouchSource_.prototype.isPrimaryTouch_ = function (inTouch) {
  return this.firstTouchId_ === inTouch.identifier;
};
/**
 * Set primary touch if there are no pointers, or the only pointer is the mouse.
 * @param {Touch} inTouch The in touch.
 * @private
 */


_ol_pointer_TouchSource_.prototype.setPrimaryTouch_ = function (inTouch) {
  var count = Object.keys(this.pointerMap).length;

  if (count === 0 || count === 1 && _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTER_ID.toString() in this.pointerMap) {
    this.firstTouchId_ = inTouch.identifier;
    this.cancelResetClickCount_();
  }
};
/**
 * @private
 * @param {Object} inPointer The in pointer object.
 */


_ol_pointer_TouchSource_.prototype.removePrimaryPointer_ = function (inPointer) {
  if (inPointer.isPrimary) {
    this.firstTouchId_ = undefined;
    this.resetClickCount_();
  }
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.resetClickCount_ = function () {
  this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), _ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT);
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.resetClickCountHandler_ = function () {
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.cancelResetClickCount_ = function () {
  if (this.resetId_ !== undefined) {
    clearTimeout(this.resetId_);
  }
};
/**
 * @private
 * @param {Event} browserEvent Browser event
 * @param {Touch} inTouch Touch event
 * @return {Object} A pointer object.
 */


_ol_pointer_TouchSource_.prototype.touchToPointer_ = function (browserEvent, inTouch) {
  var e = this.dispatcher.cloneEvent(browserEvent, inTouch); // Spec specifies that pointerId 1 is reserved for Mouse.
  // Touch identifiers can start at 0.
  // Add 2 to the touch identifier for compatibility.

  e.pointerId = inTouch.identifier + 2; // TODO: check if this is necessary?
  //e.target = findTarget(e);

  e.bubbles = true;
  e.cancelable = true;
  e.detail = this.clickCount_;
  e.button = 0;
  e.buttons = 1;
  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
  e.isPrimary = this.isPrimaryTouch_(inTouch);
  e.pointerType = _ol_pointer_TouchSource_.POINTER_TYPE; // make sure that the properties that are different for
  // each `Touch` object are not copied from the BrowserEvent object

  e.clientX = inTouch.clientX;
  e.clientY = inTouch.clientY;
  e.screenX = inTouch.screenX;
  e.screenY = inTouch.screenY;
  return e;
};
/**
 * @private
 * @param {Event} inEvent Touch event
 * @param {function(Event, Object)} inFunction In function.
 */


_ol_pointer_TouchSource_.prototype.processTouches_ = function (inEvent, inFunction) {
  var touches = Array.prototype.slice.call(inEvent.changedTouches);
  var count = touches.length;

  function preventDefault() {
    inEvent.preventDefault();
  }

  var i, pointer;

  for (i = 0; i < count; ++i) {
    pointer = this.touchToPointer_(inEvent, touches[i]); // forward touch preventDefaults

    pointer.preventDefault = preventDefault;
    inFunction.call(this, inEvent, pointer);
  }
};
/**
 * @private
 * @param {TouchList} touchList The touch list.
 * @param {number} searchId Search identifier.
 * @return {boolean} True, if the `Touch` with the given id is in the list.
 */


_ol_pointer_TouchSource_.prototype.findTouch_ = function (touchList, searchId) {
  var l = touchList.length;
  var touch;

  for (var i = 0; i < l; i++) {
    touch = touchList[i];

    if (touch.identifier === searchId) {
      return true;
    }
  }

  return false;
};
/**
 * In some instances, a touchstart can happen without a touchend. This
 * leaves the pointermap in a broken state.
 * Therefore, on every touchstart, we remove the touches that did not fire a
 * touchend event.
 * To keep state globally consistent, we fire a pointercancel for
 * this "abandoned" touch
 *
 * @private
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.vacuumTouches_ = function (inEvent) {
  var touchList = inEvent.touches; // pointerMap.getCount() should be < touchList.length here,
  // as the touchstart has not been processed yet.

  var keys = Object.keys(this.pointerMap);
  var count = keys.length;

  if (count >= touchList.length) {
    var d = [];
    var i, key, value;

    for (i = 0; i < count; ++i) {
      key = keys[i];
      value = this.pointerMap[key]; // Never remove pointerId == 1, which is mouse.
      // Touch identifiers are 2 smaller than their pointerId, which is the
      // index in pointermap.

      if (key != _pointer_mousesource_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTER_ID && !this.findTouch_(touchList, key - 2)) {
        d.push(value.out);
      }
    }

    for (i = 0; i < d.length; ++i) {
      this.cancelOut_(inEvent, d[i]);
    }
  }
};
/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchstart = function (inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer object.
 */


_ol_pointer_TouchSource_.prototype.overDown_ = function (browserEvent, inPointer) {
  this.pointerMap[inPointer.pointerId] = {
    target: inPointer.target,
    out: inPointer,
    outTarget: inPointer.target
  };
  this.dispatcher.over(inPointer, browserEvent);
  this.dispatcher.enter(inPointer, browserEvent);
  this.dispatcher.down(inPointer, browserEvent);
};
/**
 * Handler for `touchmove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchmove = function (inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */


_ol_pointer_TouchSource_.prototype.moveOverOut_ = function (browserEvent, inPointer) {
  var event = inPointer;
  var pointer = this.pointerMap[event.pointerId]; // a finger drifted off the screen, ignore it

  if (!pointer) {
    return;
  }

  var outEvent = pointer.out;
  var outTarget = pointer.outTarget;
  this.dispatcher.move(event, browserEvent);

  if (outEvent && outTarget !== event.target) {
    outEvent.relatedTarget = event.target;
    event.relatedTarget = outTarget; // recover from retargeting by shadow

    outEvent.target = outTarget;

    if (event.target) {
      this.dispatcher.leaveOut(outEvent, browserEvent);
      this.dispatcher.enterOver(event, browserEvent);
    } else {
      // clean up case when finger leaves the screen
      event.target = outTarget;
      event.relatedTarget = null;
      this.cancelOut_(browserEvent, event);
    }
  }

  pointer.out = event;
  pointer.outTarget = event.target;
};
/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The event.
 */


_ol_pointer_TouchSource_.prototype.touchend = function (inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
};
/**
 * @private
 * @param {Event} browserEvent An event.
 * @param {Object} inPointer The inPointer object.
 */


_ol_pointer_TouchSource_.prototype.upOut_ = function (browserEvent, inPointer) {
  this.dispatcher.up(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchcancel = function (inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */


_ol_pointer_TouchSource_.prototype.cancelOut_ = function (browserEvent, inPointer) {
  this.dispatcher.cancel(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
/**
 * @private
 * @param {Object} inPointer The inPointer object.
 */


_ol_pointer_TouchSource_.prototype.cleanUpPointer_ = function (inPointer) {
  delete this.pointerMap[inPointer.pointerId];
  this.removePrimaryPointer_(inPointer);
};
/**
 * Prevent synth mouse events from creating pointer events.
 *
 * @private
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.dedupSynthMouse_ = function (inEvent) {
  var lts = this.mouseSource.lastTouches;
  var t = inEvent.changedTouches[0]; // only the primary finger will synth mouse events

  if (this.isPrimaryTouch_(t)) {
    // remember x/y of last touch
    var lt = [t.clientX, t.clientY];
    lts.push(lt);
    setTimeout(function () {
      // remove touch after timeout
      _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].remove(lts, lt);
    }, _ol_pointer_TouchSource_.DEDUP_TIMEOUT);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_pointer_TouchSource_);

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_projection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/projection.js */ "./node_modules/ol/proj/projection.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proj/units.js */ "./node_modules/ol/proj/units.js");
/* harmony import */ var _proj_proj4_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/proj4.js */ "./node_modules/ol/proj/proj4.js");
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");











var _ol_proj_ = {};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */

_ol_proj_.METERS_PER_UNIT = _proj_units_js__WEBPACK_IMPORTED_MODULE_7__["default"].METERS_PER_UNIT;
/**
 * A place to store the mean radius of the Earth.
 * @private
 * @type {ol.Sphere}
 */

_ol_proj_.SPHERE_ = new _sphere_js__WEBPACK_IMPORTED_MODULE_1__["default"](_sphere_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEFAULT_RADIUS);

if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_PROJ4JS) {
  /**
   * Register proj4. If not explicitly registered, it will be assumed that
   * proj4js will be loaded in the global namespace. For example in a
   * browserify ES6 environment you could use:
   *
   *     import ol from 'openlayers';
   *     import proj4 from 'proj4';
   *     ol.proj.setProj4(proj4);
   *
   * @param {Proj4} proj4 Proj4.
   * @api
   */
  _ol_proj_.setProj4 = function (proj4) {
    _proj_proj4_js__WEBPACK_IMPORTED_MODULE_8__["default"].set(proj4);
  };
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link ol.proj.Projection} constructor or by using
 * {@link ol.proj.Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ol.ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {ol.Coordinate} point Point to find adjusted resolution at.
 * @param {ol.proj.Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */


_ol_proj_.getPointResolution = function (projection, resolution, point, opt_units) {
  projection = _ol_proj_.get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();

    if (units == _proj_units_js__WEBPACK_IMPORTED_MODULE_7__["default"].DEGREES && !opt_units || opt_units == _proj_units_js__WEBPACK_IMPORTED_MODULE_7__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));

      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326(vertices, vertices, 2);

      var width = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));

      var height = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));

      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? _proj_units_js__WEBPACK_IMPORTED_MODULE_7__["default"].METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();

      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }

  return pointResolution;
};
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<ol.proj.Projection>} projections Projections.
 * @api
 */


_ol_proj_.addEquivalentProjections = function (projections) {
  _ol_proj_.addProjections(projections);

  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(source, destination, _ol_proj_.cloneTransform);
      }
    });
  });
};
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<ol.proj.Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<ol.proj.Projection>} projections2 Projections with equal
 *     meaning.
 * @param {ol.TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {ol.TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */


_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(projection1, projection2, forwardTransform);

      _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(projection2, projection1, inverseTransform);
    });
  });
};
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {ol.proj.Projection} projection Projection instance.
 * @api
 */


_ol_proj_.addProjection = function (projection) {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_9__["default"].add(projection.getCode(), projection);

  _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(projection, projection, _ol_proj_.cloneTransform);
};
/**
 * @param {Array.<ol.proj.Projection>} projections Projections.
 */


_ol_proj_.addProjections = function (projections) {
  projections.forEach(_ol_proj_.addProjection);
};
/**
 * Clear all cached projections and transforms.
 */


_ol_proj_.clearAllProjections = function () {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_9__["default"].clear();

  _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].clear();
};
/**
 * @param {ol.proj.Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {ol.proj.Projection} Projection.
 */


_ol_proj_.createProjection = function (projection, defaultCode) {
  if (!projection) {
    return _ol_proj_.get(defaultCode);
  } else if (typeof projection === 'string') {
    return _ol_proj_.get(projection);
  } else {
    return (
      /** @type {ol.proj.Projection} */
      projection
    );
  }
};
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ol.ProjectionLike} source Source projection.
 * @param {ol.ProjectionLike} destination Destination projection.
 * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @api
 */


_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {
  var sourceProj = _ol_proj_.get(source);

  var destProj = _ol_proj_.get(destination);

  _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));

  _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));
};
/**
 * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate
 *     transform.
 * @return {ol.TransformFunction} Transform function.
 */


_ol_proj_.createTransformFromCoordinateTransform = function (transform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      var point, i, j;

      for (i = 0; i < length; i += dimension) {
        point = transform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];

        for (j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }

      return output;
    }
  );
};
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ol.ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate projected to the target projection.
 * @api
 */


_ol_proj_.fromLonLat = function (coordinate, opt_projection) {
  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
};
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {ol.Coordinate} coordinate Projected coordinate.
 * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */


_ol_proj_.toLonLat = function (coordinate, opt_projection) {
  var lonLat = _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');

  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = _math_js__WEBPACK_IMPORTED_MODULE_3__["default"].modulo(lon + 180, 360) - 180;
  }

  return lonLat;
};
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ol.ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {ol.proj.Projection} Projection object, or null if not in list.
 * @api
 */


_ol_proj_.get = function (projectionLike) {
  var projection = null;

  if (projectionLike instanceof _proj_projection_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = _proj_projections_js__WEBPACK_IMPORTED_MODULE_9__["default"].get(code);

    if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_PROJ4JS && !projection) {
      var proj4js = _proj_proj4_js__WEBPACK_IMPORTED_MODULE_8__["default"].get();

      if (typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {
        projection = new _proj_projection_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
          code: code
        });

        _ol_proj_.addProjection(projection);
      }
    }
  }

  return projection;
};
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {ol.proj.Projection} projection1 Projection 1.
 * @param {ol.proj.Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */


_ol_proj_.equivalent = function (projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);

    return transformFn === _ol_proj_.cloneTransform && equalUnits;
  }
};
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ol.ProjectionLike} source Source.
 * @param {ol.ProjectionLike} destination Destination.
 * @return {ol.TransformFunction} Transform function.
 * @api
 */


_ol_proj_.getTransform = function (source, destination) {
  var sourceProjection = _ol_proj_.get(source);

  var destinationProjection = _ol_proj_.get(destination);

  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
};
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {ol.proj.Projection} sourceProjection Source Projection object.
 * @param {ol.proj.Projection} destinationProjection Destination Projection
 *     object.
 * @return {ol.TransformFunction} Transform function.
 */


_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();

  var transform = _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].get(sourceCode, destinationCode);

  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_PROJ4JS && !transform) {
    var proj4js = _proj_proj4_js__WEBPACK_IMPORTED_MODULE_8__["default"].get();

    if (typeof proj4js == 'function') {
      var sourceDef = proj4js.defs(sourceCode);
      var destinationDef = proj4js.defs(destinationCode);

      if (sourceDef !== undefined && destinationDef !== undefined) {
        if (sourceDef === destinationDef) {
          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);
        } else {
          var proj4Transform = proj4js(destinationCode, sourceCode);

          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);
        }

        transform = _proj_transforms_js__WEBPACK_IMPORTED_MODULE_10__["default"].get(sourceCode, destinationCode);
      }
    }
  }

  if (!transform) {
    transform = _ol_proj_.identityTransform;
  }

  return transform;
};
/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */


_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    input = opt_output;
  }

  return input;
};
/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */


_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {
  var output;

  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    output = opt_output;
  } else {
    output = input.slice();
  }

  return output;
};
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_proj_.transform = function (coordinate, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);

  return transformFn(coordinate, undefined, coordinate.length);
};
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {ol.Extent} extent The extent to transform.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Extent} The transformed extent.
 * @api
 */


_ol_proj_.transformExtent = function (extent, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);

  return _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].applyTransform(extent, transformFn);
};
/**
 * Transforms the given point to the destination projection.
 *
 * @param {ol.Coordinate} point Point.
 * @param {ol.proj.Projection} sourceProjection Source projection.
 * @param {ol.proj.Projection} destinationProjection Destination projection.
 * @return {ol.Coordinate} Point.
 */


_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {
  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);

  return transformFn(point);
};
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `ol.proj.clearAllProjections()` is called (e.g. in tests).
 */


_ol_proj_.addCommon = function () {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  _ol_proj_.addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROJECTIONS);

  _ol_proj_.addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_5__["default"].PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.


  _ol_proj_.addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_5__["default"].PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromEPSG4326, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_4__["default"].toEPSG4326);
};

_ol_proj_.addCommon();

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_);

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/projection.js */ "./node_modules/ol/proj/projection.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj/units.js */ "./node_modules/ol/proj/units.js");




var _ol_proj_EPSG3857_ = {};
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @private
 */

_ol_proj_EPSG3857_.Projection_ = function (code) {
  _proj_projection_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, {
    code: code,
    units: _proj_units_js__WEBPACK_IMPORTED_MODULE_3__["default"].METERS,
    extent: _ol_proj_EPSG3857_.EXTENT,
    global: true,
    worldExtent: _ol_proj_EPSG3857_.WORLD_EXTENT,
    getPointResolution: function (resolution, point) {
      return resolution / _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].cosh(point[1] / _ol_proj_EPSG3857_.RADIUS);
    }
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_proj_EPSG3857_.Projection_, _proj_projection_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */


_ol_proj_EPSG3857_.RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

_ol_proj_EPSG3857_.HALF_SIZE = Math.PI * _ol_proj_EPSG3857_.RADIUS;
/**
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG3857_.EXTENT = [-_ol_proj_EPSG3857_.HALF_SIZE, -_ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE];
/**
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG3857_.WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */

_ol_proj_EPSG3857_.PROJECTIONS = [new _ol_proj_EPSG3857_.Projection_('EPSG:3857'), new _ol_proj_EPSG3857_.Projection_('EPSG:102100'), new _ol_proj_EPSG3857_.Projection_('EPSG:102113'), new _ol_proj_EPSG3857_.Projection_('EPSG:900913'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG:6.18:3:3857'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG::3857'), new _ol_proj_EPSG3857_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */

_ol_proj_EPSG3857_.fromEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  var halfSize = _ol_proj_EPSG3857_.HALF_SIZE;

  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = _ol_proj_EPSG3857_.RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));

    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }

    output[i + 1] = y;
  }

  return output;
};
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */


_ol_proj_EPSG3857_.toEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / _ol_proj_EPSG3857_.HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / _ol_proj_EPSG3857_.RADIUS)) / Math.PI - 90;
  }

  return output;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_EPSG3857_);

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _proj_projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj/projection.js */ "./node_modules/ol/proj/projection.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/units.js */ "./node_modules/ol/proj/units.js");



var _ol_proj_EPSG4326_ = {};
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 * @private
 */

_ol_proj_EPSG4326_.Projection_ = function (code, opt_axisOrientation) {
  _proj_projection_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, {
    code: code,
    units: _proj_units_js__WEBPACK_IMPORTED_MODULE_2__["default"].DEGREES,
    extent: _ol_proj_EPSG4326_.EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: _ol_proj_EPSG4326_.METERS_PER_UNIT,
    worldExtent: _ol_proj_EPSG4326_.EXTENT
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_proj_EPSG4326_.Projection_, _proj_projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */


_ol_proj_EPSG4326_.RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG4326_.EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

_ol_proj_EPSG4326_.METERS_PER_UNIT = Math.PI * _ol_proj_EPSG4326_.RADIUS / 180;
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */

_ol_proj_EPSG4326_.PROJECTIONS = [new _ol_proj_EPSG4326_.Projection_('CRS:84'), new _ol_proj_EPSG4326_.Projection_('EPSG:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'), new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')];
/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_EPSG4326_);

/***/ }),

/***/ "./node_modules/ol/proj/proj4.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/proj4.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_proj_proj4_ = {};
/**
 * @private
 * @type {Proj4}
 */

_ol_proj_proj4_.cache_ = null;
/**
 * Store the proj4 function.
 * @param {Proj4} proj4 The proj4 function.
 */

_ol_proj_proj4_.set = function (proj4) {
  _ol_proj_proj4_.cache_ = proj4;
};
/**
 * Get proj4.
 * @return {Proj4} The proj4 function set above or available globally.
 */


_ol_proj_proj4_.get = function () {
  return _ol_proj_proj4_.cache_ || window['proj4'];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_proj4_);

/***/ }),

/***/ "./node_modules/ol/proj/projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/projection.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj/units.js */ "./node_modules/ol/proj/units.js");
/* harmony import */ var _proj_proj4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/proj4.js */ "./node_modules/ol/proj/proj4.js");



/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link ol.proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link ol.proj.setProj4}.
 *
 * @constructor
 * @param {olx.ProjectionOptions} options Projection options.
 * @struct
 * @api
 */

var _ol_proj_Projection_ = function (options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;
  /**
   * Units of projected coordinates. When set to `ol.proj.Units.TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {ol.proj.Units}
   */

  this.units_ =
  /** @type {ol.proj.Units} */
  options.units;
  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = options.extent !== undefined ? options.extent : null;
  /**
   * Extent of the world in EPSG:4326. For projections with
   * `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {ol.Extent}
   */

  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
  /**
   * @private
   * @type {string}
   */

  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
  /**
   * @private
   * @type {boolean}
   */

  this.global_ = options.global !== undefined ? options.global : false;
  /**
   * @private
   * @type {boolean}
   */

  this.canWrapX_ = !!(this.global_ && this.extent_);
  /**
   * @private
   * @type {function(number, ol.Coordinate):number|undefined}
   */

  this.getPointResolutionFunc_ = options.getPointResolution;
  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */

  this.defaultTileGrid_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.metersPerUnit_ = options.metersPerUnit;
  var code = options.code;

  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_PROJ4JS) {
    var proj4js = _proj_proj4_js__WEBPACK_IMPORTED_MODULE_2__["default"].get();

    if (typeof proj4js == 'function') {
      var def = proj4js.defs(code);

      if (def !== undefined) {
        if (def.axis !== undefined && options.axisOrientation === undefined) {
          this.axisOrientation_ = def.axis;
        }

        if (options.metersPerUnit === undefined) {
          this.metersPerUnit_ = def.to_meter;
        }

        if (options.units === undefined) {
          this.units_ = def.units;
        }
      }
    }
  }
};
/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */


_ol_proj_Projection_.prototype.canWrapX = function () {
  return this.canWrapX_;
};
/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */


_ol_proj_Projection_.prototype.getCode = function () {
  return this.code_;
};
/**
 * Get the validity extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_proj_Projection_.prototype.getExtent = function () {
  return this.extent_;
};
/**
 * Get the units of this projection.
 * @return {ol.proj.Units} Units.
 * @api
 */


_ol_proj_Projection_.prototype.getUnits = function () {
  return this.units_;
};
/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */


_ol_proj_Projection_.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || _proj_units_js__WEBPACK_IMPORTED_MODULE_1__["default"].METERS_PER_UNIT[this.units_];
};
/**
 * Get the world extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_proj_Projection_.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};
/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */


_ol_proj_Projection_.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};
/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */


_ol_proj_Projection_.prototype.isGlobal = function () {
  return this.global_;
};
/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/


_ol_proj_Projection_.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};
/**
 * @return {ol.tilegrid.TileGrid} The default tile grid.
 */


_ol_proj_Projection_.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};
/**
 * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.
 */


_ol_proj_Projection_.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};
/**
 * Set the validity extent for this projection.
 * @param {ol.Extent} extent Extent.
 * @api
 */


_ol_proj_Projection_.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};
/**
 * Set the world extent for this projection.
 * @param {ol.Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */


_ol_proj_Projection_.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};
/**
 * Set the getPointResolution function (see {@link ol.proj#getPointResolution}
 * for this projection.
 * @param {function(number, ol.Coordinate):number} func Function
 * @api
 */


_ol_proj_Projection_.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};
/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, ol.Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */


_ol_proj_Projection_.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_Projection_);

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_proj_projections_ = {};
/**
 * @private
 * @type {Object.<string, ol.proj.Projection>}
 */

_ol_proj_projections_.cache_ = {};
/**
 * Clear the projections cache.
 */

_ol_proj_projections_.clear = function () {
  _ol_proj_projections_.cache_ = {};
};
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {ol.proj.Projection} The projection (if cached).
 */


_ol_proj_projections_.get = function (code) {
  var projections = _ol_proj_projections_.cache_;
  return projections[code] || null;
};
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {ol.proj.Projection} projection The projection to cache.
 */


_ol_proj_projections_.add = function (code, projection) {
  var projections = _ol_proj_projections_.cache_;
  projections[code] = projection;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_projections_);

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");

var _ol_proj_transforms_ = {};
/**
 * @private
 * @type {Object.<string, Object.<string, ol.TransformFunction>>}
 */

_ol_proj_transforms_.cache_ = {};
/**
 * Clear the transform cache.
 */

_ol_proj_transforms_.clear = function () {
  _ol_proj_transforms_.cache_ = {};
};
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {ol.proj.Projection} source Source.
 * @param {ol.proj.Projection} destination Destination.
 * @param {ol.TransformFunction} transformFn Transform.
 */


_ol_proj_transforms_.add = function (source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
};
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {ol.proj.Projection} source Source projection.
 * @param {ol.proj.Projection} destination Destination projection.
 * @return {ol.TransformFunction} transformFn The unregistered transform.
 */


_ol_proj_transforms_.remove = function (source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if (_obj_js__WEBPACK_IMPORTED_MODULE_0__["default"].isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
};
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {ol.TransformFunction|undefined} The transform function (if found).
 */


_ol_proj_transforms_.get = function (sourceCode, destinationCode) {
  var transform;
  var transforms = _ol_proj_transforms_.cache_;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_transforms_);

/***/ }),

/***/ "./node_modules/ol/proj/units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/units.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var _ol_proj_Units_ = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */

_ol_proj_Units_.METERS_PER_UNIT = {}; // use the radius of the Normal sphere

_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES] = 2 * Math.PI * 6370997 / 360;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET] = 0.3048;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS] = 1;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET] = 1200 / 3937;
/* harmony default export */ __webpack_exports__["default"] = (_ol_proj_Units_);

/***/ }),

/***/ "./node_modules/ol/render/box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/box.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../disposable.js */ "./node_modules/ol/disposable.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
// FIXME add rotation



/**
 * @constructor
 * @extends {ol.Disposable}
 * @param {string} className CSS class name.
 */

var _ol_render_Box_ = function (className) {
  /**
   * @type {ol.geom.Polygon}
   * @private
   */
  this.geometry_ = null;
  /**
   * @type {HTMLDivElement}
   * @private
   */

  this.element_ =
  /** @type {HTMLDivElement} */
  document.createElement('div');
  this.element_.style.position = 'absolute';
  this.element_.className = 'ol-box ' + className;
  /**
   * @private
   * @type {ol.PluggableMap}
   */

  this.map_ = null;
  /**
   * @private
   * @type {ol.Pixel}
   */

  this.startPixel_ = null;
  /**
   * @private
   * @type {ol.Pixel}
   */

  this.endPixel_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_Box_, _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_render_Box_.prototype.disposeInternal = function () {
  this.setMap(null);
};
/**
 * @private
 */


_ol_render_Box_.prototype.render_ = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var px = 'px';
  var style = this.element_.style;
  style.left = Math.min(startPixel[0], endPixel[0]) + px;
  style.top = Math.min(startPixel[1], endPixel[1]) + px;
  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
};
/**
 * @param {ol.PluggableMap} map Map.
 */


_ol_render_Box_.prototype.setMap = function (map) {
  if (this.map_) {
    this.map_.getOverlayContainer().removeChild(this.element_);
    var style = this.element_.style;
    style.left = style.top = style.width = style.height = 'inherit';
  }

  this.map_ = map;

  if (this.map_) {
    this.map_.getOverlayContainer().appendChild(this.element_);
  }
};
/**
 * @param {ol.Pixel} startPixel Start pixel.
 * @param {ol.Pixel} endPixel End pixel.
 */


_ol_render_Box_.prototype.setPixels = function (startPixel, endPixel) {
  this.startPixel_ = startPixel;
  this.endPixel_ = endPixel;
  this.createOrUpdateGeometry();
  this.render_();
};
/**
 * Creates or updates the cached geometry.
 */


_ol_render_Box_.prototype.createOrUpdateGeometry = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
  var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_); // close the polygon

  coordinates[4] = coordinates[0].slice();

  if (!this.geometry_) {
    this.geometry_ = new _geom_polygon_js__WEBPACK_IMPORTED_MODULE_2__["default"]([coordinates]);
  } else {
    this.geometry_.setCoordinates([coordinates]);
  }
};
/**
 * @return {ol.geom.Polygon} Geometry.
 */


_ol_render_Box_.prototype.getGeometry = function () {
  return this.geometry_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_Box_);

/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/lrucache.js */ "./node_modules/ol/structs/lrucache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");





var _ol_render_canvas_ = {};
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultFont = '10px sans-serif';
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultLineCap = 'round';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_canvas_.defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultLineDashOffset = 0;
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultMiterLimit = 10;
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_canvas_.defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultLineWidth = 1;
/**
 * @type {ol.structs.LRUCache.<HTMLCanvasElement>}
 */

_ol_render_canvas_.labelCache = new _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
/**
 * @type {!Object.<string, number>}
 */

_ol_render_canvas_.checkedFonts_ = {};
/**
 * @type {CanvasRenderingContext2D}
 */

_ol_render_canvas_.measureContext_ = null;
/**
 * @type {!Object.<string, number>}
 */

_ol_render_canvas_.textHeights_ = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

_ol_render_canvas_.checkFont = function () {
  var retries = 60;
  var checked = _ol_render_canvas_.checkedFonts_;
  var labelCache = _ol_render_canvas_.labelCache;
  var font = '32px monospace';
  var text = 'wmytzilWMYTZIL@#/&?$%10';
  var interval, referenceWidth;

  function isAvailable(fontFamily) {
    var context = _ol_render_canvas_.getMeasureContext();

    context.font = font;
    referenceWidth = context.measureText(text).width;
    var available = true;

    if (fontFamily != 'monospace') {
      context.font = '32px ' + fontFamily + ',monospace';
      var width = context.measureText(text).width; // If width and referenceWidth are the same, then the 'monospace'
      // fallback was used instead of the font we wanted, so the font is not
      // available.

      available = width != referenceWidth;
    }

    return available;
  }

  function check() {
    var done = true;

    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;

          _obj_js__WEBPACK_IMPORTED_MODULE_2__["default"].clear(_ol_render_canvas_.textHeights_); // Make sure that loaded fonts are picked up by Safari


          _ol_render_canvas_.measureContext_ = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }

    if (done) {
      window.clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var fontFamilies = _css_js__WEBPACK_IMPORTED_MODULE_0__["default"].getFontFamilies(fontSpec);

    if (!fontFamilies) {
      return;
    }

    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];

      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;

        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;

          if (interval === undefined) {
            interval = window.setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @return {CanvasRenderingContext2D} Measure context.
 */


_ol_render_canvas_.getMeasureContext = function () {
  var context = _ol_render_canvas_.measureContext_;

  if (!context) {
    context = _ol_render_canvas_.measureContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_1__["default"].createCanvasContext2D(1, 1);
  }

  return context;
};
/**
 * @param {string} font Font to use for measuring.
 * @return {ol.Size} Measurement.
 */


_ol_render_canvas_.measureTextHeight = function () {
  var span;
  var heights = _ol_render_canvas_.textHeights_;
  return function (font) {
    var height = heights[font];

    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }

      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


_ol_render_canvas_.measureTextWidth = function (font, text) {
  var measureContext = _ol_render_canvas_.getMeasureContext();

  if (font != measureContext.font) {
    measureContext.font = font;
  }

  return measureContext.measureText(text).width;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */


_ol_render_canvas_.rotateAtOffset = function (context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};

_ol_render_canvas_.resetTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_4__["default"].create();
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */

_ol_render_canvas_.drawImage = function (context, transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;

  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }

  if (transform) {
    context.setTransform.apply(context, _ol_render_canvas_.resetTransform_);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/imagereplay.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/imagereplay.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas/instruction.js */ "./node_modules/ol/render/canvas/instruction.js");
/* harmony import */ var _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas/replay.js */ "./node_modules/ol/render/canvas/replay.js");



/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */

var _ol_render_canvas_ImageReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  /**
   * @private
   * @type {ol.DeclutterGroup}
   */


  this.declutterGroup_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.hitDetectionImage_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.anchorX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.anchorY_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.height_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.opacity_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.originX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.originY_ = undefined;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.rotateWithView_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.scale_ = undefined;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.snapToPixel_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.width_ = undefined;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_ImageReplay_, _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */


_ol_render_canvas_ImageReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  if (!this.image_) {
    return;
  }

  this.beginGeometry(pointGeometry, feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(pointGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  if (!this.image_) {
    return;
  }

  this.beginGeometry(multiPointGeometry, feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(multiPointGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.height_ = undefined;
  this.scale_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.setImageStyle = function (imageStyle, declutterGroup) {
  var anchor = imageStyle.getAnchor();
  var size = imageStyle.getSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var image = imageStyle.getImage(1);
  var origin = imageStyle.getOrigin();
  this.anchorX_ = anchor[0];
  this.anchorY_ = anchor[1];
  this.declutterGroup_ =
  /** @type {ol.DeclutterGroup} */
  declutterGroup;
  this.hitDetectionImage_ = hitDetectionImage;
  this.image_ = image;
  this.height_ = size[1];
  this.opacity_ = imageStyle.getOpacity();
  this.originX_ = origin[0];
  this.originY_ = origin[1];
  this.rotateWithView_ = imageStyle.getRotateWithView();
  this.rotation_ = imageStyle.getRotation();
  this.scale_ = imageStyle.getScale();
  this.snapToPixel_ = imageStyle.getSnapToPixel();
  this.width_ = size[0];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_ImageReplay_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/immediate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _vectorcontext_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../vectorcontext.js */ "./node_modules/ol/render/vectorcontext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol.geom.flat.transform.transform2D?











/**
 * @classdesc
 * A concrete subclass of {@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 *
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @struct
 */

var _ol_render_canvas_Immediate_ = function (context, pixelRatio, extent, transform, viewRotation) {
  _vectorcontext_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this);
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */


  this.context_ = context;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = extent;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = transform;
  /**
   * @private
   * @type {number}
   */

  this.viewRotation_ = viewRotation;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.contextFillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.contextStrokeState_ = null;
  /**
   * @private
   * @type {?ol.CanvasTextState}
   */

  this.contextTextState_ = null;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.fillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.strokeState_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {number}
   */

  this.imageAnchorX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageAnchorY_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageHeight_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOpacity_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOriginX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOriginY_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.imageRotateWithView_ = false;
  /**
   * @private
   * @type {number}
   */

  this.imageRotation_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageScale_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.imageSnapToPixel_ = false;
  /**
   * @private
   * @type {number}
   */

  this.imageWidth_ = 0;
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number}
   */

  this.textOffsetX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textOffsetY_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.textRotateWithView_ = false;
  /**
   * @private
   * @type {number}
   */

  this.textRotation_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textScale_ = 0;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.textFillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.textStrokeState_ = null;
  /**
   * @private
   * @type {?ol.CanvasTextState}
   */

  this.textState_ = null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.pixelCoordinates_ = [];
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpLocalTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_10__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_Immediate_, _vectorcontext_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
  if (!this.image_) {
    return;
  }

  var pixelCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__["default"].transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);

  var context = this.context_;
  var localTransform = this.tmpLocalTransform_;
  var alpha = context.globalAlpha;

  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha * this.imageOpacity_;
  }

  var rotation = this.imageRotation_;

  if (this.imageRotateWithView_) {
    rotation += this.viewRotation_;
  }

  var i, ii;

  for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
    var x = pixelCoordinates[i] - this.imageAnchorX_;
    var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

    if (this.imageSnapToPixel_) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (rotation !== 0 || this.imageScale_ != 1) {
      var centerX = x + this.imageAnchorX_;
      var centerY = y + this.imageAnchorY_;

      _transform_js__WEBPACK_IMPORTED_MODULE_10__["default"].compose(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);

      context.setTransform.apply(context, localTransform);
    }

    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
  }

  if (rotation !== 0 || this.imageScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }

  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha;
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  if (!this.textState_ || this.text_ === '') {
    return;
  }

  if (this.textFillState_) {
    this.setContextFillState_(this.textFillState_);
  }

  if (this.textStrokeState_) {
    this.setContextStrokeState_(this.textStrokeState_);
  }

  this.setContextTextState_(this.textState_);

  var pixelCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__["default"].transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);

  var context = this.context_;
  var rotation = this.textRotation_;

  if (this.textRotateWithView_) {
    rotation += this.viewRotation_;
  }

  for (; offset < end; offset += stride) {
    var x = pixelCoordinates[offset] + this.textOffsetX_;
    var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

    if (rotation !== 0 || this.textScale_ != 1) {
      var localTransform = _transform_js__WEBPACK_IMPORTED_MODULE_10__["default"].compose(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);

      context.setTransform.apply(context, localTransform);
    }

    if (this.textStrokeState_) {
      context.strokeText(this.text_, x, y);
    }

    if (this.textFillState_) {
      context.fillText(this.text_, x, y);
    }
  }

  if (rotation !== 0 || this.textScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @private
 * @return {number} end End.
 */


_ol_render_canvas_Immediate_.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
  var context = this.context_;

  var pixelCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__["default"].transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);

  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
  var length = pixelCoordinates.length;

  if (close) {
    length -= 2;
  }

  for (var i = 2; i < length; i += 2) {
    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
  }

  if (close) {
    context.closePath();
  }

  return end;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */


_ol_render_canvas_Immediate_.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
  }

  return offset;
};
/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 *
 * @param {ol.geom.Circle} geometry Circle geometry.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawCircle = function (geometry) {
  if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.fillState_ || this.strokeState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var pixelCoordinates = _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"].transform2D(geometry, this.transform_, this.pixelCoordinates_);

    var dx = pixelCoordinates[2] - pixelCoordinates[0];
    var dy = pixelCoordinates[3] - pixelCoordinates[1];
    var radius = Math.sqrt(dx * dx + dy * dy);
    var context = this.context_;
    context.beginPath();
    context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    this.drawText_(geometry.getCenter(), 0, 2, 2);
  }
};
/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();

  switch (type) {
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINT:
      this.drawPoint(
      /** @type {ol.geom.Point} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING:
      this.drawLineString(
      /** @type {ol.geom.LineString} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON:
      this.drawPolygon(
      /** @type {ol.geom.Polygon} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POINT:
      this.drawMultiPoint(
      /** @type {ol.geom.MultiPoint} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_LINE_STRING:
      this.drawMultiLineString(
      /** @type {ol.geom.MultiLineString} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POLYGON:
      this.drawMultiPolygon(
      /** @type {ol.geom.MultiPolygon} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].GEOMETRY_COLLECTION:
      this.drawGeometryCollection(
      /** @type {ol.geom.GeometryCollection} */
      geometry);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CIRCLE:
      this.drawCircle(
      /** @type {ol.geom.Circle} */
      geometry);
      break;

    default:
  }
};
/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {@link ol.layer.Vector} instead.
 *
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry || !_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  this.setStyle(style);
  this.drawGeometry(geometry);
};
/**
 * Render a GeometryCollection to the canvas.  Rendering is immediate and
 * uses the current styles appropriate for each geometry in the collection.
 *
 * @param {ol.geom.GeometryCollection} geometry Geometry collection.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawGeometryCollection = function (geometry) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
/**
 * Render a Point geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();

  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }

  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
 * uses the current style.
 *
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();

  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }

  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * Render a LineString into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawLineString = function (geometry) {
  if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    context.beginPath();
    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
    context.stroke();
  }

  if (this.text_ !== '') {
    var flatMidpoint = geometry.getFlatMidpoint();
    this.drawText_(flatMidpoint, 0, 2, 2);
  }
};
/**
 * Render a MultiLineString geometry into the canvas.  Rendering is immediate
 * and uses the current style.
 *
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString
 *     geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiLineString = function (geometry) {
  var geometryExtent = geometry.getExtent();

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometryExtent)) {
    return;
  }

  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    var offset = 0;
    var ends = geometry.getEnds();
    var stride = geometry.getStride();
    context.beginPath();
    var i, ii;

    for (i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
    }

    context.stroke();
  }

  if (this.text_ !== '') {
    var flatMidpoints = geometry.getFlatMidpoints();
    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
  }
};
/**
 * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawPolygon = function (geometry) {
  if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var context = this.context_;
    context.beginPath();
    this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    var flatInteriorPoint = geometry.getFlatInteriorPoint();
    this.drawText_(flatInteriorPoint, 0, 2, 2);
  }
};
/**
 * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
 * uses the current style.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiPolygon = function (geometry) {
  if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var context = this.context_;
    var flatCoordinates = geometry.getOrientedFlatCoordinates();
    var offset = 0;
    var endss = geometry.getEndss();
    var stride = geometry.getStride();
    var i, ii;
    context.beginPath();

    for (i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      offset = this.drawRings_(flatCoordinates, offset, ends, stride);
    }

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    var flatInteriorPoints = geometry.getFlatInteriorPoints();
    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
  }
};
/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextFillState_ = function (fillState) {
  var context = this.context_;
  var contextFillState = this.contextFillState_;

  if (!contextFillState) {
    context.fillStyle = fillState.fillStyle;
    this.contextFillState_ = {
      fillStyle: fillState.fillStyle
    };
  } else {
    if (contextFillState.fillStyle != fillState.fillStyle) {
      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
    }
  }
};
/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextStrokeState_ = function (strokeState) {
  var context = this.context_;
  var contextStrokeState = this.contextStrokeState_;

  if (!contextStrokeState) {
    context.lineCap = strokeState.lineCap;

    if (_has_js__WEBPACK_IMPORTED_MODULE_7__["default"].CANVAS_LINE_DASH) {
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
    }

    context.lineJoin = strokeState.lineJoin;
    context.lineWidth = strokeState.lineWidth;
    context.miterLimit = strokeState.miterLimit;
    context.strokeStyle = strokeState.strokeStyle;
    this.contextStrokeState_ = {
      lineCap: strokeState.lineCap,
      lineDash: strokeState.lineDash,
      lineDashOffset: strokeState.lineDashOffset,
      lineJoin: strokeState.lineJoin,
      lineWidth: strokeState.lineWidth,
      miterLimit: strokeState.miterLimit,
      strokeStyle: strokeState.strokeStyle
    };
  } else {
    if (contextStrokeState.lineCap != strokeState.lineCap) {
      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
    }

    if (_has_js__WEBPACK_IMPORTED_MODULE_7__["default"].CANVAS_LINE_DASH) {
      if (!_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }

      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;
      }
    }

    if (contextStrokeState.lineJoin != strokeState.lineJoin) {
      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
    }

    if (contextStrokeState.lineWidth != strokeState.lineWidth) {
      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
    }

    if (contextStrokeState.miterLimit != strokeState.miterLimit) {
      contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;
    }

    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
      contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;
    }
  }
};
/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextTextState_ = function (textState) {
  var context = this.context_;
  var contextTextState = this.contextTextState_;
  var textAlign = textState.textAlign ? textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultTextAlign;

  if (!contextTextState) {
    context.font = textState.font;
    context.textAlign = textAlign;
    context.textBaseline = textState.textBaseline;
    this.contextTextState_ = {
      font: textState.font,
      textAlign: textAlign,
      textBaseline: textState.textBaseline
    };
  } else {
    if (contextTextState.font != textState.font) {
      contextTextState.font = context.font = textState.font;
    }

    if (contextTextState.textAlign != textAlign) {
      contextTextState.textAlign = textAlign;
    }

    if (contextTextState.textBaseline != textState.textBaseline) {
      contextTextState.textBaseline = context.textBaseline = textState.textBaseline;
    }
  }
};
/**
 * Set the fill and stroke style for subsequent draw operations.  To clear
 * either fill or stroke styles, pass null for the appropriate parameter.
 *
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  if (!fillStyle) {
    this.fillState_ = null;
  } else {
    var fillStyleColor = fillStyle.getColor();
    this.fillState_ = {
      fillStyle: _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFillStyle)
    };
  }

  if (!strokeStyle) {
    this.strokeState_ = null;
  } else {
    var strokeStyleColor = strokeStyle.getColor();
    var strokeStyleLineCap = strokeStyle.getLineCap();
    var strokeStyleLineDash = strokeStyle.getLineDash();
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    var strokeStyleWidth = strokeStyle.getWidth();
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    this.strokeState_ = {
      lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineCap,
      lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDash,
      lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDashOffset,
      lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineJoin,
      lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineWidth),
      miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultMiterLimit,
      strokeStyle: _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultStrokeStyle)
    };
  }
};
/**
 * Set the image style for subsequent draw operations.  Pass null to remove
 * the image style.
 *
 * @param {ol.style.Image} imageStyle Image style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setImageStyle = function (imageStyle) {
  if (!imageStyle) {
    this.image_ = null;
  } else {
    var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio

    var imageImage = imageStyle.getImage(1);
    var imageOrigin = imageStyle.getOrigin();
    var imageSize = imageStyle.getSize();
    this.imageAnchorX_ = imageAnchor[0];
    this.imageAnchorY_ = imageAnchor[1];
    this.imageHeight_ = imageSize[1];
    this.image_ = imageImage;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
    this.imageWidth_ = imageSize[0];
  }
};
/**
 * Set the text style for subsequent draw operations.  Pass null to
 * remove the text style.
 *
 * @param {ol.style.Text} textStyle Text style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setTextStyle = function (textStyle) {
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();

    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      this.textFillState_ = {
        fillStyle: _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(textFillStyleColor ? textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFillStyle)
      };
    }

    var textStrokeStyle = textStyle.getStroke();

    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      this.textStrokeState_ = {
        lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineCap,
        lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDash,
        lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDashOffset,
        lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineJoin,
        lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineWidth,
        miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultMiterLimit,
        strokeStyle: _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultStrokeStyle)
      };
    }

    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    this.textState_ = {
      font: textFont !== undefined ? textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFont,
      textAlign: textTextAlign !== undefined ? textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultTextAlign,
      textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultTextBaseline
    };
    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_Immediate_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/instruction.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/instruction.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {number}
 */
var _ol_render_canvas_Instruction_ = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_Instruction_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/linestringreplay.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/render/canvas/linestringreplay.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas/instruction.js */ "./node_modules/ol/render/canvas/instruction.js");
/* harmony import */ var _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas/replay.js */ "./node_modules/ol/render/canvas/replay.js");



/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */

var _ol_render_canvas_LineStringReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_LineStringReplay_, _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */


_ol_render_canvas_LineStringReplay_.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var moveToLineToInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
  this.instructions.push(moveToLineToInstruction);
  this.hitDetectionInstructions.push(moveToLineToInstruction);
  return end;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;

  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }

  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(lineStringGeometry, feature);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].BEGIN_PATH]);
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].STROKE]);
  this.endGeometry(lineStringGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;

  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }

  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(multiLineStringGeometry, feature);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].BEGIN_PATH]);
  var ends = multiLineStringGeometry.getEnds();
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var offset = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
  }

  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].STROKE]);
  this.endGeometry(multiLineStringGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.finish = function () {
  var state = this.state;

  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].STROKE]);
  }

  this.reverseHitDetectionInstructions();
  this.state = null;
};
/**
 * @inheritDoc.
 */


_ol_render_canvas_LineStringReplay_.prototype.applyStroke = function (state) {
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].STROKE]);
    state.lastStroke = this.coordinates.length;
  }

  state.lastStroke = 0;

  _canvas_replay_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.applyStroke.call(this, state);

  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].BEGIN_PATH]);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_LineStringReplay_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/polygonreplay.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/polygonreplay.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../canvas/instruction.js */ "./node_modules/ol/render/canvas/instruction.js");
/* harmony import */ var _canvas_replay_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../canvas/replay.js */ "./node_modules/ol/render/canvas/replay.js");






/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */

var _ol_render_canvas_PolygonReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _canvas_replay_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_PolygonReplay_, _canvas_replay_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */


_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
  var state = this.state;
  var fill = state.fillStyle !== undefined;
  var stroke = state.strokeStyle != undefined;
  var numEnds = ends.length;
  var beginPathInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].BEGIN_PATH];
  this.instructions.push(beginPathInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction);

  for (var i = 0; i < numEnds; ++i) {
    var end = ends[i];
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
    var moveToLineToInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);

    if (stroke) {
      // Performance optimization: only call closePath() when we have a stroke.
      // Otherwise the ring is closed already (see appendFlatCoordinates above).
      var closePathInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLOSE_PATH];
      this.instructions.push(closePathInstruction);
      this.hitDetectionInstructions.push(closePathInstruction);
    }

    offset = end;
  }

  var fillInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].FILL];
  this.hitDetectionInstructions.push(fillInstruction);

  if (fill) {
    this.instructions.push(fillInstruction);
  }

  if (stroke) {
    var strokeInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }

  return offset;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;

  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }

  this.setFillStrokeStyles_(circleGeometry);
  this.beginGeometry(circleGeometry, feature); // always fill the circle for hit detection

  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_FILL_STYLE, _color_js__WEBPACK_IMPORTED_MODULE_1__["default"].asString(_canvas_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var flatCoordinates = circleGeometry.getFlatCoordinates();
  var stride = circleGeometry.getStride();
  var myBegin = this.coordinates.length;
  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
  var beginPathInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].BEGIN_PATH];
  var circleInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].CIRCLE, myBegin];
  this.instructions.push(beginPathInstruction, circleInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
  var fillInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].FILL];
  this.hitDetectionInstructions.push(fillInstruction);

  if (state.fillStyle !== undefined) {
    this.instructions.push(fillInstruction);
  }

  if (state.strokeStyle !== undefined) {
    var strokeInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }

  this.endGeometry(circleGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var state = this.state;
  this.setFillStrokeStyles_(polygonGeometry);
  this.beginGeometry(polygonGeometry, feature); // always fill the polygon for hit detection

  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_FILL_STYLE, _color_js__WEBPACK_IMPORTED_MODULE_1__["default"].asString(_canvas_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var ends = polygonGeometry.getEnds();
  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
  var stride = polygonGeometry.getStride();
  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
  this.endGeometry(polygonGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;

  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }

  this.setFillStrokeStyles_(multiPolygonGeometry);
  this.beginGeometry(multiPolygonGeometry, feature); // always fill the multi-polygon for hit detection

  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_FILL_STYLE, _color_js__WEBPACK_IMPORTED_MODULE_1__["default"].asString(_canvas_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_4__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var endss = multiPolygonGeometry.getEndss();
  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
  var stride = multiPolygonGeometry.getStride();
  var offset = 0;
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
  }

  this.endGeometry(multiPolygonGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
  // simplified using quantization and point elimination. However, we might
  // have received a mix of quantized and non-quantized geometries, so ensure
  // that all are quantized by quantizing all coordinates in the batch.

  var tolerance = this.tolerance;

  if (tolerance !== 0) {
    var coordinates = this.coordinates;
    var i, ii;

    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      coordinates[i] = _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_2__["default"].snap(coordinates[i], tolerance);
    }
  }
};
/**
 * @private
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function (geometry) {
  var state = this.state;
  var fillStyle = state.fillStyle;

  if (fillStyle !== undefined) {
    this.updateFillStyle(state, this.applyFill, geometry);
  }

  if (state.strokeStyle !== undefined) {
    this.updateStrokeStyle(state, this.applyStroke);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_PolygonReplay_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/replay.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/canvas/replay.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_relationship_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent/relationship.js */ "./node_modules/ol/extent/relationship.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _vectorcontext_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vectorcontext.js */ "./node_modules/ol/render/vectorcontext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../canvas/instruction.js */ "./node_modules/ol/render/canvas/instruction.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");

















/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */

var _ol_render_canvas_Replay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _vectorcontext_js__WEBPACK_IMPORTED_MODULE_12__["default"].call(this);
  /**
   * @type {?}
   */


  this.declutterTree = declutterTree;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.tmpExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createEmpty();
  /**
   * @protected
   * @type {number}
   */

  this.tolerance = tolerance;
  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */

  this.maxExtent = maxExtent;
  /**
   * @protected
   * @type {boolean}
   */

  this.overlaps = overlaps;
  /**
   * @protected
   * @type {number}
   */

  this.pixelRatio = pixelRatio;
  /**
   * @protected
   * @type {number}
   */

  this.maxLineWidth = 0;
  /**
   * @protected
   * @const
   * @type {number}
   */

  this.resolution = resolution;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.fillOrigin_;
  /**
   * @private
   * @type {Array.<*>}
   */

  this.beginGeometryInstruction1_ = null;
  /**
   * @private
   * @type {Array.<*>}
   */

  this.beginGeometryInstruction2_ = null;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.bufferedMaxExtent_ = null;
  /**
   * @protected
   * @type {Array.<*>}
   */

  this.instructions = [];
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.coordinates = [];
  /**
   * @private
   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}
   */

  this.coordinateCache_ = {};
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.renderedTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].create();
  /**
   * @protected
   * @type {Array.<*>}
   */

  this.hitDetectionInstructions = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.pixelCoordinates_ = null;
  /**
   * @protected
   * @type {ol.CanvasFillStrokeState}
   */

  this.state =
  /** @type {ol.CanvasFillStrokeState} */
  {};
  /**
   * @private
   * @type {number}
   */

  this.viewRotation_ = 0;
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.tmpLocalTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].create();
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.resetTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_Replay_, _vectorcontext_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Coordinate} p1 1st point of the background box.
 * @param {ol.Coordinate} p2 2nd point of the background box.
 * @param {ol.Coordinate} p3 3rd point of the background box.
 * @param {ol.Coordinate} p4 4th point of the background box.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */


_ol_render_canvas_Replay_.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
  context.beginPath();
  context.moveTo.apply(context, p1);
  context.lineTo.apply(context, p2);
  context.lineTo.apply(context, p3);
  context.lineTo.apply(context, p4);
  context.lineTo.apply(context, p1);

  if (fillInstruction) {
    this.fillOrigin_ =
    /** @type {Array.<number>} */
    fillInstruction[2];
    this.fill_(context);
  }

  if (strokeInstruction) {
    this.setStrokeStyle_(context,
    /** @type {Array.<*>} */
    strokeInstruction);
    context.stroke();
  }
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} anchorX Anchor X.
 * @param {number} anchorY Anchor Y.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {number} height Height.
 * @param {number} opacity Opacity.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} rotation Rotation.
 * @param {number} scale Scale.
 * @param {boolean} snapToPixel Snap to pixel.
 * @param {number} width Width.
 * @param {Array.<number>} padding Padding.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */


_ol_render_canvas_Replay_.prototype.replayImage_ = function (context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
  var fillStroke = fillInstruction || strokeInstruction;
  var localTransform = this.tmpLocalTransform_;
  anchorX *= scale;
  anchorY *= scale;
  x -= anchorX;
  y -= anchorY;

  if (snapToPixel) {
    x = Math.round(x);
    y = Math.round(y);
  }

  var w = width + originX > image.width ? image.width - originX : width;
  var h = height + originY > image.height ? image.height - originY : height;
  var box = this.tmpExtent_;
  var boxW = padding[3] + w * scale + padding[1];
  var boxH = padding[0] + h * scale + padding[2];
  var boxX = x - padding[3];
  var boxY = y - padding[0];
  /** @type {ol.Coordinate} */

  var p1;
  /** @type {ol.Coordinate} */

  var p2;
  /** @type {ol.Coordinate} */

  var p3;
  /** @type {ol.Coordinate} */

  var p4;

  if (fillStroke || rotation !== 0) {
    p1 = [boxX, boxY];
    p2 = [boxX + boxW, boxY];
    p3 = [boxX + boxW, boxY + boxH];
    p4 = [boxX, boxY + boxH];
  }

  var transform = null;

  if (rotation !== 0) {
    var centerX = x + anchorX;
    var centerY = y + anchorY;
    transform = _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createOrUpdateEmpty(box);

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extendCoordinate(box, _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].apply(localTransform, p1));

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extendCoordinate(box, _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].apply(localTransform, p2));

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extendCoordinate(box, _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].apply(localTransform, p3));

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extendCoordinate(box, _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].apply(localTransform, p4));
  } else {
    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);
  }

  var canvas = context.canvas;
  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;

  if (declutterGroup) {
    if (!intersects && declutterGroup[4] == 1) {
      return;
    }

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extend(declutterGroup, box);

    var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;

    if (declutterArgs && fillStroke) {
      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
    }

    declutterGroup.push(declutterArgs);
  } else if (intersects) {
    if (fillStroke) {
      this.replayTextBackground_(context, p1, p2, p3, p4,
      /** @type {Array.<*>} */
      fillInstruction,
      /** @type {Array.<*>} */
      strokeInstruction);
    }

    _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
  }
};
/**
 * @protected
 * @param {Array.<number>} dashArray Dash array.
 * @return {Array.<number>} Dash array with pixel ratio applied
 */


_ol_render_canvas_Replay_.prototype.applyPixelRatio = function (dashArray) {
  var pixelRatio = this.pixelRatio;
  return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
    return dash * pixelRatio;
  });
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} closed Last input coordinate equals first.
 * @param {boolean} skipFirst Skip first coordinate.
 * @protected
 * @return {number} My end.
 */


_ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
  var myEnd = this.coordinates.length;
  var extent = this.getBufferedMaxExtent();

  if (skipFirst) {
    offset += stride;
  }

  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var nextCoord = [NaN, NaN];
  var skipped = true;
  var i, lastRel, nextRel;

  for (i = offset + stride; i < end; i += stride) {
    nextCoord[0] = flatCoordinates[i];
    nextCoord[1] = flatCoordinates[i + 1];
    nextRel = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].coordinateRelationship(extent, nextCoord);

    if (nextRel !== lastRel) {
      if (skipped) {
        this.coordinates[myEnd++] = lastCoord[0];
        this.coordinates[myEnd++] = lastCoord[1];
      }

      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else if (nextRel === _extent_relationship_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERSECTING) {
      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else {
      skipped = true;
    }

    lastCoord[0] = nextCoord[0];
    lastCoord[1] = nextCoord[1];
    lastRel = nextRel;
  } // Last coordinate equals first or only one point to append:


  if (closed && skipped || i === offset + stride) {
    this.coordinates[myEnd++] = lastCoord[0];
    this.coordinates[myEnd++] = lastCoord[1];
  }

  return myEnd;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} replayEnds Replay ends.
 * @return {number} Offset.
 */


_ol_render_canvas_Replay_.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, replayEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
    replayEnds.push(replayEnd);
    offset = end;
  }

  return offset;
};
/**
 * @inheritDoc.
 */


_ol_render_canvas_Replay_.prototype.drawCustom = function (geometry, feature, renderer) {
  this.beginGeometry(geometry, feature);
  var type = geometry.getType();
  var stride = geometry.getStride();
  var replayBegin = this.coordinates.length;
  var flatCoordinates, replayEnd, replayEnds, replayEndss;
  var offset;

  if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
    geometry =
    /** @type {ol.geom.MultiPolygon} */
    geometry;
    flatCoordinates = geometry.getOrientedFlatCoordinates();
    replayEndss = [];
    var endss = geometry.getEndss();
    offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var myEnds = [];
      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
      replayEndss.push(myEnds);
    }

    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM, replayBegin, replayEndss, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["default"].coordinatesss]);
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON || type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
    replayEnds = [];
    flatCoordinates = type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON ?
    /** @type {ol.geom.Polygon} */
    geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
    offset = this.drawCustomCoordinates_(flatCoordinates, 0,
    /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */
    geometry.getEnds(), stride, replayEnds);
    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM, replayBegin, replayEnds, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["default"].coordinatess]);
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING || type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM, replayBegin, replayEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["default"].coordinates]);
  } else if (type == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
    replayEnd = this.coordinates.length;
    this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM, replayBegin, replayEnd, geometry, renderer]);
  }

  this.endGeometry(geometry, feature);
};
/**
 * @protected
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.beginGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_ = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
  this.instructions.push(this.beginGeometryInstruction1_);
  this.beginGeometryInstruction2_ = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 */


_ol_render_canvas_Replay_.prototype.fill_ = function (context) {
  if (this.fillOrigin_) {
    var origin = _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].apply(this.renderedTransform_, this.fillOrigin_.slice());

    context.translate(origin[0], origin[1]);
    context.rotate(this.viewRotation_);
  }

  context.fill();

  if (this.fillOrigin_) {
    context.setTransform.apply(context, _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].resetTransform_);
  }
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {Array.<*>} instruction Instruction.
 */


_ol_render_canvas_Replay_.prototype.setStrokeStyle_ = function (context, instruction) {
  context.strokeStyle =
  /** @type {ol.ColorLike} */
  instruction[1];
  context.lineWidth =
  /** @type {number} */
  instruction[2];
  context.lineCap =
  /** @type {string} */
  instruction[3];
  context.lineJoin =
  /** @type {string} */
  instruction[4];
  context.miterLimit =
  /** @type {number} */
  instruction[5];

  if (_has_js__WEBPACK_IMPORTED_MODULE_10__["default"].CANVAS_LINE_DASH) {
    context.lineDashOffset =
    /** @type {number} */
    instruction[7];
    context.setLineDash(
    /** @type {Array.<number>} */
    instruction[6]);
  }
};
/**
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.renderDeclutter_ = function (declutterGroup, feature) {
  if (declutterGroup && declutterGroup.length > 5) {
    var groupCount = declutterGroup[4];

    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
      /** @type {ol.RBushEntry} */
      var box = {
        minX:
        /** @type {number} */
        declutterGroup[0],
        minY:
        /** @type {number} */
        declutterGroup[1],
        maxX:
        /** @type {number} */
        declutterGroup[2],
        maxY:
        /** @type {number} */
        declutterGroup[3],
        value: feature
      };

      if (!this.declutterTree.collides(box)) {
        this.declutterTree.insert(box);
        var drawImage = _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].drawImage;

        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
          var declutterData =
          /** @type {Array} */
          declutterGroup[j];

          if (declutterData) {
            if (declutterData.length > 11) {
              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);
            }

            drawImage.apply(undefined, declutterData);
          }
        }
      }

      declutterGroup.length = 5;

      _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createOrUpdateEmpty(declutterGroup);
    }
  }
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined}
 *     featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_Replay_.prototype.replay_ = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {
  /** @type {Array.<number>} */
  var pixelCoordinates;

  if (this.pixelCoordinates_ && _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(transform, this.renderedTransform_)) {
    pixelCoordinates = this.pixelCoordinates_;
  } else {
    if (!this.pixelCoordinates_) {
      this.pixelCoordinates_ = [];
    }

    pixelCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);

    _transform_js__WEBPACK_IMPORTED_MODULE_16__["default"].setFromArray(this.renderedTransform_, transform);
  }

  var skipFeatures = !_obj_js__WEBPACK_IMPORTED_MODULE_11__["default"].isEmpty(skippedFeaturesHash);
  var i = 0; // instruction index

  var ii = instructions.length; // end of instructions

  var d = 0; // data index

  var dd; // end of per-instruction data

  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
  var pendingFill = 0;
  var pendingStroke = 0;
  var lastFillInstruction = null;
  var lastStrokeInstruction = null;
  var coordinateCache = this.coordinateCache_;
  var viewRotation = this.viewRotation_;
  var state =
  /** @type {olx.render.State} */
  {
    context: context,
    pixelRatio: this.pixelRatio,
    resolution: this.resolution,
    rotation: viewRotation
  }; // When the batch size gets too big, performance decreases. 200 is a good
  // balance between batch size and number of fill/stroke instructions.

  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;

  while (i < ii) {
    var instruction = instructions[i];
    var type =
    /** @type {ol.render.canvas.Instruction} */
    instruction[0];
    var
    /** @type {ol.Feature|ol.render.Feature} */
    feature, x, y;

    switch (type) {
      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY:
        feature =
        /** @type {ol.Feature|ol.render.Feature} */
        instruction[1];

        if (skipFeatures && skippedFeaturesHash[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString()] || !feature.getGeometry()) {
          i =
          /** @type {number} */
          instruction[2];
        } else if (opt_hitExtent !== undefined && !_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(opt_hitExtent, feature.getGeometry().getExtent())) {
          i =
          /** @type {number} */
          instruction[2] + 1;
        } else {
          ++i;
        }

        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_PATH:
        if (pendingFill > batchSize) {
          this.fill_(context);
          pendingFill = 0;
        }

        if (pendingStroke > batchSize) {
          context.stroke();
          pendingStroke = 0;
        }

        if (!pendingFill && !pendingStroke) {
          context.beginPath();
          prevX = prevY = NaN;
        }

        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE:
        d =
        /** @type {number} */
        instruction[1];
        var x1 = pixelCoordinates[d];
        var y1 = pixelCoordinates[d + 1];
        var x2 = pixelCoordinates[d + 2];
        var y2 = pixelCoordinates[d + 3];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var r = Math.sqrt(dx * dx + dy * dy);
        context.moveTo(x1 + r, y1);
        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CLOSE_PATH:
        context.closePath();
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM:
        d =
        /** @type {number} */
        instruction[1];
        dd = instruction[2];
        var geometry =
        /** @type {ol.geom.SimpleGeometry} */
        instruction[3];
        var renderer = instruction[4];
        var fn = instruction.length == 6 ? instruction[5] : undefined;
        state.geometry = geometry;
        state.feature = feature;

        if (!(i in coordinateCache)) {
          coordinateCache[i] = [];
        }

        var coords = coordinateCache[i];

        if (fn) {
          fn(pixelCoordinates, d, dd, 2, coords);
        } else {
          coords[0] = pixelCoordinates[d];
          coords[1] = pixelCoordinates[d + 1];
          coords.length = 2;
        }

        renderer(coords, state);
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_IMAGE:
        d =
        /** @type {number} */
        instruction[1];
        dd =
        /** @type {number} */
        instruction[2];
        image =
        /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
        instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

        anchorX =
        /** @type {number} */
        instruction[4];
        anchorY =
        /** @type {number} */
        instruction[5];
        declutterGroup = featureCallback ? null :
        /** @type {ol.DeclutterGroup} */
        instruction[6];
        var height =
        /** @type {number} */
        instruction[7];
        var opacity =
        /** @type {number} */
        instruction[8];
        var originX =
        /** @type {number} */
        instruction[9];
        var originY =
        /** @type {number} */
        instruction[10];
        var rotateWithView =
        /** @type {boolean} */
        instruction[11];
        var rotation =
        /** @type {number} */
        instruction[12];
        var scale =
        /** @type {number} */
        instruction[13];
        var snapToPixel =
        /** @type {boolean} */
        instruction[14];
        var width =
        /** @type {number} */
        instruction[15];
        var padding, backgroundFill, backgroundStroke;

        if (instruction.length > 16) {
          padding =
          /** @type {Array.<number>} */
          instruction[16];
          backgroundFill =
          /** @type {boolean} */
          instruction[17];
          backgroundStroke =
          /** @type {boolean} */
          instruction[18];
        } else {
          padding = _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultPadding;
          backgroundFill = backgroundStroke = false;
        }

        if (rotateWithView) {
          rotation += viewRotation;
        }

        for (; d < dd; d += 2) {
          this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?
          /** @type {Array.<*>} */
          lastFillInstruction : null, backgroundStroke ?
          /** @type {Array.<*>} */
          lastStrokeInstruction : null);
        }

        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_CHARS:
        var begin =
        /** @type {number} */
        instruction[1];
        var end =
        /** @type {number} */
        instruction[2];
        var baseline =
        /** @type {number} */
        instruction[3];
        declutterGroup = featureCallback ? null :
        /** @type {ol.DeclutterGroup} */
        instruction[4];
        var overflow =
        /** @type {number} */
        instruction[5];
        var fillKey =
        /** @type {string} */
        instruction[6];
        var maxAngle =
        /** @type {number} */
        instruction[7];
        var measure =
        /** @type {function(string):number} */
        instruction[8];
        var offsetY =
        /** @type {number} */
        instruction[9];
        var strokeKey =
        /** @type {string} */
        instruction[10];
        var strokeWidth =
        /** @type {number} */
        instruction[11];
        var text =
        /** @type {string} */
        instruction[12];
        var textKey =
        /** @type {string} */
        instruction[13];
        var textScale =
        /** @type {number} */
        instruction[14];

        var pathLength = _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__["default"].lineString(pixelCoordinates, begin, end, 2);

        var textLength = measure(text);

        if (overflow || textLength <= pathLength) {
          var textAlign =
          /** @type {ol.render.canvas.TextReplay} */
          this.textStates[textKey].textAlign;
          var startM = (pathLength - textLength) * _replay_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXT_ALIGN[textAlign];

          var parts = _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__["default"].lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);

          if (parts) {
            var c, cc, chars, label, part;

            if (strokeKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk

                chars =
                /** @type {string} */
                part[4];
                label =
                /** @type {ol.render.canvas.TextReplay} */
                this.getImage(chars, textKey, '', strokeKey);
                anchorX =
                /** @type {number} */
                part[2] + strokeWidth;
                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                this.replayImage_(context,
                /** @type {number} */
                part[0],
                /** @type {number} */
                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */
                part[3], textScale, false, label.width, _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultPadding, null, null);
              }
            }

            if (fillKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk

                chars =
                /** @type {string} */
                part[4];
                label =
                /** @type {ol.render.canvas.TextReplay} */
                this.getImage(chars, textKey, fillKey, '');
                anchorX =
                /** @type {number} */
                part[2];
                anchorY = baseline * label.height - offsetY;
                this.replayImage_(context,
                /** @type {number} */
                part[0],
                /** @type {number} */
                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */
                part[3], textScale, false, label.width, _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultPadding, null, null);
              }
            }
          }
        }

        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY:
        if (featureCallback !== undefined) {
          feature =
          /** @type {ol.Feature|ol.render.Feature} */
          instruction[1];
          var result = featureCallback(feature);

          if (result) {
            return result;
          }
        }

        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].FILL:
        if (batchSize) {
          pendingFill++;
        } else {
          this.fill_(context);
        }

        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].MOVE_TO_LINE_TO:
        d =
        /** @type {number} */
        instruction[1];
        dd =
        /** @type {number} */
        instruction[2];
        x = pixelCoordinates[d];
        y = pixelCoordinates[d + 1];
        roundX = x + 0.5 | 0;
        roundY = y + 0.5 | 0;

        if (roundX !== prevX || roundY !== prevY) {
          context.moveTo(x, y);
          prevX = roundX;
          prevY = roundY;
        }

        for (d += 2; d < dd; d += 2) {
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;

          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
            context.lineTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
        }

        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE:
        lastFillInstruction = instruction;
        this.fillOrigin_ = instruction[2];

        if (pendingFill) {
          this.fill_(context);
          pendingFill = 0;

          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
        }

        context.fillStyle =
        /** @type {ol.ColorLike} */
        instruction[1];
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE:
        lastStrokeInstruction = instruction;

        if (pendingStroke) {
          context.stroke();
          pendingStroke = 0;
        }

        this.setStrokeStyle_(context,
        /** @type {Array.<*>} */
        instruction);
        ++i;
        break;

      case _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].STROKE:
        if (batchSize) {
          pendingStroke++;
        } else {
          context.stroke();
        }

        ++i;
        break;

      default:
        ++i; // consume the instruction anyway, to avoid an infinite loop

        break;
    }
  }

  if (pendingFill) {
    this.fill_(context);
  }

  if (pendingStroke) {
    context.stroke();
  }

  return undefined;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 */


_ol_render_canvas_Replay_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash) {
  this.viewRotation_ = viewRotation;
  this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_Replay_.prototype.replayHitDetection = function (context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {
  this.viewRotation_ = viewRotation;
  return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
};
/**
 * Reverse the hit detection instructions.
 */


_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function () {
  var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

  hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

  var i;
  var n = hitDetectionInstructions.length;
  var instruction;
  var type;
  var begin = -1;

  for (i = 0; i < n; ++i) {
    instruction = hitDetectionInstructions[i];
    type =
    /** @type {ol.render.canvas.Instruction} */
    instruction[0];

    if (type == _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY) {
      begin = i;
    } else if (type == _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY) {
      instruction[2] = i;

      _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].reverseSubArray(this.hitDetectionInstructions, begin, i);

      begin = -1;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_canvas_Replay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var state = this.state;

  if (fillStyle) {
    var fillStyleColor = fillStyle.getColor();
    state.fillStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultFillStyle);
  } else {
    state.fillStyle = undefined;
  }

  if (strokeStyle) {
    var strokeStyleColor = strokeStyle.getColor();
    state.strokeStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_2__["default"].asColorLike(strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultStrokeStyle);
    var strokeStyleLineCap = strokeStyle.getLineCap();
    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultLineJoin;
    var strokeStyleWidth = strokeStyle.getWidth();
    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultMiterLimit;

    if (state.lineWidth > this.maxLineWidth) {
      this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

      this.bufferedMaxExtent_ = null;
    }
  } else {
    state.strokeStyle = undefined;
    state.lineCap = undefined;
    state.lineDash = null;
    state.lineDashOffset = undefined;
    state.lineJoin = undefined;
    state.lineWidth = undefined;
    state.miterLimit = undefined;
  }
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_Replay_.prototype.applyFill = function (state, geometry) {
  var fillStyle = state.fillStyle;
  var fillInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE, fillStyle];

  if (typeof fillStyle !== 'string') {
    var fillExtent = geometry.getExtent();
    fillInstruction.push([fillExtent[0], fillExtent[3]]);
  }

  this.instructions.push(fillInstruction);
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 */


_ol_render_canvas_Replay_.prototype.applyStroke = function (state) {
  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio]);
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_Replay_.prototype.updateFillStyle = function (state, applyFill, geometry) {
  var fillStyle = state.fillStyle;

  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
    applyFill.call(this, state, geometry);
    state.currentFillStyle = fillStyle;
  }
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.
 */


_ol_render_canvas_Replay_.prototype.updateStrokeStyle = function (state, applyStroke) {
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;

  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
    applyStroke.call(this, state);
    state.currentStrokeStyle = strokeStyle;
    state.currentLineCap = lineCap;
    state.currentLineDash = lineDash;
    state.currentLineDashOffset = lineDashOffset;
    state.currentLineJoin = lineJoin;
    state.currentLineWidth = lineWidth;
    state.currentMiterLimit = miterLimit;
  }
};
/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.endGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_[2] = this.instructions.length;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
  this.beginGeometryInstruction2_ = null;
  var endGeometryInstruction = [_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY, feature];
  this.instructions.push(endGeometryInstruction);
  this.hitDetectionInstructions.push(endGeometryInstruction);
};
/**
 * FIXME empty description for jsdoc
 */


_ol_render_canvas_Replay_.prototype.finish = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */

_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function () {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].clone(this.maxExtent);

    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;

      _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }

  return this.bufferedMaxExtent_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_Replay_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/replaygroup.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/replaygroup.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _replaygroup_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../replaygroup.js */ "./node_modules/ol/render/replaygroup.js");
/* harmony import */ var _replaytype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../replaytype.js */ "./node_modules/ol/render/replaytype.js");
/* harmony import */ var _canvas_replay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas/replay.js */ "./node_modules/ol/render/canvas/replay.js");
/* harmony import */ var _canvas_imagereplay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../canvas/imagereplay.js */ "./node_modules/ol/render/canvas/imagereplay.js");
/* harmony import */ var _canvas_linestringreplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../canvas/linestringreplay.js */ "./node_modules/ol/render/canvas/linestringreplay.js");
/* harmony import */ var _canvas_polygonreplay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../canvas/polygonreplay.js */ "./node_modules/ol/render/canvas/polygonreplay.js");
/* harmony import */ var _canvas_textreplay_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../canvas/textreplay.js */ "./node_modules/ol/render/canvas/textreplay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");















/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay group can have overlapping geometries.
 * @param {?} declutterTree Declutter tree
 * for declutter processing in postrender.
 * @param {number=} opt_renderBuffer Optional rendering buffer.
 * @struct
 */

var _ol_render_canvas_ReplayGroup_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {
  _replaygroup_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this);
  /**
   * Declutter tree.
   * @private
   */


  this.declutterTree_ = declutterTree;
  /**
   * @type {ol.DeclutterGroup}
   * @private
   */

  this.declutterGroup_ = null;
  /**
   * @private
   * @type {number}
   */

  this.tolerance_ = tolerance;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.maxExtent_ = maxExtent;
  /**
   * @private
   * @type {boolean}
   */

  this.overlaps_ = overlaps;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   * @type {number}
   */

  this.resolution_ = resolution;
  /**
   * @private
   * @type {number|undefined}
   */

  this.renderBuffer_ = opt_renderBuffer;
  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}
   */

  this.replaysByZIndex_ = {};
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitDetectionContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(1, 1);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.hitDetectionTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_14__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_ReplayGroup_, _replaygroup_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 * @private
 */


_ol_render_canvas_ReplayGroup_.circleArrayCache_ = {
  0: [[true]]
};
/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @private
 */

_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_ = function (array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);

  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
};
/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 * @private
 */


_ol_render_canvas_ReplayGroup_.getCircleArray_ = function (radius) {
  if (_ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] !== undefined) {
    return _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);

  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;

    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] = arr;
  return arr;
};
/**
 * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */


_ol_render_canvas_ReplayGroup_.replayDeclutter = function (declutterReplays, context, rotation) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].numberSafeCompareFunction);
  var skippedFeatureUids = {};

  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];

    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids);
    }
  }
};
/**
 * @param {boolean} group Group with previous replay.
 * @return {ol.DeclutterGroup} Declutter instruction group.
 */


_ol_render_canvas_ReplayGroup_.prototype.addDeclutter = function (group) {
  var declutter = null;

  if (this.declutterTree_) {
    if (group) {
      declutter = this.declutterGroup_;
      /** @type {number} */

      declutter[4]++;
    } else {
      declutter = this.declutterGroup_ = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createEmpty();
      declutter.push(1);
    }
  }

  return declutter;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 */


_ol_render_canvas_ReplayGroup_.prototype.clip = function (context, transform) {
  var flatClipCoords = this.getClipCoords(transform);
  context.beginPath();
  context.moveTo(flatClipCoords[0], flatClipCoords[1]);
  context.lineTo(flatClipCoords[2], flatClipCoords[3]);
  context.lineTo(flatClipCoords[4], flatClipCoords[5]);
  context.lineTo(flatClipCoords[6], flatClipCoords[7]);
  context.clip();
};
/**
 * @param {Array.<ol.render.ReplayType>} replays Replays.
 * @return {boolean} Has replays of the provided types.
 */


_ol_render_canvas_ReplayGroup_.prototype.hasReplays = function (replays) {
  for (var zIndex in this.replaysByZIndex_) {
    var candidates = this.replaysByZIndex_[zIndex];

    for (var i = 0, ii = replays.length; i < ii; ++i) {
      if (replays[i] in candidates) {
        return true;
      }
    }
  }

  return false;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_render_canvas_ReplayGroup_.prototype.finish = function () {
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      replays[replayKey].finish();
    }
  }
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @param {Object.<string, ol.DeclutterGroup>} declutterReplays Declutter
 *     replays.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {
  hitTolerance = Math.round(hitTolerance);
  var contextSize = hitTolerance * 2 + 1;

  var transform = _transform_js__WEBPACK_IMPORTED_MODULE_14__["default"].compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);

  var context = this.hitDetectionContext_;

  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
    context.canvas.width = contextSize;
    context.canvas.height = contextSize;
  } else {
    context.clearRect(0, 0, contextSize, contextSize);
  }
  /**
   * @type {ol.Extent}
   */


  var hitExtent;

  if (this.renderBuffer_ !== undefined) {
    hitExtent = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createEmpty();

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].extendCoordinate(hitExtent, coordinate);

    _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
  }

  var mask = _ol_render_canvas_ReplayGroup_.getCircleArray_(hitTolerance);

  var declutteredFeatures;

  if (this.declutterTree_) {
    declutteredFeatures = this.declutterTree_.all().map(function (entry) {
      return entry.value;
    });
  }

  var replayType;
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */

  function featureCallback(feature) {
    var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

    for (var i = 0; i < contextSize; i++) {
      for (var j = 0; j < contextSize; j++) {
        if (mask[i][j]) {
          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
            var result;

            if (!(declutteredFeatures && (replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].IMAGE || replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {
              result = callback(feature);
            }

            if (result) {
              return result;
            } else {
              context.clearRect(0, 0, contextSize, contextSize);
              return undefined;
            }
          }
        }
      }
    }
  }
  /** @type {Array.<number>} */


  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].numberSafeCompareFunction);
  var i, j, replays, replay, result;

  for (i = zs.length - 1; i >= 0; --i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];

    for (j = _replay_js__WEBPACK_IMPORTED_MODULE_13__["default"].ORDER.length - 1; j >= 0; --j) {
      replayType = _replay_js__WEBPACK_IMPORTED_MODULE_13__["default"].ORDER[j];
      replay = replays[replayType];

      if (replay !== undefined) {
        if (declutterReplays && (replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].IMAGE || replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].TEXT)) {
          var declutter = declutterReplays[zIndexKey];

          if (!declutter) {
            declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);

          if (result) {
            return result;
          }
        }
      }
    }
  }

  return undefined;
};
/**
 * @param {ol.Transform} transform Transform.
 * @return {Array.<number>} Clip coordinates.
 */


_ol_render_canvas_ReplayGroup_.prototype.getClipCoords = function (transform) {
  var maxExtent = this.maxExtent_;
  var minX = maxExtent[0];
  var minY = maxExtent[1];
  var maxX = maxExtent[2];
  var maxY = maxExtent[3];
  var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];

  _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["default"].transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);

  return flatClipCoords;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];

  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }

  var replay = replays[replayType];

  if (replay === undefined) {
    var Constructor = _ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
    replays[replayType] = replay;
  }

  return replay;
};
/**
 * @return {Object.<string, Object.<ol.render.ReplayType, ol.render.canvas.Replay>>} Replays.
 */


_ol_render_canvas_ReplayGroup_.prototype.getReplays = function () {
  return this.replaysByZIndex_;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ReplayGroup_.prototype.isEmpty = function () {
  return _obj_js__WEBPACK_IMPORTED_MODULE_5__["default"].isEmpty(this.replaysByZIndex_);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types
 *     to replay. Default is {@link ol.render.replay.ORDER}
 * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter
 *     replays.
 */


_ol_render_canvas_ReplayGroup_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
  // visible outside the current extent when panning

  context.save();
  this.clip(context, transform);
  var replayTypes = opt_replayTypes ? opt_replayTypes : _replay_js__WEBPACK_IMPORTED_MODULE_13__["default"].ORDER;
  var i, ii, j, jj, replays, replay;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];

    for (j = 0, jj = replayTypes.length; j < jj; ++j) {
      var replayType = replayTypes[j];
      replay = replays[replayType];

      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].IMAGE || replayType == _replaytype_js__WEBPACK_IMPORTED_MODULE_7__["default"].TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];

          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          replay.replay(context, transform, viewRotation, skippedFeaturesHash);
        }
      }
    }
  }

  context.restore();
};
/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.canvas.Replay, number, ol.Extent,
 *                number, number, boolean, Array.<ol.DeclutterGroup>)>}
 */


_ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': _canvas_polygonreplay_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  'Default': _canvas_replay_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  'Image': _canvas_imagereplay_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  'LineString': _canvas_linestringreplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Polygon': _canvas_polygonreplay_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  'Text': _canvas_textreplay_js__WEBPACK_IMPORTED_MODULE_12__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_ReplayGroup_);

/***/ }),

/***/ "./node_modules/ol/render/canvas/textreplay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/canvas/textreplay.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./node_modules/ol/geom/flat/straightchunk.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_instruction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas/instruction.js */ "./node_modules/ol/render/canvas/instruction.js");
/* harmony import */ var _canvas_replay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../canvas/replay.js */ "./node_modules/ol/render/canvas/replay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _style_textplacement_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../style/textplacement.js */ "./node_modules/ol/style/textplacement.js");












/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */

var _ol_render_canvas_TextReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _canvas_replay_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  /**
   * @private
   * @type {ol.DeclutterGroup}
   */


  this.declutterGroup_;
  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */

  this.labels_ = null;
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number}
   */

  this.textOffsetX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textOffsetY_ = 0;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.textRotateWithView_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.textRotation_ = 0;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.textFillState_ = null;
  /**
   * @type {Object.<string, ol.CanvasFillState>}
   */

  this.fillStates = {};
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.textStrokeState_ = null;
  /**
   * @type {Object.<string, ol.CanvasStrokeState>}
   */

  this.strokeStates = {};
  /**
   * @private
   * @type {ol.CanvasTextState}
   */

  this.textState_ =
  /** @type {ol.CanvasTextState} */
  {};
  /**
   * @type {Object.<string, ol.CanvasTextState>}
   */

  this.textStates = {};
  /**
   * @private
   * @type {string}
   */

  this.textKey_ = '';
  /**
   * @private
   * @type {string}
   */

  this.fillKey_ = '';
  /**
   * @private
   * @type {string}
   */

  this.strokeKey_ = '';
  /**
   * @private
   * @type {Object.<string, Object.<string, number>>}
   */

  this.widths_ = {};
  var labelCache = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].labelCache;
  labelCache.prune();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_canvas_TextReplay_, _canvas_replay_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * @param {string} font Font to use for measuring.
 * @param {Array.<string>} lines Lines to measure.
 * @param {Array.<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */


_ol_render_canvas_TextReplay_.measureTextWidths = function (font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  var currentWidth, i;

  for (i = 0; i < numLines; ++i) {
    currentWidth = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }

  return width;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_TextReplay_.prototype.drawText = function (geometry, feature) {
  var fillState = this.textFillState_;
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;

  if (this.text_ === '' || !textState || !fillState && !strokeState) {
    return;
  }

  var begin = this.coordinates.length;
  var geometryType = geometry.getType();
  var flatCoordinates = null;
  var end = 2;
  var stride = 2;
  var i, ii;

  if (textState.placement === _style_textplacement_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE) {
    if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
      return;
    }

    var ends;
    flatCoordinates = geometry.getFlatCoordinates();
    stride = geometry.getStride();

    if (geometryType == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING) {
      ends = [flatCoordinates.length];
    } else if (geometryType == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
      ends = geometry.getEnds();
    } else if (geometryType == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) {
      ends = geometry.getEnds().slice(0, 1);
    } else if (geometryType == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
      var endss = geometry.getEndss();
      ends = [];

      for (i = 0, ii = endss.length; i < ii; ++i) {
        ends.push(endss[i][0]);
      }
    }

    this.beginGeometry(geometry, feature);
    var textAlign = textState.textAlign;
    var flatOffset = 0;
    var flatEnd;

    for (var o = 0, oo = ends.length; o < oo; ++o) {
      if (textAlign == undefined) {
        var range = _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__["default"].lineString(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);

        flatOffset = range[0];
        flatEnd = range[1];
      } else {
        flatEnd = ends[o];
      }

      for (i = flatOffset; i < flatEnd; i += stride) {
        this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
      }

      end = this.coordinates.length;
      flatOffset = ends[o];
      this.drawChars_(begin, end, this.declutterGroup_);
      begin = end;
    }

    this.endGeometry(geometry, feature);
  } else {
    var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
    var width = label.width / this.pixelRatio;

    switch (geometryType) {
      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.LineString} */
        geometry.getFlatMidpoint();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE:
        flatCoordinates =
        /** @type {ol.geom.Circle} */
        geometry.getCenter();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.MultiLineString} */
        geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
        flatCoordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getFlatInteriorPoint();

        if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
          return;
        }

        stride = 3;
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
        var interiorPoints =
        /** @type {ol.geom.MultiPolygon} */
        geometry.getFlatInteriorPoints();
        flatCoordinates = [];

        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
          if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
        }

        end = flatCoordinates.length;

        if (end == 0) {
          return;
        }

        break;

      default:
    }

    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
    this.beginGeometry(geometry, feature);

    if (textState.backgroundFill || textState.backgroundStroke) {
      this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
      this.updateFillStyle(this.state, this.applyFill, geometry);
      this.updateStrokeStyle(this.state, this.applyStroke);
    }

    this.drawTextImage_(label, begin, end);
    this.endGeometry(geometry, feature);
  }
};
/**
 * @param {string} text Text.
 * @param {string} textKey Text style key.
 * @param {string} fillKey Fill style key.
 * @param {string} strokeKey Stroke style key.
 * @return {HTMLCanvasElement} Image.
 */


_ol_render_canvas_TextReplay_.prototype.getImage = function (text, textKey, fillKey, strokeKey) {
  var label;
  var key = strokeKey + textKey + text + fillKey + this.pixelRatio;
  var labelCache = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].labelCache;

  if (!labelCache.containsKey(key)) {
    var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
    var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
    var textState = this.textStates[textKey] || this.textState_;
    var pixelRatio = this.pixelRatio;
    var scale = textState.scale * pixelRatio;
    var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["default"].TEXT_ALIGN[textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultTextAlign];
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var lines = text.split('\n');
    var numLines = lines.length;
    var widths = [];

    var width = _ol_render_canvas_TextReplay_.measureTextWidths(textState.font, lines, widths);

    var lineHeight = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].measureTextHeight(textState.font);

    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;

    var context = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));

    label = context.canvas;
    labelCache.set(key, label);

    if (scale != 1) {
      context.scale(scale, scale);
    }

    context.font = textState.font;

    if (strokeKey) {
      context.strokeStyle = strokeState.strokeStyle;
      context.lineWidth = strokeWidth * (_has_js__WEBPACK_IMPORTED_MODULE_6__["default"].SAFARI ? scale : 1);
      context.lineCap = strokeState.lineCap;
      context.lineJoin = strokeState.lineJoin;
      context.miterLimit = strokeState.miterLimit;

      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["default"].CANVAS_LINE_DASH && strokeState.lineDash.length) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
    }

    if (fillKey) {
      context.fillStyle = fillState.fillStyle;
    }

    context.textBaseline = 'middle';
    context.textAlign = 'center';
    var leftRight = 0.5 - align;
    var x = align * label.width / scale + leftRight * strokeWidth;
    var i;

    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }

    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
  }

  return labelCache.get(key);
};
/**
 * @private
 * @param {HTMLCanvasElement} label Label.
 * @param {number} begin Begin.
 * @param {number} end End.
 */


_ol_render_canvas_TextReplay_.prototype.drawTextImage_ = function (label, begin, end) {
  var textState = this.textState_;
  var strokeState = this.textStrokeState_;
  var pixelRatio = this.pixelRatio;
  var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["default"].TEXT_ALIGN[textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultTextAlign];
  var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["default"].TEXT_ALIGN[textState.textBaseline];
  var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
  var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
  var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, true, label.width, textState.padding == _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultPadding ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultPadding : textState.padding.map(function (p) {
    return p * pixelRatio;
  }), !!textState.backgroundFill, !!textState.backgroundStroke]);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, true, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);
};
/**
 * @private
 * @param {number} begin Begin.
 * @param {number} end End.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 */


_ol_render_canvas_TextReplay_.prototype.drawChars_ = function (begin, end, declutterGroup) {
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  var fillState = this.textFillState_;
  var strokeKey = this.strokeKey_;

  if (strokeState) {
    if (!(strokeKey in this.strokeStates)) {
      this.strokeStates[strokeKey] =
      /** @type {ol.CanvasStrokeState} */
      {
        strokeStyle: strokeState.strokeStyle,
        lineCap: strokeState.lineCap,
        lineDashOffset: strokeState.lineDashOffset,
        lineWidth: strokeState.lineWidth,
        lineJoin: strokeState.lineJoin,
        miterLimit: strokeState.miterLimit,
        lineDash: strokeState.lineDash
      };
    }
  }

  var textKey = this.textKey_;

  if (!(this.textKey_ in this.textStates)) {
    this.textStates[this.textKey_] =
    /** @type {ol.CanvasTextState} */
    {
      font: textState.font,
      textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultTextAlign,
      scale: textState.scale
    };
  }

  var fillKey = this.fillKey_;

  if (fillState) {
    if (!(fillKey in this.fillStates)) {
      this.fillStates[fillKey] =
      /** @type {ol.CanvasFillState} */
      {
        fillStyle: fillState.fillStyle
      };
    }
  }

  var pixelRatio = this.pixelRatio;
  var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["default"].TEXT_ALIGN[textState.textBaseline];
  var offsetY = this.textOffsetY_ * pixelRatio;
  var text = this.text_;
  var font = textState.font;
  var textScale = textState.scale;
  var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
  var widths = this.widths_[font];

  if (!widths) {
    this.widths_[font] = widths = {};
  }

  this.instructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];

    if (!width) {
      width = widths[text] = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].measureTextWidth(font, text);
    }

    return width * textScale * pixelRatio;
  }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
  this.hitDetectionInstructions.push([_canvas_instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];

    if (!width) {
      width = widths[text] = _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].measureTextWidth(font, text);
    }

    return width * textScale;
  }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_TextReplay_.prototype.setTextStyle = function (textStyle, declutterGroup) {
  var textState, fillState, strokeState;

  if (!textStyle) {
    this.text_ = '';
  } else {
    this.declutterGroup_ =
    /** @type {ol.DeclutterGroup} */
    declutterGroup;
    var textFillStyle = textStyle.getFill();

    if (!textFillStyle) {
      fillState = this.textFillState_ = null;
    } else {
      fillState = this.textFillState_;

      if (!fillState) {
        fillState = this.textFillState_ =
        /** @type {ol.CanvasFillState} */
        {};
      }

      fillState.fillStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultFillStyle);
    }

    var textStrokeStyle = textStyle.getStroke();

    if (!textStrokeStyle) {
      strokeState = this.textStrokeState_ = null;
    } else {
      strokeState = this.textStrokeState_;

      if (!strokeState) {
        strokeState = this.textStrokeState_ =
        /** @type {ol.CanvasStrokeState} */
        {};
      }

      var lineDash = textStrokeStyle.getLineDash();
      var lineDashOffset = textStrokeStyle.getLineDashOffset();
      var lineWidth = textStrokeStyle.getWidth();
      var miterLimit = textStrokeStyle.getMiterLimit();
      strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultLineCap;
      strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultLineDash;
      strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultLineDashOffset : lineDashOffset;
      strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultLineJoin;
      strokeState.lineWidth = lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultLineWidth : lineWidth;
      strokeState.miterLimit = miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultMiterLimit : miterLimit;
      strokeState.strokeStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultStrokeStyle);
    }

    textState = this.textState_;

    var font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultFont;

    _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkFont(font);

    var textScale = textStyle.getScale();
    textState.overflow = textStyle.getOverflow();
    textState.font = font;
    textState.maxAngle = textStyle.getMaxAngle();
    textState.placement = textStyle.getPlacement();
    textState.textAlign = textStyle.getTextAlign();
    textState.textBaseline = textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultTextBaseline;
    textState.backgroundFill = textStyle.getBackgroundFill();
    textState.backgroundStroke = textStyle.getBackgroundStroke();
    textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultPadding;
    textState.scale = textScale === undefined ? 1 : textScale;
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    this.text_ = textStyle.getText() || '';
    this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
    this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
    this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
    this.textRotation_ = textRotation === undefined ? 0 : textRotation;
    this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
    this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
    this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(fillState.fillStyle) : '';
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_canvas_TextReplay_);

/***/ }),

/***/ "./node_modules/ol/render/event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");


/**
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.render.Event}
 * @param {ol.render.EventType} type Type.
 * @param {ol.render.VectorContext=} opt_vectorContext Vector context.
 * @param {olx.FrameState=} opt_frameState Frame state.
 * @param {?CanvasRenderingContext2D=} opt_context Context.
 * @param {?ol.webgl.Context=} opt_glContext WebGL Context.
 */

var _ol_render_Event_ = function (type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, type);
  /**
   * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
   * @type {ol.render.VectorContext|undefined}
   * @api
   */


  this.vectorContext = opt_vectorContext;
  /**
   * An object representing the current render frame state.
   * @type {olx.FrameState|undefined}
   * @api
   */

  this.frameState = opt_frameState;
  /**
   * Canvas context. Only available when a Canvas renderer is used, null
   * otherwise.
   * @type {CanvasRenderingContext2D|null|undefined}
   * @api
   */

  this.context = opt_context;
  /**
   * WebGL context. Only available when a WebGL renderer is used, null
   * otherwise.
   * @type {ol.webgl.Context|null|undefined}
   * @api
   */

  this.glContext = opt_glContext;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_Event_, _events_event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_Event_);

/***/ }),

/***/ "./node_modules/ol/render/eventtype.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/eventtype.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_render_EventType_ = {
  /**
   * @event ol.render.Event#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * @event ol.render.Event#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * @event ol.render.Event#render
   * @api
   */
  RENDER: 'render'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_EventType_);

/***/ }),

/***/ "./node_modules/ol/render/replay.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/replay.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/replaytype.js */ "./node_modules/ol/render/replaytype.js");

var _ol_render_replay_ = {};
/**
 * @const
 * @type {Array.<ol.render.ReplayType>}
 */

_ol_render_replay_.ORDER = [_render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT];
/**
 * @const
 * @enum {number}
 */

_ol_render_replay_.TEXT_ALIGN = {};
_ol_render_replay_.TEXT_ALIGN['left'] = 0;
_ol_render_replay_.TEXT_ALIGN['end'] = 0;
_ol_render_replay_.TEXT_ALIGN['center'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['right'] = 1;
_ol_render_replay_.TEXT_ALIGN['start'] = 1;
_ol_render_replay_.TEXT_ALIGN['top'] = 0;
_ol_render_replay_.TEXT_ALIGN['middle'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['hanging'] = 0.2;
_ol_render_replay_.TEXT_ALIGN['alphabetic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['ideographic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['bottom'] = 1;
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_replay_);

/***/ }),

/***/ "./node_modules/ol/render/replaygroup.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/render/replaygroup.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Base class for replay groups.
 * @constructor
 * @abstract
 */
var _ol_render_ReplayGroup_ = function () {};
/**
 * @abstract
 * @param {number|undefined} zIndex Z index.
 * @param {ol.render.ReplayType} replayType Replay type.
 * @return {ol.render.VectorContext} Replay.
 */


_ol_render_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {};
/**
 * @abstract
 * @return {boolean} Is empty.
 */


_ol_render_ReplayGroup_.prototype.isEmpty = function () {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_ReplayGroup_);

/***/ }),

/***/ "./node_modules/ol/render/replaytype.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/render/replaytype.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_render_ReplayType_ = {
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_ReplayType_);

/***/ }),

/***/ "./node_modules/ol/render/vectorcontext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/vectorcontext.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @constructor
 * @abstract
 * @struct
 * @api
 */
var _ol_render_VectorContext_ = function () {};
/**
 * Render a geometry with a custom renderer.
 *
 * @param {ol.geom.SimpleGeometry} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {Function} renderer Renderer.
 */


_ol_render_VectorContext_.prototype.drawCustom = function (geometry, feature, renderer) {};
/**
 * Render a geometry.
 *
 * @param {ol.geom.Geometry} geometry The geometry to render.
 */


_ol_render_VectorContext_.prototype.drawGeometry = function (geometry) {};
/**
 * Set the rendering style.
 *
 * @param {ol.style.Style} style The rendering style.
 */


_ol_render_VectorContext_.prototype.setStyle = function (style) {};
/**
 * @param {ol.geom.Circle} circleGeometry Circle geometry.
 * @param {ol.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawCircle = function (circleGeometry, feature) {};
/**
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 */


_ol_render_VectorContext_.prototype.drawFeature = function (feature, style) {};
/**
 * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry
 *     collection.
 * @param {ol.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};
/**
 * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line
 *     string geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawLineString = function (lineStringGeometry, feature) {};
/**
 * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry
 *     MultiLineString geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};
/**
 * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};
/**
 * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};
/**
 * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawPoint = function (pointGeometry, feature) {};
/**
 * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawPolygon = function (polygonGeometry, feature) {};
/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawText = function (geometry, feature) {};
/**
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 */


_ol_render_VectorContext_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};
/**
 * @param {ol.style.Image} imageStyle Image style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */


_ol_render_VectorContext_.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) {};
/**
 * @param {ol.style.Text} textStyle Text style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */


_ol_render_VectorContext_.prototype.setTextStyle = function (textStyle, opt_declutterGroup) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_VectorContext_);

/***/ }),

/***/ "./node_modules/ol/render/webgl.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/webgl.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_render_webgl_ = {};
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultFont = '10px sans-serif';
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_webgl_.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultLineCap = 'round';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_webgl_.defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultLineDashOffset = 0;
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultMiterLimit = 10;
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_webgl_.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultTextAlign = 0.5;
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultTextBaseline = 0.5;
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultLineWidth = 1;
/**
 * Calculates the orientation of a triangle based on the determinant method.
 * @param {number} x1 First X coordinate.
 * @param {number} y1 First Y coordinate.
 * @param {number} x2 Second X coordinate.
 * @param {number} y2 Second Y coordinate.
 * @param {number} x3 Third X coordinate.
 * @param {number} y3 Third Y coordinate.
 * @return {boolean|undefined} Triangle is clockwise.
 */

_ol_render_webgl_.triangleIsCounterClockwise = function (x1, y1, x2, y2, x3, y3) {
  var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
  return area <= _ol_render_webgl_.EPSILON && area >= -_ol_render_webgl_.EPSILON ? undefined : area > 0;
};
/**
 * @const
 * @type {number}
 */


_ol_render_webgl_.EPSILON = Number.EPSILON || 2.220446049250313e-16;
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/circlereplay.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/webgl/circlereplay.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _webgl_circlereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl/circlereplay/defaultshader.js */ "./node_modules/ol/render/webgl/circlereplay/defaultshader.js");
/* harmony import */ var _webgl_circlereplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl/circlereplay/defaultshader/locations.js */ "./node_modules/ol/render/webgl/circlereplay/defaultshader/locations.js");
/* harmony import */ var _webgl_replay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/replay.js */ "./node_modules/ol/render/webgl/replay.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/render/webgl.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");












/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_CircleReplay_ = function (tolerance, maxExtent) {
  _webgl_replay_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.circlereplay.defaultshader.Locations}
   */


  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<Array.<number>|number>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {number}
   */

  this.radius_ = 0;
  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         strokeColor: (Array.<number>|null),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineWidth: (number|undefined),
   *         changed: boolean}|null}
   */

  this.state_ = {
    fillColor: null,
    strokeColor: null,
    lineDash: null,
    lineDashOffset: undefined,
    lineWidth: undefined,
    changed: false
  };
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_CircleReplay_, _webgl_replay_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_CircleReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  var n = numVertices / 4;
  var i, ii;

  for (i = offset, ii = end; i < ii; i += stride) {
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 0;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 1;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 2;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 3;
    this.vertices[numVertices++] = this.radius_;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
    this.indices[numIndices++] = n;
    n += 4;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var radius = circleGeometry.getRadius();
  var stride = circleGeometry.getStride();

  if (radius) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }

    this.radius_ = radius;
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    flatCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);
    this.drawCoordinates_(flatCoordinates, 0, 2, stride);
  } else {
    if (this.state_.changed) {
      this.styles_.pop();

      if (this.styles_.length) {
        var lastState = this.styles_[this.styles_.length - 1];
        this.state_.fillColor =
        /** @type {Array.<number>} */
        lastState[0];
        this.state_.strokeColor =
        /** @type {Array.<number>} */
        lastState[1];
        this.state_.lineWidth =
        /** @type {number} */
        lastState[2];
        this.state_.changed = false;
      }
    }
  }
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_CircleReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.indices);
  this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.getDeleteResourcesFunction = function (context) {
  // We only delete our stuff here. The shaders and the program may
  // be used by other CircleReplay instances (for other layers). And
  // they will be deleted when disposing of the ol.webgl.Context
  // object.
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _webgl_circlereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_6__["default"].fragment;
  vertexShader = _webgl_circlereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_6__["default"].vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _webgl_circlereplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_7__["default"](gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_10__["default"].FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(locations.a_instruction);
  gl.vertexAttribPointer(locations.a_instruction, 1, _webgl_js__WEBPACK_IMPORTED_MODULE_10__["default"].FLOAT, false, 16, 8);
  gl.enableVertexAttribArray(locations.a_radius);
  gl.vertexAttribPointer(locations.a_radius, 1, _webgl_js__WEBPACK_IMPORTED_MODULE_10__["default"].FLOAT, false, 16, 12); // Enable renderer specific uniforms.

  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_instruction);
  gl.disableVertexAttribArray(locations.a_radius);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  if (!_obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl,
      /** @type {Array.<number>} */
      nextStyle[0]);
      this.setStrokeStyle_(gl,
      /** @type {Array.<number>} */
      nextStyle[1],
      /** @type {number} */
      nextStyle[2]);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[0]);
    this.setStrokeStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[1],
    /** @type {number} */
    nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_CircleReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[0]);
    this.setStrokeStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[1],
    /** @type {number} */
    nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
    }

    start = end = groupStart;
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */


_ol_render_webgl_CircleReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_fillColor, color);
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 */


_ol_render_webgl_CircleReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth) {
  gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleColor, strokeStyleWidth;

  if (strokeStyle) {
    var strokeStyleLineDash = strokeStyle.getLineDash();
    this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineDashOffset;
    strokeStyleColor = strokeStyle.getColor();

    if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
      strokeStyleColor = _color_js__WEBPACK_IMPORTED_MODULE_2__["default"].asArray(strokeStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultStrokeStyle;
    } else {
      strokeStyleColor = _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultStrokeStyle;
    }

    strokeStyleWidth = strokeStyle.getWidth();
    strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultLineWidth;
  } else {
    strokeStyleColor = [0, 0, 0, 0];
    strokeStyleWidth = 0;
  }

  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];

  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = _color_js__WEBPACK_IMPORTED_MODULE_2__["default"].asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFillStyle;
  } else {
    fillStyleColor = _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFillStyle;
  }

  if (!this.state_.strokeColor || !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {
    this.state_.changed = true;
    this.state_.fillColor = fillStyleColor;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_CircleReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/circlereplay/defaultshader.js":
/*!********************************************************************!*\
  !*** ./node_modules/ol/render/webgl/circlereplay/defaultshader.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_render_webgl_circlereplay_defaultshader_ = {};
_ol_render_webgl_circlereplay_defaultshader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n' : 'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');
_ol_render_webgl_circlereplay_defaultshader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_circlereplay_defaultshader_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/circlereplay/defaultshader/locations.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ol/render/webgl/circlereplay/defaultshader/locations.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_render_webgl_circlereplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_lineWidth = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_lineWidth' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_pixelRatio = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_pixelRatio' : 'l');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_opacity' : 'm');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_fillColor = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_fillColor' : 'n');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_strokeColor = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_strokeColor' : 'o');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_size = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_size' : 'p');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'e');
  /**
   * @type {number}
   */

  this.a_instruction = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_instruction' : 'f');
  /**
   * @type {number}
   */

  this.a_radius = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_radius' : 'g');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_circlereplay_defaultshader_Locations_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/imagereplay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/webgl/imagereplay.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/texturereplay.js */ "./node_modules/ol/render/webgl/texturereplay.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");



/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_ImageReplay_ = function (tolerance, maxExtent) {
  _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tolerance, maxExtent);
  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */


  this.images_ = [];
  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */

  this.hitDetectionImages_ = [];
  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */

  this.textures_ = [];
  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */

  this.hitDetectionTextures_ = [];
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_ImageReplay_, _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.finish = function (context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices.push(this.indices.length); // create, bind, and populate the vertices buffer

  this.verticesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.vertices);
  var indices = this.indices; // create, bind, and populate the indices buffer

  this.indicesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"](indices); // create textures

  /** @type {Object.<string, WebGLTexture>} */

  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);
  this.images_ = null;
  this.hitDetectionImages_ = null;

  _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.finish.call(this, context);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.setImageStyle = function (imageStyle) {
  var anchor = imageStyle.getAnchor();
  var image = imageStyle.getImage(1);
  var imageSize = imageStyle.getImageSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var opacity = imageStyle.getOpacity();
  var origin = imageStyle.getOrigin();
  var rotateWithView = imageStyle.getRotateWithView();
  var rotation = imageStyle.getRotation();
  var size = imageStyle.getSize();
  var scale = imageStyle.getScale();
  var currentImage;

  if (this.images_.length === 0) {
    this.images_.push(image);
  } else {
    currentImage = this.images_[this.images_.length - 1];

    if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(currentImage) != _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(image)) {
      this.groupIndices.push(this.indices.length);
      this.images_.push(image);
    }
  }

  if (this.hitDetectionImages_.length === 0) {
    this.hitDetectionImages_.push(hitDetectionImage);
  } else {
    currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];

    if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(currentImage) != _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(hitDetectionImage)) {
      this.hitDetectionGroupIndices.push(this.indices.length);
      this.hitDetectionImages_.push(hitDetectionImage);
    }
  }

  this.anchorX = anchor[0];
  this.anchorY = anchor[1];
  this.height = size[1];
  this.imageHeight = imageSize[1];
  this.imageWidth = imageSize[0];
  this.opacity = opacity;
  this.originX = origin[0];
  this.originY = origin[1];
  this.rotation = rotation;
  this.rotateWithView = rotateWithView;
  this.scale = scale;
  this.width = size[0];
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.getTextures = function (opt_all) {
  return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.getHitDetectionTextures = function () {
  return this.hitDetectionTextures_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_ImageReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/immediate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/render/webgl/immediate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _replaytype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../replaytype.js */ "./node_modules/ol/render/replaytype.js");
/* harmony import */ var _vectorcontext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vectorcontext.js */ "./node_modules/ol/render/vectorcontext.js");
/* harmony import */ var _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/replaygroup.js */ "./node_modules/ol/render/webgl/replaygroup.js");






/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent} extent Extent.
 * @param {number} pixelRatio Pixel ratio.
 * @struct
 */

var _ol_render_webgl_Immediate_ = function (context, center, resolution, rotation, size, extent, pixelRatio) {
  _vectorcontext_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this);
  /**
   * @private
   */


  this.context_ = context;
  /**
   * @private
   */

  this.center_ = center;
  /**
   * @private
   */

  this.extent_ = extent;
  /**
   * @private
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   */

  this.size_ = size;
  /**
   * @private
   */

  this.rotation_ = rotation;
  /**
   * @private
   */

  this.resolution_ = resolution;
  /**
   * @private
   * @type {ol.style.Image}
   */

  this.imageStyle_ = null;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fillStyle_ = null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.strokeStyle_ = null;
  /**
   * @private
   * @type {ol.style.Text}
   */

  this.textStyle_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_Immediate_, _vectorcontext_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @private
 */


_ol_render_webgl_Immediate_.prototype.drawText_ = function (replayGroup, geometry) {
  var context = this.context_;
  var replay =
  /** @type {ol.render.webgl.TextReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
  replay.setTextStyle(this.textStyle_);
  replay.drawText(geometry, null);
  replay.finish(context); // default colors

  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
};
/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */


_ol_render_webgl_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.webgl.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */


_ol_render_webgl_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();

  switch (type) {
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT:
      this.drawPoint(
      /** @type {ol.geom.Point} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINE_STRING:
      this.drawLineString(
      /** @type {ol.geom.LineString} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POLYGON:
      this.drawPolygon(
      /** @type {ol.geom.Polygon} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT:
      this.drawMultiPoint(
      /** @type {ol.geom.MultiPoint} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_LINE_STRING:
      this.drawMultiLineString(
      /** @type {ol.geom.MultiLineString} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POLYGON:
      this.drawMultiPolygon(
      /** @type {ol.geom.MultiPolygon} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].GEOMETRY_COLLECTION:
      this.drawGeometryCollection(
      /** @type {ol.geom.GeometryCollection} */
      geometry, null);
      break;

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].CIRCLE:
      this.drawCircle(
      /** @type {ol.geom.Circle} */
      geometry, null);
      break;

    default: // pass

  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_render_webgl_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry || !_extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  this.setStyle(style);
  this.drawGeometry(geometry);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawGeometryCollection = function (geometry, data) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.ImageReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawPoint(geometry, data);
  replay.finish(context); // default colors

  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.ImageReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawMultiPoint(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.LineStringReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.LineStringReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawMultiLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.PolygonReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.PolygonReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawMultiPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawCircle = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"](1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.CircleReplay} */
  replayGroup.getReplay(0, _replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawCircle(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setImageStyle = function (imageStyle) {
  this.imageStyle_ = imageStyle;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  this.fillStyle_ = fillStyle;
  this.strokeStyle_ = strokeStyle;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setTextStyle = function (textStyle) {
  this.textStyle_ = textStyle;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_Immediate_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/linestringreplay.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/render/webgl/linestringreplay.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/topology.js */ "./node_modules/ol/geom/flat/topology.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/render/webgl.js");
/* harmony import */ var _webgl_replay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl/replay.js */ "./node_modules/ol/render/webgl/replay.js");
/* harmony import */ var _webgl_linestringreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../webgl/linestringreplay/defaultshader.js */ "./node_modules/ol/render/webgl/linestringreplay/defaultshader.js");
/* harmony import */ var _webgl_linestringreplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../webgl/linestringreplay/defaultshader/locations.js */ "./node_modules/ol/render/webgl/linestringreplay/defaultshader/locations.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");














/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_LineStringReplay_ = function (tolerance, maxExtent) {
  _webgl_replay_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.linestringreplay.defaultshader.Locations}
   */


  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<?>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {{strokeColor: (Array.<number>|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined),
   *         changed: boolean}|null}
   */

  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: undefined,
    miterLimit: undefined,
    changed: false
  };
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_LineStringReplay_, _webgl_replay_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * Draw one segment.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var i, ii;
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length; //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from
  //ol.render.webgl.LineStringReplay.Instruction_, and a rounding factor (1 or 2). If the product is even,
  //we round it. If it is odd, we don't.

  var lineJoin = this.state_.lineJoin === 'bevel' ? 0 : this.state_.lineJoin === 'miter' ? 1 : 2;
  var lineCap = this.state_.lineCap === 'butt' ? 0 : this.state_.lineCap === 'square' ? 1 : 2;

  var closed = _geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_6__["default"].lineStringIsClosed(flatCoordinates, offset, end, stride);

  var startCoords, sign, n;
  var lastIndex = numIndices;
  var lastSign = 1; //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.

  var p0, p1, p2;

  for (i = offset, ii = end; i < ii; i += stride) {
    n = numVertices / 7;
    p0 = p1;
    p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]]; //First vertex.

    if (i === offset) {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];

      if (end - offset === stride * 2 && _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(p1, p2)) {
        break;
      }

      if (closed) {
        //A closed line! Complete the circle.
        p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];
        startCoords = p2;
      } else {
        //Add the first two/four vertices.
        if (lineCap) {
          numVertices = this.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        numVertices = this.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        lastIndex = numVertices / 7 - 1;
        continue;
      }
    } else if (i === end - stride) {
      //Last vertex.
      if (closed) {
        //Same as the first vertex.
        p2 = startCoords;
        break;
      } else {
        p0 = p0 || [0, 0];
        numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);
        numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);
        this.indices[numIndices++] = n;
        this.indices[numIndices++] = lastIndex - 1;
        this.indices[numIndices++] = lastIndex;
        this.indices[numIndices++] = lastIndex;
        this.indices[numIndices++] = n + 1;
        this.indices[numIndices++] = n;

        if (lineCap) {
          numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);
          numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);
          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        break;
      }
    } else {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
    } // We group CW and straight lines, thus the not so inituitive CCW checking function.


    sign = _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

    if (i > offset) {
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastIndex - 1;
      this.indices[numIndices++] = lastIndex;
      this.indices[numIndices++] = n + 2;
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
    }

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 1;
    lastIndex = n + 2;
    lastSign = sign; //Add miter

    if (lineJoin) {
      numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_TOP * lineJoin, numVertices);
      this.indices[numIndices++] = n + 1;
      this.indices[numIndices++] = n + 3;
      this.indices[numIndices++] = n;
    }
  }

  if (closed) {
    n = n || numVertices / 7;
    sign = _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_4__["default"].linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastIndex - 1;
    this.indices[numIndices++] = lastIndex;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
  }
};
/**
 * @param {Array.<number>} p0 Last coordinates.
 * @param {Array.<number>} p1 Current coordinates.
 * @param {Array.<number>} p2 Next coordinates.
 * @param {number} product Sign, instruction, and rounding product.
 * @param {number} numVertices Vertex counter.
 * @return {number} Vertex counter.
 * @private
 */


_ol_render_webgl_LineStringReplay_.prototype.addVertices_ = function (p0, p1, p2, product, numVertices) {
  this.vertices[numVertices++] = p0[0];
  this.vertices[numVertices++] = p0[1];
  this.vertices[numVertices++] = p1[0];
  this.vertices[numVertices++] = p1[1];
  this.vertices[numVertices++] = p2[0];
  this.vertices[numVertices++] = p2[1];
  this.vertices[numVertices++] = product;
  return numVertices;
};
/**
 * Check if the linestring can be drawn (i. e. valid).
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring can be drawn.
 * @private
 */


_ol_render_webgl_LineStringReplay_.prototype.isValid_ = function (flatCoordinates, offset, end, stride) {
  var range = end - offset;

  if (range < stride * 2) {
    return false;
  } else if (range === stride * 2) {
    var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];
    return !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(firstP, lastP);
  }

  return true;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();

  if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);

    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }

    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var indexCount = this.indices.length;
  var ends = multiLineStringGeometry.getEnds();
  ends.unshift(0);
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var i, ii;

  if (ends.length > 1) {
    for (i = 1, ii = ends.length; i < ii; ++i) {
      if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {
        var lineString = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);

        this.drawCoordinates_(lineString, 0, lineString.length, stride);
      }
    }
  }

  if (this.indices.length > indexCount) {
    this.startIndices.push(indexCount);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(indexCount);
      this.state_.changed = false;
    }
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawPolygonCoordinates = function (flatCoordinates, holeFlatCoordinates, stride) {
  if (!_geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_6__["default"].lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates.push(flatCoordinates[0]);
    flatCoordinates.push(flatCoordinates[1]);
  }

  this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);

  if (holeFlatCoordinates.length) {
    var i, ii;

    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      if (!_geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_6__["default"].lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);
      }

      this.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);
    }
  }
};
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number=} opt_index Index count.
 */


_ol_render_webgl_LineStringReplay_.prototype.setPolygonStyle = function (feature, opt_index) {
  var index = opt_index === undefined ? this.indices.length : opt_index;
  this.startIndices.push(index);
  this.startIndicesFeature.push(feature);

  if (this.state_.changed) {
    this.styleIndices_.push(index);
    this.state_.changed = false;
  }
};
/**
 * @return {number} Current index.
 */


_ol_render_webgl_LineStringReplay_.prototype.getCurrentIndex = function () {
  return this.indices.length;
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_LineStringReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.indices);
  this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _webgl_linestringreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_10__["default"].fragment;
  vertexShader = _webgl_linestringreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_10__["default"].vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _webgl_linestringreplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_11__["default"](gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_lastPos);
  gl.vertexAttribPointer(locations.a_lastPos, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].FLOAT, false, 28, 0);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].FLOAT, false, 28, 8);
  gl.enableVertexAttribArray(locations.a_nextPos);
  gl.vertexAttribPointer(locations.a_nextPos, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].FLOAT, false, 28, 16);
  gl.enableVertexAttribArray(locations.a_direction);
  gl.vertexAttribPointer(locations.a_direction, 1, _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].FLOAT, false, 28, 24); // Enable renderer specific uniforms.

  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_lastPos);
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_nextPos);
  gl.disableVertexAttribArray(locations.a_direction);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc =
  /** @type {number} */
  gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask =
  /** @type {boolean} */
  gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!_obj_js__WEBPACK_IMPORTED_MODULE_7__["default"].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      end = start;
    }
  }

  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.

    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }

    start = end = groupStart;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 * @param {number} miterLimit Miter limit.
 */


_ol_render_webgl_LineStringReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth, miterLimit) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
  gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleLineCap = strokeStyle.getLineCap();
  this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultLineCap;
  var strokeStyleLineDash = strokeStyle.getLineDash();
  this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultLineDash;
  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
  this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultLineDashOffset;
  var strokeStyleLineJoin = strokeStyle.getLineJoin();
  this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultLineJoin;
  var strokeStyleColor = strokeStyle.getColor();

  if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
    strokeStyleColor = _color_js__WEBPACK_IMPORTED_MODULE_2__["default"].asArray(strokeStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultStrokeStyle;
  } else {
    strokeStyleColor = _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultStrokeStyle;
  }

  var strokeStyleWidth = strokeStyle.getWidth();
  strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultLineWidth;
  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
  strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _webgl_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultMiterLimit;

  if (!this.state_.strokeColor || !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {
    this.state_.changed = true;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.state_.miterLimit = strokeStyleMiterLimit;
    this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);
  }
};
/**
 * @enum {number}
 * @private
 */


_ol_render_webgl_LineStringReplay_.Instruction_ = {
  ROUND: 2,
  BEGIN_LINE: 3,
  END_LINE: 5,
  BEGIN_LINE_CAP: 7,
  END_LINE_CAP: 11,
  BEVEL_FIRST: 13,
  BEVEL_SECOND: 17,
  MITER_BOTTOM: 19,
  MITER_TOP: 23
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_LineStringReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/linestringreplay/defaultshader.js":
/*!************************************************************************!*\
  !*** ./node_modules/ol/render/webgl/linestringreplay/defaultshader.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_render_webgl_linestringreplay_defaultshader_ = {};
_ol_render_webgl_linestringreplay_defaultshader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_linestringreplay_defaultshader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_linestringreplay_defaultshader_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/linestringreplay/defaultshader/locations.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ol/render/webgl/linestringreplay/defaultshader/locations.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_render_webgl_linestringreplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_lineWidth = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_lineWidth' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_miterLimit = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_miterLimit' : 'l');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_opacity' : 'm');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_color = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_color' : 'n');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_size = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_size' : 'o');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_pixelRatio = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_pixelRatio' : 'p');
  /**
   * @type {number}
   */

  this.a_lastPos = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_lastPos' : 'd');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'e');
  /**
   * @type {number}
   */

  this.a_nextPos = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_nextPos' : 'f');
  /**
   * @type {number}
   */

  this.a_direction = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_direction' : 'g');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_linestringreplay_defaultshader_Locations_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/polygonreplay.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/render/webgl/polygonreplay.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _webgl_polygonreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/polygonreplay/defaultshader.js */ "./node_modules/ol/render/webgl/polygonreplay/defaultshader.js");
/* harmony import */ var _webgl_polygonreplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl/polygonreplay/defaultshader/locations.js */ "./node_modules/ol/render/webgl/polygonreplay/defaultshader/locations.js");
/* harmony import */ var _webgl_linestringreplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../webgl/linestringreplay.js */ "./node_modules/ol/render/webgl/linestringreplay.js");
/* harmony import */ var _webgl_replay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../webgl/replay.js */ "./node_modules/ol/render/webgl/replay.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/render/webgl.js");
/* harmony import */ var _style_stroke_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../style/stroke.js */ "./node_modules/ol/style/stroke.js");
/* harmony import */ var _structs_linkedlist_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../structs/linkedlist.js */ "./node_modules/ol/structs/linkedlist.js");
/* harmony import */ var _structs_rbush_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../structs/rbush.js */ "./node_modules/ol/structs/rbush.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");


















/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_PolygonReplay_ = function (tolerance, maxExtent) {
  _webgl_replay_js__WEBPACK_IMPORTED_MODULE_11__["default"].call(this, tolerance, maxExtent);

  this.lineStringReplay = new _webgl_linestringreplay_js__WEBPACK_IMPORTED_MODULE_10__["default"](tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.polygonreplay.defaultshader.Locations}
   */

  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<number>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         changed: boolean}|null}
   */

  this.state_ = {
    fillColor: null,
    changed: false
  };
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_PolygonReplay_, _webgl_replay_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
/**
 * Draw one polygon.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_webgl_PolygonReplay_.prototype.drawCoordinates_ = function (flatCoordinates, holeFlatCoordinates, stride) {
  // Triangulate the polygon
  var outerRing = new _structs_linkedlist_js__WEBPACK_IMPORTED_MODULE_14__["default"]();
  var rtree = new _structs_rbush_js__WEBPACK_IMPORTED_MODULE_15__["default"](); // Initialize the outer ring

  this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);
  var maxCoords = this.getMaxCoords_(outerRing); // Eliminate holes, if there are any

  if (holeFlatCoordinates.length) {
    var i, ii;
    var holeLists = [];

    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      var holeList = {
        list: new _structs_linkedlist_js__WEBPACK_IMPORTED_MODULE_14__["default"](),
        maxCoords: undefined,
        rtree: new _structs_rbush_js__WEBPACK_IMPORTED_MODULE_15__["default"]()
      };
      holeLists.push(holeList);
      this.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, holeList.rtree, false);
      this.classifyPoints_(holeList.list, holeList.rtree, true);
      holeList.maxCoords = this.getMaxCoords_(holeList.list);
    }

    holeLists.sort(function (a, b) {
      return b.maxCoords[0] === a.maxCoords[0] ? a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];
    });

    for (i = 0; i < holeLists.length; ++i) {
      var currList = holeLists[i].list;
      var start = currList.firstItem();
      var currItem = start;
      var intersection;

      do {
        //TODO: Triangulate holes when they intersect the outer ring.
        if (this.getIntersections_(currItem, rtree).length) {
          intersection = true;
          break;
        }

        currItem = currList.nextItem();
      } while (start !== currItem);

      if (!intersection) {
        if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {
          rtree.concat(holeLists[i].rtree);
          this.classifyPoints_(outerRing, rtree, false);
        }
      }
    }
  } else {
    this.classifyPoints_(outerRing, rtree, false);
  }

  this.triangulate_(outerRing, rtree);
};
/**
 * Inserts flat coordinates in a linked list and adds them to the vertex buffer.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} stride Stride.
 * @param {ol.structs.LinkedList} list Linked list.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} clockwise Coordinate order should be clockwise.
 */


_ol_render_webgl_PolygonReplay_.prototype.processFlatCoordinates_ = function (flatCoordinates, stride, list, rtree, clockwise) {
  var isClockwise = _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__["default"].linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);

  var i, ii;
  var n = this.vertices.length / 2;
  /** @type {ol.WebglPolygonVertex} */

  var start;
  /** @type {ol.WebglPolygonVertex} */

  var p0;
  /** @type {ol.WebglPolygonVertex} */

  var p1;
  var extents = [];
  var segments = [];

  if (clockwise === isClockwise) {
    start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);
    p0 = start;

    for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }

    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  } else {
    var end = flatCoordinates.length - stride;
    start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);
    p0 = start;

    for (i = end - stride, ii = 0; i >= ii; i -= stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }

    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  }

  rtree.load(extents, segments);
};
/**
 * Returns the rightmost coordinates of a polygon on the X axis.
 * @private
 * @param {ol.structs.LinkedList} list Polygons ring.
 * @return {Array.<number>} Max X coordinates.
 */


_ol_render_webgl_PolygonReplay_.prototype.getMaxCoords_ = function (list) {
  var start = list.firstItem();
  var seg = start;
  var maxCoords = [seg.p0.x, seg.p0.y];

  do {
    seg = list.nextItem();

    if (seg.p0.x > maxCoords[0]) {
      maxCoords = [seg.p0.x, seg.p0.y];
    }
  } while (seg !== start);

  return maxCoords;
};
/**
 * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.
 * @private
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} ccw The orientation of the polygon is counter-clockwise.
 * @return {boolean} There were reclassified points.
 */


_ol_render_webgl_PolygonReplay_.prototype.classifyPoints_ = function (list, rtree, ccw) {
  var start = list.firstItem();
  var s0 = start;
  var s1 = list.nextItem();
  var pointsReclassified = false;

  do {
    var reflex = ccw ? _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);

    if (reflex === undefined) {
      this.removeItem_(s0, s1, list, rtree);
      pointsReclassified = true;

      if (s1 === start) {
        start = list.getNextItem();
      }

      s1 = s0;
      list.prevItem();
    } else if (s0.p1.reflex !== reflex) {
      s0.p1.reflex = reflex;
      pointsReclassified = true;
    }

    s0 = s1;
    s1 = list.nextItem();
  } while (s0 !== start);

  return pointsReclassified;
};
/**
 * @private
 * @param {ol.structs.LinkedList} hole Linked list of the hole.
 * @param {number} holeMaxX Maximum X value of the hole.
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {number} listMaxX Maximum X value of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} Bridging was successful.
 */


_ol_render_webgl_PolygonReplay_.prototype.bridgeHole_ = function (hole, holeMaxX, list, listMaxX, rtree) {
  var seg = hole.firstItem();

  while (seg.p1.x !== holeMaxX) {
    seg = hole.nextItem();
  }

  var p1 = seg.p1;
  /** @type {ol.WebglPolygonVertex} */

  var p2 = {
    x: listMaxX,
    y: p1.y,
    i: -1
  };
  var minDist = Infinity;
  var i, ii, bestPoint;
  /** @type {ol.WebglPolygonVertex} */

  var p5;
  var intersectingSegments = this.getIntersections_({
    p0: p1,
    p1: p2
  }, rtree, true);

  for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {
    var currSeg = intersectingSegments[i];
    var intersection = this.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);
    var dist = Math.abs(p1.x - intersection[0]);

    if (dist < minDist && _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].triangleIsCounterClockwise(p1.x, p1.y, currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {
      minDist = dist;
      p5 = {
        x: intersection[0],
        y: intersection[1],
        i: -1
      };
      seg = currSeg;
    }
  }

  if (minDist === Infinity) {
    return false;
  }

  bestPoint = seg.p1;

  if (minDist > 0) {
    var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);

    if (pointsInTriangle.length) {
      var theta = Infinity;

      for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {
        var currPoint = pointsInTriangle[i];
        var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);

        if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {
          theta = currTheta;
          bestPoint = currPoint;
        }
      }
    }
  }

  seg = list.firstItem();

  while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {
    seg = list.nextItem();
  } //We clone the bridge points as they can have different convexity.


  var p0Bridge = {
    x: p1.x,
    y: p1.y,
    i: p1.i,
    reflex: undefined
  };
  var p1Bridge = {
    x: seg.p1.x,
    y: seg.p1.y,
    i: seg.p1.i,
    reflex: undefined
  };
  hole.getNextItem().p0 = p0Bridge;
  this.insertItem_(p1, seg.p1, hole, rtree);
  this.insertItem_(p1Bridge, p0Bridge, hole, rtree);
  seg.p1 = p1Bridge;
  hole.setFirstItem();
  list.concat(hole);
  return true;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.triangulate_ = function (list, rtree) {
  var ccw = false;
  var simple = this.isSimple_(list, rtree); // Start clipping ears

  while (list.getLength() > 3) {
    if (simple) {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // Due to the behavior of OL's PIP algorithm, the ear clipping cannot
          // introduce touching segments. However, the original data may have some.
          if (!this.resolveSelfIntersections_(list, rtree, true)) {
            break;
          }
        }
      }
    } else {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        // We ran out of ears, try to reclassify.
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // We have a bad polygon, try to resolve local self-intersections.
          if (!this.resolveSelfIntersections_(list, rtree)) {
            simple = this.isSimple_(list, rtree);

            if (!simple) {
              // We have a really bad polygon, try more time consuming methods.
              this.splitPolygon_(list, rtree);
              break;
            } else {
              ccw = !this.isClockwise_(list);
              this.classifyPoints_(list, rtree, ccw);
            }
          }
        }
      }
    }
  }

  if (list.getLength() === 3) {
    var numIndices = this.indices.length;
    this.indices[numIndices++] = list.getPrevItem().p0.i;
    this.indices[numIndices++] = list.getCurrItem().p0.i;
    this.indices[numIndices++] = list.getNextItem().p0.i;
  }
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} simple The polygon is simple.
 * @param {boolean} ccw Orientation of the polygon is counter-clockwise.
 * @return {boolean} There were processed ears.
 */


_ol_render_webgl_PolygonReplay_.prototype.clipEars_ = function (list, rtree, simple, ccw) {
  var numIndices = this.indices.length;
  var start = list.firstItem();
  var s0 = list.getPrevItem();
  var s1 = start;
  var s2 = list.nextItem();
  var s3 = list.getNextItem();
  var p0, p1, p2;
  var processedEars = false;

  do {
    p0 = s1.p0;
    p1 = s1.p1;
    p2 = s2.p1;

    if (p1.reflex === false) {
      // We might have a valid ear
      var variableCriterion;

      if (simple) {
        variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;
      } else {
        variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);
      }

      if ((simple || this.getIntersections_({
        p0: p0,
        p1: p2
      }, rtree).length === 0) && variableCriterion) {
        //The diagonal is completely inside the polygon
        if (simple || p0.reflex === false || p2.reflex === false || _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__["default"].linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {
          //The diagonal is persumably valid, we have an ear
          this.indices[numIndices++] = p0.i;
          this.indices[numIndices++] = p1.i;
          this.indices[numIndices++] = p2.i;
          this.removeItem_(s1, s2, list, rtree);

          if (s2 === start) {
            start = s3;
          }

          processedEars = true;
        }
      }
    } // Else we have a reflex point.


    s0 = list.getPrevItem();
    s1 = list.getCurrItem();
    s2 = list.nextItem();
    s3 = list.getNextItem();
  } while (s1 !== start && list.getLength() > 3);

  return processedEars;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Resolve touching segments.
 * @return {boolean} There were resolved intersections.
*/


_ol_render_webgl_PolygonReplay_.prototype.resolveSelfIntersections_ = function (list, rtree, opt_touch) {
  var start = list.firstItem();
  list.nextItem();
  var s0 = start;
  var s1 = list.nextItem();
  var resolvedIntersections = false;

  do {
    var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);

    if (intersection) {
      var breakCond = false;
      var numVertices = this.vertices.length;
      var numIndices = this.indices.length;
      var n = numVertices / 2;
      var seg = list.prevItem();
      list.removeItem();
      rtree.remove(seg);
      breakCond = seg === start;
      var p;

      if (opt_touch) {
        if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {
          list.prevItem();
          p = s0.p0;
          s1.p0 = p;
          rtree.remove(s0);
          breakCond = breakCond || s0 === start;
        } else {
          p = s1.p1;
          s0.p1 = p;
          rtree.remove(s1);
          breakCond = breakCond || s1 === start;
        }

        list.removeItem();
      } else {
        p = this.createPoint_(intersection[0], intersection[1], n);
        s0.p1 = p;
        s1.p0 = p;
        rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
        rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);
      }

      this.indices[numIndices++] = seg.p0.i;
      this.indices[numIndices++] = seg.p1.i;
      this.indices[numIndices++] = p.i;
      resolvedIntersections = true;

      if (breakCond) {
        break;
      }
    }

    s0 = list.getPrevItem();
    s1 = list.nextItem();
  } while (s0 !== start);

  return resolvedIntersections;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} The polygon is simple.
 */


_ol_render_webgl_PolygonReplay_.prototype.isSimple_ = function (list, rtree) {
  var start = list.firstItem();
  var seg = start;

  do {
    if (this.getIntersections_(seg, rtree).length) {
      return false;
    }

    seg = list.nextItem();
  } while (seg !== start);

  return true;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @return {boolean} Orientation is clockwise.
 */


_ol_render_webgl_PolygonReplay_.prototype.isClockwise_ = function (list) {
  var length = list.getLength() * 2;
  var flatCoordinates = new Array(length);
  var start = list.firstItem();
  var seg = start;
  var i = 0;

  do {
    flatCoordinates[i++] = seg.p0.x;
    flatCoordinates[i++] = seg.p0.y;
    seg = list.nextItem();
  } while (seg !== start);

  return _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__["default"].linearRingIsClockwise(flatCoordinates, 0, length, 2);
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.splitPolygon_ = function (list, rtree) {
  var start = list.firstItem();
  var s0 = start;

  do {
    var intersections = this.getIntersections_(s0, rtree);

    if (intersections.length) {
      var s1 = intersections[0];
      var n = this.vertices.length / 2;
      var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);
      var p = this.createPoint_(intersection[0], intersection[1], n);
      var newPolygon = new _structs_linkedlist_js__WEBPACK_IMPORTED_MODULE_14__["default"]();
      var newRtree = new _structs_rbush_js__WEBPACK_IMPORTED_MODULE_15__["default"]();
      this.insertItem_(p, s0.p1, newPolygon, newRtree);
      s0.p1 = p;
      rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);
      var currItem = list.nextItem();

      while (currItem !== s1) {
        this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);
        rtree.remove(currItem);
        list.removeItem();
        currItem = list.getCurrItem();
      }

      this.insertItem_(s1.p0, p, newPolygon, newRtree);
      s1.p0 = p;
      rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);
      this.classifyPoints_(list, rtree, false);
      this.triangulate_(list, rtree);
      this.classifyPoints_(newPolygon, newRtree, false);
      this.triangulate_(newPolygon, newRtree);
      break;
    }

    s0 = list.nextItem();
  } while (s0 !== start);
};
/**
 * @private
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} i Index.
 * @return {ol.WebglPolygonVertex} List item.
 */


_ol_render_webgl_PolygonReplay_.prototype.createPoint_ = function (x, y, i) {
  var numVertices = this.vertices.length;
  this.vertices[numVertices++] = x;
  this.vertices[numVertices++] = y;
  /** @type {ol.WebglPolygonVertex} */

  var p = {
    x: x,
    y: y,
    i: i,
    reflex: undefined
  };
  return p;
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point of segment.
 * @param {ol.WebglPolygonVertex} p1 Second point of segment.
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush=} opt_rtree Insert the segment into the R-Tree.
 * @return {ol.WebglPolygonSegment} segment.
 */


_ol_render_webgl_PolygonReplay_.prototype.insertItem_ = function (p0, p1, list, opt_rtree) {
  var seg = {
    p0: p0,
    p1: p1
  };
  list.insertItem(seg);

  if (opt_rtree) {
    opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);
  }

  return seg;
};
/**
  * @private
  * @param {ol.WebglPolygonSegment} s0 Segment before the remove candidate.
  * @param {ol.WebglPolygonSegment} s1 Remove candidate segment.
  * @param {ol.structs.LinkedList} list Polygon ring.
  * @param {ol.structs.RBush} rtree R-Tree of the polygon.
  */


_ol_render_webgl_PolygonReplay_.prototype.removeItem_ = function (s0, s1, list, rtree) {
  if (list.getCurrItem() === s1) {
    list.removeItem();
    s0.p1 = s1.p1;
    rtree.remove(s1);
    rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
  }
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_reflex Only include reflex points.
 * @return {Array.<ol.WebglPolygonVertex>} Points in the triangle.
 */


_ol_render_webgl_PolygonReplay_.prototype.getPointsInTriangle_ = function (p0, p1, p2, rtree, opt_reflex) {
  var i, ii, j, p;
  var result = [];
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);

  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    for (j in segmentsInExtent[i]) {
      p = segmentsInExtent[i][j];

      if (typeof p === 'object' && (!opt_reflex || p.reflex)) {
        if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_5__["default"].linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {
          result.push(p);
        }
      }
    }
  }

  return result;
};
/**
 * @private
 * @param {ol.WebglPolygonSegment} segment Segment.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<ol.WebglPolygonSegment>} Intersecting segments.
 */


_ol_render_webgl_PolygonReplay_.prototype.getIntersections_ = function (segment, rtree, opt_touch) {
  var p0 = segment.p0;
  var p1 = segment.p1;
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  var result = [];
  var i, ii;

  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    var currSeg = segmentsInExtent[i];

    if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {
      result.push(currSeg);
    }
  }

  return result;
};
/**
 * Line intersection algorithm by Paul Bourke.
 * @see http://paulbourke.net/geometry/pointlineplane/
 *
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.WebglPolygonVertex} p3 Fourth point.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<number>|undefined} Intersection coordinates.
 */


_ol_render_webgl_PolygonReplay_.prototype.calculateIntersection_ = function (p0, p1, p2, p3, opt_touch) {
  var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);

  if (denom !== 0) {
    var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;
    var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;

    if (!opt_touch && ua > _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].EPSILON && ua < 1 - _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].EPSILON && ub > _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].EPSILON && ub < 1 - _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];
    }
  }

  return undefined;
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 Point before the start of the diagonal.
 * @param {ol.WebglPolygonVertex} p1 Start point of the diagonal.
 * @param {ol.WebglPolygonVertex} p2 Ear candidate.
 * @param {ol.WebglPolygonVertex} p3 End point of the diagonal.
 * @param {ol.WebglPolygonVertex} p4 Point after the end of the diagonal.
 * @return {boolean} Diagonal is inside the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.diagonalIsInside_ = function (p0, p1, p2, p3, p4) {
  if (p1.reflex === undefined || p3.reflex === undefined) {
    return false;
  }

  var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);
  var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);
  var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);
  var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);
  var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;
  var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;
  return p1InCone && p3InCone;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var endss = multiPolygonGeometry.getEndss();
  var stride = multiPolygonGeometry.getStride();
  var currIndex = this.indices.length;
  var currLineIndex = this.lineStringReplay.getCurrentIndex();
  var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();
  var i, ii, j, jj;
  var start = 0;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (ends.length > 0) {
      var outerRing = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].translate(flatCoordinates, start, ends[0], stride, -this.origin[0], -this.origin[1]);

      if (outerRing.length) {
        var holes = [];
        var holeFlatCoords;

        for (j = 1, jj = ends.length; j < jj; ++j) {
          if (ends[j] !== ends[j - 1]) {
            holeFlatCoords = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].translate(flatCoordinates, ends[j - 1], ends[j], stride, -this.origin[0], -this.origin[1]);
            holes.push(holeFlatCoords);
          }
        }

        this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
        this.drawCoordinates_(outerRing, holes, stride);
      }
    }

    start = ends[ends.length - 1];
  }

  if (this.indices.length > currIndex) {
    this.startIndices.push(currIndex);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(currIndex);
      this.state_.changed = false;
    }
  }

  if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {
    this.lineStringReplay.setPolygonStyle(feature, currLineIndex);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var ends = polygonGeometry.getEnds();
  var stride = polygonGeometry.getStride();

  if (ends.length > 0) {
    var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);

    var outerRing = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].translate(flatCoordinates, 0, ends[0], stride, -this.origin[0], -this.origin[1]);

    if (outerRing.length) {
      var holes = [];
      var i, ii, holeFlatCoords;

      for (i = 1, ii = ends.length; i < ii; ++i) {
        if (ends[i] !== ends[i - 1]) {
          holeFlatCoords = _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
          holes.push(holeFlatCoords);
        }
      }

      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);

      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }

      this.lineStringReplay.setPolygonStyle(feature);
      this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
      this.drawCoordinates_(outerRing, holes, stride);
    }
  }
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_PolygonReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_17__["default"](this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_17__["default"](this.indices);
  this.startIndices.push(this.indices.length);
  this.lineStringReplay.finish(context); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
    lineDeleter();
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _webgl_polygonreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_8__["default"].fragment;
  vertexShader = _webgl_polygonreplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_8__["default"].vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _webgl_polygonreplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_9__["default"](gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_16__["default"].FLOAT, false, 8, 0);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc =
  /** @type {number} */
  gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask =
  /** @type {boolean} */
  gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!_obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, nextStyle);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }

  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.

    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_PolygonReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }

    start = end = groupStart;
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */


_ol_render_webgl_PolygonReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];

  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = _color_js__WEBPACK_IMPORTED_MODULE_2__["default"].asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].defaultFillStyle;
  } else {
    fillStyleColor = _webgl_js__WEBPACK_IMPORTED_MODULE_12__["default"].defaultFillStyle;
  }

  if (!this.state_.fillColor || !_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].equals(fillStyleColor, this.state_.fillColor)) {
    this.state_.fillColor = fillStyleColor;
    this.state_.changed = true;
    this.styles_.push(fillStyleColor);
  } //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.


  if (strokeStyle) {
    this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);
  } else {
    var nullStrokeStyle = new _style_stroke_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
      color: [0, 0, 0, 0],
      lineWidth: 0
    });
    this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_PolygonReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/polygonreplay/defaultshader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ol/render/webgl/polygonreplay/defaultshader.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_render_webgl_polygonreplay_defaultshader_ = {};
_ol_render_webgl_polygonreplay_defaultshader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_polygonreplay_defaultshader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? '\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n' : 'attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_polygonreplay_defaultshader_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/polygonreplay/defaultshader/locations.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ol/render/webgl/polygonreplay/defaultshader/locations.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_render_webgl_polygonreplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_projectionMatrix' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'c');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_color = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_color' : 'e');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_opacity' : 'f');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'a');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_polygonreplay_defaultshader_Locations_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/replay.js":
/*!************************************************!*\
  !*** ./node_modules/ol/render/webgl/replay.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _vectorcontext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vectorcontext.js */ "./node_modules/ol/render/vectorcontext.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../vec/mat4.js */ "./node_modules/ol/vec/mat4.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");






/**
 * @constructor
 * @abstract
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_Replay_ = function (tolerance, maxExtent) {
  _vectorcontext_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @protected
   * @type {number}
   */


  this.tolerance = tolerance;
  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */

  this.maxExtent = maxExtent;
  /**
   * The origin of the coordinate system for the point coordinates sent to
   * the GPU. To eliminate jitter caused by precision problems in the GPU
   * we use the "Rendering Relative to Eye" technique described in the "3D
   * Engine Design for Virtual Globes" book.
   * @protected
   * @type {ol.Coordinate}
   */

  this.origin = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getCenter(maxExtent);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.projectionMatrix_ = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.offsetRotateMatrix_ = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.offsetScaleMatrix_ = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].create();
  /**
   * @private
   * @type {Array.<number>}
   */

  this.tmpMat4_ = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__["default"].create();
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.indices = [];
  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */

  this.indicesBuffer = null;
  /**
   * Start index per feature (the index).
   * @protected
   * @type {Array.<number>}
   */

  this.startIndices = [];
  /**
   * Start index per feature (the feature).
   * @protected
   * @type {Array.<ol.Feature|ol.render.Feature>}
   */

  this.startIndicesFeature = [];
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.vertices = [];
  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */

  this.verticesBuffer = null;
  /**
   * Optional parameter for PolygonReplay instances.
   * @protected
   * @type {ol.render.webgl.LineStringReplay|undefined}
   */

  this.lineStringReplay = undefined;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_Replay_, _vectorcontext_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @abstract
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */


_ol_render_webgl_Replay_.prototype.getDeleteResourcesFunction = function (context) {};
/**
 * @abstract
 * @param {ol.webgl.Context} context Context.
 */


_ol_render_webgl_Replay_.prototype.finish = function (context) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @return {ol.render.webgl.circlereplay.defaultshader.Locations|
            ol.render.webgl.linestringreplay.defaultshader.Locations|
            ol.render.webgl.polygonreplay.defaultshader.Locations|
            ol.render.webgl.texturereplay.defaultshader.Locations} Locations.
 */


_ol_render_webgl_Replay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.render.webgl.circlereplay.defaultshader.Locations|
           ol.render.webgl.linestringreplay.defaultshader.Locations|
           ol.render.webgl.polygonreplay.defaultshader.Locations|
           ol.render.webgl.texturereplay.defaultshader.Locations} locations Locations.
 */


_ol_render_webgl_Replay_.prototype.shutDownProgram = function (gl, locations) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {boolean} hitDetection Hit detection mode.
 */


_ol_render_webgl_Replay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplay = function (gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  if (!oneByOne) {
    // draw all hit-detection features in "once" (by texture group)
    return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);
  } else {
    // draw hit-detection features one by one
    return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);
  }
};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplayAll = function (gl, context, skippedFeaturesHash, featureCallback) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  this.drawReplay(gl, context, skippedFeaturesHash, true);
  var result = featureCallback(null);

  if (result) {
    return result;
  } else {
    return undefined;
  }
};
/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  var gl = context.getGL();
  var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;

  if (this.lineStringReplay) {
    tmpStencil = gl.isEnabled(gl.STENCIL_TEST);
    tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
    tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);
    tmpStencilRef = gl.getParameter(gl.STENCIL_REF);
    tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);
    tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);
    tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
    tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
    gl.enable(gl.STENCIL_TEST);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilMask(255);
    gl.stencilFunc(gl.ALWAYS, 1, 255);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
    gl.stencilMask(0);
    gl.stencilFunc(gl.NOTEQUAL, 1, 255);
  }

  context.bindBuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].ARRAY_BUFFER, this.verticesBuffer);
  context.bindBuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
  var locations = this.setUpProgram(gl, context, size, pixelRatio); // set the "uniform" values

  var projectionMatrix = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset(this.projectionMatrix_);

  _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));

  _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotate(projectionMatrix, -rotation);

  _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));

  var offsetScaleMatrix = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset(this.offsetScaleMatrix_);

  _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);

  var offsetRotateMatrix = _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset(this.offsetRotateMatrix_);

  if (rotation !== 0) {
    _transform_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotate(offsetRotateMatrix, -rotation);
  }

  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromTransform(this.tmpMat4_, projectionMatrix));
  gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromTransform(this.tmpMat4_, offsetScaleMatrix));
  gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, _vec_mat4_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromTransform(this.tmpMat4_, offsetRotateMatrix));
  gl.uniform1f(locations.u_opacity, opacity); // draw!

  var result;

  if (featureCallback === undefined) {
    this.drawReplay(gl, context, skippedFeaturesHash, false);
  } else {
    // draw feature by feature for the hit-detection
    result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
  } // disable the vertex attrib arrays


  this.shutDownProgram(gl, locations);

  if (this.lineStringReplay) {
    if (!tmpStencil) {
      gl.disable(gl.STENCIL_TEST);
    }

    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(
    /** @type {number} */
    tmpStencilFunc,
    /** @type {number} */
    tmpStencilRef,
    /** @type {number} */
    tmpStencilMaskVal);
    gl.stencilMask(
    /** @type {number} */
    tmpStencilMask);
    gl.stencilOp(
    /** @type {number} */
    tmpStencilOpFail,
    /** @type {number} */
    tmpStencilOpZFail,
    /** @type {number} */
    tmpStencilOpPass);
  }

  return result;
};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {number} start Start index.
 * @param {number} end End index.
 */


_ol_render_webgl_Replay_.prototype.drawElements = function (gl, context, start, end) {
  var elementType = context.hasOESElementIndexUint ? _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].UNSIGNED_INT : _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].UNSIGNED_SHORT;
  var elementSize = context.hasOESElementIndexUint ? 4 : 2;
  var numItems = end - start;
  var offsetInBytes = start * elementSize;
  gl.drawElements(_webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].TRIANGLES, numItems, elementType, offsetInBytes);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_Replay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/replaygroup.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/webgl/replaygroup.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _replaygroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../replaygroup.js */ "./node_modules/ol/render/replaygroup.js");
/* harmony import */ var _webgl_circlereplay_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl/circlereplay.js */ "./node_modules/ol/render/webgl/circlereplay.js");
/* harmony import */ var _webgl_imagereplay_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl/imagereplay.js */ "./node_modules/ol/render/webgl/imagereplay.js");
/* harmony import */ var _webgl_linestringreplay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/linestringreplay.js */ "./node_modules/ol/render/webgl/linestringreplay.js");
/* harmony import */ var _webgl_polygonreplay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl/polygonreplay.js */ "./node_modules/ol/render/webgl/polygonreplay.js");
/* harmony import */ var _webgl_textreplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../webgl/textreplay.js */ "./node_modules/ol/render/webgl/textreplay.js");











/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number=} opt_renderBuffer Render buffer.
 * @struct
 */

var _ol_render_webgl_ReplayGroup_ = function (tolerance, maxExtent, opt_renderBuffer) {
  _replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this);
  /**
   * @type {ol.Extent}
   * @private
   */


  this.maxExtent_ = maxExtent;
  /**
   * @type {number}
   * @private
   */

  this.tolerance_ = tolerance;
  /**
   * @type {number|undefined}
   * @private
   */

  this.renderBuffer_ = opt_renderBuffer;
  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.webgl.Replay>>}
   */

  this.replaysByZIndex_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_ReplayGroup_, _replaygroup_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {ol.style.Style} style Style.
 * @param {boolean} group Group with previous replay.
 */


_ol_render_webgl_ReplayGroup_.prototype.addDeclutter = function (style, group) {};
/**
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */


_ol_render_webgl_ReplayGroup_.prototype.getDeleteResourcesFunction = function (context) {
  var functions = [];
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      functions.push(replays[replayKey].getDeleteResourcesFunction(context));
    }
  }

  return function () {
    var length = functions.length;
    var result;

    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }

    return result;
  };
};
/**
 * @param {ol.webgl.Context} context Context.
 */


_ol_render_webgl_ReplayGroup_.prototype.finish = function (context) {
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      replays[replayKey].finish(context);
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];

  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }

  var replay = replays[replayType];

  if (replay === undefined) {
    /**
     * @type {Function}
     */
    var Constructor = _ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_);
    replays[replayType] = replay;
  }

  return replay;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ReplayGroup_.prototype.isEmpty = function () {
  return _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].isEmpty(this.replaysByZIndex_);
};
/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 */


_ol_render_webgl_ReplayGroup_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"].numberSafeCompareFunction);
  var i, ii, j, jj, replays, replay;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];

    for (j = 0, jj = _replay_js__WEBPACK_IMPORTED_MODULE_4__["default"].ORDER.length; j < jj; ++j) {
      replay = replays[_replay_js__WEBPACK_IMPORTED_MODULE_4__["default"].ORDER[j]];

      if (replay !== undefined) {
        replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);
      }
    }
  }
};
/**
 * @private
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_ReplayGroup_.prototype.replayHitDetection_ = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(function (a, b) {
    return b - a;
  });
  var i, ii, j, replays, replay, result;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];

    for (j = _replay_js__WEBPACK_IMPORTED_MODULE_4__["default"].ORDER.length - 1; j >= 0; --j) {
      replay = replays[_replay_js__WEBPACK_IMPORTED_MODULE_4__["default"].ORDER[j]];

      if (replay !== undefined) {
        result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);

        if (result) {
          return result;
        }
      }
    }
  }

  return undefined;
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  /**
   * @type {ol.Extent}
   */

  var hitExtent;

  if (this.renderBuffer_ !== undefined) {
    // build an extent around the coordinate, so that only features that
    // intersect this extent are checked
    hitExtent = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].buffer(_extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);
  }

  return this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

    if (imageData[3] > 0) {
      var result = callback(feature);

      if (result) {
        return result;
      }
    }
  }, true, hitExtent);
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @return {boolean} Is there a feature at the given coordinate?
 */


_ol_render_webgl_ReplayGroup_.prototype.hasFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {boolean} Is there a feature?
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
    return imageData[3] > 0;
  }, false);
  return hasFeature !== undefined;
};
/**
 * @const
 * @private
 * @type {Array.<number>}
 */


_ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_ = [1, 1];
/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.webgl.Replay, number,
 *                ol.Extent)>}
 */

_ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': _webgl_circlereplay_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  'Image': _webgl_imagereplay_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  'LineString': _webgl_linestringreplay_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  'Polygon': _webgl_polygonreplay_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  'Text': _webgl_textreplay_js__WEBPACK_IMPORTED_MODULE_10__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_ReplayGroup_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/textreplay.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/webgl/textreplay.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/render/webgl.js");
/* harmony import */ var _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl/texturereplay.js */ "./node_modules/ol/render/webgl/texturereplay.js");
/* harmony import */ var _style_atlasmanager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../style/atlasmanager.js */ "./node_modules/ol/style/atlasmanager.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");










/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_TextReplay_ = function (tolerance, maxExtent) {
  _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */


  this.images_ = [];
  /**
   * @private
   * @type {Array.<WebGLTexture>}
   */

  this.textures_ = [];
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.measureCanvas_ = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(0, 0).canvas;
  /**
   * @private
   * @type {{strokeColor: (ol.ColorLike|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: number,
   *         miterLimit: (number|undefined),
   *         fillColor: (ol.ColorLike|null),
   *         font: (string|undefined),
   *         scale: (number|undefined)}}
   */

  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number|undefined}
   */

  this.textAlign_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.textBaseline_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.offsetX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.offsetY_ = undefined;
  /**
   * @private
   * @type {Object.<string, ol.WebglGlyphAtlas>}
   */

  this.atlases_ = {};
  /**
   * @private
   * @type {ol.WebglGlyphAtlas|undefined}
   */

  this.currAtlas_ = undefined;
  this.scale = 1;
  this.opacity = 1;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_TextReplay_, _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.drawText = function (geometry, feature) {
  if (this.text_) {
    var flatCoordinates = null;
    var offset = 0;
    var end = 2;
    var stride = 2;

    switch (geometry.getType()) {
      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT:
      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        stride = geometry.getStride();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE:
        flatCoordinates =
        /** @type {ol.geom.Circle} */
        geometry.getCenter();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.LineString} */
        geometry.getFlatMidpoint();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.MultiLineString} */
        geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON:
        flatCoordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getFlatInteriorPoint();
        break;

      case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON:
        flatCoordinates =
        /** @type {ol.geom.MultiPolygon} */
        geometry.getFlatInteriorPoints();
        end = flatCoordinates.length;
        break;

      default:
    }

    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    var glyphAtlas = this.currAtlas_;
    var lines = this.text_.split('\n');
    var textSize = this.getTextSize_(lines);
    var i, ii, j, jj, currX, currY, charArr, charInfo;
    var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);
    var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);
    var lineWidth = this.state_.lineWidth / 2 * this.state_.scale;

    for (i = 0, ii = lines.length; i < ii; ++i) {
      currX = 0;
      currY = glyphAtlas.height * i;
      charArr = lines[i].split('');

      for (j = 0, jj = charArr.length; j < jj; ++j) {
        charInfo = glyphAtlas.atlas.getInfo(charArr[j]);

        if (charInfo) {
          var image = charInfo.image;
          this.anchorX = anchorX - currX;
          this.anchorY = anchorY - currY;
          this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;
          this.originY = charInfo.offsetY;
          this.height = glyphAtlas.height;
          this.width = j === 0 || j === charArr.length - 1 ? glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];
          this.imageHeight = image.height;
          this.imageWidth = image.width;
          var currentImage;

          if (this.images_.length === 0) {
            this.images_.push(image);
          } else {
            currentImage = this.images_[this.images_.length - 1];

            if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(currentImage) != _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(image)) {
              this.groupIndices.push(this.indices.length);
              this.images_.push(image);
            }
          }

          this.drawText_(flatCoordinates, offset, end, stride);
        }

        currX += this.width;
      }
    }
  }
};
/**
 * @private
 * @param {Array.<string>} lines Label to draw split to lines.
 * @return {Array.<number>} Size of the label in pixels.
 */


_ol_render_webgl_TextReplay_.prototype.getTextSize_ = function (lines) {
  var self = this;
  var glyphAtlas = this.currAtlas_;
  var textHeight = lines.length * glyphAtlas.height; //Split every line to an array of chars, sum up their width, and select the longest.

  var textWidth = lines.map(function (str) {
    var sum = 0;
    var i, ii;

    for (i = 0, ii = str.length; i < ii; ++i) {
      var curr = str[i];

      if (!glyphAtlas.width[curr]) {
        self.addCharToAtlas_(curr);
      }

      sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;
    }

    return sum;
  }).reduce(function (max, curr) {
    return Math.max(max, curr);
  });
  return [textWidth, textHeight];
};
/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_TextReplay_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  var i, ii;

  for (i = offset, ii = end; i < ii; i += stride) {
    this.drawCoordinates(flatCoordinates, offset, end, stride);
  }
};
/**
 * @private
 * @param {string} char Character.
 */


_ol_render_webgl_TextReplay_.prototype.addCharToAtlas_ = function (char) {
  if (char.length === 1) {
    var glyphAtlas = this.currAtlas_;
    var state = this.state_;
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var width = Math.ceil(mCtx.measureText(char).width * state.scale);
    var info = glyphAtlas.atlas.add(char, width, glyphAtlas.height, function (ctx, x, y) {
      //Parameterize the canvas
      ctx.font =
      /** @type {string} */
      state.font;
      ctx.fillStyle = state.fillColor;
      ctx.strokeStyle = state.strokeColor;
      ctx.lineWidth = state.lineWidth;
      ctx.lineCap =
      /*** @type {string} */
      state.lineCap;
      ctx.lineJoin =
      /** @type {string} */
      state.lineJoin;
      ctx.miterLimit =
      /** @type {number} */
      state.miterLimit;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      if (_has_js__WEBPACK_IMPORTED_MODULE_4__["default"].CANVAS_LINE_DASH && state.lineDash) {
        //FIXME: use pixelRatio
        ctx.setLineDash(state.lineDash);
        ctx.lineDashOffset =
        /** @type {number} */
        state.lineDashOffset;
      }

      if (state.scale !== 1) {
        //FIXME: use pixelRatio
        ctx.setTransform(
        /** @type {number} */
        state.scale, 0, 0,
        /** @type {number} */
        state.scale, 0, 0);
      } //Draw the character on the canvas


      if (state.strokeColor) {
        ctx.strokeText(char, x, y);
      }

      if (state.fillColor) {
        ctx.fillText(char, x, y);
      }
    });

    if (info) {
      glyphAtlas.width[char] = width;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.finish = function (context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices = this.groupIndices; // create, bind, and populate the vertices buffer

  this.verticesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.indices); // create textures

  /** @type {Object.<string, WebGLTexture>} */

  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };
  this.text_ = '';
  this.textAlign_ = undefined;
  this.textBaseline_ = undefined;
  this.offsetX_ = undefined;
  this.offsetY_ = undefined;
  this.images_ = null;
  this.atlases_ = {};
  this.currAtlas_ = undefined;

  _webgl_texturereplay_js__WEBPACK_IMPORTED_MODULE_7__["default"].prototype.finish.call(this, context);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.setTextStyle = function (textStyle) {
  var state = this.state_;
  var textFillStyle = textStyle.getFill();
  var textStrokeStyle = textStyle.getStroke();

  if (!textStyle || !textStyle.getText() || !textFillStyle && !textStrokeStyle) {
    this.text_ = '';
  } else {
    if (!textFillStyle) {
      state.fillColor = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      state.fillColor = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(textFillStyleColor ? textFillStyleColor : _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultFillStyle);
    }

    if (!textStrokeStyle) {
      state.strokeColor = null;
      state.lineWidth = 0;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      state.strokeColor = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultStrokeStyle);
      state.lineWidth = textStrokeStyle.getWidth() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultLineWidth;
      state.lineCap = textStrokeStyle.getLineCap() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultLineCap;
      state.lineDashOffset = textStrokeStyle.getLineDashOffset() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultLineDashOffset;
      state.lineJoin = textStrokeStyle.getLineJoin() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultLineJoin;
      state.miterLimit = textStrokeStyle.getMiterLimit() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultMiterLimit;
      var lineDash = textStrokeStyle.getLineDash();
      state.lineDash = lineDash ? lineDash.slice() : _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultLineDash;
    }

    state.font = textStyle.getFont() || _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultFont;
    state.scale = textStyle.getScale() || 1;
    this.text_ =
    /** @type {string} */
    textStyle.getText();

    var textAlign = _replay_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXT_ALIGN[textStyle.getTextAlign()];

    var textBaseline = _replay_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXT_ALIGN[textStyle.getTextBaseline()];

    this.textAlign_ = textAlign === undefined ? _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultTextAlign : textAlign;
    this.textBaseline_ = textBaseline === undefined ? _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultTextBaseline : textBaseline;
    this.offsetX_ = textStyle.getOffsetX() || 0;
    this.offsetY_ = textStyle.getOffsetY() || 0;
    this.rotateWithView = !!textStyle.getRotateWithView();
    this.rotation = textStyle.getRotation() || 0;
    this.currAtlas_ = this.getAtlas_(state);
  }
};
/**
 * @private
 * @param {Object} state Font attributes.
 * @return {ol.WebglGlyphAtlas} Glyph atlas.
 */


_ol_render_webgl_TextReplay_.prototype.getAtlas_ = function (state) {
  var params = [];
  var i;

  for (i in state) {
    if (state[i] || state[i] === 0) {
      if (Array.isArray(state[i])) {
        params = params.concat(state[i]);
      } else {
        params.push(state[i]);
      }
    }
  }

  var hash = this.calculateHash_(params);

  if (!this.atlases_[hash]) {
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var height = Math.ceil((mCtx.measureText('M').width * 1.5 + state.lineWidth / 2) * state.scale);
    this.atlases_[hash] = {
      atlas: new _style_atlasmanager_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
        space: state.lineWidth + 1
      }),
      width: {},
      height: height
    };
  }

  return this.atlases_[hash];
};
/**
 * @private
 * @param {Array.<string|number>} params Array of parameters.
 * @return {string} Hash string.
 */


_ol_render_webgl_TextReplay_.prototype.calculateHash_ = function (params) {
  //TODO: Create a more performant, reliable, general hash function.
  var i, ii;
  var hash = '';

  for (i = 0, ii = params.length; i < ii; ++i) {
    hash += params[i];
  }

  return hash;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.getTextures = function (opt_all) {
  return this.textures_;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.getHitDetectionTextures = function () {
  return this.textures_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_TextReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/texturereplay.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/render/webgl/texturereplay.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _webgl_texturereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/texturereplay/defaultshader.js */ "./node_modules/ol/render/webgl/texturereplay/defaultshader.js");
/* harmony import */ var _webgl_texturereplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/texturereplay/defaultshader/locations.js */ "./node_modules/ol/render/webgl/texturereplay/defaultshader/locations.js");
/* harmony import */ var _webgl_replay_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/replay.js */ "./node_modules/ol/render/webgl/replay.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../webgl/context.js */ "./node_modules/ol/webgl/context.js");








/**
 * @constructor
 * @abstract
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */

var _ol_render_webgl_TextureReplay_ = function (tolerance, maxExtent) {
  _webgl_replay_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, tolerance, maxExtent);
  /**
   * @type {number|undefined}
   * @protected
   */


  this.anchorX = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.anchorY = undefined;
  /**
   * @type {Array.<number>}
   * @protected
   */

  this.groupIndices = [];
  /**
   * @type {Array.<number>}
   * @protected
   */

  this.hitDetectionGroupIndices = [];
  /**
   * @type {number|undefined}
   * @protected
   */

  this.height = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.imageHeight = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.imageWidth = undefined;
  /**
   * @protected
   * @type {ol.render.webgl.texturereplay.defaultshader.Locations}
   */

  this.defaultLocations = null;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.opacity = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.originX = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.originY = undefined;
  /**
   * @protected
   * @type {boolean|undefined}
   */

  this.rotateWithView = undefined;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.rotation = undefined;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.scale = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.width = undefined;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_render_webgl_TextureReplay_, _webgl_replay_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var textures = this.getTextures(true);
  var gl = context.getGL();
  return function () {
    if (!gl.isContextLost()) {
      var i, ii;

      for (i = 0, ii = textures.length; i < ii; ++i) {
        gl.deleteTexture(textures[i]);
      }
    }

    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} My end.
 * @protected
 */


_ol_render_webgl_TextureReplay_.prototype.drawCoordinates = function (flatCoordinates, offset, end, stride) {
  var anchorX =
  /** @type {number} */
  this.anchorX;
  var anchorY =
  /** @type {number} */
  this.anchorY;
  var height =
  /** @type {number} */
  this.height;
  var imageHeight =
  /** @type {number} */
  this.imageHeight;
  var imageWidth =
  /** @type {number} */
  this.imageWidth;
  var opacity =
  /** @type {number} */
  this.opacity;
  var originX =
  /** @type {number} */
  this.originX;
  var originY =
  /** @type {number} */
  this.originY;
  var rotateWithView = this.rotateWithView ? 1.0 : 0.0; // this.rotation_ is anti-clockwise, but rotation is clockwise

  var rotation =
  /** @type {number} */
  -this.rotation;
  var scale =
  /** @type {number} */
  this.scale;
  var width =
  /** @type {number} */
  this.width;
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  var numIndices = this.indices.length;
  var numVertices = this.vertices.length;
  var i, n, offsetX, offsetY, x, y;

  for (i = offset; i < end; i += stride) {
    x = flatCoordinates[i] - this.origin[0];
    y = flatCoordinates[i + 1] - this.origin[1]; // There are 4 vertices per [x, y] point, one for each corner of the
    // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if
    // WebGL supported Geometry Shaders (which can emit new vertices), but that
    // is not currently the case.
    //
    // And each vertex includes 8 values: the x and y coordinates, the x and
    // y offsets used to calculate the position of the corner, the u and
    // v texture coordinates for the corner, the opacity, and whether the
    // the image should be rotated with the view (rotateWithView).

    n = numVertices / 8; // bottom-left corner

    offsetX = -scale * anchorX;
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // bottom-right corner

    offsetX = scale * (width - anchorX);
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // top-right corner

    offsetX = scale * (width - anchorX);
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // top-left corner

    offsetX = -scale * anchorX;
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
  }

  return numVertices;
};
/**
 * @protected
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images
 *    Images.
 * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.
 * @param {WebGLRenderingContext} gl Gl.
 */


_ol_render_webgl_TextureReplay_.prototype.createTextures = function (textures, images, texturePerImage, gl) {
  var texture, image, uid, i;
  var ii = images.length;

  for (i = 0; i < ii; ++i) {
    image = images[i];
    uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(image).toString();

    if (uid in texturePerImage) {
      texture = texturePerImage[uid];
    } else {
      texture = _webgl_context_js__WEBPACK_IMPORTED_MODULE_7__["default"].createTexture(gl, image, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLAMP_TO_EDGE, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLAMP_TO_EDGE);
      texturePerImage[uid] = texture;
    }

    textures[i] = texture;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader = _webgl_texturereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_3__["default"].fragment;
  var vertexShader = _webgl_texturereplay_defaultshader_js__WEBPACK_IMPORTED_MODULE_3__["default"].vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations) {
    locations = new _webgl_texturereplay_defaultshader_locations_js__WEBPACK_IMPORTED_MODULE_4__["default"](gl, program);
    this.defaultLocations = locations;
  } else {
    locations = this.defaultLocations;
  } // use the program (FIXME: use the return value)


  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].FLOAT, false, 32, 0);
  gl.enableVertexAttribArray(locations.a_offsets);
  gl.vertexAttribPointer(locations.a_offsets, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].FLOAT, false, 32, 8);
  gl.enableVertexAttribArray(locations.a_texCoord);
  gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].FLOAT, false, 32, 16);
  gl.enableVertexAttribArray(locations.a_opacity);
  gl.vertexAttribPointer(locations.a_opacity, 1, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].FLOAT, false, 32, 24);
  gl.enableVertexAttribArray(locations.a_rotateWithView);
  gl.vertexAttribPointer(locations.a_rotateWithView, 1, _webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].FLOAT, false, 32, 28);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_offsets);
  gl.disableVertexAttribArray(locations.a_texCoord);
  gl.disableVertexAttribArray(locations.a_opacity);
  gl.disableVertexAttribArray(locations.a_rotateWithView);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();
  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;

  if (!_obj_js__WEBPACK_IMPORTED_MODULE_2__["default"].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);
  } else {
    var i, ii, start;

    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {
      gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXTURE_2D, textures[i]);
      var end = groupIndices[i];
      this.drawElements(gl, context, start, end);
      start = end;
    }
  }
};
/**
 * Draw the replay while paying attention to skipped features.
 *
 * This functions creates groups of features that can be drawn to together,
 * so that the number of `drawElements` calls is minimized.
 *
 * For example given the following texture groups:
 *
 *    Group 1: A B C
 *    Group 2: D [E] F G
 *
 * If feature E should be skipped, the following `drawElements` calls will be
 * made:
 *
 *    drawElements with feature A, B and C
 *    drawElements with feature D
 *    drawElements with feature F and G
 *
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<number>} groupIndices Texture group indices.
 */


_ol_render_webgl_TextureReplay_.prototype.drawReplaySkipping = function (gl, context, skippedFeaturesHash, textures, groupIndices) {
  var featureIndex = 0;
  var i, ii;

  for (i = 0, ii = textures.length; i < ii; ++i) {
    gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXTURE_2D, textures[i]);
    var groupStart = i > 0 ? groupIndices[i - 1] : 0;
    var groupEnd = groupIndices[i];
    var start = groupStart;
    var end = groupStart;

    while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {
      var feature = this.startIndicesFeature[featureIndex];

      var featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] !== undefined) {
        // feature should be skipped
        if (start !== end) {
          // draw the features so far
          this.drawElements(gl, context, start, end);
        } // continue with the next feature


        start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
        end = start;
      } else {
        // the feature is not skipped, augment the end index
        end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
      }

      featureIndex++;
    }

    if (start !== end) {
      // draw the remaining features (in case there was no skipped feature
      // in this texture group, all features of a group are drawn together)
      this.drawElements(gl, context, start, end);
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, groupStart, start, end, feature, featureUid;
  var featureIndex = this.startIndices.length - 1;
  var hitDetectionTextures = this.getHitDetectionTextures();

  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {
    gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXTURE_2D, hitDetectionTextures[i]);
    groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;
    end = this.hitDetectionGroupIndices[i]; // draw all features for this texture group

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      end = start;
      featureIndex--;
    }
  }

  return undefined;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.finish = function (context) {
  this.anchorX = undefined;
  this.anchorY = undefined;
  this.height = undefined;
  this.imageHeight = undefined;
  this.imageWidth = undefined;
  this.indices = null;
  this.opacity = undefined;
  this.originX = undefined;
  this.originY = undefined;
  this.rotateWithView = undefined;
  this.rotation = undefined;
  this.scale = undefined;
  this.vertices = null;
  this.width = undefined;
};
/**
 * @abstract
 * @protected
 * @param {boolean=} opt_all Return hit detection textures with regular ones.
 * @returns {Array.<WebGLTexture>} Textures.
 */


_ol_render_webgl_TextureReplay_.prototype.getTextures = function (opt_all) {};
/**
 * @abstract
 * @protected
 * @returns {Array.<WebGLTexture>} Textures.
 */


_ol_render_webgl_TextureReplay_.prototype.getHitDetectionTextures = function () {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_TextureReplay_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/texturereplay/defaultshader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ol/render/webgl/texturereplay/defaultshader.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_render_webgl_texturereplay_defaultshader_ = {};
_ol_render_webgl_texturereplay_defaultshader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_texturereplay_defaultshader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n' : 'varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_texturereplay_defaultshader_);

/***/ }),

/***/ "./node_modules/ol/render/webgl/texturereplay/defaultshader/locations.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ol/render/webgl/texturereplay/defaultshader/locations.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_render_webgl_texturereplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_opacity' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_image = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_image' : 'l');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'c');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_texCoord' : 'd');
  /**
   * @type {number}
   */

  this.a_offsets = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_offsets' : 'e');
  /**
   * @type {number}
   */

  this.a_opacity = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_opacity' : 'f');
  /**
   * @type {number}
   */

  this.a_rotateWithView = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_rotateWithView' : 'g');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_render_webgl_texturereplay_defaultshader_Locations_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/imagelayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/imagelayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../imagecanvas.js */ "./node_modules/ol/imagecanvas.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_vectorrendertype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/vectorrendertype.js */ "./node_modules/ol/layer/vectorrendertype.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _plugins_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../plugins.js */ "./node_modules/ol/plugins.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../canvas/intermediatecanvas.js */ "./node_modules/ol/renderer/canvas/intermediatecanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");












/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Image} imageLayer Single image layer.
 * @api
 */

var _ol_renderer_canvas_ImageLayer_ = function (imageLayer) {
  _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_10__["default"].call(this, imageLayer);
  /**
   * @private
   * @type {?ol.ImageBase}
   */


  this.image_ = null;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.imageTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_11__["default"].create();
  /**
   * @type {!Array.<string>}
   */

  this.skippedFeatures_ = [];
  /**
   * @private
   * @type {ol.renderer.canvas.VectorLayer}
   */

  this.vectorRenderer_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_ImageLayer_, _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_ImageLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_9__["default"].CANVAS && (layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_2__["default"].IMAGE || layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR &&
  /** @type {ol.layer.Vector} */
  layer.getRenderMode() === _layer_vectorrendertype_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE);
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.ImageLayer} The layer renderer.
 */


_ol_renderer_canvas_ImageLayer_['create'] = function (mapRenderer, layer) {
  var renderer = new _ol_renderer_canvas_ImageLayer_(
  /** @type {ol.layer.Image} */
  layer);

  if (layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR) {
    var candidates = _plugins_js__WEBPACK_IMPORTED_MODULE_8__["default"].getLayerRendererPlugins();

    for (var i = 0, ii = candidates.length; i < ii; ++i) {
      var candidate =
      /** @type {Object.<string, Function>} */
      candidates[i];

      if (candidate !== _ol_renderer_canvas_ImageLayer_ && candidate['handles'](_type_js__WEBPACK_IMPORTED_MODULE_9__["default"].CANVAS, layer)) {
        renderer.setVectorRenderer(candidate['create'](mapRenderer, layer));
      }
    }
  }

  return renderer;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.getImage = function () {
  return !this.image_ ? null : this.image_.getImage();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var image;
  var imageLayer =
  /** @type {ol.layer.Image} */
  this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;

  if (layerState.extent !== undefined) {
    renderedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(renderedExtent, layerState.extent);
  }

  if (!hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] && !hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] && !_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].isEmpty(renderedExtent)) {
    var projection = viewState.projection;

    if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();

      if (sourceProjection) {
        projection = sourceProjection;
      }
    }

    var vectorRenderer = this.vectorRenderer_;

    if (vectorRenderer) {
      var context = vectorRenderer.context;

      var imageFrameState =
      /** @type {olx.FrameState} */
      _obj_js__WEBPACK_IMPORTED_MODULE_7__["default"].assign({}, frameState, {
        size: [_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(renderedExtent) / viewResolution, _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(renderedExtent) / viewResolution],
        viewState:
        /** @type {olx.ViewState} */
        _obj_js__WEBPACK_IMPORTED_MODULE_7__["default"].assign({}, frameState.viewState, {
          rotation: 0
        })
      });

      var skippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();

      if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !_array_js__WEBPACK_IMPORTED_MODULE_4__["default"].equals(skippedFeatures, this.skippedFeatures_))) {
        context.canvas.width = imageFrameState.size[0] * pixelRatio;
        context.canvas.height = imageFrameState.size[1] * pixelRatio;
        vectorRenderer.composeFrame(imageFrameState, layerState, context);
        this.image_ = new _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas);
        this.skippedFeatures_ = skippedFeatures;
      }
    } else {
      image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

      if (image) {
        var loaded = this.loadImage(image);

        if (loaded) {
          this.image_ = image;
        }
      }
    }
  }

  if (this.image_) {
    image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);

    var transform = _transform_js__WEBPACK_IMPORTED_MODULE_11__["default"].compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);

    _transform_js__WEBPACK_IMPORTED_MODULE_11__["default"].compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

    this.updateLogos(frameState, imageSource);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
  }

  return !!this.image_;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (this.vectorRenderer_) {
    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
  } else {
    return _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_10__["default"].prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
  }
};
/**
 * @param {ol.renderer.canvas.VectorLayer} renderer Vector renderer.
 */


_ol_renderer_canvas_ImageLayer_.prototype.setVectorRenderer = function (renderer) {
  this.vectorRenderer_ = renderer;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_ImageLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/intermediatecanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/intermediatecanvas.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _canvas_layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../canvas/layer.js */ "./node_modules/ol/renderer/canvas/layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");






/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */

var _ol_renderer_canvas_IntermediateCanvas_ = function (layer) {
  _canvas_layer_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, layer);
  /**
   * @protected
   * @type {ol.Transform}
   */


  this.coordinateToCanvasPixelTransform = _transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].create();
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitCanvasContext_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_IntermediateCanvas_, _canvas_layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.composeFrame = function (frameState, layerState, context) {
  this.preCompose(context, frameState);
  var image = this.getImage();

  if (image) {
    // clipped rendering if layer extent is set
    var extent = layerState.extent;

    var clipped = extent !== undefined && !_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].containsExtent(extent, frameState.extent) && _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(extent, frameState.extent);

    if (clipped) {
      this.clip(context, frameState,
      /** @type {ol.Extent} */
      extent);
    }

    var imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used
    // to save and restore the transformation matrix and the opacity.
    // see http://jsperf.com/context-save-restore-versus-variable

    var alpha = context.globalAlpha;
    context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used
    // when the view is rotated. see http://jsperf.com/canvas-transform

    var dx = imageTransform[4];
    var dy = imageTransform[5];
    var dw = image.width * imageTransform[0];
    var dh = image.height * imageTransform[3];
    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    context.globalAlpha = alpha;

    if (clipped) {
      context.restore();
    }
  }

  this.postCompose(context, frameState, layerState);
};
/**
 * @abstract
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.getImage = function () {};
/**
 * @abstract
 * @return {!ol.Transform} Image transform.
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.getImageTransform = function () {};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  if (!this.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    return _canvas_layer_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.forEachLayerAtCoordinate.apply(this, arguments);
  } else {
    var pixel = _transform_js__WEBPACK_IMPORTED_MODULE_5__["default"].apply(this.coordinateToCanvasPixelTransform, coordinate.slice());

    _coordinate_js__WEBPACK_IMPORTED_MODULE_1__["default"].scale(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;

    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_IntermediateCanvas_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _render_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/event.js */ "./node_modules/ol/render/event.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_immediate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/canvas/immediate.js */ "./node_modules/ol/render/canvas/immediate.js");
/* harmony import */ var _layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../layer.js */ "./node_modules/ol/renderer/layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");









/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */

var _ol_renderer_canvas_Layer_ = function (layer) {
  _layer_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, layer);
  /**
   * @protected
   * @type {number}
   */


  this.renderedResolution;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_Layer_, _layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Extent} extent Clip extent.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.clip = function (context, frameState, extent) {
  var pixelRatio = frameState.pixelRatio;
  var width = frameState.size[0] * pixelRatio;
  var height = frameState.size[1] * pixelRatio;
  var rotation = frameState.viewState.rotation;

  var topLeft = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTopLeft(
  /** @type {ol.Extent} */
  extent);

  var topRight = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTopRight(
  /** @type {ol.Extent} */
  extent);

  var bottomRight = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getBottomRight(
  /** @type {ol.Extent} */
  extent);

  var bottomLeft = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getBottomLeft(
  /** @type {ol.Extent} */
  extent);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.coordinateToPixelTransform, topLeft);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.coordinateToPixelTransform, topRight);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.coordinateToPixelTransform, bottomRight);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.coordinateToPixelTransform, bottomLeft);

  context.save();

  _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotateAtOffset(context, -rotation, width / 2, height / 2);

  context.beginPath();
  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
  context.clip();

  _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotateAtOffset(context, rotation, width / 2, height / 2);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @private
 */


_ol_renderer_canvas_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState, opt_transform) {
  var layer = this.getLayer();

  if (layer.hasListener(type)) {
    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotateAtOffset(context, -rotation, width / 2, height / 2);

    var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);
    var render = new _render_canvas_immediate_js__WEBPACK_IMPORTED_MODULE_6__["default"](context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);
    var composeEvent = new _render_event_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, render, frameState, context, null);
    layer.dispatchEvent(composeEvent);

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].rotateAtOffset(context, rotation, width / 2, height / 2);
  }
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions_js__WEBPACK_IMPORTED_MODULE_2__["default"].TRUE, this);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.postCompose = function (context, frameState, layerState, opt_transform) {
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTCOMPOSE, context, frameState, opt_transform);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.preCompose = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRECOMPOSE, context, frameState, opt_transform);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.dispatchRenderEvent = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].RENDER, context, frameState, opt_transform);
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} offsetX Offset on the x-axis in view coordinates.
 * @protected
 * @return {!ol.Transform} Transform.
 */


_ol_renderer_canvas_Layer_.prototype.getTransform = function (frameState, offsetX) {
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var dx1 = pixelRatio * frameState.size[0] / 2;
  var dy1 = pixelRatio * frameState.size[1] / 2;
  var sx = pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0] + offsetX;
  var dy2 = -viewState.center[1];
  return _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {CanvasRenderingContext2D} context Context.
 */


_ol_renderer_canvas_Layer_.prototype.composeFrame = function (frameState, layerState, context) {};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @return {boolean} whether composeFrame should be called.
 */


_ol_renderer_canvas_Layer_.prototype.prepareFrame = function (frameState, layerState) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_Layer_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/map.js":
/*!************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/map.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _render_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/event.js */ "./node_modules/ol/render/event.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_immediate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas/immediate.js */ "./node_modules/ol/render/canvas/immediate.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../map.js */ "./node_modules/ol/renderer/map.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../source/state.js */ "./node_modules/ol/source/state.js");
// FIXME offset panning













/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */

var _ol_renderer_canvas_Map_ = function (container, map) {
  _map_js__WEBPACK_IMPORTED_MODULE_10__["default"].call(this, container, map);
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */


  this.context_ = _dom_js__WEBPACK_IMPORTED_MODULE_4__["default"].createCanvasContext2D();
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = this.context_.canvas;
  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = _transform_js__WEBPACK_IMPORTED_MODULE_0__["default"].create();
};

_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(_ol_renderer_canvas_Map_, _map_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_Map_['handles'] = function (type) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_11__["default"].CANVAS;
};
/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.canvas.Map} The map renderer.
 */


_ol_renderer_canvas_Map_['create'] = function (container, map) {
  return new _ol_renderer_canvas_Map_(container, map);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_canvas_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();
  var context = this.context_;

  if (map.hasListener(type)) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var transform = this.getTransform(frameState);
    var vectorContext = new _render_canvas_immediate_js__WEBPACK_IMPORTED_MODULE_9__["default"](context, pixelRatio, extent, transform, rotation);
    var composeEvent = new _render_event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, vectorContext, frameState, context, null);
    map.dispatchEvent(composeEvent);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 * @return {!ol.Transform} Transform.
 */


_ol_renderer_canvas_Map_.prototype.getTransform = function (frameState) {
  var viewState = frameState.viewState;
  var dx1 = this.canvas_.width / 2;
  var dy1 = this.canvas_.height / 2;
  var sx = frameState.pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0];
  var dy2 = -viewState.center[1];
  return _transform_js__WEBPACK_IMPORTED_MODULE_0__["default"].compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.getType = function () {
  return _type_js__WEBPACK_IMPORTED_MODULE_11__["default"].CANVAS;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.renderFrame = function (frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return;
  }

  var context = this.context_;
  var pixelRatio = frameState.pixelRatio;
  var width = Math.round(frameState.size[0] * pixelRatio);
  var height = Math.round(frameState.size[1] * pixelRatio);

  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  } else {
    context.clearRect(0, 0, width, height);
  }

  var rotation = frameState.viewState.rotation;
  this.calculateMatrices2D(frameState);
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, frameState);
  var layerStatesArray = frameState.layerStatesArray;

  _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].stableSort(layerStatesArray, _map_js__WEBPACK_IMPORTED_MODULE_10__["default"].sortByZIndex);

  if (rotation) {
    context.save();

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_8__["default"].rotateAtOffset(context, rotation, width / 2, height / 2);
  }

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layer, layerRenderer, layerState;

  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    layer = layerState.layer;
    layerRenderer =
    /** @type {ol.renderer.canvas.Layer} */
    this.getLayerRenderer(layer);

    if (!_layer_layer_js__WEBPACK_IMPORTED_MODULE_5__["default"].visibleAtResolution(layerState, viewResolution) || layerState.sourceState != _source_state_js__WEBPACK_IMPORTED_MODULE_12__["default"].READY) {
      continue;
    }

    if (layerRenderer.prepareFrame(frameState, layerState)) {
      layerRenderer.composeFrame(frameState, layerState, context);
    }
  }

  if (rotation) {
    context.restore();
  }

  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTCOMPOSE, frameState);

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;

  var coordinate = _transform_js__WEBPACK_IMPORTED_MODULE_0__["default"].apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_5__["default"].visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer =
      /** @type {ol.renderer.canvas.Layer} */
      this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_Map_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/tilelayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/tilelayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _tilerange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tilerange.js */ "./node_modules/ol/tilerange.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas/intermediatecanvas.js */ "./node_modules/ol/renderer/canvas/intermediatecanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");










/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.
 * @api
 */

var _ol_renderer_canvas_TileLayer_ = function (tileLayer) {
  _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, tileLayer);
  /**
   * @protected
   * @type {CanvasRenderingContext2D}
   */


  this.context = this.context === null ? null : _dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].createCanvasContext2D();
  /**
   * @private
   * @type {number}
   */

  this.oversampling_;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = null;
  /**
   * @protected
   * @type {number}
   */

  this.renderedRevision;
  /**
   * @protected
   * @type {!Array.<ol.Tile>}
   */

  this.renderedTiles = [];
  /**
   * @protected
   * @type {ol.Extent}
   */

  this.tmpExtent = _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].createEmpty();
  /**
   * @private
   * @type {ol.TileRange}
   */

  this.tmpTileRange_ = new _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.imageTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].create();
  /**
   * @protected
   * @type {number}
   */

  this.zDirection = 0;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_TileLayer_, _canvas_intermediatecanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_TileLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_7__["default"].CANVAS && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.TileLayer} The layer renderer.
 */


_ol_renderer_canvas_TileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_TileLayer_(
  /** @type {ol.layer.Tile} */
  layer);
};
/**
 * @private
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Tile is drawable.
 */


_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function (tile) {
  var tileState = tile.getState();
  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
  return tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var viewResolution = viewState.resolution;
  var viewCenter = viewState.center;
  var tileLayer = this.getLayer();
  var tileSource =
  /** @type {ol.source.Tile} */
  tileLayer.getSource();
  var sourceRevision = tileSource.getRevision();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
  var tileResolution = tileGrid.getResolution(z);
  var oversampling = Math.round(viewResolution / tileResolution) || 1;
  var extent = frameState.extent;

  if (layerState.extent !== undefined) {
    extent = _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].getIntersection(extent, layerState.extent);
  }

  if (_extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].isEmpty(extent)) {
    // Return false to prevent the rendering of the layer.
    return false;
  }

  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);
  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
  /**
   * @type {Object.<number, Object.<string, ol.Tile>>}
   */

  var tilesToDrawByZ = {};
  tilesToDrawByZ[z] = {};
  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
  var tmpExtent = this.tmpExtent;
  var tmpTileRange = this.tmpTileRange_;
  var newTiles = false;
  var tile, x, y;

  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tile = tileSource.getTile(z, x, y, pixelRatio, projection);

      if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
        if (!tileLayer.getUseInterimTilesOnError()) {
          // When useInterimTilesOnError is false, we consider the error tile as loaded.
          tile.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
        } else if (tileLayer.getPreload() > 0) {
          // Preloaded tiles for lower resolutions might have finished loading.
          newTiles = true;
        }
      }

      if (!this.isDrawableTile_(tile)) {
        tile = tile.getInterimTile();
      }

      if (this.isDrawableTile_(tile)) {
        var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this);

        if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
          var inTransition = tile.inTransition(uid);

          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
            newTiles = true;
          }
        }

        if (tile.getAlpha(uid, frameState.time) === 1) {
          // don't look for alt tiles if alpha is 1
          continue;
        }
      }

      var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
      var covered = false;

      if (childTileRange) {
        covered = findLoadedTiles(z + 1, childTileRange);
      }

      if (!covered) {
        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
      }
    }
  }

  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
  var hints = frameState.viewHints;
  var animatingOrInteracting = hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] || hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING];

  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles || !(this.renderedExtent_ && _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {
    var context = this.context;

    if (context) {
      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
      var canvas = context.canvas;

      if (canvas.width != width || canvas.height != height) {
        this.oversampling_ = oversampling;
        canvas.width = width;
        canvas.height = height;
      } else {
        if (this.renderedExtent_ && !_extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].equals(imageExtent, this.renderedExtent_)) {
          context.clearRect(0, 0, width, height);
        }

        oversampling = this.oversampling_;
      }
    }

    this.renderedTiles.length = 0;
    /** @type {Array.<number>} */

    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(function (a, b) {
      if (a === z) {
        return 1;
      } else if (b === z) {
        return -1;
      } else {
        return a > b ? 1 : a < b ? -1 : 0;
      }
    });
    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
    var tileExtent, tileGutter, tilesToDraw, w, h;

    for (i = 0, ii = zs.length; i < ii; ++i) {
      currentZ = zs[i];
      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      currentResolution = tileGrid.getResolution(currentZ);
      currentScale = currentResolution / tileResolution;
      tileGutter = tilePixelRatio * tileSource.getGutter(projection);
      tilesToDraw = tilesToDrawByZ[currentZ];

      for (var tileCoordKey in tilesToDraw) {
        tile = tilesToDraw[tileCoordKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
        w = currentTilePixelSize[0] * currentScale / oversampling;
        h = currentTilePixelSize[1] * currentScale / oversampling;
        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
        this.renderedTiles.push(tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    this.renderedExtent_ = imageExtent;
  }

  var scale = this.renderedResolution / viewResolution;

  var transform = _transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);

  _transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  return this.renderedTiles.length > 0;
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} x Left of the tile.
 * @param {number} y Top of the tile.
 * @param {number} w Width of the tile.
 * @param {number} h Height of the tile.
 * @param {number} gutter Tile gutter.
 * @param {boolean} transition Apply an alpha transition.
 */


_ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var image = tile.getImage(this.getLayer());

  if (!image) {
    return;
  }

  var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this);

  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;

  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
    this.context.clearRect(x, y, w, h);
  }

  var alphaChanged = alpha !== this.context.globalAlpha;

  if (alphaChanged) {
    this.context.save();
    this.context.globalAlpha = alpha;
  }

  this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

  if (alphaChanged) {
    this.context.restore();
  }

  if (alpha !== 1) {
    frameState.animate = true;
  } else if (transition) {
    tile.endTransition(uid);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_TileLayer_.prototype.getImage = function () {
  var context = this.context;
  return context ? context.canvas : null;
};
/**
 * @function
 * @return {ol.layer.Tile|ol.layer.VectorTile}
 */


_ol_renderer_canvas_TileLayer_.prototype.getLayer;
/**
 * @inheritDoc
 */

_ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_TileLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/vectorlayer.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/vectorlayer.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../render/canvas/replaygroup.js */ "./node_modules/ol/render/canvas/replaygroup.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _canvas_layer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../canvas/layer.js */ "./node_modules/ol/renderer/canvas/layer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");














/**
 * @constructor
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */

var _ol_renderer_canvas_VectorLayer_ = function (vectorLayer) {
  _canvas_layer_js__WEBPACK_IMPORTED_MODULE_12__["default"].call(this, vectorLayer);
  /**
   * Declutter tree.
   * @private
   */


  this.declutterTree_ = vectorLayer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9) : null;
  /**
   * @private
   * @type {boolean}
   */

  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.renderedResolution_ = NaN;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].createEmpty();
  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */

  this.renderedRenderOrder_ = null;
  /**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */

  this.replayGroup_ = null;
  /**
   * A new replay group had to be created by `prepareFrame()`
   * @type {boolean}
   */

  this.replayGroupChanged = true;
  /**
   * @type {CanvasRenderingContext2D}
   */

  this.context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D();

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].labelCache, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_VectorLayer_, _canvas_layer_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_VectorLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_11__["default"].CANVAS && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorLayer} The layer renderer.
 */


_ol_renderer_canvas_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_VectorLayer_(
  /** @type {ol.layer.Vector} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.disposeInternal = function () {
  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlisten(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].labelCache, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  _canvas_layer_js__WEBPACK_IMPORTED_MODULE_12__["default"].prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  var extent = frameState.extent;
  var pixelRatio = frameState.pixelRatio;
  var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var rotation = viewState.rotation;
  var projectionExtent = projection.getExtent();
  var vectorSource =
  /** @type {ol.source.Vector} */
  this.getLayer().getSource();
  var transform = this.getTransform(frameState, 0);
  this.preCompose(context, frameState, transform); // clipped rendering if layer extent is set

  var clipExtent = layerState.extent;
  var clipped = clipExtent !== undefined;

  if (clipped) {
    this.clip(context, frameState,
    /** @type {ol.Extent} */
    clipExtent);
  }

  var replayGroup = this.replayGroup_;

  if (replayGroup && !replayGroup.isEmpty()) {
    if (this.declutterTree_) {
      this.declutterTree_.clear();
    }

    var layer =
    /** @type {ol.layer.Vector} */
    this.getLayer();
    var drawOffsetX = 0;
    var drawOffsetY = 0;
    var replayContext;
    var transparentLayer = layerState.opacity !== 1;
    var hasRenderListeners = layer.hasListener(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_8__["default"].RENDER);

    if (transparentLayer || hasRenderListeners) {
      var drawWidth = context.canvas.width;
      var drawHeight = context.canvas.height;

      if (rotation) {
        var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
        drawOffsetX = (drawSize - drawWidth) / 2;
        drawOffsetY = (drawSize - drawHeight) / 2;
        drawWidth = drawHeight = drawSize;
      } // resize and clear


      this.context.canvas.width = drawWidth;
      this.context.canvas.height = drawHeight;
      replayContext = this.context;
    } else {
      replayContext = context;
    }

    var alpha = replayContext.globalAlpha;

    if (!transparentLayer) {
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      replayContext.globalAlpha = layerState.opacity;
    }

    if (replayContext != context) {
      replayContext.translate(drawOffsetX, drawOffsetY);
    }

    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].rotateAtOffset(replayContext, -rotation, width / 2, height / 2);

    replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);

    if (vectorSource.getWrapX() && projection.canWrapX() && !_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].containsExtent(projectionExtent, extent)) {
      var startX = extent[0];

      var worldWidth = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].getWidth(projectionExtent);

      var world = 0;
      var offsetX;

      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX += worldWidth;
      }

      world = 0;
      startX = extent[2];

      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX -= worldWidth;
      } // restore original transform for render and compose events


      transform = this.getTransform(frameState, 0);
    }

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["default"].rotateAtOffset(replayContext, rotation, width / 2, height / 2);

    if (replayContext != context) {
      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }

      if (transparentLayer) {
        var mainContextAlpha = context.globalAlpha;
        context.globalAlpha = layerState.opacity;
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        context.globalAlpha = mainContextAlpha;
      } else {
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
      }

      replayContext.translate(-drawOffsetX, -drawOffsetY);
    }

    if (!transparentLayer) {
      replayContext.globalAlpha = alpha;
    }
  }

  if (clipped) {
    context.restore();
  }

  this.postCompose(context, frameState, layerState, transform);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer =
    /** @type {ol.layer.Vector} */
    this.getLayer();
    /** @type {Object.<string, boolean>} */

    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    }, null);
    return result;
  }
};
/**
 * @param {ol.events.Event} event Event.
 */


_ol_renderer_canvas_VectorLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();

  if (layer.getVisible() && this.replayGroup_) {
    layer.changed();
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_canvas_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var vectorLayer =
  /** @type {ol.layer.Vector} */
  this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
  var interacting = frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].defaultOrder;
  }

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

  var projectionExtent = viewState.projection.getExtent();

  if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].containsExtent(projectionExtent, frameState.extent)) {
    // For the replay group, we need an extent that intersects the real world
    // (-180° to +180°). To support geometries in a coordinate range from -540°
    // to +540°, we add at least 1 world width on each side of the projection
    // extent. If the viewport is wider than the world, we need to add half of
    // the viewport width to make sure we cover the whole viewport.
    var worldWidth = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].getWidth(projectionExtent);

    var buffer = Math.max(_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].getWidth(extent) / 2, worldWidth);
    extent[0] = projectionExtent[0] - buffer;
    extent[2] = projectionExtent[2] + buffer;
  }

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].containsExtent(this.renderedExtent_, extent)) {
    this.replayGroupChanged = false;
    return true;
  }

  this.replayGroup_ = null;
  this.dirty_ = false;
  var replayGroup = new _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_10__["default"](_vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorLayer}
   */

  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();

    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }

    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  }.bind(this);

  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);

    for (var i = 0, ii = features.length; i < ii; ++i) {
      renderFeature(features[i]);
    }
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }

  replayGroup.finish();
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  this.replayGroupChanged = true;
  return true;
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_canvas_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].renderFeature(replayGroup, feature, styles[i], _vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].renderFeature(replayGroup, feature, styles, _vector_js__WEBPACK_IMPORTED_MODULE_13__["default"].getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);
  }

  return loading;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_VectorLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/vectortilelayer.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/vectortilelayer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../layer/vectortilerendertype.js */ "./node_modules/ol/layer/vectortilerendertype.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../proj/units.js */ "./node_modules/ol/proj/units.js");
/* harmony import */ var _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../render/replaytype.js */ "./node_modules/ol/render/replaytype.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../render/canvas/replaygroup.js */ "./node_modules/ol/render/canvas/replaygroup.js");
/* harmony import */ var _render_replay_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../render/replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../canvas/tilelayer.js */ "./node_modules/ol/renderer/canvas/tilelayer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");



















/**
 * @constructor
 * @extends {ol.renderer.canvas.TileLayer}
 * @param {ol.layer.VectorTile} layer VectorTile layer.
 * @api
 */

var _ol_renderer_canvas_VectorTileLayer_ = function (layer) {
  /**
   * @type {CanvasRenderingContext2D}
   */
  this.context = null;

  _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"].call(this, layer);
  /**
   * Declutter tree.
   * @private
     */


  this.declutterTree_ = layer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9) : null;
  /**
   * @private
   * @type {boolean}
   */

  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedLayerRevision_;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpTransform_ = _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].create(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.

  this.zDirection = layer.getRenderMode() == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR ? 1 : 0;

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["default"].labelCache, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_canvas_VectorTileLayer_, _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_VectorTileLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_15__["default"].CANVAS && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR_TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorTileLayer} The layer renderer.
 */


_ol_renderer_canvas_VectorTileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_VectorTileLayer_(
  /** @type {ol.layer.VectorTile} */
  layer);
};
/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */


_ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS = {
  'image': [_render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].CIRCLE, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].IMAGE, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].TEXT],
  'hybrid': [_render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING]
};
/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */

_ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS = {
  'image': [_render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].DEFAULT],
  'hybrid': [_render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].IMAGE, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].TEXT, _render_replaytype_js__WEBPACK_IMPORTED_MODULE_11__["default"].DEFAULT],
  'vector': _render_replay_js__WEBPACK_IMPORTED_MODULE_14__["default"].ORDER
};
/**
 * @inheritDoc
 */

_ol_renderer_canvas_VectorTileLayer_.prototype.disposeInternal = function () {
  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlisten(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["default"].labelCache, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"].prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var layer = this.getLayer();
  var layerRevision = layer.getRevision();

  if (this.renderedLayerRevision_ != layerRevision) {
    this.renderedTiles.length = 0;
    var renderMode = layer.getRenderMode();

    if (!this.context && renderMode != _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR) {
      this.context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D();
    }

    if (this.context && renderMode == _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR) {
      this.context = null;
    }
  }

  this.renderedLayerRevision_ = layerRevision;
  return _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"].prototype.prepareFrame.apply(this, arguments);
};
/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.createReplayGroup_ = function (tile, frameState) {
  var layer = this.getLayer();
  var pixelRatio = frameState.pixelRatio;
  var projection = frameState.viewState.projection;
  var revision = layer.getRevision();
  var renderOrder =
  /** @type {ol.RenderOrderFunction} */
  layer.getRenderOrder() || null;
  var replayState = tile.getReplayState(layer);

  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {
    return;
  }

  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var sourceTileGrid = source.getTileGrid();
  var tileGrid = source.getTileGridForProjection(projection);
  var resolution = tileGrid.getResolution(tile.tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
  var zIndexKeys = {};

  for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
    var sourceTile = tile.getTile(tile.tileKeys[t]);

    if (sourceTile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      continue;
    }

    var sourceTileCoord = sourceTile.tileCoord;
    var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);

    var sharedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].getIntersection(tileExtent, sourceTileExtent);

    var bufferedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].equals(sourceTileExtent, sharedExtent) ? null : _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].buffer(sharedExtent, layer.getRenderBuffer() * resolution);
    var tileProjection = sourceTile.getProjection();
    var reproject = false;

    if (!_proj_js__WEBPACK_IMPORTED_MODULE_9__["default"].equivalent(projection, tileProjection)) {
      reproject = true;
      sourceTile.setProjection(projection);
    }

    replayState.dirty = false;
    var replayGroup = new _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_13__["default"](0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());

    var squaredTolerance = _vector_js__WEBPACK_IMPORTED_MODULE_17__["default"].getSquaredTolerance(resolution, pixelRatio);
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @this {ol.renderer.canvas.VectorTileLayer}
     */


    var renderFeature = function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction.call(
        /** @type {ol.Feature} */
        feature, resolution);
      } else {
        styleFunction = layer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
      }

      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
        replayState.dirty = replayState.dirty || dirty;
      }
    };

    var features = sourceTile.getFeatures();

    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
      features.sort(renderOrder);
    }

    var feature;

    for (var i = 0, ii = features.length; i < ii; ++i) {
      feature = features[i];

      if (reproject) {
        if (tileProjection.getUnits() == _proj_units_js__WEBPACK_IMPORTED_MODULE_10__["default"].TILE_PIXELS) {
          // projected tile extent
          tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space

          tileProjection.setExtent(sourceTile.getExtent());
        }

        feature.getGeometry().transform(tileProjection, projection);
      }

      if (!bufferedExtent || _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].intersects(bufferedExtent, feature.getGeometry().getExtent())) {
        renderFeature.call(this, feature);
      }
    }

    replayGroup.finish();

    for (var r in replayGroup.getReplays()) {
      zIndexKeys[r] = true;
    }

    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
  }

  replayState.renderedRevision = revision;
  replayState.renderedRenderOrder = renderOrder;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var vectorImageTile =
  /** @type {ol.VectorImageTile} */
  tile;
  this.createReplayGroup_(vectorImageTile, frameState);

  if (this.context) {
    this.renderTileImage_(vectorImageTile, frameState, layerState);

    _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"].prototype.drawTileImage.apply(this, arguments);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
  var layer = this.getLayer();
  /** @type {Object.<string, boolean>} */

  var features = {};
  /** @type {Array.<ol.VectorImageTile>} */

  var renderedTiles = this.renderedTiles;
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var bufferedExtent, found;
  var i, ii, replayGroup;
  var tile, tileCoord, tileExtent;

  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
    tile = renderedTiles[i];
    tileCoord = tile.wrappedTileCoord;
    tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    bufferedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].buffer(tileExtent, hitTolerance * resolution, bufferedExtent);

    if (!_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].containsCoordinate(bufferedExtent, coordinate)) {
      continue;
    }

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);

      if (sourceTile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        continue;
      }

      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
      /**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */
      function (feature) {
        var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

        if (!(key in features)) {
          features[key] = true;
          return callback.call(thisArg, feature, layer);
        }
      }, null);
    }
  }

  return found;
};
/**
 * @param {ol.VectorTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @return {ol.Transform} transform Transform.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.getReplayTransform_ = function (tile, frameState) {
  var layer = this.getLayer();
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var tileGrid = source.getTileGrid();
  var tileCoord = tile.tileCoord;
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var renderResolution = viewState.resolution / pixelRatio;
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
  var center = viewState.center;

  var origin = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].getTopLeft(tileExtent);

  var size = frameState.size;
  var offsetX = Math.round(pixelRatio * size[0] / 2);
  var offsetY = Math.round(pixelRatio * size[1] / 2);
  return _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);
};
/**
 * @param {ol.events.Event} event Event.
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();

  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
    layer.changed();
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.postCompose = function (context, frameState, layerState) {
  var layer = this.getLayer();
  var declutterReplays = layer.getDeclutter() ? {} : null;
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var renderMode = layer.getRenderMode();
  var replayTypes = _ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS[renderMode];
  var pixelRatio = frameState.pixelRatio;
  var rotation = frameState.viewState.rotation;
  var size = frameState.size;
  var offsetX, offsetY;

  if (rotation) {
    offsetX = Math.round(pixelRatio * size[0] / 2);
    offsetY = Math.round(pixelRatio * size[1] / 2);

    _render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["default"].rotateAtOffset(context, -rotation, offsetX, offsetY);
  }

  if (declutterReplays) {
    this.declutterTree_.clear();
  }

  var tiles = this.renderedTiles;
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var clips = [];
  var zs = [];

  for (var i = tiles.length - 1; i >= 0; --i) {
    var tile =
    /** @type {ol.VectorImageTile} */
    tiles[i];

    if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT) {
      continue;
    }

    var tileCoord = tile.tileCoord;
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] - tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];
    var transform = undefined;

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);

      if (sourceTile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        continue;
      }

      var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());

      if (renderMode != _layer_vectortilerendertype_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR && !replayGroup.hasReplays(replayTypes)) {
        continue;
      }

      if (!transform) {
        transform = this.getTransform(frameState, worldOffset);
      }

      var currentZ = sourceTile.tileCoord[0];
      var currentClip = replayGroup.getClipCoords(transform);
      context.save();
      context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are
      // already filled by a higher resolution tile

      for (var j = 0, jj = clips.length; j < jj; ++j) {
        var clip = clips[j];

        if (currentZ < zs[j]) {
          context.beginPath(); // counter-clockwise (outer ring) for current tile

          context.moveTo(currentClip[0], currentClip[1]);
          context.lineTo(currentClip[2], currentClip[3]);
          context.lineTo(currentClip[4], currentClip[5]);
          context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile

          context.moveTo(clip[6], clip[7]);
          context.lineTo(clip[4], clip[5]);
          context.lineTo(clip[2], clip[3]);
          context.lineTo(clip[0], clip[1]);
          context.clip();
        }
      }

      replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);
      context.restore();
      clips.push(currentClip);
      zs.push(currentZ);
    }
  }

  if (declutterReplays) {
    _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_13__["default"].replayDeclutter(declutterReplays, context, rotation);
  }

  if (rotation) {
    _render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["default"].rotateAtOffset(context, rotation,
    /** @type {number} */
    offsetX,
    /** @type {number} */
    offsetY);
  }

  _canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_16__["default"].prototype.postCompose.apply(this, arguments);
};
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.renderFeature = function (feature, squaredTolerance, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector_js__WEBPACK_IMPORTED_MODULE_17__["default"].renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector_js__WEBPACK_IMPORTED_MODULE_17__["default"].renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);
  }

  return loading;
};
/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.renderTileImage_ = function (tile, frameState, layerState) {
  var layer = this.getLayer();
  var replayState = tile.getReplayState(layer);
  var revision = layer.getRevision();

  var replays = _ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS[layer.getRenderMode()];

  if (replays && replayState.renderedTileRevision !== revision) {
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var pixelRatio = frameState.pixelRatio;
    var source =
    /** @type {ol.source.VectorTile} */
    layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer);
    var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);

    for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
      var sourceTile = tile.getTile(tile.tileKeys[i]);

      if (sourceTile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        continue;
      }

      var pixelScale = pixelRatio / resolution;

      var transform = _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].reset(this.tmpTransform_);

      _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].scale(transform, pixelScale, -pixelScale);

      _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].translate(transform, -tileExtent[0], -tileExtent[3]);

      var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      replayGroup.replay(context, transform, 0, {}, replays);
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_canvas_VectorTileLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/layer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable.js */ "./node_modules/ol/observable.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");









/**
 * @constructor
 * @extends {ol.Observable}
 * @param {ol.layer.Layer} layer Layer.
 * @struct
 */

var _ol_renderer_Layer_ = function (layer) {
  _observable_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @private
   * @type {ol.layer.Layer}
   */


  this.layer_ = layer;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_Layer_, _observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */


_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */

_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = _functions_js__WEBPACK_IMPORTED_MODULE_7__["default"].FALSE;
/**
 * Create a function that adds loaded tiles to the tile lookup.
 * @param {ol.source.Tile} source Tile source.
 * @param {ol.proj.Projection} projection Projection of the tiles.
 * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded
 *     tiles by zoom level.
 * @return {function(number, ol.TileRange):boolean} A function that can be
 *     called with a zoom level and a tile range to add loaded tiles to the
 *     lookup.
 * @protected
 */

_ol_renderer_Layer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }

        tiles[zoom][tile.tileCoord.toString()] = tile;
      }

      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};
/**
 * @return {ol.layer.Layer} Layer.
 */


_ol_renderer_Layer_.prototype.getLayer = function () {
  return this.layer_;
};
/**
 * Handle changes in image state.
 * @param {ol.events.Event} event Image change event.
 * @private
 */


_ol_renderer_Layer_.prototype.handleImageChange_ = function (event) {
  var image =
  /** @type {ol.Image} */
  event.target;

  if (image.getState() === _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
    this.renderIfReadyAndVisible();
  }
};
/**
 * Load the image if not already loaded, and register the image change
 * listener if needed.
 * @param {ol.ImageBase} image Image.
 * @return {boolean} `true` if the image is already loaded, `false`
 *     otherwise.
 * @protected
 */


_ol_renderer_Layer_.prototype.loadImage = function (image) {
  var imageState = image.getState();

  if (imageState != _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
    _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listen(image, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, this.handleImageChange_, this);
  }

  if (imageState == _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
    image.load();
    imageState = image.getState();
  }

  return imageState == _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
};
/**
 * @protected
 */


_ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function () {
  var layer = this.getLayer();

  if (layer.getVisible() && layer.getSourceState() == _source_state_js__WEBPACK_IMPORTED_MODULE_8__["default"].READY) {
    this.changed();
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @protected
 */


_ol_renderer_Layer_.prototype.scheduleExpireCache = function (frameState, tileSource) {
  if (tileSource.canExpireCache()) {
    /**
     * @param {ol.source.Tile} tileSource Tile source.
     * @param {ol.PluggableMap} map Map.
     * @param {olx.FrameState} frameState Frame state.
     */
    var postRenderFunction = function (tileSource, map, frameState) {
      var tileSourceKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(tileSource).toString();

      if (tileSourceKey in frameState.usedTiles) {
        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
      }
    }.bind(null, tileSource);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    postRenderFunction);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Source} source Source.
 * @protected
 */


_ol_renderer_Layer_.prototype.updateLogos = function (frameState, source) {
  var logo = source.getLogo();

  if (logo !== undefined) {
    if (typeof logo === 'string') {
      frameState.logos[logo] = '';
    } else if (logo) {
      _asserts_js__WEBPACK_IMPORTED_MODULE_4__["default"].assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.


      _asserts_js__WEBPACK_IMPORTED_MODULE_4__["default"].assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.


      frameState.logos[logo.src] = logo.href;
    }
  }
};
/**
 * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @protected
 */


_ol_renderer_Layer_.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {
  // FIXME should we use tilesToDrawByZ instead?
  var tileSourceKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(tileSource).toString();

  var zKey = z.toString();

  if (tileSourceKey in usedTiles) {
    if (zKey in usedTiles[tileSourceKey]) {
      usedTiles[tileSourceKey][zKey].extend(tileRange);
    } else {
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  } else {
    usedTiles[tileSourceKey] = {};
    usedTiles[tileSourceKey][zKey] = tileRange;
  }
};
/**
 * Manage tile pyramid.
 * This function performs a number of functions related to the tiles at the
 * current zoom and lower zoom levels:
 * - registers idle tiles in frameState.wantedTiles so that they are not
 *   discarded by the tile queue
 * - enqueues missing tiles
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {ol.Extent} extent Extent.
 * @param {number} currentZ Current Z.
 * @param {number} preload Load low resolution tiles up to 'preload' levels.
 * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.
 * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
 * @protected
 * @template T
 */


_ol_renderer_Layer_.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {
  var tileSourceKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(tileSource).toString();

  if (!(tileSourceKey in frameState.wantedTiles)) {
    frameState.wantedTiles[tileSourceKey] = {};
  }

  var wantedTiles = frameState.wantedTiles[tileSourceKey];
  var tileQueue = frameState.tileQueue;
  var minZoom = tileGrid.getMinZoom();
  var tile, tileRange, tileResolution, x, y, z;

  for (z = minZoom; z <= currentZ; ++z) {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
    tileResolution = tileGrid.getResolution(z);

    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (currentZ - z <= preload) {
          tile = tileSource.getTile(z, x, y, pixelRatio, projection);

          if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
            wantedTiles[tile.getKey()] = true;

            if (!tileQueue.isKeyQueued(tile.getKey())) {
              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
            }
          }

          if (opt_tileCallback !== undefined) {
            opt_tileCallback.call(opt_this, tile);
          }
        } else {
          tileSource.useTile(z, x, y, projection);
        }
      }
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_Layer_);

/***/ }),

/***/ "./node_modules/ol/renderer/map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/map.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../disposable.js */ "./node_modules/ol/disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _plugins_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../plugins.js */ "./node_modules/ol/plugins.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style.js */ "./node_modules/ol/style.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");










/**
 * @constructor
 * @abstract
 * @extends {ol.Disposable}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @struct
 */

var _ol_renderer_Map_ = function (container, map) {
  _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this);
  /**
   * @private
   * @type {ol.PluggableMap}
   */


  this.map_ = map;
  /**
   * @private
   * @type {Object.<string, ol.renderer.Layer>}
   */

  this.layerRenderers_ = {};
  /**
   * @private
   * @type {Object.<string, ol.EventsKey>}
   */

  this.layerRendererListeners_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_Map_, _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {olx.FrameState} frameState FrameState.
 * @protected
 */


_ol_renderer_Map_.prototype.calculateMatrices2D = function (frameState) {
  var viewState = frameState.viewState;
  var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
  var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

  _transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);

  _transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].invert(_transform_js__WEBPACK_IMPORTED_MODULE_9__["default"].setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
};
/**
 * Removes all layer renderers.
 */


_ol_renderer_Map_.prototype.removeLayerRenderers = function () {
  for (var key in this.layerRenderers_) {
    this.removeLayerRendererByKey_(key).dispose();
  }
};
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_Map_.expireIconCache_ = function (map, frameState) {
  var cache = _style_js__WEBPACK_IMPORTED_MODULE_8__["default"].iconImageCache;
  cache.expire();
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {ol.layer.Layer} layer Layer.
   * @return {?} Callback result.
   */

  function forEachFeatureAtCoordinate(feature, layer) {
    var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

    var managed = frameState.layerStates[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer)].managed;

    if (!(key in frameState.skippedFeatureUids && !managed)) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }
  }

  var projection = viewState.projection;
  var translatedCoordinate = coordinate;

  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();

    var worldWidth = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getWidth(projectionExtent);

    var x = coordinate[0];

    if (x < projectionExtent[0] || x > projectionExtent[2]) {
      var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
    }
  }

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_6__["default"].visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);

      if (layer.getSource()) {
        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
      }

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};
/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
 * @return {boolean} Is there a feature at the given coordinate?
 * @template U
 */


_ol_renderer_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_5__["default"].TRUE, this, layerFilter, thisArg);
  return hasFeature !== undefined;
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */


_ol_renderer_Map_.prototype.getLayerRenderer = function (layer) {
  var layerKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString();

  if (layerKey in this.layerRenderers_) {
    return this.layerRenderers_[layerKey];
  } else {
    var layerRendererPlugins = _plugins_js__WEBPACK_IMPORTED_MODULE_7__["default"].getLayerRendererPlugins();

    var renderer;
    var type = this.getType();

    for (var i = 0, ii = layerRendererPlugins.length; i < ii; ++i) {
      var plugin = layerRendererPlugins[i];

      if (plugin['handles'](type, layer)) {
        renderer = plugin['create'](this, layer);
        break;
      }
    }

    if (renderer) {
      this.layerRenderers_[layerKey] = renderer;
      this.layerRendererListeners_[layerKey] = _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listen(renderer, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleLayerRendererChange_, this);
    } else {
      throw new Error('Unable to create renderer for layer: ' + layer.getType());
    }

    return renderer;
  }
};
/**
 * @param {string} layerKey Layer key.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */


_ol_renderer_Map_.prototype.getLayerRendererByKey = function (layerKey) {
  return this.layerRenderers_[layerKey];
};
/**
 * @protected
 * @return {Object.<string, ol.renderer.Layer>} Layer renderers.
 */


_ol_renderer_Map_.prototype.getLayerRenderers = function () {
  return this.layerRenderers_;
};
/**
 * @return {ol.PluggableMap} Map.
 */


_ol_renderer_Map_.prototype.getMap = function () {
  return this.map_;
};
/**
 * @abstract
 * @return {ol.renderer.Type} Type
 */


_ol_renderer_Map_.prototype.getType = function () {};
/**
 * Handle changes in a layer renderer.
 * @private
 */


_ol_renderer_Map_.prototype.handleLayerRendererChange_ = function () {
  this.map_.render();
};
/**
 * @param {string} layerKey Layer key.
 * @return {ol.renderer.Layer} Layer renderer.
 * @private
 */


_ol_renderer_Map_.prototype.removeLayerRendererByKey_ = function (layerKey) {
  var layerRenderer = this.layerRenderers_[layerKey];
  delete this.layerRenderers_[layerKey];

  _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].unlistenByKey(this.layerRendererListeners_[layerKey]);

  delete this.layerRendererListeners_[layerKey];
  return layerRenderer;
};
/**
 * Render.
 * @param {?olx.FrameState} frameState Frame state.
 */


_ol_renderer_Map_.prototype.renderFrame = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */

_ol_renderer_Map_.prototype.removeUnusedLayerRenderers_ = function (map, frameState) {
  var layerKey;

  for (layerKey in this.layerRenderers_) {
    if (!frameState || !(layerKey in frameState.layerStates)) {
      this.removeLayerRendererByKey_(layerKey).dispose();
    }
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 */


_ol_renderer_Map_.prototype.scheduleExpireIconCache = function (frameState) {
  frameState.postRenderFunctions.push(
  /** @type {ol.PostRenderFunction} */
  _ol_renderer_Map_.expireIconCache_);
};
/**
 * @param {!olx.FrameState} frameState Frame state.
 * @protected
 */


_ol_renderer_Map_.prototype.scheduleRemoveUnusedLayerRenderers = function (frameState) {
  var layerKey;

  for (layerKey in this.layerRenderers_) {
    if (!(layerKey in frameState.layerStates)) {
      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */
      this.removeUnusedLayerRenderers_.bind(this));
      return;
    }
  }
};
/**
 * @param {ol.LayerState} state1 First layer state.
 * @param {ol.LayerState} state2 Second layer state.
 * @return {number} The zIndex difference.
 */


_ol_renderer_Map_.sortByZIndex = function (state1, state2) {
  return state1.zIndex - state2.zIndex;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_Map_);

/***/ }),

/***/ "./node_modules/ol/renderer/type.js":
/*!******************************************!*\
  !*** ./node_modules/ol/renderer/type.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Available renderers: `'canvas'` or `'webgl'`.
 * @enum {string}
 */
var _ol_renderer_Type_ = {
  CANVAS: 'canvas',
  WEBGL: 'webgl'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_Type_);

/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/*!********************************************!*\
  !*** ./node_modules/ol/renderer/vector.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/replaytype.js */ "./node_modules/ol/render/replaytype.js");




var _ol_renderer_vector_ = {};
/**
 * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.
 * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.
 * @return {number} Order.
 */

_ol_renderer_vector_.defaultOrder = function (feature1, feature2) {
  return _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature1) - _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature2);
};
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */


_ol_renderer_vector_.getSquaredTolerance = function (resolution, pixelRatio) {
  var tolerance = _ol_renderer_vector_.getTolerance(resolution, pixelRatio);

  return tolerance * tolerance;
};
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */


_ol_renderer_vector_.getTolerance = function (resolution, pixelRatio) {
  return _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].SIMPLIFY_TOLERANCE * resolution / pixelRatio;
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Circle} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderCircleGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */


_ol_renderer_vector_.renderFeature = function (replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle, imageState;
  imageStyle = style.getImage();

  if (imageStyle) {
    imageState = imageStyle.getImageState();

    if (imageState == _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }

      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }

  _ol_renderer_vector_.renderFeature_(replayGroup, feature, style, squaredTolerance);

  return loading;
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @private
 */


_ol_renderer_vector_.renderFeature_ = function (replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();

  if (renderer) {
    _ol_renderer_vector_.renderGeometry_(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];

    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderGeometry_ = function (replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_2__["default"].GEOMETRY_COLLECTION) {
    var geometries =
    /** @type {ol.geom.GeometryCollection} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      _ol_renderer_vector_.renderGeometry_(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT);
  replay.drawCustom(
  /** @type {ol.geom.SimpleGeometry} */
  geometry, feature, style.getRenderer());
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderGeometryCollectionGeometry_ = function (replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[geometries[i].getType()];

    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }

    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }

    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_replaytype_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @const
 * @private
 * @type {Object.<ol.geom.GeometryType,
 *                function(ol.render.ReplayGroup, ol.geom.Geometry,
 *                         ol.style.Style, Object)>}
 */


_ol_renderer_vector_.GEOMETRY_RENDERERS_ = {
  'Point': _ol_renderer_vector_.renderPointGeometry_,
  'LineString': _ol_renderer_vector_.renderLineStringGeometry_,
  'Polygon': _ol_renderer_vector_.renderPolygonGeometry_,
  'MultiPoint': _ol_renderer_vector_.renderMultiPointGeometry_,
  'MultiLineString': _ol_renderer_vector_.renderMultiLineStringGeometry_,
  'MultiPolygon': _ol_renderer_vector_.renderMultiPolygonGeometry_,
  'GeometryCollection': _ol_renderer_vector_.renderGeometryCollectionGeometry_,
  'Circle': _ol_renderer_vector_.renderCircleGeometry_
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_vector_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/defaultmapshader.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/defaultmapshader.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_renderer_webgl_defaultmapshader_ = {};
_ol_renderer_webgl_defaultmapshader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n' : 'precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}');
_ol_renderer_webgl_defaultmapshader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_defaultmapshader_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/defaultmapshader/locations.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/defaultmapshader/locations.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_renderer_webgl_defaultmapshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_texCoordMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_texCoordMatrix' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_projectionMatrix = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_projectionMatrix' : 'e');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_opacity' : 'f');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_texture = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_texture' : 'g');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'b');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_defaultmapshader_Locations_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/imagelayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/imagelayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl/layer.js */ "./node_modules/ol/renderer/webgl/layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_context_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../webgl/context.js */ "./node_modules/ol/webgl/context.js");











/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Image} imageLayer Tile layer.
 * @api
 */

var _ol_renderer_webgl_ImageLayer_ = function (mapRenderer, imageLayer) {
  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, mapRenderer, imageLayer);
  /**
   * The last rendered image.
   * @private
   * @type {?ol.ImageBase}
   */


  this.image_ = null;
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitCanvasContext_ = null;
  /**
   * @private
   * @type {?ol.Transform}
   */

  this.hitTransformationMatrix_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_webgl_ImageLayer_, _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_ImageLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_6__["default"].WEBGL && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.ImageLayer} The layer renderer.
 */


_ol_renderer_webgl_ImageLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_ImageLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Image} */
  layer);
};
/**
 * @param {ol.ImageBase} image Image.
 * @private
 * @return {WebGLTexture} Texture.
 */


_ol_renderer_webgl_ImageLayer_.prototype.createTexture_ = function (image) {
  // We meet the conditions to work with non-power of two textures.
  // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
  // http://learningwebgl.com/blog/?p=2101
  var imageElement = image.getImage();
  var gl = this.mapRenderer.getGL();
  return _webgl_context_js__WEBPACK_IMPORTED_MODULE_10__["default"].createTexture(gl, imageElement, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLAMP_TO_EDGE, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLAMP_TO_EDGE);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var gl = this.mapRenderer.getGL();
  var pixelRatio = frameState.pixelRatio;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var viewRotation = viewState.rotation;
  var image = this.image_;
  var texture = this.texture;
  var imageLayer =
  /** @type {ol.layer.Image} */
  this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;

  if (layerState.extent !== undefined) {
    renderedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getIntersection(renderedExtent, layerState.extent);
  }

  if (!hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING] && !hints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING] && !_extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].isEmpty(renderedExtent)) {
    var projection = viewState.projection;

    if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();

      if (sourceProjection) {
        projection = sourceProjection;
      }
    }

    var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

    if (image_) {
      var loaded = this.loadImage(image_);

      if (loaded) {
        image = image_;
        texture = this.createTexture_(image_);

        if (this.texture) {
          /**
           * @param {WebGLRenderingContext} gl GL.
           * @param {WebGLTexture} texture Texture.
           */
          var postRenderFunction = function (gl, texture) {
            if (!gl.isContextLost()) {
              gl.deleteTexture(texture);
            }
          }.bind(null, gl, this.texture);

          frameState.postRenderFunctions.push(
          /** @type {ol.PostRenderFunction} */
          postRenderFunction);
        }
      }
    }
  }

  if (image) {
    var canvas = this.mapRenderer.getContext().getCanvas();
    this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());
    this.hitTransformationMatrix_ = null; // Translate and scale to flip the Y coord.

    var texCoordMatrix = this.texCoordMatrix;

    _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].reset(texCoordMatrix);

    _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(texCoordMatrix, 1, -1);

    _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(texCoordMatrix, 0, -1);

    this.image_ = image;
    this.texture = texture;
    this.updateLogos(frameState, imageSource);
  }

  return !!image;
};
/**
 * @param {number} canvasWidth Canvas width.
 * @param {number} canvasHeight Canvas height.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Coordinate} viewCenter View center.
 * @param {number} viewResolution View resolution.
 * @param {number} viewRotation View rotation.
 * @param {ol.Extent} imageExtent Image extent.
 * @private
 */


_ol_renderer_webgl_ImageLayer_.prototype.updateProjectionMatrix_ = function (canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {
  var canvasExtentWidth = canvasWidth * viewResolution;
  var canvasExtentHeight = canvasHeight * viewResolution;
  var projectionMatrix = this.projectionMatrix;

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].reset(projectionMatrix);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].rotate(projectionMatrix, -viewRotation);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(projectionMatrix, 1, 1);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions_js__WEBPACK_IMPORTED_MODULE_5__["default"].TRUE, this);
  return hasFeature !== undefined;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.image_ || !this.image_.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    var coordinate = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.pixelToCoordinateTransform, pixel.slice());

    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions_js__WEBPACK_IMPORTED_MODULE_5__["default"].TRUE, this);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  } else {
    var imageSize = [this.image_.getImage().width, this.image_.getImage().height];

    if (!this.hitTransformationMatrix_) {
      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);
    }

    var pixelOnFrameBuffer = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(this.hitTransformationMatrix_, pixel.slice());

    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {
      // outside the image, no need to check
      return undefined;
    }

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;

    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
/**
 * The transformation matrix to get the pixel on the image for a
 * pixel on the map.
 * @param {ol.Size} mapSize The map size.
 * @param {ol.Size} imageSize The image size.
 * @return {ol.Transform} The transformation matrix.
 * @private
 */


_ol_renderer_webgl_ImageLayer_.prototype.getHitTransformationMatrix_ = function (mapSize, imageSize) {
  // the first matrix takes a map pixel, flips the y-axis and scales to
  // a range between -1 ... 1
  var mapCoordTransform = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].create();

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(mapCoordTransform, -1, -1);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(mapCoordTransform, 0, mapSize[1]);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(mapCoordTransform, 1, -1); // the second matrix is the inverse of the projection matrix used in the
  // shader for drawing


  var projectionMatrixInv = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].invert(this.projectionMatrix.slice()); // the third matrix scales to the image dimensions and flips the y-axis again


  var transform = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].create();

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(transform, 0, imageSize[1]);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(transform, 1, -1);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].scale(transform, imageSize[0] / 2, imageSize[1] / 2);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].translate(transform, 1, 1);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].multiply(transform, projectionMatrixInv);

  _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].multiply(transform, mapCoordTransform);

  return transform;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_ImageLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/layer.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/layer.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _render_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../render/event.js */ "./node_modules/ol/render/event.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _render_webgl_immediate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/webgl/immediate.js */ "./node_modules/ol/render/webgl/immediate.js");
/* harmony import */ var _layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer.js */ "./node_modules/ol/renderer/layer.js");
/* harmony import */ var _webgl_defaultmapshader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/defaultmapshader.js */ "./node_modules/ol/renderer/webgl/defaultmapshader.js");
/* harmony import */ var _webgl_defaultmapshader_locations_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl/defaultmapshader/locations.js */ "./node_modules/ol/renderer/webgl/defaultmapshader/locations.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../vec/mat4.js */ "./node_modules/ol/vec/mat4.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");
/* harmony import */ var _webgl_context_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../webgl/context.js */ "./node_modules/ol/webgl/context.js");












/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Layer} layer Layer.
 */

var _ol_renderer_webgl_Layer_ = function (mapRenderer, layer) {
  _layer_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this, layer);
  /**
   * @protected
   * @type {ol.renderer.webgl.Map}
   */


  this.mapRenderer = mapRenderer;
  /**
   * @private
   * @type {ol.webgl.Buffer}
   */

  this.arrayBuffer_ = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_10__["default"]([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);
  /**
   * @protected
   * @type {WebGLTexture}
   */

  this.texture = null;
  /**
   * @protected
   * @type {WebGLFramebuffer}
   */

  this.framebuffer = null;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.framebufferDimension = undefined;
  /**
   * @protected
   * @type {ol.Transform}
   */

  this.texCoordMatrix = _transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].create();
  /**
   * @protected
   * @type {ol.Transform}
   */

  this.projectionMatrix = _transform_js__WEBPACK_IMPORTED_MODULE_7__["default"].create();
  /**
   * @type {Array.<number>}
   * @private
   */

  this.tmpMat4_ = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_8__["default"].create();
  /**
   * @private
   * @type {ol.renderer.webgl.defaultmapshader.Locations}
   */

  this.defaultLocations_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_webgl_Layer_, _layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} framebufferDimension Framebuffer dimension.
 * @protected
 */


_ol_renderer_webgl_Layer_.prototype.bindFramebuffer = function (frameState, framebufferDimension) {
  var gl = this.mapRenderer.getGL();

  if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {
    /**
     * @param {WebGLRenderingContext} gl GL.
     * @param {WebGLFramebuffer} framebuffer Framebuffer.
     * @param {WebGLTexture} texture Texture.
     */
    var postRenderFunction = function (gl, framebuffer, texture) {
      if (!gl.isContextLost()) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
      }
    }.bind(null, gl, this.framebuffer, this.texture);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    postRenderFunction);

    var texture = _webgl_context_js__WEBPACK_IMPORTED_MODULE_11__["default"].createEmptyTexture(gl, framebufferDimension, framebufferDimension);

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].FRAMEBUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].COLOR_ATTACHMENT0, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].TEXTURE_2D, texture, 0);
    this.texture = texture;
    this.framebuffer = framebuffer;
    this.framebufferDimension = framebufferDimension;
  } else {
    gl.bindFramebuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].FRAMEBUFFER, this.framebuffer);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 */


_ol_renderer_webgl_Layer_.prototype.composeFrame = function (frameState, layerState, context) {
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRECOMPOSE, context, frameState);
  context.bindBuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].ARRAY_BUFFER, this.arrayBuffer_);
  var gl = context.getGL();
  var fragmentShader = _webgl_defaultmapshader_js__WEBPACK_IMPORTED_MODULE_5__["default"].fragment;
  var vertexShader = _webgl_defaultmapshader_js__WEBPACK_IMPORTED_MODULE_5__["default"].vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;

  if (!this.defaultLocations_) {
    locations = new _webgl_defaultmapshader_locations_js__WEBPACK_IMPORTED_MODULE_6__["default"](gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  if (context.useProgram(program)) {
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(locations.a_texCoord);
    gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].FLOAT, false, 16, 8);
    gl.uniform1i(locations.u_texture, 0);
  }

  gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, _vec_mat4_js__WEBPACK_IMPORTED_MODULE_8__["default"].fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));
  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _vec_mat4_js__WEBPACK_IMPORTED_MODULE_8__["default"].fromTransform(this.tmpMat4_, this.getProjectionMatrix()));
  gl.uniform1f(locations.u_opacity, layerState.opacity);
  gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].TEXTURE_2D, this.getTexture());
  gl.drawArrays(_webgl_js__WEBPACK_IMPORTED_MODULE_9__["default"].TRIANGLE_STRIP, 0, 4);
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].POSTCOMPOSE, context, frameState);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {ol.webgl.Context} context WebGL context.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState) {
  var layer = this.getLayer();

  if (layer.hasListener(type)) {
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var extent = frameState.extent;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var render = new _render_webgl_immediate_js__WEBPACK_IMPORTED_MODULE_3__["default"](context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new _render_event_js__WEBPACK_IMPORTED_MODULE_1__["default"](type, render, frameState, null, context);
    layer.dispatchEvent(composeEvent);
  }
};
/**
 * @return {!ol.Transform} Matrix.
 */


_ol_renderer_webgl_Layer_.prototype.getTexCoordMatrix = function () {
  return this.texCoordMatrix;
};
/**
 * @return {WebGLTexture} Texture.
 */


_ol_renderer_webgl_Layer_.prototype.getTexture = function () {
  return this.texture;
};
/**
 * @return {!ol.Transform} Matrix.
 */


_ol_renderer_webgl_Layer_.prototype.getProjectionMatrix = function () {
  return this.projectionMatrix;
};
/**
 * Handle webglcontextlost.
 */


_ol_renderer_webgl_Layer_.prototype.handleWebGLContextLost = function () {
  this.texture = null;
  this.framebuffer = null;
  this.framebufferDimension = undefined;
};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 * @return {boolean} whether composeFrame should be called.
 */


_ol_renderer_webgl_Layer_.prototype.prepareFrame = function (frameState, layerState, context) {};
/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_webgl_Layer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_Layer_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/map.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/renderer/webgl/map.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _layer_layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/layer.js */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var _render_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/event.js */ "./node_modules/ol/render/event.js");
/* harmony import */ var _render_eventtype_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/eventtype.js */ "./node_modules/ol/render/eventtype.js");
/* harmony import */ var _render_webgl_immediate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/webgl/immediate.js */ "./node_modules/ol/render/webgl/immediate.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../map.js */ "./node_modules/ol/renderer/map.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../structs/lrucache.js */ "./node_modules/ol/structs/lrucache.js");
/* harmony import */ var _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../structs/priorityqueue.js */ "./node_modules/ol/structs/priorityqueue.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_context_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../webgl/context.js */ "./node_modules/ol/webgl/context.js");
/* harmony import */ var _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../webgl/contexteventtype.js */ "./node_modules/ol/webgl/contexteventtype.js");
// FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)


















/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */

var _ol_renderer_webgl_Map_ = function (container, map) {
  _map_js__WEBPACK_IMPORTED_MODULE_10__["default"].call(this, container, map);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ =
  /** @type {HTMLCanvasElement} */
  document.createElement('CANVAS');
  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  /**
   * @private
   * @type {number}
   */

  this.clipTileCanvasWidth_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.clipTileCanvasHeight_ = 0;
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.clipTileContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D();
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {WebGLRenderingContext}
   */

  this.gl_ = _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].getContext(this.canvas_, {
    antialias: true,
    depth: true,
    failIfMajorPerformanceCaveat: true,
    preserveDrawingBuffer: false,
    stencil: true
  });
  /**
   * @private
   * @type {ol.webgl.Context}
   */

  this.context_ = new _webgl_context_js__WEBPACK_IMPORTED_MODULE_16__["default"](this.canvas_, this.gl_);

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.canvas_, _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_17__["default"].LOST, this.handleWebGLContextLost, this);

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.canvas_, _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_17__["default"].RESTORED, this.handleWebGLContextRestored, this);
  /**
   * @private
   * @type {ol.structs.LRUCache.<ol.WebglTextureCacheEntry|null>}
   */


  this.textureCache_ = new _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_13__["default"]();
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.focus_ = null;
  /**
   * @private
   * @type {ol.structs.PriorityQueue.<Array>}
   */

  this.tileTextureQueue_ = new _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_14__["default"](
  /**
   * @param {Array.<*>} element Element.
   * @return {number} Priority.
   * @this {ol.renderer.webgl.Map}
   */
  function (element) {
    var tileCenter =
    /** @type {ol.Coordinate} */
    element[1];
    var tileResolution =
    /** @type {number} */
    element[2];
    var deltaX = tileCenter[0] - this.focus_[0];
    var deltaY = tileCenter[1] - this.focus_[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }.bind(this),
  /**
   * @param {Array.<*>} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (
      /** @type {ol.Tile} */
      element[0].getKey()
    );
  });
  /**
   * @param {ol.PluggableMap} map Map.
   * @param {?olx.FrameState} frameState Frame state.
   * @return {boolean} false.
   * @this {ol.renderer.webgl.Map}
   */

  this.loadNextTileTexture_ = function (map, frameState) {
    if (!this.tileTextureQueue_.isEmpty()) {
      this.tileTextureQueue_.reprioritize();
      var element = this.tileTextureQueue_.dequeue();
      var tile =
      /** @type {ol.Tile} */
      element[0];
      var tileSize =
      /** @type {ol.Size} */
      element[3];
      var tileGutter =
      /** @type {number} */
      element[4];
      this.bindTileTexture(tile, tileSize, tileGutter, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINEAR, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINEAR);
    }

    return false;
  }.bind(this);
  /**
   * @private
   * @type {number}
   */


  this.textureCacheFrameMarkerCount_ = 0;
  this.initializeGL_();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_webgl_Map_, _map_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_Map_['handles'] = function (type) {
  return _has_js__WEBPACK_IMPORTED_MODULE_5__["default"].WEBGL && type === _type_js__WEBPACK_IMPORTED_MODULE_11__["default"].WEBGL;
};
/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.webgl.Map} The map renderer.
 */


_ol_renderer_webgl_Map_['create'] = function (container, map) {
  return new _ol_renderer_webgl_Map_(container, map);
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {ol.Size} tileSize Tile size.
 * @param {number} tileGutter Tile gutter.
 * @param {number} magFilter Mag filter.
 * @param {number} minFilter Min filter.
 */


_ol_renderer_webgl_Map_.prototype.bindTileTexture = function (tile, tileSize, tileGutter, magFilter, minFilter) {
  var gl = this.getGL();
  var tileKey = tile.getKey();

  if (this.textureCache_.containsKey(tileKey)) {
    var textureCacheEntry = this.textureCache_.get(tileKey);
    gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, textureCacheEntry.texture);

    if (textureCacheEntry.magFilter != magFilter) {
      gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_MAG_FILTER, magFilter);
      textureCacheEntry.magFilter = magFilter;
    }

    if (textureCacheEntry.minFilter != minFilter) {
      gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_MIN_FILTER, minFilter);
      textureCacheEntry.minFilter = minFilter;
    }
  } else {
    var texture = gl.createTexture();
    gl.bindTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, texture);

    if (tileGutter > 0) {
      var clipTileCanvas = this.clipTileContext_.canvas;
      var clipTileContext = this.clipTileContext_;

      if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {
        clipTileCanvas.width = tileSize[0];
        clipTileCanvas.height = tileSize[1];
        this.clipTileCanvasWidth_ = tileSize[0];
        this.clipTileCanvasHeight_ = tileSize[1];
      } else {
        clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);
      }

      clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);
      gl.texImage2D(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, 0, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].RGBA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].RGBA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].UNSIGNED_BYTE, clipTileCanvas);
    } else {
      gl.texImage2D(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, 0, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].RGBA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].RGBA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].UNSIGNED_BYTE, tile.getImage());
    }

    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_MAG_FILTER, magFilter);
    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_WRAP_S, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].CLAMP_TO_EDGE);
    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE_WRAP_T, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].CLAMP_TO_EDGE);
    this.textureCache_.set(tileKey, {
      texture: texture,
      magFilter: magFilter,
      minFilter: minFilter
    });
  }
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();

  if (map.hasListener(type)) {
    var context = this.context_;
    var extent = frameState.extent;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var resolution = viewState.resolution;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var vectorContext = new _render_webgl_immediate_js__WEBPACK_IMPORTED_MODULE_9__["default"](context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new _render_event_js__WEBPACK_IMPORTED_MODULE_7__["default"](type, vectorContext, frameState, null, context);
    map.dispatchEvent(composeEvent);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.disposeInternal = function () {
  var gl = this.getGL();

  if (!gl.isContextLost()) {
    this.textureCache_.forEach(
    /**
     * @param {?ol.WebglTextureCacheEntry} textureCacheEntry
     *     Texture cache entry.
     */
    function (textureCacheEntry) {
      if (textureCacheEntry) {
        gl.deleteTexture(textureCacheEntry.texture);
      }
    });
  }

  this.context_.dispose();

  _map_js__WEBPACK_IMPORTED_MODULE_10__["default"].prototype.disposeInternal.call(this);
};
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Map_.prototype.expireCache_ = function (map, frameState) {
  var gl = this.getGL();
  var textureCacheEntry;

  while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    textureCacheEntry = this.textureCache_.peekLast();

    if (!textureCacheEntry) {
      if (+this.textureCache_.peekLastKey() == frameState.index) {
        break;
      } else {
        --this.textureCacheFrameMarkerCount_;
      }
    } else {
      gl.deleteTexture(textureCacheEntry.texture);
    }

    this.textureCache_.pop();
  }
};
/**
 * @return {ol.webgl.Context} The context.
 */


_ol_renderer_webgl_Map_.prototype.getContext = function () {
  return this.context_;
};
/**
 * @return {WebGLRenderingContext} GL.
 */


_ol_renderer_webgl_Map_.prototype.getGL = function () {
  return this.gl_;
};
/**
 * @return {ol.structs.PriorityQueue.<Array>} Tile texture queue.
 */


_ol_renderer_webgl_Map_.prototype.getTileTextureQueue = function () {
  return this.tileTextureQueue_;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.getType = function () {
  return _type_js__WEBPACK_IMPORTED_MODULE_11__["default"].WEBGL;
};
/**
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_renderer_webgl_Map_.prototype.handleWebGLContextLost = function (event) {
  event.preventDefault();
  this.textureCache_.clear();
  this.textureCacheFrameMarkerCount_ = 0;
  var renderers = this.getLayerRenderers();

  for (var id in renderers) {
    var renderer =
    /** @type {ol.renderer.webgl.Layer} */
    renderers[id];
    renderer.handleWebGLContextLost();
  }
};
/**
 * @protected
 */


_ol_renderer_webgl_Map_.prototype.handleWebGLContextRestored = function () {
  this.initializeGL_();
  this.getMap().render();
};
/**
 * @private
 */


_ol_renderer_webgl_Map_.prototype.initializeGL_ = function () {
  var gl = this.gl_;
  gl.activeTexture(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].TEXTURE0);
  gl.blendFuncSeparate(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].SRC_ALPHA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].ONE_MINUS_SRC_ALPHA, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].ONE, _webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].ONE_MINUS_SRC_ALPHA);
  gl.disable(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].CULL_FACE);
  gl.disable(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].DEPTH_TEST);
  gl.disable(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].SCISSOR_TEST);
  gl.disable(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].STENCIL_TEST);
};
/**
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Is tile texture loaded.
 */


_ol_renderer_webgl_Map_.prototype.isTileTextureLoaded = function (tile) {
  return this.textureCache_.containsKey(tile.getKey());
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.renderFrame = function (frameState) {
  var context = this.getContext();
  var gl = this.getGL();

  if (gl.isContextLost()) {
    return false;
  }

  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return false;
  }

  this.focus_ = frameState.focus;
  this.textureCache_.set((-frameState.index).toString(), null);
  ++this.textureCacheFrameMarkerCount_;
  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_8__["default"].PRECOMPOSE, frameState);
  /** @type {Array.<ol.LayerState>} */

  var layerStatesToDraw = [];
  var layerStatesArray = frameState.layerStatesArray;

  _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].stableSort(layerStatesArray, _map_js__WEBPACK_IMPORTED_MODULE_10__["default"].sortByZIndex);

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layerRenderer, layerState;

  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_6__["default"].visibleAtResolution(layerState, viewResolution) && layerState.sourceState == _source_state_js__WEBPACK_IMPORTED_MODULE_12__["default"].READY) {
      layerRenderer =
      /** @type {ol.renderer.webgl.Layer} */
      this.getLayerRenderer(layerState.layer);

      if (layerRenderer.prepareFrame(frameState, layerState, context)) {
        layerStatesToDraw.push(layerState);
      }
    }
  }

  var width = frameState.size[0] * frameState.pixelRatio;
  var height = frameState.size[1] * frameState.pixelRatio;

  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  }

  gl.bindFramebuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].FRAMEBUFFER, null);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].COLOR_BUFFER_BIT);
  gl.enable(_webgl_js__WEBPACK_IMPORTED_MODULE_15__["default"].BLEND);
  gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);

  for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {
    layerState = layerStatesToDraw[i];
    layerRenderer =
    /** @type {ol.renderer.webgl.Layer} */
    this.getLayerRenderer(layerState.layer);
    layerRenderer.composeFrame(frameState, layerState, context);
  }

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.calculateMatrices2D(frameState);

  if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    this.expireCache_.bind(this));
  }

  if (!this.tileTextureQueue_.isEmpty()) {
    frameState.postRenderFunctions.push(this.loadNextTileTexture_);
    frameState.animate = true;
  }

  this.dispatchComposeEvent_(_render_eventtype_js__WEBPACK_IMPORTED_MODULE_8__["default"].POSTCOMPOSE, frameState);
  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_6__["default"].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = false;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_6__["default"].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);

      if (hasFeature) {
        return true;
      }
    }
  }

  return hasFeature;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var result;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer_layer_js__WEBPACK_IMPORTED_MODULE_6__["default"].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer =
      /** @type {ol.renderer.webgl.Layer} */
      this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_Map_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/tilelayer.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/tilelayer.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _tilerange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tilerange.js */ "./node_modules/ol/tilerange.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _webgl_layer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/layer.js */ "./node_modules/ol/renderer/webgl/layer.js");
/* harmony import */ var _webgl_tilelayershader_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl/tilelayershader.js */ "./node_modules/ol/renderer/webgl/tilelayershader.js");
/* harmony import */ var _webgl_tilelayershader_locations_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../webgl/tilelayershader/locations.js */ "./node_modules/ol/renderer/webgl/tilelayershader/locations.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../webgl/buffer.js */ "./node_modules/ol/webgl/buffer.js");
// FIXME large resolutions lead to too large framebuffers :-(
// FIXME animated shaders! check in redraw















/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Tile} tileLayer Tile layer.
 * @api
 */

var _ol_renderer_webgl_TileLayer_ = function (mapRenderer, tileLayer) {
  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, mapRenderer, tileLayer);
  /**
   * @private
   * @type {ol.webgl.Fragment}
   */


  this.fragmentShader_ = _webgl_tilelayershader_js__WEBPACK_IMPORTED_MODULE_9__["default"].fragment;
  /**
   * @private
   * @type {ol.webgl.Vertex}
   */

  this.vertexShader_ = _webgl_tilelayershader_js__WEBPACK_IMPORTED_MODULE_9__["default"].vertex;
  /**
   * @private
   * @type {ol.renderer.webgl.tilelayershader.Locations}
   */

  this.locations_ = null;
  /**
   * @private
   * @type {ol.webgl.Buffer}
   */

  this.renderArrayBuffer_ = new _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_14__["default"]([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);
  /**
   * @private
   * @type {ol.TileRange}
   */

  this.renderedTileRange_ = null;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedFramebufferExtent_ = null;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {ol.Size}
   */

  this.tmpSize_ = [0, 0];
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_webgl_TileLayer_, _webgl_layer_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_TileLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_7__["default"].WEBGL && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.TileLayer} The layer renderer.
 */


_ol_renderer_webgl_TileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_TileLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Tile} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.disposeInternal = function () {
  var context = this.mapRenderer.getContext();
  context.deleteBuffer(this.renderArrayBuffer_);

  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  var mapRenderer = this.mapRenderer;
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        var loaded = mapRenderer.isTileTextureLoaded(tile);

        if (loaded) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }

          tiles[zoom][tile.tileCoord.toString()] = tile;
        }

        return loaded;
      }

      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.handleWebGLContextLost = function () {
  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.handleWebGLContextLost.call(this);

  this.locations_ = null;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var mapRenderer = this.mapRenderer;
  var gl = context.getGL();
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var tileLayer =
  /** @type {ol.layer.Tile} */
  this.getLayer();
  var tileSource = tileLayer.getSource();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewState.resolution);
  var tileResolution = tileGrid.getResolution(z);
  var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);

  var pixelRatio = tilePixelSize[0] / _size_js__WEBPACK_IMPORTED_MODULE_11__["default"].toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];

  var tilePixelResolution = tileResolution / pixelRatio;
  var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);
  var center = viewState.center;
  var extent = frameState.extent;
  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var framebufferExtent;

  if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {
    framebufferExtent = this.renderedFramebufferExtent_;
  } else {
    var tileRangeSize = tileRange.getSize();
    var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);

    var framebufferDimension = _math_js__WEBPACK_IMPORTED_MODULE_6__["default"].roundUpToPowerOfTwo(maxDimension);

    var framebufferExtentDimension = tilePixelResolution * framebufferDimension;
    var origin = tileGrid.getOrigin(z);
    var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;
    var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;
    framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];
    this.bindFramebuffer(frameState, framebufferDimension);
    gl.viewport(0, 0, framebufferDimension, framebufferDimension);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(_webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].COLOR_BUFFER_BIT);
    gl.disable(_webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].BLEND);
    var program = context.getProgram(this.fragmentShader_, this.vertexShader_);
    context.useProgram(program);

    if (!this.locations_) {
      this.locations_ = new _webgl_tilelayershader_locations_js__WEBPACK_IMPORTED_MODULE_10__["default"](gl, program);
    }

    context.bindBuffer(_webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].ARRAY_BUFFER, this.renderArrayBuffer_);
    gl.enableVertexAttribArray(this.locations_.a_position);
    gl.vertexAttribPointer(this.locations_.a_position, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(this.locations_.a_texCoord);
    gl.vertexAttribPointer(this.locations_.a_texCoord, 2, _webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].FLOAT, false, 16, 8);
    gl.uniform1i(this.locations_.u_texture, 0);
    /**
     * @type {Object.<number, Object.<string, ol.Tile>>}
     */

    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    var allTilesLoaded = true;

    var tmpExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].createEmpty();

    var tmpTileRange = new _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);
    var childTileRange, drawable, fullyLoaded, tile, tileState;
    var x, y, tileExtent;

    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tile = tileSource.getTile(z, x, y, pixelRatio, projection);

        if (layerState.extent !== undefined) {
          // ignore tiles outside layer extent
          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);

          if (!_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].intersects(tileExtent, layerState.extent)) {
            continue;
          }
        }

        tileState = tile.getState();
        drawable = tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;

        if (!drawable) {
          tile = tile.getInterimTile();
        }

        tileState = tile.getState();

        if (tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
          if (mapRenderer.isTileTextureLoaded(tile)) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            continue;
          }
        } else if (tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError) {
          continue;
        }

        allTilesLoaded = false;
        fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);

        if (!fullyLoaded) {
          childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);

          if (childTileRange) {
            findLoadedTiles(z + 1, childTileRange);
          }
        }
      }
    }
    /** @type {Array.<number>} */


    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_4__["default"].numberSafeCompareFunction);
    var u_tileOffset = new Float32Array(4);
    var i, ii, tileKey, tilesToDraw;

    for (i = 0, ii = zs.length; i < ii; ++i) {
      tilesToDraw = tilesToDrawByZ[zs[i]];

      for (tileKey in tilesToDraw) {
        tile = tilesToDraw[tileKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
        u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;
        u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;
        u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;
        u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;
        gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);
        mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, _webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINEAR, _webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINEAR);
        gl.drawArrays(_webgl_js__WEBPACK_IMPORTED_MODULE_13__["default"].TRIANGLE_STRIP, 0, 4);
      }
    }

    if (allTilesLoaded) {
      this.renderedTileRange_ = tileRange;
      this.renderedFramebufferExtent_ = framebufferExtent;
      this.renderedRevision_ = tileSource.getRevision();
    } else {
      this.renderedTileRange_ = null;
      this.renderedFramebufferExtent_ = null;
      this.renderedRevision_ = -1;
      frameState.animate = true;
    }
  }

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  var tileTextureQueue = mapRenderer.getTileTextureQueue();
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(),
  /**
   * @param {ol.Tile} tile Tile.
   */
  function (tile) {
    if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {
      tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);
    }
  }, this);
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  var texCoordMatrix = this.texCoordMatrix;

  _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].reset(texCoordMatrix);

  _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].translate(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));

  if (viewState.rotation !== 0) {
    _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].rotate(texCoordMatrix, viewState.rotation);
  }

  _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].scale(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));

  _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].translate(texCoordMatrix, -0.5, -0.5);

  return true;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.framebuffer) {
    return undefined;
  }

  var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];

  var pixelOnFrameBufferScaled = _transform_js__WEBPACK_IMPORTED_MODULE_12__["default"].apply(this.texCoordMatrix, pixelOnMapScaled.slice());

  var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];
  var gl = this.mapRenderer.getContext().getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  var imageData = new Uint8Array(4);
  gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

  if (imageData[3] > 0) {
    return callback.call(thisArg, this.getLayer(), imageData);
  } else {
    return undefined;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_TileLayer_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/tilelayershader.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/tilelayershader.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/fragment.js */ "./node_modules/ol/webgl/fragment.js");
/* harmony import */ var _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/vertex.js */ "./node_modules/ol/webgl/vertex.js");
// This file is automatically generated, do not edit



var _ol_renderer_webgl_tilelayershader_ = {};
_ol_renderer_webgl_tilelayershader_.fragment = new _webgl_fragment_js__WEBPACK_IMPORTED_MODULE_1__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n' : 'precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}');
_ol_renderer_webgl_tilelayershader_.vertex = new _webgl_vertex_js__WEBPACK_IMPORTED_MODULE_2__["default"](_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}');
/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_tilelayershader_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/tilelayershader/locations.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/tilelayershader/locations.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../index.js */ "./node_modules/ol/index.js");
// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */

var _ol_renderer_webgl_tilelayershader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_tileOffset = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_tileOffset' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_texture = gl.getUniformLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'u_texture' : 'e');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_position' : 'b');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_tilelayershader_Locations_);

/***/ }),

/***/ "./node_modules/ol/renderer/webgl/vectorlayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/webgl/vectorlayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _layertype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layertype.js */ "./node_modules/ol/layertype.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/webgl/replaygroup.js */ "./node_modules/ol/render/webgl/replaygroup.js");
/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../type.js */ "./node_modules/ol/renderer/type.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl/layer.js */ "./node_modules/ol/renderer/webgl/layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");









/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */

var _ol_renderer_webgl_VectorLayer_ = function (mapRenderer, vectorLayer) {
  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, mapRenderer, vectorLayer);
  /**
   * @private
   * @type {boolean}
   */


  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.renderedResolution_ = NaN;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].createEmpty();
  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */

  this.renderedRenderOrder_ = null;
  /**
   * @private
   * @type {ol.render.webgl.ReplayGroup}
   */

  this.replayGroup_ = null;
  /**
   * The last layer state.
   * @private
   * @type {?ol.LayerState}
   */

  this.layerState_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_renderer_webgl_VectorLayer_, _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_VectorLayer_['handles'] = function (type, layer) {
  return type === _type_js__WEBPACK_IMPORTED_MODULE_5__["default"].WEBGL && layer.getType() === _layertype_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.VectorLayer} The layer renderer.
 */


_ol_renderer_webgl_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_VectorLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Vector} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  this.layerState_ = layerState;
  var viewState = frameState.viewState;
  var replayGroup = this.replayGroup_;
  var size = frameState.size;
  var pixelRatio = frameState.pixelRatio;
  var gl = this.mapRenderer.getGL();

  if (replayGroup && !replayGroup.isEmpty()) {
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);
    replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});
    gl.disable(gl.SCISSOR_TEST);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.disposeInternal = function () {
  var replayGroup = this.replayGroup_;

  if (replayGroup) {
    var context = this.mapRenderer.getContext();
    replayGroup.getDeleteResourcesFunction(context)();
    this.replayGroup_ = null;
  }

  _webgl_layer_js__WEBPACK_IMPORTED_MODULE_7__["default"].prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_ || !this.layerState_) {
    return undefined;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layer = this.getLayer();
    var layerState = this.layerState_;
    /** @type {Object.<string, boolean>} */

    var features = {};
    return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  if (!this.replayGroup_ || !this.layerState_) {
    return false;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layerState = this.layerState_;
    return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  var coordinate = _transform_js__WEBPACK_IMPORTED_MODULE_8__["default"].apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_webgl_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var vectorLayer =
  /** @type {ol.layer.Vector} */
  this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
  var interacting = frameState.viewHints[_viewhint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultOrder;
  }

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].containsExtent(this.renderedExtent_, extent)) {
    return true;
  }

  if (this.replayGroup_) {
    frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));
  }

  this.dirty_ = false;
  var replayGroup = new _render_webgl_replaygroup_js__WEBPACK_IMPORTED_MODULE_4__["default"](_vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.webgl.VectorLayer}
   */

  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();

    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }

    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  };

  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    features.forEach(renderFeature, this);
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }

  replayGroup.finish(context);
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  return true;
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_webgl_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = styles.length - 1, ii = 0; i >= ii; --i) {
      loading = _vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].renderFeature(replayGroup, feature, styles[i], _vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].renderFeature(replayGroup, feature, styles, _vector_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
  }

  return loading;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_renderer_webgl_VectorLayer_);

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");




var _ol_reproj_ = {};
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */

_ol_reproj_.calculateSourceResolution = function (sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = _proj_js__WEBPACK_IMPORTED_MODULE_3__["default"].transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data


  var sourceResolution = _proj_js__WEBPACK_IMPORTED_MODULE_3__["default"].getPointResolution(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = _proj_js__WEBPACK_IMPORTED_MODULE_3__["default"].getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
};
/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {ol.Coordinate} New point 1 px farther from the centroid.
 * @private
 */


_ol_reproj_.enlargeClipPoint_ = function (centroidX, centroidY, x, y) {
  var dX = x - centroidX,
      dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
};
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {ol.Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.
 * @param {Array.<{extent: ol.Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 *             Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */


_ol_reproj_.render = function (width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {
  var context = _dom_js__WEBPACK_IMPORTED_MODULE_0__["default"].createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].createEmpty();

  sources.forEach(function (src, i, arr) {
    _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(sourceDataExtent);

  var canvasHeightInUnits = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getHeight(sourceDataExtent);

  var stitchContext = _dom_js__WEBPACK_IMPORTED_MODULE_0__["default"].createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);

    var srcWidth = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(src.extent);

    var srcHeight = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getHeight(src.extent);

    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTopLeft(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source,
        target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1],
        x1 = source[1][0],
        y1 = source[1][1],
        x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
        v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
        v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
        v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0,
        sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];

    var affineCoefs = _math_js__WEBPACK_IMPORTED_MODULE_2__["default"].solveLinearSystem(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3,
        centroidY = (v0 + v1 + v2) / 3;

    var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);

    var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);

    var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_reproj_);

/***/ }),

/***/ "./node_modules/ol/reproj/image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/reproj/image.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagebase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagebase.js */ "./node_modules/ol/imagebase.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _reproj_triangulation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj/triangulation.js */ "./node_modules/ol/reproj/triangulation.js");








/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link ol.source.Image}.
 *
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.proj.Projection} sourceProj Source projection (of the data).
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {number} targetResolution Target resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.ReprojImageFunctionType} getImageFunction
 *     Function returning source images (extent, resolution, pixelRatio).
 */

var _ol_reproj_Image_ = function (sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
  /**
   * @private
   * @type {ol.proj.Projection}
   */
  this.targetProj_ = targetProj;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.maxSourceExtent_ = sourceProj.getExtent();
  var maxTargetExtent = targetProj.getExtent();
  var limitedTargetExtent = maxTargetExtent ? _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(targetExtent, maxTargetExtent) : targetExtent;

  var targetCenter = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getCenter(limitedTargetExtent);

  var sourceResolution = _reproj_js__WEBPACK_IMPORTED_MODULE_6__["default"].calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  var errorThresholdInPixels = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
  /**
   * @private
   * @type {!ol.reproj.Triangulation}
   */

  this.triangulation_ = new _reproj_triangulation_js__WEBPACK_IMPORTED_MODULE_7__["default"](sourceProj, targetProj, limitedTargetExtent, this.maxSourceExtent_, sourceResolution * errorThresholdInPixels);
  /**
   * @private
   * @type {number}
   */

  this.targetResolution_ = targetResolution;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.targetExtent_ = targetExtent;
  var sourceExtent = this.triangulation_.calculateSourceExtent();
  /**
   * @private
   * @type {ol.ImageBase}
   */

  this.sourceImage_ = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
  /**
   * @private
   * @type {number}
   */

  this.sourcePixelRatio_ = this.sourceImage_ ? this.sourceImage_.getPixelRatio() : 1;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.sourceListenerKey_ = null;
  var state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;

  if (this.sourceImage_) {
    state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;
  }

  _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, targetExtent, targetResolution, this.sourcePixelRatio_, state);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_reproj_Image_, _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.disposeInternal = function () {
  if (this.state == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
    this.unlistenSource_();
  }

  _imagebase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.getImage = function () {
  return this.canvas_;
};
/**
 * @return {ol.proj.Projection} Projection.
 */


_ol_reproj_Image_.prototype.getProjection = function () {
  return this.targetProj_;
};
/**
 * @private
 */


_ol_reproj_Image_.prototype.reproject_ = function () {
  var sourceState = this.sourceImage_.getState();

  if (sourceState == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
    var width = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(this.targetExtent_) / this.targetResolution_;
    var height = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(this.targetExtent_) / this.targetResolution_;
    this.canvas_ = _reproj_js__WEBPACK_IMPORTED_MODULE_6__["default"].render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
      extent: this.sourceImage_.getExtent(),
      image: this.sourceImage_.getImage()
    }], 0);
  }

  this.state = sourceState;
  this.changed();
};
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.load = function () {
  if (this.state == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.state = _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();
    var sourceState = this.sourceImage_.getState();

    if (sourceState == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      this.reproject_();
    } else {
      this.sourceListenerKey_ = _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(this.sourceImage_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, function (e) {
        var sourceState = this.sourceImage_.getState();

        if (sourceState == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
          this.unlistenSource_();
          this.reproject_();
        }
      }, this);
      this.sourceImage_.load();
    }
  }
};
/**
 * @private
 */


_ol_reproj_Image_.prototype.unlistenSource_ = function () {
  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].unlistenByKey(
  /** @type {!ol.EventsKey} */
  this.sourceListenerKey_);

  this.sourceListenerKey_ = null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_reproj_Image_);

/***/ }),

/***/ "./node_modules/ol/reproj/tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _reproj_triangulation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/triangulation.js */ "./node_modules/ol/reproj/triangulation.js");









/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link ol.source.TileImage}.
 *
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.
 * @param {ol.TileCoord} tileCoord Coordinate of the tile.
 * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {ol.ReprojTileFunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */

var _ol_reproj_Tile_ = function (sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);
  /**
   * @private
   * @type {boolean}
   */


  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   * @type {number}
   */

  this.gutter_ = gutter;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */

  this.sourceTileGrid_ = sourceTileGrid;
  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */

  this.targetTileGrid_ = targetTileGrid;
  /**
   * @private
   * @type {ol.TileCoord}
   */

  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
  /**
   * @private
   * @type {!Array.<ol.Tile>}
   */

  this.sourceTiles_ = [];
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.sourcesListenerKeys_ = null;
  /**
   * @private
   * @type {number}
   */

  this.sourceZ_ = 0;
  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();
  var limitedTargetExtent = maxTargetExtent ? _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(targetExtent, maxTargetExtent) : targetExtent;

  if (_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getArea(limitedTargetExtent) === 0) {
    // Tile is completely outside range -> EMPTY
    // TODO: is it actually correct that the source even creates the tile ?
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    return;
  }

  var sourceProjExtent = sourceProj.getExtent();

  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(maxSourceExtent, sourceProjExtent);
    }
  }

  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);

  var targetCenter = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getCenter(limitedTargetExtent);

  var sourceResolution = _reproj_js__WEBPACK_IMPORTED_MODULE_7__["default"].calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    // invalid sourceResolution -> EMPTY
    // probably edges of the projections when no extent is defined
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    return;
  }

  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
  /**
   * @private
   * @type {!ol.reproj.Triangulation}
   */

  this.triangulation_ = new _reproj_triangulation_js__WEBPACK_IMPORTED_MODULE_8__["default"](sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);

  if (this.triangulation_.getTriangles().length === 0) {
    // no valid triangles -> EMPTY
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    return;
  }

  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();

  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = _math_js__WEBPACK_IMPORTED_MODULE_6__["default"].clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = _math_js__WEBPACK_IMPORTED_MODULE_6__["default"].clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(sourceExtent, maxSourceExtent);
    }
  }

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getArea(sourceExtent)) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);

    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);

        if (tile) {
          this.sourceTiles_.push(tile);
        }
      }
    }

    if (this.sourceTiles_.length === 0) {
      this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    }
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_reproj_Tile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_reproj_Tile_.prototype.disposeInternal = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
    this.unlistenSources_();
  }

  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.disposeInternal.call(this);
};
/**
 * Get the HTML Canvas element for this tile.
 * @return {HTMLCanvasElement} Canvas.
 */


_ol_reproj_Tile_.prototype.getImage = function () {
  return this.canvas_;
};
/**
 * @private
 */


_ol_reproj_Tile_.prototype.reproject_ = function () {
  var sources = [];
  this.sourceTiles_.forEach(function (tile, i, arr) {
    if (tile && tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      sources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
        image: tile.getImage()
      });
    }
  }, this);
  this.sourceTiles_.length = 0;

  if (sources.length === 0) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === 'number' ? size : size[0];
    var height = typeof size === 'number' ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = _reproj_js__WEBPACK_IMPORTED_MODULE_7__["default"].render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  this.changed();
};
/**
 * @inheritDoc
 */


_ol_reproj_Tile_.prototype.load = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();
    var leftToLoad = 0;
    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();

      if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
        leftToLoad++;
        var sourceListenKey;
        sourceListenKey = _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(tile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, function (e) {
          var state = tile.getState();

          if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR || state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
            _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].unlistenByKey(sourceListenKey);

            leftToLoad--;

            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }, this);
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();

      if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
        tile.load();
      }
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};
/**
 * @private
 */


_ol_reproj_Tile_.prototype.unlistenSources_ = function () {
  this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["default"].unlistenByKey);
  this.sourcesListenerKeys_ = null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_reproj_Tile_);

/***/ }),

/***/ "./node_modules/ol/reproj/triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/triangulation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");




/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent to triangulate.
 * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */

var _ol_reproj_Triangulation_ = function (sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {
  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;
  /**
   * @type {ol.proj.Projection}
   * @private
   */

  this.targetProj_ = targetProj;
  /** @type {!Object.<string, ol.Coordinate>} */

  var transformInvCache = {};

  var transformInv = _proj_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTransform(this.targetProj_, this.sourceProj_);
  /**
   * @param {ol.Coordinate} c A coordinate.
   * @return {ol.Coordinate} Transformed coordinate.
   * @private
   */


  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];

    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }

    return transformInvCache[key];
  };
  /**
   * @type {ol.Extent}
   * @private
   */


  this.maxSourceExtent_ = maxSourceExtent;
  /**
   * @type {number}
   * @private
   */

  this.errorThresholdSquared_ = errorThreshold * errorThreshold;
  /**
   * @type {Array.<ol.ReprojTriangle>}
   * @private
   */

  this.triangles_ = [];
  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */

  this.wrapsXInSource_ = false;
  /**
   * @type {boolean}
   * @private
   */

  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(maxSourceExtent) == _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(this.sourceProj_.getExtent());
  /**
   * @type {?number}
   * @private
   */

  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(this.sourceProj_.getExtent()) : null;
  /**
   * @type {?number}
   * @private
   */

  this.targetWorldWidth_ = this.targetProj_.getExtent() ? _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTopLeft(targetExtent);

  var destinationTopRight = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTopRight(targetExtent);

  var destinationBottomRight = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getBottomRight(targetExtent);

  var destinationBottomLeft = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getBottomLeft(targetExtent);

  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].RASTER_REPROJECTION_MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    }); // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.

    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }

        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }

        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        } // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.


        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }, this);
  }

  transformInvCache = {};
};
/**
 * Adds triangle to the triangulation.
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @private
 */


_ol_reproj_Triangulation_.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};
/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} d The target d coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @param {ol.Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */


_ol_reproj_Triangulation_.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
  var sourceQuadExtent = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].boundingExtent([aSrc, bSrc, cSrc, dSrc]);

  var sourceCoverageX = this.sourceWorldWidth_ ? _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth =
  /** @type {number} */
  this.sourceWorldWidth_; // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully

  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].boundingExtent([a, b, c, d]);

      var targetCoverageX = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].getWidth(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }

    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!_extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].intersects(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);
      var dx;

      if (wrapsX) {
        var centerSrcEstimX = (_math_js__WEBPACK_IMPORTED_MODULE_2__["default"].modulo(aSrc[0], sourceWorldWidth) + _math_js__WEBPACK_IMPORTED_MODULE_2__["default"].modulo(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - _math_js__WEBPACK_IMPORTED_MODULE_2__["default"].modulo(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }

      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }

    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);
        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);
        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }

      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }

    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};
/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {ol.Extent} Calculated extent.
 */


_ol_reproj_Triangulation_.prototype.calculateSourceExtent = function () {
  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].createEmpty();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;

    _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].extendCoordinate(extent, src[0]);

    _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].extendCoordinate(extent, src[1]);

    _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].extendCoordinate(extent, src[2]);
  });
  return extent;
};
/**
 * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.
 */


_ol_reproj_Triangulation_.prototype.getTriangles = function () {
  return this.triangles_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_reproj_Triangulation_);

/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");


var _ol_ResolutionConstraint_ = {};
/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */

_ol_ResolutionConstraint_.createSnapToResolutions = function (resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = _array_js__WEBPACK_IMPORTED_MODULE_0__["default"].linearFindNearest(resolutions, resolution, direction);

        z = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);

        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */


_ol_ResolutionConstraint_.createSnapToPower = function (power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);

        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }

        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    }
  );
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_ResolutionConstraint_);

/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _ol_RotationConstraint_ = {};
/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */

_ol_RotationConstraint_.disable = function (rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
};
/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */


_ol_RotationConstraint_.none = function (rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
};
/**
 * @param {number} n N.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_RotationConstraint_.createSnapToN = function (n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_RotationConstraint_.createSnapToZero = function (opt_tolerance) {
  var tolerance = opt_tolerance || _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(5);

  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    }
  );
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_RotationConstraint_);

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_size_ = {};
/**
 * Returns a buffered size.
 * @param {ol.Size} size Size.
 * @param {number} buffer Buffer.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The buffered size.
 */

_ol_size_.buffer = function (size, buffer, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] + 2 * buffer;
  opt_size[1] = size[1] + 2 * buffer;
  return opt_size;
};
/**
 * Determines if a size has a positive area.
 * @param {ol.Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */


_ol_size_.hasArea = function (size) {
  return size[0] > 0 && size[1] > 0;
};
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {ol.Size} size Size.
 * @param {number} ratio Ratio.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The scaled size.
 */


_ol_size_.scale = function (size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
};
/**
 * Returns an `ol.Size` array for the passed in number (meaning: square) or
 * `ol.Size` array.
 * (meaning: non-square),
 * @param {number|ol.Size} size Width and height.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} Size.
 * @api
 */


_ol_size_.toSize = function (size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] =
      /** @type {number} */
      size;
    }

    return opt_size;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_size_);

/***/ }),

/***/ "./node_modules/ol/source/bingmaps.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/bingmaps.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");









/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.BingMapsOptions} options Bing Maps options.
 * @api
 */

var _ol_source_BingMaps_ = function (options) {
  /**
   * @private
   * @type {boolean}
   */
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : false;

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    cacheSize: options.cacheSize,
    crossOrigin: 'anonymous',
    opaque: true,
    projection: _proj_js__WEBPACK_IMPORTED_MODULE_4__["default"].get('EPSG:3857'),
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    state: _source_state_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADING,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: this.hidpi_ ? 2 : 1,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
  /**
   * @private
   * @type {string}
   */


  this.culture_ = options.culture !== undefined ? options.culture : 'en-us';
  /**
   * @private
   * @type {number}
   */

  this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;
  /**
   * @private
   * @type {string}
   */

  this.apiKey_ = options.key;
  /**
   * @private
   * @type {string}
   */

  this.imagerySet_ = options.imagerySet;
  var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' + this.imagerySet_ + '?uriScheme=https&include=ImageryProviders&key=' + this.apiKey_ + '&c=' + this.culture_;

  _net_js__WEBPACK_IMPORTED_MODULE_3__["default"].jsonp(url, this.handleImageryMetadataResponse.bind(this), undefined, 'jsonp');
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_BingMaps_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’
 * Terms Of Use.
 * @const
 * @type {string}
 * @api
 */


_ol_source_BingMaps_.TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" ' + 'href="https://www.microsoft.com/maps/product/terms.html">' + 'Terms of Use</a>';
/**
 * Get the api key used for this source.
 *
 * @return {string} The api key.
 * @api
 */

_ol_source_BingMaps_.prototype.getApiKey = function () {
  return this.apiKey_;
};
/**
 * Get the imagery set associated with this source.
 *
 * @return {string} The imagery set.
 * @api
 */


_ol_source_BingMaps_.prototype.getImagerySet = function () {
  return this.imagerySet_;
};
/**
 * @param {BingMapsImageryMetadataResponse} response Response.
 */


_ol_source_BingMaps_.prototype.handleImageryMetadataResponse = function (response) {
  if (response.statusCode != 200 || response.statusDescription != 'OK' || response.authenticationResultCode != 'ValidCredentials' || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
    this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERROR);
    return;
  }

  var brandLogoUri = response.brandLogoUri;

  if (brandLogoUri.indexOf('https') == -1) {
    brandLogoUri = brandLogoUri.replace('http', 'https');
  } //var copyright = response.copyright;  // FIXME do we need to display this?


  var resource = response.resourceSets[0].resources[0];
  var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
  var sourceProjection = this.getProjection();

  var extent = _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].extentFromProjection(sourceProjection);

  var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth : [resource.imageWidth, resource.imageHeight];

  var tileGrid = _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].createXYZ({
    extent: extent,
    minZoom: resource.zoomMin,
    maxZoom: maxZoom,
    tileSize: tileSize / (this.hidpi_ ? 2 : 1)
  });

  this.tileGrid = tileGrid;
  var culture = this.culture_;
  var hidpi = this.hidpi_;
  this.tileUrlFunction = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function (subdomain) {
    var quadKeyTileCoord = [0, 0, 0];
    var imageUrl = resource.imageUrl.replace('{subdomain}', subdomain).replace('{culture}', culture);
    return (
      /**
       * @param {ol.TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {ol.proj.Projection} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].createOrUpdate(tileCoord[0], tileCoord[1], -tileCoord[2] - 1, quadKeyTileCoord);

          var url = imageUrl;

          if (hidpi) {
            url += '&dpi=d1&device=mobile';
          }

          return url.replace('{quadkey}', _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].quadKey(quadKeyTileCoord));
        }
      }
    );
  }));

  if (resource.imageryProviders) {
    var transform = _proj_js__WEBPACK_IMPORTED_MODULE_4__["default"].getTransformFromProjections(_proj_js__WEBPACK_IMPORTED_MODULE_4__["default"].get('EPSG:4326'), this.getProjection());

    this.setAttributions(function (frameState) {
      var attributions = [];
      var zoom = frameState.viewState.zoom;
      resource.imageryProviders.map(function (imageryProvider) {
        var intersects = false;
        var coverageAreas = imageryProvider.coverageAreas;

        for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
          var coverageArea = coverageAreas[i];

          if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
            var bbox = coverageArea.bbox;
            var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];

            var extent = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].applyTransform(epsg4326Extent, transform);

            if (_extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].intersects(extent, frameState.extent)) {
              intersects = true;
              break;
            }
          }
        }

        if (intersects) {
          attributions.push(imageryProvider.attribution);
        }
      });
      attributions.push(_ol_source_BingMaps_.TOS_ATTRIBUTION);
      return attributions;
    });
  }

  this.setLogo(brandLogoUri);
  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_5__["default"].READY);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_BingMaps_);

/***/ }),

/***/ "./node_modules/ol/source/cartodb.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/cartodb.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_xyz_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/xyz.js */ "./node_modules/ol/source/xyz.js");




/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 *
 * @constructor
 * @extends {ol.source.XYZ}
 * @param {olx.source.CartoDBOptions} options CartoDB options.
 * @api
 */

var _ol_source_CartoDB_ = function (options) {
  /**
   * @type {string}
   * @private
   */
  this.account_ = options.account;
  /**
   * @type {string}
   * @private
   */

  this.mapId_ = options.map || '';
  /**
   * @type {!Object}
   * @private
   */

  this.config_ = options.config || {};
  /**
   * @type {!Object.<string, CartoDBLayerInfo>}
   * @private
   */

  this.templateCache_ = {};

  _source_xyz_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,
    minZoom: options.minZoom,
    projection: options.projection,
    state: _source_state_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING,
    wrapX: options.wrapX
  });

  this.initializeMap_();
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_CartoDB_, _source_xyz_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * Returns the current config.
 * @return {!Object} The current configuration.
 * @api
 */


_ol_source_CartoDB_.prototype.getConfig = function () {
  return this.config_;
};
/**
 * Updates the carto db config.
 * @param {Object} config a key-value lookup. Values will replace current values
 *     in the config.
 * @api
 */


_ol_source_CartoDB_.prototype.updateConfig = function (config) {
  _obj_js__WEBPACK_IMPORTED_MODULE_1__["default"].assign(this.config_, config);

  this.initializeMap_();
};
/**
 * Sets the CartoDB config
 * @param {Object} config In the case of anonymous maps, a CartoDB configuration
 *     object.
 * If using named maps, a key-value lookup with the template parameters.
 * @api
 */


_ol_source_CartoDB_.prototype.setConfig = function (config) {
  this.config_ = config || {};
  this.initializeMap_();
};
/**
 * Issue a request to initialize the CartoDB map.
 * @private
 */


_ol_source_CartoDB_.prototype.initializeMap_ = function () {
  var paramHash = JSON.stringify(this.config_);

  if (this.templateCache_[paramHash]) {
    this.applyTemplate_(this.templateCache_[paramHash]);
    return;
  }

  var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';

  if (this.mapId_) {
    mapUrl += '/named/' + this.mapId_;
  }

  var client = new XMLHttpRequest();
  client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));
  client.addEventListener('error', this.handleInitError_.bind(this));
  client.open('POST', mapUrl);
  client.setRequestHeader('Content-type', 'application/json');
  client.send(JSON.stringify(this.config_));
};
/**
 * Handle map initialization response.
 * @param {string} paramHash a hash representing the parameter set that was used
 *     for the request
 * @param {Event} event Event.
 * @private
 */


_ol_source_CartoDB_.prototype.handleInitResponse_ = function (paramHash, event) {
  var client =
  /** @type {XMLHttpRequest} */
  event.target; // status will be 0 for file:// urls

  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;

    try {
      response =
      /** @type {CartoDBLayerInfo} */
      JSON.parse(client.responseText);
    } catch (err) {
      this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
      return;
    }

    this.applyTemplate_(response);
    this.templateCache_[paramHash] = response;
    this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_2__["default"].READY);
  } else {
    this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
  }
};
/**
 * @private
 * @param {Event} event Event.
 */


_ol_source_CartoDB_.prototype.handleInitError_ = function (event) {
  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
};
/**
 * Apply the new tile urls returned by carto db
 * @param {CartoDBLayerInfo} data Result of carto db call.
 * @private
 */


_ol_source_CartoDB_.prototype.applyTemplate_ = function (data) {
  var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ + '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';
  this.setUrl(tilesUrl);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_CartoDB_);

/***/ }),

/***/ "./node_modules/ol/source/cluster.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/cluster.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../feature.js */ "./node_modules/ol/feature.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/point.js */ "./node_modules/ol/geom/point.js");
/* harmony import */ var _source_vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/vector.js */ "./node_modules/ol/source/vector.js");
// FIXME keep cluster cache by resolution ?
// FIXME distance not respected because of the centroid








/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * @constructor
 * @param {olx.source.ClusterOptions} options Constructor options.
 * @extends {ol.source.Vector}
 * @api
 */

var _ol_source_Cluster_ = function (options) {
  _source_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    wrapX: options.wrapX
  });
  /**
   * @type {number|undefined}
   * @protected
   */


  this.resolution = undefined;
  /**
   * @type {number}
   * @protected
   */

  this.distance = options.distance !== undefined ? options.distance : 20;
  /**
   * @type {Array.<ol.Feature>}
   * @protected
   */

  this.features = [];
  /**
   * @param {ol.Feature} feature Feature.
   * @return {ol.geom.Point} Cluster calculation point.
   * @protected
   */

  this.geometryFunction = options.geometryFunction || function (feature) {
    var geometry =
    /** @type {ol.geom.Point} */
    feature.getGeometry();

    _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(geometry instanceof _geom_point_js__WEBPACK_IMPORTED_MODULE_6__["default"], 10); // The default `geometryFunction` can only handle `ol.geom.Point` geometries


    return geometry;
  };
  /**
   * @type {ol.source.Vector}
   * @protected
   */


  this.source = options.source;
  this.source.on(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, _ol_source_Cluster_.prototype.refresh, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Cluster_, _source_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Get the distance in pixels between clusters.
 * @return {number} Distance.
 * @api
 */


_ol_source_Cluster_.prototype.getDistance = function () {
  return this.distance;
};
/**
 * Get a reference to the wrapped source.
 * @return {ol.source.Vector} Source.
 * @api
 */


_ol_source_Cluster_.prototype.getSource = function () {
  return this.source;
};
/**
 * @inheritDoc
 */


_ol_source_Cluster_.prototype.loadFeatures = function (extent, resolution, projection) {
  this.source.loadFeatures(extent, resolution, projection);

  if (resolution !== this.resolution) {
    this.clear();
    this.resolution = resolution;
    this.cluster();
    this.addFeatures(this.features);
  }
};
/**
 * Set the distance in pixels between clusters.
 * @param {number} distance The distance in pixels.
 * @api
 */


_ol_source_Cluster_.prototype.setDistance = function (distance) {
  this.distance = distance;
  this.refresh();
};
/**
 * handle the source changing
 * @override
 */


_ol_source_Cluster_.prototype.refresh = function () {
  this.clear();
  this.cluster();
  this.addFeatures(this.features);

  _source_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"].prototype.refresh.call(this);
};
/**
 * @protected
 */


_ol_source_Cluster_.prototype.cluster = function () {
  if (this.resolution === undefined) {
    return;
  }

  this.features.length = 0;

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].createEmpty();

  var mapDistance = this.distance * this.resolution;
  var features = this.source.getFeatures();
  /**
   * @type {!Object.<string, boolean>}
   */

  var clustered = {};

  for (var i = 0, ii = features.length; i < ii; i++) {
    var feature = features[i];

    if (!(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString() in clustered)) {
      var geometry = this.geometryFunction(feature);

      if (geometry) {
        var coordinates = geometry.getCoordinates();

        _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].createOrUpdateFromCoordinate(coordinates, extent);

        _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].buffer(extent, mapDistance, extent);

        var neighbors = this.source.getFeaturesInExtent(extent);
        neighbors = neighbors.filter(function (neighbor) {
          var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(neighbor).toString();

          if (!(uid in clustered)) {
            clustered[uid] = true;
            return true;
          } else {
            return false;
          }
        });
        this.features.push(this.createCluster(neighbors));
      }
    }
  }
};
/**
 * @param {Array.<ol.Feature>} features Features
 * @return {ol.Feature} The cluster feature.
 * @protected
 */


_ol_source_Cluster_.prototype.createCluster = function (features) {
  var centroid = [0, 0];

  for (var i = features.length - 1; i >= 0; --i) {
    var geometry = this.geometryFunction(features[i]);

    if (geometry) {
      _coordinate_js__WEBPACK_IMPORTED_MODULE_3__["default"].add(centroid, geometry.getCoordinates());
    } else {
      features.splice(i, 1);
    }
  }

  _coordinate_js__WEBPACK_IMPORTED_MODULE_3__["default"].scale(centroid, 1 / features.length);

  var cluster = new _feature_js__WEBPACK_IMPORTED_MODULE_2__["default"](new _geom_point_js__WEBPACK_IMPORTED_MODULE_6__["default"](centroid));
  cluster.set('features', features);
  return cluster;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Cluster_);

/***/ }),

/***/ "./node_modules/ol/source/image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/image.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj/image.js */ "./node_modules/ol/reproj/image.js");
/* harmony import */ var _source_source_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/source.js */ "./node_modules/ol/source/source.js");








/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceImageOptions} options Single image source options.
 * @api
 */

var _ol_source_Image_ = function (options) {
  _source_source_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    state: options.state
  });
  /**
   * @private
   * @type {Array.<number>}
   */


  this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
  /**
   * @private
   * @type {ol.reproj.Image}
   */

  this.reprojectedImage_ = null;
  /**
   * @private
   * @type {number}
   */

  this.reprojectedRevision_ = 0;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Image_, _source_source_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * @return {Array.<number>} Resolutions.
 * @override
 */


_ol_source_Image_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * @protected
 * @param {number} resolution Resolution.
 * @return {number} Resolution.
 */


_ol_source_Image_.prototype.findNearestResolution = function (resolution) {
  if (this.resolutions_) {
    var idx = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].linearFindNearest(this.resolutions_, resolution, 0);

    resolution = this.resolutions_[idx];
  }

  return resolution;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.ImageBase} Single image.
 */


_ol_source_Image_.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
  var sourceProjection = this.getProjection();

  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].equivalent(sourceProjection, projection)) {
    if (sourceProjection) {
      projection = sourceProjection;
    }

    return this.getImageInternal(extent, resolution, pixelRatio, projection);
  } else {
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].equals(this.reprojectedImage_.getExtent(), extent)) {
        return this.reprojectedImage_;
      }

      this.reprojectedImage_.dispose();
      this.reprojectedImage_ = null;
    }

    this.reprojectedImage_ = new _reproj_image_js__WEBPACK_IMPORTED_MODULE_6__["default"](sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
      return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
    }.bind(this));
    this.reprojectedRevision_ = this.getRevision();
    return this.reprojectedImage_;
  }
};
/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.ImageBase} Single image.
 * @protected
 */


_ol_source_Image_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {};
/**
 * Handle image change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_source_Image_.prototype.handleImageChange = function (event) {
  var image =
  /** @type {ol.Image} */
  event.target;

  switch (image.getState()) {
    case _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADSTART, image));
      break;

    case _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADEND, image));
      break;

    case _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADERROR, image));
      break;

    default: // pass

  }
};
/**
 * Default image load function for image sources that use ol.Image image
 * instances.
 * @param {ol.Image} image Image.
 * @param {string} src Source.
 */


_ol_source_Image_.defaultImageLoadFunction = function (image, src) {
  image.getImage().src = src;
};
/**
 * @classdesc
 * Events emitted by {@link ol.source.Image} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.ImageEvent}
 * @param {string} type Type.
 * @param {ol.Image} image The image.
 */


_ol_source_Image_.Event = function (type, image) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, type);
  /**
   * The image related to the event.
   * @type {ol.Image}
   * @api
   */


  this.image = image;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Image_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @enum {string}
 * @private
 */


_ol_source_Image_.EventType_ = {
  /**
   * Triggered when an image starts loading.
   * @event ol.source.Image.Event#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event ol.source.Image.Event#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event ol.source.Image.Event#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Image_);

/***/ }),

/***/ "./node_modules/ol/source/imagearcgisrest.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/imagearcgisrest.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image.js */ "./node_modules/ol/image.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");









/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link ol.source.TileArcGISRest} data source.
 *
 * @constructor
 * @fires ol.source.Image.Event
 * @extends {ol.source.Image}
 * @param {olx.source.ImageArcGISRestOptions=} opt_options Image ArcGIS Rest Options.
 * @api
 */

var _ol_source_ImageArcGISRest_ = function (opt_options) {
  var options = opt_options || {};

  _source_image_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: options.projection,
    resolutions: options.resolutions
  });
  /**
   * @private
   * @type {?string}
   */


  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @private
   * @type {boolean}
   */

  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  /**
   * @private
   * @type {string|undefined}
   */

  this.url_ = options.url;
  /**
   * @private
   * @type {ol.ImageLoadFunctionType}
   */

  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _source_image_js__WEBPACK_IMPORTED_MODULE_7__["default"].defaultImageLoadFunction;
  /**
   * @private
   * @type {!Object}
   */

  this.params_ = options.params || {};
  /**
   * @private
   * @type {ol.Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = [0, 0];
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageArcGISRest_, _source_image_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * @return {Object} Params.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.getParams = function () {
  return this.params_;
};
/**
 * @inheritDoc
 */


_ol_source_ImageArcGISRest_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  if (this.url_ === undefined) {
    return null;
  }

  resolution = this.findNearestResolution(resolution);
  pixelRatio = this.hidpi_ ? pixelRatio : 1;
  var image = this.image_;

  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].containsExtent(image.getExtent(), extent)) {
    return image;
  }

  var params = {
    'F': 'image',
    'FORMAT': 'PNG32',
    'TRANSPARENT': true
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign(params, this.params_);

  extent = extent.slice();
  var centerX = (extent[0] + extent[2]) / 2;
  var centerY = (extent[1] + extent[3]) / 2;

  if (this.ratio_ != 1) {
    var halfWidth = this.ratio_ * _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(extent) / 2;
    var halfHeight = this.ratio_ * _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(extent) / 2;
    extent[0] = centerX - halfWidth;
    extent[1] = centerY - halfHeight;
    extent[2] = centerX + halfWidth;
    extent[3] = centerY + halfHeight;
  }

  var imageResolution = resolution / pixelRatio; // Compute an integer width and height.

  var width = Math.ceil(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(extent) / imageResolution);
  var height = Math.ceil(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(extent) / imageResolution); // Modify the extent to match the integer width and height.

  extent[0] = centerX - imageResolution * width / 2;
  extent[2] = centerX + imageResolution * width / 2;
  extent[1] = centerY - imageResolution * height / 2;
  extent[3] = centerY + imageResolution * height / 2;
  this.imageSize_[0] = width;
  this.imageSize_[1] = height;
  var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio, projection, params);
  this.image_ = new _image_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
  this.renderedRevision_ = this.getRevision();

  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, this.handleImageChange, this);

  return this.image_;
};
/**
 * Return the image load function of the source.
 * @return {ol.ImageLoadFunctionType} The image load function.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.getImageLoadFunction = function () {
  return this.imageLoadFunction_;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object} params Params.
 * @return {string} Request URL.
 * @private
 */


_ol_source_ImageArcGISRest_.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
  // ArcGIS Server only wants the numeric portion of the projection ID.
  var srid = projection.getCode().split(':').pop();
  params['SIZE'] = size[0] + ',' + size[1];
  params['BBOX'] = extent.join(',');
  params['BBOXSR'] = srid;
  params['IMAGESR'] = srid;
  params['DPI'] = Math.round(90 * pixelRatio);
  var url = this.url_;
  var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');

  if (modifiedUrl == url) {
    _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(false, 50); // `options.featureTypes` should be an Array

  }

  return _uri_js__WEBPACK_IMPORTED_MODULE_8__["default"].appendParams(modifiedUrl, params);
};
/**
 * Return the URL used for this ArcGIS source.
 * @return {string|undefined} URL.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.getUrl = function () {
  return this.url_;
};
/**
 * Set the image load function of the source.
 * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.setImageLoadFunction = function (imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};
/**
 * Set the URL to use for requests.
 * @param {string|undefined} url URL.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.setUrl = function (url) {
  if (url != this.url_) {
    this.url_ = url;
    this.image_ = null;
    this.changed();
  }
};
/**
 * Update the user-provided params.
 * @param {Object} params Params.
 * @api
 */


_ol_source_ImageArcGISRest_.prototype.updateParams = function (params) {
  _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign(this.params_, params);

  this.image_ = null;
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageArcGISRest_);

/***/ }),

/***/ "./node_modules/ol/source/imagecanvas.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/imagecanvas.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagecanvas.js */ "./node_modules/ol/imagecanvas.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");




/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 *
 * @constructor
 * @extends {ol.source.Image}
 * @param {olx.source.ImageCanvasOptions} options Constructor options.
 * @api
 */

var _ol_source_ImageCanvas_ = function (options) {
  _source_image_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: options.projection,
    resolutions: options.resolutions,
    state: options.state
  });
  /**
   * @private
   * @type {ol.CanvasFunctionType}
   */


  this.canvasFunction_ = options.canvasFunction;
  /**
   * @private
   * @type {ol.ImageCanvas}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageCanvas_, _source_image_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @inheritDoc
 */


_ol_source_ImageCanvas_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  resolution = this.findNearestResolution(resolution);
  var canvas = this.canvas_;

  if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].containsExtent(canvas.getExtent(), extent)) {
    return canvas;
  }

  extent = extent.slice();

  _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].scaleFromCenter(extent, this.ratio_);

  var width = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getWidth(extent) / resolution;
  var height = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHeight(extent) / resolution;
  var size = [width * pixelRatio, height * pixelRatio];
  var canvasElement = this.canvasFunction_(extent, resolution, pixelRatio, size, projection);

  if (canvasElement) {
    canvas = new _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, pixelRatio, canvasElement);
  }

  this.canvas_ = canvas;
  this.renderedRevision_ = this.getRevision();
  return canvas;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageCanvas_);

/***/ }),

/***/ "./node_modules/ol/source/imagemapguide.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/imagemapguide.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image.js */ "./node_modules/ol/image.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");








/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @constructor
 * @fires ol.source.Image.Event
 * @extends {ol.source.Image}
 * @param {olx.source.ImageMapGuideOptions} options Options.
 * @api
 */

var _ol_source_ImageMapGuide_ = function (options) {
  _source_image_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    projection: options.projection,
    resolutions: options.resolutions
  });
  /**
   * @private
   * @type {?string}
   */


  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @private
   * @type {number}
   */

  this.displayDpi_ = options.displayDpi !== undefined ? options.displayDpi : 96;
  /**
   * @private
   * @type {!Object}
   */

  this.params_ = options.params || {};
  /**
   * @private
   * @type {string|undefined}
   */

  this.url_ = options.url;
  /**
   * @private
   * @type {ol.ImageLoadFunctionType}
   */

  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _source_image_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultImageLoadFunction;
  /**
   * @private
   * @type {boolean}
   */

  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  /**
   * @private
   * @type {number}
   */

  this.metersPerUnit_ = options.metersPerUnit !== undefined ? options.metersPerUnit : 1;
  /**
   * @private
   * @type {number}
   */

  this.ratio_ = options.ratio !== undefined ? options.ratio : 1;
  /**
   * @private
   * @type {boolean}
   */

  this.useOverlay_ = options.useOverlay !== undefined ? options.useOverlay : false;
  /**
   * @private
   * @type {ol.Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = 0;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageMapGuide_, _source_image_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * @return {Object} Params.
 * @api
 */


_ol_source_ImageMapGuide_.prototype.getParams = function () {
  return this.params_;
};
/**
 * @inheritDoc
 */


_ol_source_ImageMapGuide_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  resolution = this.findNearestResolution(resolution);
  pixelRatio = this.hidpi_ ? pixelRatio : 1;
  var image = this.image_;

  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].containsExtent(image.getExtent(), extent)) {
    return image;
  }

  if (this.ratio_ != 1) {
    extent = extent.slice();

    _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].scaleFromCenter(extent, this.ratio_);
  }

  var width = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getWidth(extent) / resolution;
  var height = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getHeight(extent) / resolution;
  var size = [width * pixelRatio, height * pixelRatio];

  if (this.url_ !== undefined) {
    var imageUrl = this.getUrl(this.url_, this.params_, extent, size, projection);
    image = new _image_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, pixelRatio, imageUrl, this.crossOrigin_, this.imageLoadFunction_);

    _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listen(image, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleImageChange, this);
  } else {
    image = null;
  }

  this.image_ = image;
  this.renderedRevision_ = this.getRevision();
  return image;
};
/**
 * Return the image load function of the source.
 * @return {ol.ImageLoadFunctionType} The image load function.
 * @api
 */


_ol_source_ImageMapGuide_.prototype.getImageLoadFunction = function () {
  return this.imageLoadFunction_;
};
/**
 * @param {ol.Extent} extent The map extents.
 * @param {ol.Size} size The viewport size.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} dpi The display resolution.
 * @return {number} The computed map scale.
 */


_ol_source_ImageMapGuide_.getScale = function (extent, size, metersPerUnit, dpi) {
  var mcsW = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getWidth(extent);

  var mcsH = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getHeight(extent);

  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;

  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp); // width limited
  } else {
    return mcsH * metersPerUnit / (devH * mpp); // height limited
  }
};
/**
 * Update the user-provided params.
 * @param {Object} params Params.
 * @api
 */


_ol_source_ImageMapGuide_.prototype.updateParams = function (params) {
  _obj_js__WEBPACK_IMPORTED_MODULE_5__["default"].assign(this.params_, params);

  this.changed();
};
/**
 * @param {string} baseUrl The mapagent url.
 * @param {Object.<string, string|number>} params Request parameters.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size} size Size.
 * @param {ol.proj.Projection} projection Projection.
 * @return {string} The mapagent map image request URL.
 */


_ol_source_ImageMapGuide_.prototype.getUrl = function (baseUrl, params, extent, size, projection) {
  var scale = _ol_source_ImageMapGuide_.getScale(extent, size, this.metersPerUnit_, this.displayDpi_);

  var center = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getCenter(extent);

  var baseParams = {
    'OPERATION': this.useOverlay_ ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',
    'VERSION': '2.0.0',
    'LOCALE': 'en',
    'CLIENTAGENT': 'ol.source.ImageMapGuide source',
    'CLIP': '1',
    'SETDISPLAYDPI': this.displayDpi_,
    'SETDISPLAYWIDTH': Math.round(size[0]),
    'SETDISPLAYHEIGHT': Math.round(size[1]),
    'SETVIEWSCALE': scale,
    'SETVIEWCENTERX': center[0],
    'SETVIEWCENTERY': center[1]
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_5__["default"].assign(baseParams, params);

  return _uri_js__WEBPACK_IMPORTED_MODULE_7__["default"].appendParams(baseUrl, baseParams);
};
/**
 * Set the image load function of the MapGuide source.
 * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.
 * @api
 */


_ol_source_ImageMapGuide_.prototype.setImageLoadFunction = function (imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageMapGuide_);

/***/ }),

/***/ "./node_modules/ol/source/imagestatic.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/imagestatic.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image.js */ "./node_modules/ol/image.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");









/**
 * @classdesc
 * A layer source for displaying a single, static image.
 *
 * @constructor
 * @extends {ol.source.Image}
 * @param {olx.source.ImageStaticOptions} options Options.
 * @api
 */

var _ol_source_ImageStatic_ = function (options) {
  var imageExtent = options.imageExtent;
  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
  var
  /** @type {ol.ImageLoadFunctionType} */
  imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _source_image_js__WEBPACK_IMPORTED_MODULE_8__["default"].defaultImageLoadFunction;

  _source_image_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].get(options.projection)
  });
  /**
   * @private
   * @type {ol.Image}
   */


  this.image_ = new _image_js__WEBPACK_IMPORTED_MODULE_1__["default"](imageExtent, undefined, 1, options.url, crossOrigin, imageLoadFunction);
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = options.imageSize ? options.imageSize : null;

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleImageChange, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageStatic_, _source_image_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @inheritDoc
 */


_ol_source_ImageStatic_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  if (_extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].intersects(extent, this.image_.getExtent())) {
    return this.image_;
  }

  return null;
};
/**
 * @inheritDoc
 */


_ol_source_ImageStatic_.prototype.handleImageChange = function (evt) {
  if (this.image_.getState() == _imagestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
    var imageExtent = this.image_.getExtent();
    var image = this.image_.getImage();
    var imageWidth, imageHeight;

    if (this.imageSize_) {
      imageWidth = this.imageSize_[0];
      imageHeight = this.imageSize_[1];
    } else {
      imageWidth = image.width;
      imageHeight = image.height;
    }

    var resolution = _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].getHeight(imageExtent) / imageHeight;
    var targetWidth = Math.ceil(_extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].getWidth(imageExtent) / resolution);

    if (targetWidth != imageWidth) {
      var context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(targetWidth, imageHeight);

      var canvas = context.canvas;
      context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
      this.image_.setImage(canvas);
    }
  }

  _source_image_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.handleImageChange.call(this, evt);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageStatic_);

/***/ }),

/***/ "./node_modules/ol/source/imagevector.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/imagevector.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/canvas/replaygroup.js */ "./node_modules/ol/render/canvas/replaygroup.js");
/* harmony import */ var _renderer_vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../renderer/vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _source_imagecanvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/imagecanvas.js */ "./node_modules/ol/source/imagecanvas.js");
/* harmony import */ var _style_style_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/style.js */ "./node_modules/ol/style/style.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");











/**
 * @deprecated
 * @classdesc
 * **Deprecated**. Use an `ol.layer.Vector` with `renderMode: 'image'` and an
 * `ol.source.Vector` instead.
 *
 * An image source whose images are canvas elements into which vector features
 * read from a vector source (`ol.source.Vector`) are drawn. An
 * `ol.source.ImageVector` object is to be used as the `source` of an image
 * layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
 * as opposed to being re-rendered, during animations and interactions. So, like
 * any other image layer, an image layer configured with an
 * `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
 * vector layer, where vector features are re-drawn during animations and
 * interactions.
 *
 * @constructor
 * @extends {ol.source.ImageCanvas}
 * @param {olx.source.ImageVectorOptions} options Options.
 * @api
 */

var _ol_source_ImageVector_ = function (options) {
  /**
   * @private
   * @type {ol.source.Vector}
   */
  this.source_ = options.source;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = _transform_js__WEBPACK_IMPORTED_MODULE_10__["default"].create();
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.canvasContext_ = _dom_js__WEBPACK_IMPORTED_MODULE_1__["default"].createCanvasContext2D();
  /**
   * @private
   * @type {ol.Size}
   */

  this.canvasSize_ = [0, 0];
  /**
   * Declutter tree.
   * @private
   */

  this.declutterTree_ = rbush__WEBPACK_IMPORTED_MODULE_4___default()(9);
  /**
   * @private
   * @type {number}
   */

  this.renderBuffer_ = options.renderBuffer == undefined ? 100 : options.renderBuffer;
  /**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */

  this.replayGroup_ = null;

  _source_imagecanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, {
    attributions: options.attributions,
    canvasFunction: this.canvasFunctionInternal_.bind(this),
    logo: options.logo,
    projection: options.projection,
    ratio: options.ratio,
    resolutions: options.resolutions,
    state: this.source_.getState()
  });
  /**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */


  this.style_ = null;
  /**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */

  this.styleFunction_ = undefined;
  this.setStyle(options.style);

  _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listen(this.source_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleSourceChange_, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageVector_, _source_imagecanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Size} size Size.
 * @param {ol.proj.Projection} projection Projection;
 * @return {HTMLCanvasElement} Canvas element.
 * @private
 */


_ol_source_ImageVector_.prototype.canvasFunctionInternal_ = function (extent, resolution, pixelRatio, size, projection) {
  var replayGroup = new _render_canvas_replaygroup_js__WEBPACK_IMPORTED_MODULE_6__["default"](_renderer_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"].getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, this.source_.getOverlaps(), this.declutterTree_, this.renderBuffer_);
  this.source_.loadFeatures(extent, resolution, projection);
  var loading = false;
  this.source_.forEachFeatureInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   */
  function (feature) {
    loading = loading || this.renderFeature_(feature, resolution, pixelRatio, replayGroup);
  }, this);
  replayGroup.finish();

  if (loading) {
    return null;
  }

  if (this.canvasSize_[0] != size[0] || this.canvasSize_[1] != size[1]) {
    this.canvasContext_.canvas.width = size[0];
    this.canvasContext_.canvas.height = size[1];
    this.canvasSize_[0] = size[0];
    this.canvasSize_[1] = size[1];
  } else {
    this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  }

  this.declutterTree_.clear();
  var transform = this.getTransform_(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getCenter(extent), resolution, pixelRatio, size);
  replayGroup.replay(this.canvasContext_, transform, 0, {});
  this.replayGroup_ = replayGroup;
  return this.canvasContext_.canvas;
};
/**
 * @inheritDoc
 */


_ol_source_ImageVector_.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, skippedFeatureUids, callback) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    /** @type {Object.<string, boolean>} */
    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, 0, hitTolerance, skippedFeatureUids,
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

      if (!(key in features)) {
        features[key] = true;
        return callback(feature);
      }
    }, null);
    return result;
  }
};
/**
 * Get a reference to the wrapped source.
 * @return {ol.source.Vector} Source.
 * @api
 */


_ol_source_ImageVector_.prototype.getSource = function () {
  return this.source_;
};
/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */


_ol_source_ImageVector_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */


_ol_source_ImageVector_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};
/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Size} size Size.
 * @return {!ol.Transform} Transform.
 * @private
 */


_ol_source_ImageVector_.prototype.getTransform_ = function (center, resolution, pixelRatio, size) {
  var dx1 = size[0] / 2;
  var dy1 = size[1] / 2;
  var sx = pixelRatio / resolution;
  var sy = -sx;
  var dx2 = -center[0];
  var dy2 = -center[1];
  return _transform_js__WEBPACK_IMPORTED_MODULE_10__["default"].compose(this.transform_, dx1, dy1, sx, sy, 0, dx2, dy2);
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_source_ImageVector_.prototype.handleImageChange_ = function (event) {
  this.changed();
};
/**
 * @private
 */


_ol_source_ImageVector_.prototype.handleSourceChange_ = function () {
  // setState will trigger a CHANGE event, so we always rely
  // change events by calling setState.
  this.setState(this.source_.getState());
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 * @private
 */


_ol_source_ImageVector_.prototype.renderFeature_ = function (feature, resolution, pixelRatio, replayGroup) {
  var styles;
  var styleFunction = feature.getStyleFunction();

  if (styleFunction) {
    styles = styleFunction.call(feature, resolution);
  } else if (this.styleFunction_) {
    styles = this.styleFunction_(feature, resolution);
  }

  if (!styles) {
    return false;
  }

  var i,
      ii,
      loading = false;

  if (!Array.isArray(styles)) {
    styles = [styles];
  }

  for (i = 0, ii = styles.length; i < ii; ++i) {
    loading = _renderer_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"].renderFeature(replayGroup, feature, styles[i], _renderer_vector_js__WEBPACK_IMPORTED_MODULE_7__["default"].getSquaredTolerance(resolution, pixelRatio), this.handleImageChange_, this) || loading;
  }

  return loading;
};
/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined}
 *     style Layer style.
 * @api
 */


_ol_source_ImageVector_.prototype.setStyle = function (style) {
  this.style_ = style !== undefined ? style : _style_style_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultFunction;
  this.styleFunction_ = !style ? undefined : _style_style_js__WEBPACK_IMPORTED_MODULE_9__["default"].createFunction(this.style_);
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageVector_);

/***/ }),

/***/ "./node_modules/ol/source/imagewms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/imagewms.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image.js */ "./node_modules/ol/image.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");
/* harmony import */ var _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../source/wmsservertype.js */ "./node_modules/ol/source/wmsservertype.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
// FIXME cannot be shared between maps with different projections













/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @constructor
 * @fires ol.source.Image.Event
 * @extends {ol.source.Image}
 * @param {olx.source.ImageWMSOptions=} opt_options Options.
 * @api
 */

var _ol_source_ImageWMS_ = function (opt_options) {
  var options = opt_options || {};

  _source_image_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: options.projection,
    resolutions: options.resolutions
  });
  /**
   * @private
   * @type {?string}
   */


  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @private
   * @type {string|undefined}
   */

  this.url_ = options.url;
  /**
   * @private
   * @type {ol.ImageLoadFunctionType}
   */

  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _source_image_js__WEBPACK_IMPORTED_MODULE_9__["default"].defaultImageLoadFunction;
  /**
   * @private
   * @type {!Object}
   */

  this.params_ = options.params || {};
  /**
   * @private
   * @type {boolean}
   */

  this.v13_ = true;
  this.updateV13_();
  /**
   * @private
   * @type {ol.source.WMSServerType|undefined}
   */

  this.serverType_ =
  /** @type {ol.source.WMSServerType|undefined} */
  options.serverType;
  /**
   * @private
   * @type {boolean}
   */

  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  /**
   * @private
   * @type {ol.Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = [0, 0];
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_ImageWMS_, _source_image_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * @const
 * @type {ol.Size}
 * @private
 */


_ol_source_ImageWMS_.GETFEATUREINFO_IMAGE_SIZE_ = [101, 101];
/**
 * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
 * projection. Return `undefined` if the GetFeatureInfo URL cannot be
 * constructed.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.ProjectionLike} projection Projection.
 * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
 *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
 *     in the `LAYERS` parameter will be used. `VERSION` should not be
 *     specified here.
 * @return {string|undefined} GetFeatureInfo URL.
 * @api
 */

_ol_source_ImageWMS_.prototype.getGetFeatureInfoUrl = function (coordinate, resolution, projection, params) {
  if (this.url_ === undefined) {
    return undefined;
  }

  var projectionObj = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].get(projection);

  var sourceProjectionObj = this.getProjection();

  if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
    resolution = _reproj_js__WEBPACK_IMPORTED_MODULE_8__["default"].calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
    coordinate = _proj_js__WEBPACK_IMPORTED_MODULE_7__["default"].transform(coordinate, projectionObj, sourceProjectionObj);
  }

  var extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getForViewAndSize(coordinate, resolution, 0, _ol_source_ImageWMS_.GETFEATUREINFO_IMAGE_SIZE_);

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION,
    'REQUEST': 'GetFeatureInfo',
    'FORMAT': 'image/png',
    'TRANSPARENT': true,
    'QUERY_LAYERS': this.params_['LAYERS']
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign(baseParams, this.params_, params);

  var x = Math.floor((coordinate[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinate[1]) / resolution);
  baseParams[this.v13_ ? 'I' : 'X'] = x;
  baseParams[this.v13_ ? 'J' : 'Y'] = y;
  return this.getRequestUrl_(extent, _ol_source_ImageWMS_.GETFEATUREINFO_IMAGE_SIZE_, 1, sourceProjectionObj || projectionObj, baseParams);
};
/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * @return {Object} Params.
 * @api
 */


_ol_source_ImageWMS_.prototype.getParams = function () {
  return this.params_;
};
/**
 * @inheritDoc
 */


_ol_source_ImageWMS_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  if (this.url_ === undefined) {
    return null;
  }

  resolution = this.findNearestResolution(resolution);

  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }

  var imageResolution = resolution / pixelRatio;

  var center = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getCenter(extent);

  var viewWidth = Math.ceil(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(extent) / imageResolution);
  var viewHeight = Math.ceil(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(extent) / imageResolution);

  var viewExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getForViewAndSize(center, imageResolution, 0, [viewWidth, viewHeight]);

  var requestWidth = Math.ceil(this.ratio_ * _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(extent) / imageResolution);
  var requestHeight = Math.ceil(this.ratio_ * _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(extent) / imageResolution);

  var requestExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getForViewAndSize(center, imageResolution, 0, [requestWidth, requestHeight]);

  var image = this.image_;

  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].containsExtent(image.getExtent(), viewExtent)) {
    return image;
  }

  var params = {
    'SERVICE': 'WMS',
    'VERSION': _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION,
    'REQUEST': 'GetMap',
    'FORMAT': 'image/png',
    'TRANSPARENT': true
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign(params, this.params_);

  this.imageSize_[0] = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(requestExtent) / imageResolution);
  this.imageSize_[1] = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(requestExtent) / imageResolution);
  var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
  this.image_ = new _image_js__WEBPACK_IMPORTED_MODULE_1__["default"](requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
  this.renderedRevision_ = this.getRevision();

  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, this.handleImageChange, this);

  return this.image_;
};
/**
 * Return the image load function of the source.
 * @return {ol.ImageLoadFunctionType} The image load function.
 * @api
 */


_ol_source_ImageWMS_.prototype.getImageLoadFunction = function () {
  return this.imageLoadFunction_;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object} params Params.
 * @return {string} Request URL.
 * @private
 */


_ol_source_ImageWMS_.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
  _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`


  params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

  if (!('STYLES' in this.params_)) {
    params['STYLES'] = '';
  }

  if (pixelRatio != 1) {
    switch (this.serverType_) {
      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_10__["default"].GEOSERVER:
        var dpi = 90 * pixelRatio + 0.5 | 0;

        if ('FORMAT_OPTIONS' in params) {
          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
        } else {
          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
        }

        break;

      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_10__["default"].MAPSERVER:
        params['MAP_RESOLUTION'] = 90 * pixelRatio;
        break;

      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_10__["default"].CARMENTA_SERVER:
      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_10__["default"].QGIS:
        params['DPI'] = 90 * pixelRatio;
        break;

      default:
        _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(false, 8); // Unknown `serverType` configured


        break;
    }
  }

  params['WIDTH'] = size[0];
  params['HEIGHT'] = size[1];
  var axisOrientation = projection.getAxisOrientation();
  var bbox;

  if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }

  params['BBOX'] = bbox.join(',');
  return _uri_js__WEBPACK_IMPORTED_MODULE_12__["default"].appendParams(
  /** @type {string} */
  this.url_, params);
};
/**
 * Return the URL used for this WMS source.
 * @return {string|undefined} URL.
 * @api
 */


_ol_source_ImageWMS_.prototype.getUrl = function () {
  return this.url_;
};
/**
 * Set the image load function of the source.
 * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.
 * @api
 */


_ol_source_ImageWMS_.prototype.setImageLoadFunction = function (imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};
/**
 * Set the URL to use for requests.
 * @param {string|undefined} url URL.
 * @api
 */


_ol_source_ImageWMS_.prototype.setUrl = function (url) {
  if (url != this.url_) {
    this.url_ = url;
    this.image_ = null;
    this.changed();
  }
};
/**
 * Update the user-provided params.
 * @param {Object} params Params.
 * @api
 */


_ol_source_ImageWMS_.prototype.updateParams = function (params) {
  _obj_js__WEBPACK_IMPORTED_MODULE_6__["default"].assign(this.params_, params);

  this.updateV13_();
  this.image_ = null;
  this.changed();
};
/**
 * @private
 */


_ol_source_ImageWMS_.prototype.updateV13_ = function () {
  var version = this.params_['VERSION'] || _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION;
  this.v13_ = _string_js__WEBPACK_IMPORTED_MODULE_11__["default"].compareVersions(version, '1.3') >= 0;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_ImageWMS_);

/***/ }),

/***/ "./node_modules/ol/source/osm.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/osm.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _source_xyz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../source/xyz.js */ "./node_modules/ol/source/xyz.js");


/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 *
 * @constructor
 * @extends {ol.source.XYZ}
 * @param {olx.source.OSMOptions=} opt_options Open Street Map options.
 * @api
 */

var _ol_source_OSM_ = function (opt_options) {
  var options = opt_options || {};
  var attributions;

  if (options.attributions !== undefined) {
    attributions = options.attributions;
  } else {
    attributions = [_ol_source_OSM_.ATTRIBUTION];
  }

  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
  var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

  _source_xyz_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, {
    attributions: attributions,
    cacheSize: options.cacheSize,
    crossOrigin: crossOrigin,
    opaque: options.opaque !== undefined ? options.opaque : true,
    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileLoadFunction: options.tileLoadFunction,
    url: url,
    wrapX: options.wrapX
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_OSM_, _source_xyz_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */


_ol_source_OSM_.ATTRIBUTION = '&copy; ' + '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' + 'contributors.';
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_OSM_);

/***/ }),

/***/ "./node_modules/ol/source/raster.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/raster.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagecanvas.js */ "./node_modules/ol/imagecanvas.js");
/* harmony import */ var _tilequeue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilequeue.js */ "./node_modules/ol/tilequeue.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var pixelworks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pixelworks */ "./node_modules/pixelworks/lib/index.js");
/* harmony import */ var pixelworks__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pixelworks__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/image.js */ "./node_modules/ol/layer/image.js");
/* harmony import */ var _layer_tile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../layer/tile.js */ "./node_modules/ol/layer/tile.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _renderer_canvas_imagelayer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../renderer/canvas/imagelayer.js */ "./node_modules/ol/renderer/canvas/imagelayer.js");
/* harmony import */ var _renderer_canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../renderer/canvas/tilelayer.js */ "./node_modules/ol/renderer/canvas/tilelayer.js");
/* harmony import */ var _source_image_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../source/image.js */ "./node_modules/ol/source/image.js");
/* harmony import */ var _source_rasteroperationtype_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../source/rasteroperationtype.js */ "./node_modules/ol/source/rasteroperationtype.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_tile_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../source/tile.js */ "./node_modules/ol/source/tile.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");



















/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link ol.RasterOperation} function to transform input pixel values into
 * output pixel values.
 *
 * @constructor
 * @extends {ol.source.Image}
 * @fires ol.source.Raster.Event
 * @param {olx.source.RasterOptions} options Options.
 * @api
 */

var _ol_source_Raster_ = function (options) {
  /**
   * @private
   * @type {*}
   */
  this.worker_ = null;
  /**
   * @private
   * @type {ol.source.RasterOperationType}
   */

  this.operationType_ = options.operationType !== undefined ? options.operationType : _source_rasteroperationtype_js__WEBPACK_IMPORTED_MODULE_15__["default"].PIXEL;
  /**
   * @private
   * @type {number}
   */

  this.threads_ = options.threads !== undefined ? options.threads : 1;
  /**
   * @private
   * @type {Array.<ol.renderer.canvas.Layer>}
   */

  this.renderers_ = _ol_source_Raster_.createRenderers_(options.sources);

  for (var r = 0, rr = this.renderers_.length; r < rr; ++r) {
    _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.renderers_[r], _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, this.changed, this);
  }
  /**
   * @private
   * @type {ol.TileQueue}
   */


  this.tileQueue_ = new _tilequeue_js__WEBPACK_IMPORTED_MODULE_2__["default"](function () {
    return 1;
  }, this.changed.bind(this));

  var layerStatesArray = _ol_source_Raster_.getLayerStatesArray_(this.renderers_);

  var layerStates = {};

  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerStates[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
  }
  /**
   * The most recently requested frame state.
   * @type {olx.FrameState}
   * @private
   */


  this.requestedFrameState_;
  /**
   * The most recently rendered image canvas.
   * @type {ol.ImageCanvas}
   * @private
   */

  this.renderedImageCanvas_ = null;
  /**
   * The most recently rendered revision.
   * @type {number}
   */

  this.renderedRevision_;
  /**
   * @private
   * @type {olx.FrameState}
   */

  this.frameState_ = {
    animate: false,
    coordinateToPixelTransform: _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].create(),
    extent: null,
    focus: null,
    index: 0,
    layerStates: layerStates,
    layerStatesArray: layerStatesArray,
    logos: {},
    pixelRatio: 1,
    pixelToCoordinateTransform: _transform_js__WEBPACK_IMPORTED_MODULE_18__["default"].create(),
    postRenderFunctions: [],
    size: [0, 0],
    skippedFeatureUids: {},
    tileQueue: this.tileQueue_,
    time: Date.now(),
    usedTiles: {},
    viewState:
    /** @type {olx.ViewState} */
    {
      rotation: 0
    },
    viewHints: [],
    wantedTiles: {}
  };

  _source_image_js__WEBPACK_IMPORTED_MODULE_14__["default"].call(this, {});

  if (options.operation !== undefined) {
    this.setOperation(options.operation, options.lib);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Raster_, _source_image_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
/**
 * Set the operation.
 * @param {ol.RasterOperation} operation New operation.
 * @param {Object=} opt_lib Functions that will be available to operations run
 *     in a worker.
 * @api
 */


_ol_source_Raster_.prototype.setOperation = function (operation, opt_lib) {
  this.worker_ = new pixelworks__WEBPACK_IMPORTED_MODULE_7__["Processor"]({
    operation: operation,
    imageOps: this.operationType_ === _source_rasteroperationtype_js__WEBPACK_IMPORTED_MODULE_15__["default"].IMAGE,
    queue: 1,
    lib: opt_lib,
    threads: this.threads_
  });
  this.changed();
};
/**
 * Update the stored frame state.
 * @param {ol.Extent} extent The view extent (in map units).
 * @param {number} resolution The view resolution.
 * @param {ol.proj.Projection} projection The view projection.
 * @return {olx.FrameState} The updated frame state.
 * @private
 */


_ol_source_Raster_.prototype.updateFrameState_ = function (extent, resolution, projection) {
  var frameState =
  /** @type {olx.FrameState} */
  _obj_js__WEBPACK_IMPORTED_MODULE_11__["default"].assign({}, this.frameState_);

  frameState.viewState =
  /** @type {olx.ViewState} */
  _obj_js__WEBPACK_IMPORTED_MODULE_11__["default"].assign({}, frameState.viewState);

  var center = _extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getCenter(extent);

  frameState.extent = extent.slice();
  frameState.focus = center;
  frameState.size[0] = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getWidth(extent) / resolution);
  frameState.size[1] = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getHeight(extent) / resolution);
  frameState.time = Date.now();
  frameState.animate = false;
  var viewState = frameState.viewState;
  viewState.center = center;
  viewState.projection = projection;
  viewState.resolution = resolution;
  return frameState;
};
/**
 * Determine if all sources are ready.
 * @return {boolean} All sources are ready.
 * @private
 */


_ol_source_Raster_.prototype.allSourcesReady_ = function () {
  var ready = true;
  var source;

  for (var i = 0, ii = this.renderers_.length; i < ii; ++i) {
    source = this.renderers_[i].getLayer().getSource();

    if (source.getState() !== _source_state_js__WEBPACK_IMPORTED_MODULE_16__["default"].READY) {
      ready = false;
      break;
    }
  }

  return ready;
};
/**
 * @inheritDoc
 */


_ol_source_Raster_.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
  if (!this.allSourcesReady_()) {
    return null;
  }

  var frameState = this.updateFrameState_(extent, resolution, projection);
  this.requestedFrameState_ = frameState; // check if we can't reuse the existing ol.ImageCanvas

  if (this.renderedImageCanvas_) {
    var renderedResolution = this.renderedImageCanvas_.getResolution();
    var renderedExtent = this.renderedImageCanvas_.getExtent();

    if (resolution !== renderedResolution || !_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].equals(extent, renderedExtent)) {
      this.renderedImageCanvas_ = null;
    }
  }

  if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
    this.processSources_();
  }

  frameState.tileQueue.loadMoreTiles(16, 16);

  if (frameState.animate) {
    requestAnimationFrame(this.changed.bind(this));
  }

  return this.renderedImageCanvas_;
};
/**
 * Start processing source data.
 * @private
 */


_ol_source_Raster_.prototype.processSources_ = function () {
  var frameState = this.requestedFrameState_;
  var len = this.renderers_.length;
  var imageDatas = new Array(len);

  for (var i = 0; i < len; ++i) {
    var imageData = _ol_source_Raster_.getImageData_(this.renderers_[i], frameState, frameState.layerStatesArray[i]);

    if (imageData) {
      imageDatas[i] = imageData;
    } else {
      return;
    }
  }

  var data = {};
  this.dispatchEvent(new _ol_source_Raster_.Event(_ol_source_Raster_.EventType_.BEFOREOPERATIONS, frameState, data));
  this.worker_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
};
/**
 * Called when pixel processing is complete.
 * @param {olx.FrameState} frameState The frame state.
 * @param {Error} err Any error during processing.
 * @param {ImageData} output The output image data.
 * @param {Object} data The user data.
 * @private
 */


_ol_source_Raster_.prototype.onWorkerComplete_ = function (frameState, err, output, data) {
  if (err || !output) {
    return;
  } // do nothing if extent or resolution changed


  var extent = frameState.extent;
  var resolution = frameState.viewState.resolution;

  if (resolution !== this.requestedFrameState_.viewState.resolution || !_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].equals(extent, this.requestedFrameState_.extent)) {
    return;
  }

  var context;

  if (this.renderedImageCanvas_) {
    context = this.renderedImageCanvas_.getImage().getContext('2d');
  } else {
    var width = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getWidth(extent) / resolution);
    var height = Math.round(_extent_js__WEBPACK_IMPORTED_MODULE_8__["default"].getHeight(extent) / resolution);
    context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(width, height);
    this.renderedImageCanvas_ = new _imagecanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, 1, context.canvas);
  }

  context.putImageData(output, 0, 0);
  this.changed();
  this.renderedRevision_ = this.getRevision();
  this.dispatchEvent(new _ol_source_Raster_.Event(_ol_source_Raster_.EventType_.AFTEROPERATIONS, frameState, data));
};
/**
 * Get image data from a renderer.
 * @param {ol.renderer.canvas.Layer} renderer Layer renderer.
 * @param {olx.FrameState} frameState The frame state.
 * @param {ol.LayerState} layerState The layer state.
 * @return {ImageData} The image data.
 * @private
 */


_ol_source_Raster_.getImageData_ = function (renderer, frameState, layerState) {
  if (!renderer.prepareFrame(frameState, layerState)) {
    return null;
  }

  var width = frameState.size[0];
  var height = frameState.size[1];

  if (!_ol_source_Raster_.context_) {
    _ol_source_Raster_.context_ = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(width, height);
  } else {
    var canvas = _ol_source_Raster_.context_.canvas;

    if (canvas.width !== width || canvas.height !== height) {
      _ol_source_Raster_.context_ = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(width, height);
    } else {
      _ol_source_Raster_.context_.clearRect(0, 0, width, height);
    }
  }

  renderer.composeFrame(frameState, layerState, _ol_source_Raster_.context_);
  return _ol_source_Raster_.context_.getImageData(0, 0, width, height);
};
/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */


_ol_source_Raster_.context_ = null;
/**
 * Get a list of layer states from a list of renderers.
 * @param {Array.<ol.renderer.canvas.Layer>} renderers Layer renderers.
 * @return {Array.<ol.LayerState>} The layer states.
 * @private
 */

_ol_source_Raster_.getLayerStatesArray_ = function (renderers) {
  return renderers.map(function (renderer) {
    return renderer.getLayer().getLayerState();
  });
};
/**
 * Create renderers for all sources.
 * @param {Array.<ol.source.Source>} sources The sources.
 * @return {Array.<ol.renderer.canvas.Layer>} Array of layer renderers.
 * @private
 */


_ol_source_Raster_.createRenderers_ = function (sources) {
  var len = sources.length;
  var renderers = new Array(len);

  for (var i = 0; i < len; ++i) {
    renderers[i] = _ol_source_Raster_.createRenderer_(sources[i]);
  }

  return renderers;
};
/**
 * Create a renderer for the provided source.
 * @param {ol.source.Source} source The source.
 * @return {ol.renderer.canvas.Layer} The renderer.
 * @private
 */


_ol_source_Raster_.createRenderer_ = function (source) {
  var renderer = null;

  if (source instanceof _source_tile_js__WEBPACK_IMPORTED_MODULE_17__["default"]) {
    renderer = _ol_source_Raster_.createTileRenderer_(source);
  } else if (source instanceof _source_image_js__WEBPACK_IMPORTED_MODULE_14__["default"]) {
    renderer = _ol_source_Raster_.createImageRenderer_(source);
  }

  return renderer;
};
/**
 * Create an image renderer for the provided source.
 * @param {ol.source.Image} source The source.
 * @return {ol.renderer.canvas.Layer} The renderer.
 * @private
 */


_ol_source_Raster_.createImageRenderer_ = function (source) {
  var layer = new _layer_image_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    source: source
  });
  return new _renderer_canvas_imagelayer_js__WEBPACK_IMPORTED_MODULE_12__["default"](layer);
};
/**
 * Create a tile renderer for the provided source.
 * @param {ol.source.Tile} source The source.
 * @return {ol.renderer.canvas.Layer} The renderer.
 * @private
 */


_ol_source_Raster_.createTileRenderer_ = function (source) {
  var layer = new _layer_tile_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
    source: source
  });
  return new _renderer_canvas_tilelayer_js__WEBPACK_IMPORTED_MODULE_13__["default"](layer);
};
/**
 * @classdesc
 * Events emitted by {@link ol.source.Raster} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.RasterEvent}
 * @param {string} type Type.
 * @param {olx.FrameState} frameState The frame state.
 * @param {Object} data An object made available to operations.
 */


_ol_source_Raster_.Event = function (type, frameState, data) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, type);
  /**
   * The raster extent.
   * @type {ol.Extent}
   * @api
   */


  this.extent = frameState.extent;
  /**
   * The pixel resolution (map units per pixel).
   * @type {number}
   * @api
   */

  this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
  /**
   * An object made available to all operations.  This can be used by operations
   * as a storage object (e.g. for calculating statistics).
   * @type {Object}
   * @api
   */

  this.data = data;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Raster_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @override
 */


_ol_source_Raster_.prototype.getImageInternal = function () {
  return null; // not implemented
};
/**
 * @enum {string}
 * @private
 */


_ol_source_Raster_.EventType_ = {
  /**
   * Triggered before operations are run.
   * @event ol.source.Raster.Event#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: 'beforeoperations',

  /**
   * Triggered after operations are run.
   * @event ol.source.Raster.Event#afteroperations
   * @api
   */
  AFTEROPERATIONS: 'afteroperations'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Raster_);

/***/ }),

/***/ "./node_modules/ol/source/rasteroperationtype.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/source/rasteroperationtype.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 * @enum {string}
 */
var _ol_source_RasterOperationType_ = {
  PIXEL: 'pixel',
  IMAGE: 'image'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_RasterOperationType_);

/***/ }),

/***/ "./node_modules/ol/source/source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/source.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _attribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../attribution.js */ "./node_modules/ol/attribution.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link ol.layer.Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {ol.SourceSourceOptions} options Source options.
 * @api
 */

var _ol_source_Source_ = function (options) {
  _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @private
   * @type {ol.proj.Projection}
   */


  this.projection_ = _proj_js__WEBPACK_IMPORTED_MODULE_3__["default"].get(options.projection);
  /**
   * @private
   * @type {Array.<ol.Attribution>}
   */

  this.attributions_ = null;
  /**
   * @private
   * @type {?ol.Attribution2}
   */

  this.attributions2_ = this.adaptAttributions_(options.attributions);
  /**
   * @private
   * @type {string|olx.LogoOptions|undefined}
   */

  this.logo_ = options.logo;
  /**
   * @private
   * @type {ol.source.State}
   */

  this.state_ = options.state !== undefined ? options.state : _source_state_js__WEBPACK_IMPORTED_MODULE_4__["default"].READY;
  /**
   * @private
   * @type {boolean}
   */

  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Source_, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Turns the attributions option into an attributions function.
 * @suppress {deprecated}
 * @param {ol.AttributionLike|undefined} attributionLike The attribution option.
 * @return {?ol.Attribution2} An attribution function (or null).
 */


_ol_source_Source_.prototype.adaptAttributions_ = function (attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (attributionLike instanceof _attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    // TODO: remove attributions_ in next major release
    this.attributions_ = [attributionLike];
    return function (frameState) {
      return [attributionLike.getHTML()];
    };
  }

  if (Array.isArray(attributionLike)) {
    if (attributionLike[0] instanceof _attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
      // TODO: remove attributions_ in next major release
      this.attributions_ = attributionLike;
      var attributions = attributionLike.map(function (attribution) {
        return attribution.getHTML();
      });
      return function (frameState) {
        return attributions;
      };
    } // TODO: remove attributions_ in next major release


    this.attributions_ = attributionLike.map(function (attribution) {
      return new _attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        html: attribution
      });
    });
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  } // TODO: remove attributions_ in next major release


  this.attributions_ = [new _attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    html: attributionLike
  })];
  return function (frameState) {
    return [attributionLike];
  };
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_source_Source_.prototype.forEachFeatureAtCoordinate = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * Get the attributions of the source.
 * @return {Array.<ol.Attribution>} Attributions.
 * @api
 */

_ol_source_Source_.prototype.getAttributions = function () {
  return this.attributions_;
};
/**
 * Get the attribution function for the source.
 * @return {?ol.Attribution2} Attribution function.
 */


_ol_source_Source_.prototype.getAttributions2 = function () {
  return this.attributions2_;
};
/**
 * Get the logo of the source.
 * @return {string|olx.LogoOptions|undefined} Logo.
 * @api
 */


_ol_source_Source_.prototype.getLogo = function () {
  return this.logo_;
};
/**
 * Get the projection of the source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */


_ol_source_Source_.prototype.getProjection = function () {
  return this.projection_;
};
/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */


_ol_source_Source_.prototype.getResolutions = function () {};
/**
 * Get the state of the source, see {@link ol.source.State} for possible states.
 * @return {ol.source.State} State.
 * @api
 */


_ol_source_Source_.prototype.getState = function () {
  return this.state_;
};
/**
 * @return {boolean|undefined} Wrap X.
 */


_ol_source_Source_.prototype.getWrapX = function () {
  return this.wrapX_;
};
/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */


_ol_source_Source_.prototype.refresh = function () {
  this.changed();
};
/**
 * Set the attributions of the source.
 * @param {ol.AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution2}`,
 *     or `undefined`.
 * @api
 */


_ol_source_Source_.prototype.setAttributions = function (attributions) {
  this.attributions2_ = this.adaptAttributions_(attributions);
  this.changed();
};
/**
 * Set the logo of the source.
 * @param {string|olx.LogoOptions|undefined} logo Logo.
 */


_ol_source_Source_.prototype.setLogo = function (logo) {
  this.logo_ = logo;
};
/**
 * Set the state of the source.
 * @param {ol.source.State} state State.
 * @protected
 */


_ol_source_Source_.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Source_);

/***/ }),

/***/ "./node_modules/ol/source/stamen.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/stamen.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _source_osm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../source/osm.js */ "./node_modules/ol/source/osm.js");
/* harmony import */ var _source_xyz_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../source/xyz.js */ "./node_modules/ol/source/xyz.js");



/**
 * @classdesc
 * Layer source for the Stamen tile server.
 *
 * @constructor
 * @extends {ol.source.XYZ}
 * @param {olx.source.StamenOptions} options Stamen options.
 * @api
 */

var _ol_source_Stamen_ = function (options) {
  var i = options.layer.indexOf('-');
  var provider = i == -1 ? options.layer : options.layer.slice(0, i);
  var providerConfig = _ol_source_Stamen_.ProviderConfig[provider];
  var layerConfig = _ol_source_Stamen_.LayerConfig[options.layer];
  var url = options.url !== undefined ? options.url : 'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer + '/{z}/{x}/{y}.' + layerConfig.extension;

  _source_xyz_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, {
    attributions: _ol_source_Stamen_.ATTRIBUTIONS,
    cacheSize: options.cacheSize,
    crossOrigin: 'anonymous',
    maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
    minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
    opaque: layerConfig.opaque,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileLoadFunction: options.tileLoadFunction,
    url: url,
    wrapX: options.wrapX
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Stamen_, _source_xyz_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @const
 * @type {Array.<string>}
 */


_ol_source_Stamen_.ATTRIBUTIONS = ['Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' + 'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' + ' 3.0</a>.', _source_osm_js__WEBPACK_IMPORTED_MODULE_1__["default"].ATTRIBUTION];
/**
 * @type {Object.<string, {extension: string, opaque: boolean}>}
 */

_ol_source_Stamen_.LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};
/**
 * @type {Object.<string, {minZoom: number, maxZoom: number}>}
 */

_ol_source_Stamen_.ProviderConfig = {
  'terrain': {
    minZoom: 4,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 1,
    maxZoom: 16
  }
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Stamen_);

/***/ }),

/***/ "./node_modules/ol/source/state.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/state.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
var _ol_source_State_ = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_State_);

/***/ }),

/***/ "./node_modules/ol/source/tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tilecache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilecache.js */ "./node_modules/ol/tilecache.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/source.js */ "./node_modules/ol/source/source.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");









/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceTileOptions} options Tile source options.
 * @api
 */

var _ol_source_Tile_ = function (options) {
  _source_source_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    state: options.state,
    wrapX: options.wrapX
  });
  /**
   * @private
   * @type {boolean}
   */


  this.opaque_ = options.opaque !== undefined ? options.opaque : false;
  /**
   * @private
   * @type {number}
   */

  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
  /**
   * @protected
   * @type {ol.tilegrid.TileGrid}
   */

  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
  /**
   * @protected
   * @type {ol.TileCache}
   */

  this.tileCache = new _tilecache_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.cacheSize);
  /**
   * @protected
   * @type {ol.Size}
   */

  this.tmpSize = [0, 0];
  /**
   * @private
   * @type {string}
   */

  this.key_ = '';
  /**
   * @protected
   * @type {olx.TileOptions}
   */

  this.tileOptions = {
    transition: options.transition
  };
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Tile_, _source_source_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * @return {boolean} Can expire cache.
 */


_ol_source_Tile_.prototype.canExpireCache = function () {
  return this.tileCache.canExpireCache();
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */


_ol_source_Tile_.prototype.expireCache = function (projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);

  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {function(ol.Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */


_ol_source_Tile_.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
  var tileCache = this.getTileCacheForProjection(projection);

  if (!tileCache) {
    return false;
  }

  var covered = true;
  var tile, tileCoordKey, loaded;

  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].getKeyZXY(z, x, y);
      loaded = false;

      if (tileCache.containsKey(tileCoordKey)) {
        tile =
        /** @type {!ol.Tile} */
        tileCache.get(tileCoordKey);
        loaded = tile.getState() === _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;

        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }

      if (!loaded) {
        covered = false;
      }
    }
  }

  return covered;
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {number} Gutter.
 */


_ol_source_Tile_.prototype.getGutter = function (projection) {
  return 0;
};
/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */


_ol_source_Tile_.prototype.getKey = function () {
  return this.key_;
};
/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */


_ol_source_Tile_.prototype.setKey = function (key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {boolean} Opaque.
 */


_ol_source_Tile_.prototype.getOpaque = function (projection) {
  return this.opaque_;
};
/**
 * @inheritDoc
 */


_ol_source_Tile_.prototype.getResolutions = function () {
  return this.tileGrid.getResolutions();
};
/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 */


_ol_source_Tile_.prototype.getTile = function (z, x, y, pixelRatio, projection) {};
/**
 * Return the tile grid of the tile source.
 * @return {ol.tilegrid.TileGrid} Tile grid.
 * @api
 */


_ol_source_Tile_.prototype.getTileGrid = function () {
  return this.tileGrid;
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Tile grid.
 */


_ol_source_Tile_.prototype.getTileGridForProjection = function (projection) {
  if (!this.tileGrid) {
    return _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].getForProjection(projection);
  } else {
    return this.tileGrid;
  }
};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCache} Tile cache.
 * @protected
 */


_ol_source_Tile_.prototype.getTileCacheForProjection = function (projection) {
  var thisProj = this.getProjection();

  if (thisProj && !_proj_js__WEBPACK_IMPORTED_MODULE_4__["default"].equivalent(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};
/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `pixelRatio` as close as possible.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */


_ol_source_Tile_.prototype.getTilePixelRatio = function (pixelRatio) {
  return this.tilePixelRatio_;
};
/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.Size} Tile size.
 */


_ol_source_Tile_.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_5__["default"].toSize(tileGrid.getTileSize(z), this.tmpSize);

  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return _size_js__WEBPACK_IMPORTED_MODULE_5__["default"].scale(tileSize, tilePixelRatio, this.tmpSize);
  }
};
/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection=} opt_projection Projection.
 * @return {ol.TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */


_ol_source_Tile_.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);

  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].wrapX(tileGrid, tileCoord, projection);
  }

  return _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
};
/**
 * @inheritDoc
 */


_ol_source_Tile_.prototype.refresh = function () {
  this.tileCache.clear();
  this.changed();
};
/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {ol.proj.Projection} projection Projection.
 */


_ol_source_Tile_.prototype.useTile = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
/**
 * @classdesc
 * Events emitted by {@link ol.source.Tile} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Tile.Event}
 * @param {string} type Type.
 * @param {ol.Tile} tile The tile.
 */

_ol_source_Tile_.Event = function (type, tile) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, type);
  /**
   * The tile related to the event.
   * @type {ol.Tile}
   * @api
   */


  this.tile = tile;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Tile_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Tile_);

/***/ }),

/***/ "./node_modules/ol/source/tilearcgisrest.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/source/tilearcgisrest.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");








/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link ol.source.XYZ} data source.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.TileArcGISRestOptions=} opt_options Tile ArcGIS Rest
 *     options.
 * @api
 */

var _ol_source_TileArcGISRest_ = function (opt_options) {
  var options = opt_options || {};

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
  /**
   * @private
   * @type {!Object}
   */


  this.params_ = options.params || {};
  /**
   * @private
   * @type {ol.Extent}
   */

  this.tmpExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_1__["default"].createEmpty();
  this.setKey(this.getKeyForParams_());
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileArcGISRest_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @private
 * @return {string} The key for the current params.
 */


_ol_source_TileArcGISRest_.prototype.getKeyForParams_ = function () {
  var i = 0;
  var res = [];

  for (var key in this.params_) {
    res[i++] = key + '-' + this.params_[key];
  }

  return res.join('/');
};
/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * @return {Object} Params.
 * @api
 */


_ol_source_TileArcGISRest_.prototype.getParams = function () {
  return this.params_;
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Size} tileSize Tile size.
 * @param {ol.Extent} tileExtent Tile extent.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object} params Params.
 * @return {string|undefined} Request URL.
 * @private
 */


_ol_source_TileArcGISRest_.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
  var urls = this.urls;

  if (!urls) {
    return undefined;
  } // ArcGIS Server only wants the numeric portion of the projection ID.


  var srid = projection.getCode().split(':').pop();
  params['SIZE'] = tileSize[0] + ',' + tileSize[1];
  params['BBOX'] = tileExtent.join(',');
  params['BBOXSR'] = srid;
  params['IMAGESR'] = srid;
  params['DPI'] = Math.round(params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio);
  var url;

  if (urls.length == 1) {
    url = urls[0];
  } else {
    var index = _math_js__WEBPACK_IMPORTED_MODULE_2__["default"].modulo(_tilecoord_js__WEBPACK_IMPORTED_MODULE_6__["default"].hash(tileCoord), urls.length);

    url = urls[index];
  }

  var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');
  return _uri_js__WEBPACK_IMPORTED_MODULE_7__["default"].appendParams(modifiedUrl, params);
};
/**
 * @inheritDoc
 */


_ol_source_TileArcGISRest_.prototype.getTilePixelRatio = function (pixelRatio) {
  return (
    /** @type {number} */
    pixelRatio
  );
};
/**
 * @inheritDoc
 */


_ol_source_TileArcGISRest_.prototype.fixedTileUrlFunction = function (tileCoord, pixelRatio, projection) {
  var tileGrid = this.getTileGrid();

  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_4__["default"].toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

  if (pixelRatio != 1) {
    tileSize = _size_js__WEBPACK_IMPORTED_MODULE_4__["default"].scale(tileSize, pixelRatio, this.tmpSize);
  } // Apply default params and override with user specified values.


  var baseParams = {
    'F': 'image',
    'FORMAT': 'PNG32',
    'TRANSPARENT': true
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].assign(baseParams, this.params_);

  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
};
/**
 * Update the user-provided params.
 * @param {Object} params Params.
 * @api
 */


_ol_source_TileArcGISRest_.prototype.updateParams = function (params) {
  _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].assign(this.params_, params);

  this.setKey(this.getKeyForParams_());
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileArcGISRest_);

/***/ }),

/***/ "./node_modules/ol/source/tiledebug.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/tiledebug.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_tile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../source/tile.js */ "./node_modules/ol/source/tile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");







/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 *
 * Uses Canvas context2d, so requires Canvas support.
 *
 * @constructor
 * @extends {ol.source.Tile}
 * @param {olx.source.TileDebugOptions} options Debug tile options.
 * @api
 */

var _ol_source_TileDebug_ = function (options) {
  _source_tile_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    opaque: false,
    projection: options.projection,
    tileGrid: options.tileGrid,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileDebug_, _source_tile_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @inheritDoc
 */


_ol_source_TileDebug_.prototype.getTile = function (z, x, y) {
  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__["default"].getKeyZXY(z, x, y);

  if (this.tileCache.containsKey(tileCoordKey)) {
    return (
      /** @type {!ol.source.TileDebug.Tile_} */
      this.tileCache.get(tileCoordKey)
    );
  } else {
    var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_4__["default"].toSize(this.tileGrid.getTileSize(z));

    var tileCoord = [z, x, y];
    var textTileCoord = this.getTileCoordForTileUrlFunction(tileCoord);
    var text = !textTileCoord ? '' : this.getTileCoordForTileUrlFunction(textTileCoord).toString();
    var tile = new _ol_source_TileDebug_.Tile_(tileCoord, tileSize, text);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Size} tileSize Tile size.
 * @param {string} text Text.
 * @private
 */


_ol_source_TileDebug_.Tile_ = function (tileCoord, tileSize, text) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED);
  /**
   * @private
   * @type {ol.Size}
   */


  this.tileSize_ = tileSize;
  /**
   * @private
   * @type {string}
   */

  this.text_ = text;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileDebug_.Tile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Get the image element for this tile.
 * @return {HTMLCanvasElement} Image.
 */


_ol_source_TileDebug_.Tile_.prototype.getImage = function () {
  if (this.canvas_) {
    return this.canvas_;
  } else {
    var tileSize = this.tileSize_;

    var context = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D(tileSize[0], tileSize[1]);

    context.strokeStyle = 'black';
    context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.font = '24px sans-serif';
    context.fillText(this.text_, tileSize[0] / 2, tileSize[1] / 2);
    this.canvas_ = context.canvas;
    return context.canvas;
  }
};
/**
 * @override
 */


_ol_source_TileDebug_.Tile_.prototype.load = function () {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileDebug_);

/***/ }),

/***/ "./node_modules/ol/source/tileeventtype.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/tileeventtype.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_source_TileEventType_ = {
  /**
   * Triggered when a tile starts loading.
   * @event ol.source.Tile.Event#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event ol.source.Tile.Event#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event ol.source.Tile.Event#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileEventType_);

/***/ }),

/***/ "./node_modules/ol/source/tileimage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/tileimage.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagetile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagetile.js */ "./node_modules/ol/imagetile.js");
/* harmony import */ var _tilecache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilecache.js */ "./node_modules/ol/tilecache.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj/tile.js */ "./node_modules/ol/reproj/tile.js");
/* harmony import */ var _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/urltile.js */ "./node_modules/ol/source/urltile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");











/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.TileImageOptions} options Image tile options.
 * @api
 */

var _ol_source_TileImage_ = function (options) {
  _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _ol_source_TileImage_.defaultTileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX,
    transition: options.transition
  });
  /**
   * @protected
   * @type {?string}
   */


  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @protected
   * @type {function(new: ol.ImageTile, ol.TileCoord, ol.TileState, string,
   *        ?string, ol.TileLoadFunctionType, olx.TileOptions=)}
   */

  this.tileClass = options.tileClass !== undefined ? options.tileClass : _imagetile_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  /**
   * @protected
   * @type {Object.<string, ol.TileCache>}
   */

  this.tileCacheForProjection = {};
  /**
   * @protected
   * @type {Object.<string, ol.tilegrid.TileGrid>}
   */

  this.tileGridForProjection = {};
  /**
   * @private
   * @type {number|undefined}
   */

  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
  /**
   * @private
   * @type {boolean}
   */

  this.renderReprojectionEdges_ = false;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileImage_, _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.canExpireCache = function () {
  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
    return _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.canExpireCache.call(this);
  }

  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }

  return false;
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.expireCache = function (projection, usedTiles) {
  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
    _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.expireCache.call(this, projection, usedTiles);

    return;
  }

  var usedTileCache = this.getTileCacheForProjection(projection);
  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

  for (var id in this.tileCacheForProjection) {
    var tileCache = this.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.getGutter = function (projection) {
  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !_proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].equivalent(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};
/**
 * @protected
 * @return {number} Gutter.
 */


_ol_source_TileImage_.prototype.getGutterInternal = function () {
  return 0;
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.getOpaque = function (projection) {
  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !_proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].equivalent(this.getProjection(), projection)) {
    return false;
  } else {
    return _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.getOpaque.call(this, projection);
  }
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.getTileGridForProjection = function (projection) {
  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
    return _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.getTileGridForProjection.call(this, projection);
  }

  var thisProj = this.getProjection();

  if (this.tileGrid && (!thisProj || _proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].equivalent(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(projection).toString();

    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = _tilegrid_js__WEBPACK_IMPORTED_MODULE_10__["default"].getForProjection(projection);
    }

    return (
      /** @type {!ol.tilegrid.TileGrid} */
      this.tileGridForProjection[projKey]
    );
  }
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.getTileCacheForProjection = function (projection) {
  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
    return _source_urltile_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.getTileCacheForProjection.call(this, projection);
  }

  var thisProj = this.getProjection();

  if (!thisProj || _proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].equivalent(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(projection).toString();

    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _tilecache_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.tileCache.highWaterMark);
    }

    return this.tileCacheForProjection[projKey];
  }
};
/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!ol.Tile} Tile.
 * @private
 */


_ol_source_TileImage_.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE : _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
  tile.key = key;

  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(tile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleTileChange, this);

  return tile;
};
/**
 * @inheritDoc
 */


_ol_source_TileImage_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var sourceProjection =
  /** @type {!ol.proj.Projection} */
  this.getProjection();

  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || _proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].equivalent(sourceProjection, projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile;

    var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_9__["default"].getKey(tileCoord);

    if (cache.containsKey(tileCoordKey)) {
      tile =
      /** @type {!ol.Tile} */
      cache.get(tileCoordKey);
    }

    var key = this.getKey();

    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new _reproj_tile_js__WEBPACK_IMPORTED_MODULE_7__["default"](sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function (z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;

      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }

      return newTile;
    }
  }
};
/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 * @protected
 */


_ol_source_TileImage_.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
  var tile = null;

  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_9__["default"].getKeyZXY(z, x, y);

  var key = this.getKey();

  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);

    if (tile.key != key) {
      // The source's params changed. If the tile has an interim tile and if we
      // can use it then we use it. Otherwise we create a new tile.  In both
      // cases we attempt to assign an interim tile to the new tile.
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

      if (interimTile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }

      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }

  return tile;
};
/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */


_ol_source_TileImage_.prototype.setRenderReprojectionEdges = function (render) {
  if (!_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }

  this.renderReprojectionEdges_ = render;

  for (var id in this.tileCacheForProjection) {
    this.tileCacheForProjection[id].clear();
  }

  this.changed();
};
/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {ol.ProjectionLike} projection Projection.
 * @param {ol.tilegrid.TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */


_ol_source_TileImage_.prototype.setTileGridForProjection = function (projection, tilegrid) {
  if (_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].ENABLE_RASTER_REPROJECTION) {
    var proj = _proj_js__WEBPACK_IMPORTED_MODULE_6__["default"].get(projection);

    if (proj) {
      var projKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(proj).toString();

      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};
/**
 * @param {ol.ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */


_ol_source_TileImage_.defaultTileLoadFunction = function (imageTile, src) {
  imageTile.getImage().src = src;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileImage_);

/***/ }),

/***/ "./node_modules/ol/source/tilejson.js":
/*!********************************************!*\
  !*** ./node_modules/ol/source/tilejson.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
// FIXME check order of async callbacks

/**
 * @see http://mapbox.com/developers/api/
 */









/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.TileJSONOptions} options TileJSON options.
 * @api
 */

var _ol_source_TileJSON_ = function (options) {
  /**
   * @type {TileJSON}
   * @private
   */
  this.tileJSON_ = null;

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    projection: _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get('EPSG:3857'),
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    state: _source_state_js__WEBPACK_IMPORTED_MODULE_6__["default"].LOADING,
    tileLoadFunction: options.tileLoadFunction,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });

  if (options.url) {
    if (options.jsonp) {
      _net_js__WEBPACK_IMPORTED_MODULE_4__["default"].jsonp(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
    } else {
      var client = new XMLHttpRequest();
      client.addEventListener('load', this.onXHRLoad_.bind(this));
      client.addEventListener('error', this.onXHRError_.bind(this));
      client.open('GET', options.url);
      client.send();
    }
  } else if (options.tileJSON) {
    this.handleTileJSONResponse(options.tileJSON);
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(false, 51); // Either `url` or `tileJSON` options must be provided

  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileJSON_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * @private
 * @param {Event} event The load event.
 */


_ol_source_TileJSON_.prototype.onXHRLoad_ = function (event) {
  var client =
  /** @type {XMLHttpRequest} */
  event.target; // status will be 0 for file:// urls

  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;

    try {
      response =
      /** @type {TileJSON} */
      JSON.parse(client.responseText);
    } catch (err) {
      this.handleTileJSONError();
      return;
    }

    this.handleTileJSONResponse(response);
  } else {
    this.handleTileJSONError();
  }
};
/**
 * @private
 * @param {Event} event The error event.
 */


_ol_source_TileJSON_.prototype.onXHRError_ = function (event) {
  this.handleTileJSONError();
};
/**
 * @return {TileJSON} The tilejson object.
 * @api
 */


_ol_source_TileJSON_.prototype.getTileJSON = function () {
  return this.tileJSON_;
};
/**
 * @protected
 * @param {TileJSON} tileJSON Tile JSON.
 */


_ol_source_TileJSON_.prototype.handleTileJSONResponse = function (tileJSON) {
  var epsg4326Projection = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get('EPSG:4326');

  var sourceProjection = this.getProjection();
  var extent;

  if (tileJSON.bounds !== undefined) {
    var transform = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].getTransformFromProjections(epsg4326Projection, sourceProjection);

    extent = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].applyTransform(tileJSON.bounds, transform);
  }

  var minZoom = tileJSON.minzoom || 0;
  var maxZoom = tileJSON.maxzoom || 22;

  var tileGrid = _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].createXYZ({
    extent: _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["default"].extentFromProjection(sourceProjection),
    maxZoom: maxZoom,
    minZoom: minZoom
  });

  this.tileGrid = tileGrid;
  this.tileUrlFunction = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].createFromTemplates(tileJSON.tiles, tileGrid);

  if (tileJSON.attribution !== undefined && !this.getAttributions2()) {
    var attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();
    this.setAttributions(function (frameState) {
      if (_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].intersects(attributionExtent, frameState.extent)) {
        return [tileJSON.attribution];
      }

      return null;
    });
  }

  this.tileJSON_ = tileJSON;
  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_6__["default"].READY);
};
/**
 * @protected
 */


_ol_source_TileJSON_.prototype.handleTileJSONError = function () {
  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_6__["default"].ERROR);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileJSON_);

/***/ }),

/***/ "./node_modules/ol/source/tileutfgrid.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/tileutfgrid.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../net.js */ "./node_modules/ol/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_tile_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/tile.js */ "./node_modules/ol/source/tile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");














/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 *
 * @constructor
 * @extends {ol.source.Tile}
 * @param {olx.source.TileUTFGridOptions} options Source options.
 * @api
 */

var _ol_source_TileUTFGrid_ = function (options) {
  _source_tile_js__WEBPACK_IMPORTED_MODULE_11__["default"].call(this, {
    projection: _proj_js__WEBPACK_IMPORTED_MODULE_9__["default"].get('EPSG:3857'),
    state: _source_state_js__WEBPACK_IMPORTED_MODULE_10__["default"].LOADING
  });
  /**
   * @private
   * @type {boolean}
   */


  this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;
  /**
   * @private
   * @type {!ol.TileUrlFunctionType}
   */

  this.tileUrlFunction_ = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["default"].nullTileUrlFunction;
  /**
   * @private
   * @type {string|undefined}
   */

  this.template_ = undefined;
  /**
   * @private
   * @type {boolean}
   */

  this.jsonp_ = options.jsonp || false;

  if (options.url) {
    if (this.jsonp_) {
      _net_js__WEBPACK_IMPORTED_MODULE_8__["default"].jsonp(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
    } else {
      var client = new XMLHttpRequest();
      client.addEventListener('load', this.onXHRLoad_.bind(this));
      client.addEventListener('error', this.onXHRError_.bind(this));
      client.open('GET', options.url);
      client.send();
    }
  } else if (options.tileJSON) {
    this.handleTileJSONResponse(options.tileJSON);
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_4__["default"].assert(false, 51); // Either `url` or `tileJSON` options must be provided

  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileUTFGrid_, _source_tile_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
/**
 * @private
 * @param {Event} event The load event.
 */


_ol_source_TileUTFGrid_.prototype.onXHRLoad_ = function (event) {
  var client =
  /** @type {XMLHttpRequest} */
  event.target; // status will be 0 for file:// urls

  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;

    try {
      response =
      /** @type {TileJSON} */
      JSON.parse(client.responseText);
    } catch (err) {
      this.handleTileJSONError();
      return;
    }

    this.handleTileJSONResponse(response);
  } else {
    this.handleTileJSONError();
  }
};
/**
 * @private
 * @param {Event} event The error event.
 */


_ol_source_TileUTFGrid_.prototype.onXHRError_ = function (event) {
  this.handleTileJSONError();
};
/**
 * Return the template from TileJSON.
 * @return {string|undefined} The template from TileJSON.
 * @api
 */


_ol_source_TileUTFGrid_.prototype.getTemplate = function () {
  return this.template_;
};
/**
 * Calls the callback (synchronously by default) with the available data
 * for given coordinate and resolution (or `null` if not yet loaded or
 * in case of an error).
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {function(this: T, *)} callback Callback.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @param {boolean=} opt_request If `true` the callback is always async.
 *                               The tile data is requested if not yet loaded.
 * @template T
 * @api
 */


_ol_source_TileUTFGrid_.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_this, opt_request) {
  if (this.tileGrid) {
    var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
    var tile =
    /** @type {!ol.source.TileUTFGrid.Tile_} */
    this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
    tile.forDataAtCoordinate(coordinate, callback, opt_this, opt_request);
  } else {
    if (opt_request === true) {
      setTimeout(function () {
        callback.call(opt_this, null);
      }, 0);
    } else {
      callback.call(opt_this, null);
    }
  }
};
/**
 * @protected
 */


_ol_source_TileUTFGrid_.prototype.handleTileJSONError = function () {
  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_10__["default"].ERROR);
};
/**
 * TODO: very similar to ol.source.TileJSON#handleTileJSONResponse
 * @protected
 * @param {TileJSON} tileJSON Tile JSON.
 */


_ol_source_TileUTFGrid_.prototype.handleTileJSONResponse = function (tileJSON) {
  var epsg4326Projection = _proj_js__WEBPACK_IMPORTED_MODULE_9__["default"].get('EPSG:4326');

  var sourceProjection = this.getProjection();
  var extent;

  if (tileJSON.bounds !== undefined) {
    var transform = _proj_js__WEBPACK_IMPORTED_MODULE_9__["default"].getTransformFromProjections(epsg4326Projection, sourceProjection);

    extent = _extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].applyTransform(tileJSON.bounds, transform);
  }

  var minZoom = tileJSON.minzoom || 0;
  var maxZoom = tileJSON.maxzoom || 22;

  var tileGrid = _tilegrid_js__WEBPACK_IMPORTED_MODULE_13__["default"].createXYZ({
    extent: _tilegrid_js__WEBPACK_IMPORTED_MODULE_13__["default"].extentFromProjection(sourceProjection),
    maxZoom: maxZoom,
    minZoom: minZoom
  });

  this.tileGrid = tileGrid;
  this.template_ = tileJSON.template;
  var grids = tileJSON.grids;

  if (!grids) {
    this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_10__["default"].ERROR);
    return;
  }

  this.tileUrlFunction_ = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["default"].createFromTemplates(grids, tileGrid);

  if (tileJSON.attribution !== undefined) {
    var attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();
    this.setAttributions(function (frameState) {
      if (_extent_js__WEBPACK_IMPORTED_MODULE_7__["default"].intersects(attributionExtent, frameState.extent)) {
        return [tileJSON.attribution];
      }

      return null;
    });
  }

  this.setState(_source_state_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY);
};
/**
 * @inheritDoc
 */


_ol_source_TileUTFGrid_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_12__["default"].getKeyZXY(z, x, y);

  if (this.tileCache.containsKey(tileCoordKey)) {
    return (
      /** @type {!ol.Tile} */
      this.tileCache.get(tileCoordKey)
    );
  } else {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
    var tile = new _ol_source_TileUTFGrid_.Tile_(tileCoord, tileUrl !== undefined ? _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE : _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
/**
 * @inheritDoc
 */


_ol_source_TileUTFGrid_.prototype.useTile = function (z, x, y) {
  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_12__["default"].getKeyZXY(z, x, y);

  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {ol.Extent} extent Extent of the tile.
 * @param {boolean} preemptive Load the tile when visible (before it's needed).
 * @param {boolean} jsonp Load the tile as a script.
 * @private
 */


_ol_source_TileUTFGrid_.Tile_ = function (tileCoord, state, src, extent, preemptive, jsonp) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, state);
  /**
   * @private
   * @type {string}
   */


  this.src_ = src;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = extent;
  /**
   * @private
   * @type {boolean}
   */

  this.preemptive_ = preemptive;
  /**
   * @private
   * @type {Array.<string>}
   */

  this.grid_ = null;
  /**
   * @private
   * @type {Array.<string>}
   */

  this.keys_ = null;
  /**
   * @private
   * @type {Object.<string, Object>|undefined}
   */

  this.data_ = null;
  /**
   * @private
   * @type {boolean}
   */

  this.jsonp_ = jsonp;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileUTFGrid_.Tile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Get the image element for this tile.
 * @return {Image} Image.
 */


_ol_source_TileUTFGrid_.Tile_.prototype.getImage = function () {
  return null;
};
/**
 * Synchronously returns data at given coordinate (if available).
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {*} The data.
 */


_ol_source_TileUTFGrid_.Tile_.prototype.getData = function (coordinate) {
  if (!this.grid_ || !this.keys_) {
    return null;
  }

  var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
  var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
  var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];

  if (typeof row !== 'string') {
    return null;
  }

  var code = row.charCodeAt(Math.floor(xRelative * row.length));

  if (code >= 93) {
    code--;
  }

  if (code >= 35) {
    code--;
  }

  code -= 32;
  var data = null;

  if (code in this.keys_) {
    var id = this.keys_[code];

    if (this.data_ && id in this.data_) {
      data = this.data_[id];
    } else {
      data = id;
    }
  }

  return data;
};
/**
 * Calls the callback (synchronously by default) with the available data
 * for given coordinate (or `null` if not yet loaded).
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, *)} callback Callback.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @param {boolean=} opt_request If `true` the callback is always async.
 *                               The tile data is requested if not yet loaded.
 * @template T
 */


_ol_source_TileUTFGrid_.Tile_.prototype.forDataAtCoordinate = function (coordinate, callback, opt_this, opt_request) {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && opt_request === true) {
    _events_js__WEBPACK_IMPORTED_MODULE_5__["default"].listenOnce(this, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, function (e) {
      callback.call(opt_this, this.getData(coordinate));
    }, this);

    this.loadInternal_();
  } else {
    if (opt_request === true) {
      setTimeout(function () {
        callback.call(opt_this, this.getData(coordinate));
      }.bind(this), 0);
    } else {
      callback.call(opt_this, this.getData(coordinate));
    }
  }
};
/**
 * @inheritDoc
 */


_ol_source_TileUTFGrid_.Tile_.prototype.getKey = function () {
  return this.src_;
};
/**
 * @private
 */


_ol_source_TileUTFGrid_.Tile_.prototype.handleError_ = function () {
  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
  this.changed();
};
/**
 * @param {!UTFGridJSON} json UTFGrid data.
 * @private
 */


_ol_source_TileUTFGrid_.Tile_.prototype.handleLoad_ = function (json) {
  this.grid_ = json.grid;
  this.keys_ = json.keys;
  this.data_ = json.data;
  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
  this.changed();
};
/**
 * @private
 */


_ol_source_TileUTFGrid_.Tile_.prototype.loadInternal_ = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;

    if (this.jsonp_) {
      _net_js__WEBPACK_IMPORTED_MODULE_8__["default"].jsonp(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
    } else {
      var client = new XMLHttpRequest();
      client.addEventListener('load', this.onXHRLoad_.bind(this));
      client.addEventListener('error', this.onXHRError_.bind(this));
      client.open('GET', this.src_);
      client.send();
    }
  }
};
/**
 * @private
 * @param {Event} event The load event.
 */


_ol_source_TileUTFGrid_.Tile_.prototype.onXHRLoad_ = function (event) {
  var client =
  /** @type {XMLHttpRequest} */
  event.target; // status will be 0 for file:// urls

  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;

    try {
      response =
      /** @type {!UTFGridJSON} */
      JSON.parse(client.responseText);
    } catch (err) {
      this.handleError_();
      return;
    }

    this.handleLoad_(response);
  } else {
    this.handleError_();
  }
};
/**
 * @private
 * @param {Event} event The error event.
 */


_ol_source_TileUTFGrid_.Tile_.prototype.onXHRError_ = function (event) {
  this.handleError_();
};
/**
 * @override
 */


_ol_source_TileUTFGrid_.Tile_.prototype.load = function () {
  if (this.preemptive_) {
    this.loadInternal_();
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileUTFGrid_);

/***/ }),

/***/ "./node_modules/ol/source/tilewms.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/tilewms.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/wmsservertype.js */ "./node_modules/ol/source/wmsservertype.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
// FIXME add minZoom support
// FIXME add date line wrap (tile coord transform)
// FIXME cannot be shared between maps with different projections













/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.TileWMSOptions=} opt_options Tile WMS options.
 * @api
 */

var _ol_source_TileWMS_ = function (opt_options) {
  var options = opt_options || {};
  var params = options.params || {};
  var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    opaque: !transparent,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileClass: options.tileClass,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
  /**
   * @private
   * @type {number}
   */


  this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
  /**
   * @private
   * @type {!Object}
   */

  this.params_ = params;
  /**
   * @private
   * @type {boolean}
   */

  this.v13_ = true;
  /**
   * @private
   * @type {ol.source.WMSServerType|undefined}
   */

  this.serverType_ =
  /** @type {ol.source.WMSServerType|undefined} */
  options.serverType;
  /**
   * @private
   * @type {boolean}
   */

  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.tmpExtent_ = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createEmpty();
  this.updateV13_();
  this.setKey(this.getKeyForParams_());
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_TileWMS_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
 * projection. Return `undefined` if the GetFeatureInfo URL cannot be
 * constructed.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.ProjectionLike} projection Projection.
 * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
 *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
 *     in the `LAYERS` parameter will be used. `VERSION` should not be
 *     specified here.
 * @return {string|undefined} GetFeatureInfo URL.
 * @api
 */


_ol_source_TileWMS_.prototype.getGetFeatureInfoUrl = function (coordinate, resolution, projection, params) {
  var projectionObj = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(projection);

  var sourceProjectionObj = this.getProjection();
  var tileGrid = this.getTileGrid();

  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projectionObj);
  }

  var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

  var gutter = this.gutter_;

  if (gutter !== 0) {
    tileSize = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].buffer(tileSize, gutter, this.tmpSize);
    tileExtent = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].buffer(tileExtent, tileResolution * gutter, tileExtent);
  }

  if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
    tileResolution = _reproj_js__WEBPACK_IMPORTED_MODULE_6__["default"].calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
    tileExtent = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].transformExtent(tileExtent, projectionObj, sourceProjectionObj);
    coordinate = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].transform(coordinate, projectionObj, sourceProjectionObj);
  }

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION,
    'REQUEST': 'GetFeatureInfo',
    'FORMAT': 'image/png',
    'TRANSPARENT': true,
    'QUERY_LAYERS': this.params_['LAYERS']
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].assign(baseParams, this.params_, params);

  var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
  var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
  baseParams[this.v13_ ? 'I' : 'X'] = x;
  baseParams[this.v13_ ? 'J' : 'Y'] = y;
  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
};
/**
 * @inheritDoc
 */


_ol_source_TileWMS_.prototype.getGutterInternal = function () {
  return this.gutter_;
};
/**
 * Get the user-provided params, i.e. those passed to the constructor through
 * the "params" option, and possibly updated using the updateParams method.
 * @return {Object} Params.
 * @api
 */


_ol_source_TileWMS_.prototype.getParams = function () {
  return this.params_;
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Size} tileSize Tile size.
 * @param {ol.Extent} tileExtent Tile extent.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object} params Params.
 * @return {string|undefined} Request URL.
 * @private
 */


_ol_source_TileWMS_.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
  var urls = this.urls;

  if (!urls) {
    return undefined;
  }

  params['WIDTH'] = tileSize[0];
  params['HEIGHT'] = tileSize[1];
  params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

  if (!('STYLES' in this.params_)) {
    params['STYLES'] = '';
  }

  if (pixelRatio != 1) {
    switch (this.serverType_) {
      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_9__["default"].GEOSERVER:
        var dpi = 90 * pixelRatio + 0.5 | 0;

        if ('FORMAT_OPTIONS' in params) {
          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
        } else {
          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
        }

        break;

      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_9__["default"].MAPSERVER:
        params['MAP_RESOLUTION'] = 90 * pixelRatio;
        break;

      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_9__["default"].CARMENTA_SERVER:
      case _source_wmsservertype_js__WEBPACK_IMPORTED_MODULE_9__["default"].QGIS:
        params['DPI'] = 90 * pixelRatio;
        break;

      default:
        _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(false, 52); // Unknown `serverType` configured


        break;
    }
  }

  var axisOrientation = projection.getAxisOrientation();
  var bbox = tileExtent;

  if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
    var tmp;
    tmp = tileExtent[0];
    bbox[0] = tileExtent[1];
    bbox[1] = tmp;
    tmp = tileExtent[2];
    bbox[2] = tileExtent[3];
    bbox[3] = tmp;
  }

  params['BBOX'] = bbox.join(',');
  var url;

  if (urls.length == 1) {
    url = urls[0];
  } else {
    var index = _math_js__WEBPACK_IMPORTED_MODULE_4__["default"].modulo(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["default"].hash(tileCoord), urls.length);

    url = urls[index];
  }

  return _uri_js__WEBPACK_IMPORTED_MODULE_12__["default"].appendParams(url, params);
};
/**
 * @inheritDoc
 */


_ol_source_TileWMS_.prototype.getTilePixelRatio = function (pixelRatio) {
  return !this.hidpi_ || this.serverType_ === undefined ? 1 :
  /** @type {number} */
  pixelRatio;
};
/**
 * @private
 * @return {string} The key for the current params.
 */


_ol_source_TileWMS_.prototype.getKeyForParams_ = function () {
  var i = 0;
  var res = [];

  for (var key in this.params_) {
    res[i++] = key + '-' + this.params_[key];
  }

  return res.join('/');
};
/**
 * @inheritDoc
 */


_ol_source_TileWMS_.prototype.fixedTileUrlFunction = function (tileCoord, pixelRatio, projection) {
  var tileGrid = this.getTileGrid();

  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }

  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

  var gutter = this.gutter_;

  if (gutter !== 0) {
    tileSize = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].buffer(tileSize, gutter, this.tmpSize);
    tileExtent = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].buffer(tileExtent, tileResolution * gutter, tileExtent);
  }

  if (pixelRatio != 1) {
    tileSize = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].scale(tileSize, pixelRatio, this.tmpSize);
  }

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION,
    'REQUEST': 'GetMap',
    'FORMAT': 'image/png',
    'TRANSPARENT': true
  };

  _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].assign(baseParams, this.params_);

  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
};
/**
 * Update the user-provided params.
 * @param {Object} params Params.
 * @api
 */


_ol_source_TileWMS_.prototype.updateParams = function (params) {
  _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].assign(this.params_, params);

  this.updateV13_();
  this.setKey(this.getKeyForParams_());
};
/**
 * @private
 */


_ol_source_TileWMS_.prototype.updateV13_ = function () {
  var version = this.params_['VERSION'] || _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_WMS_VERSION;
  this.v13_ = _string_js__WEBPACK_IMPORTED_MODULE_11__["default"].compareVersions(version, '1.3') >= 0;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_TileWMS_);

/***/ }),

/***/ "./node_modules/ol/source/urltile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/urltile.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _source_tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/tile.js */ "./node_modules/ol/source/tile.js");
/* harmony import */ var _source_tileeventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/tileeventtype.js */ "./node_modules/ol/source/tileeventtype.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");






/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires ol.source.Tile.Event
 * @extends {ol.source.Tile}
 * @param {ol.SourceUrlTileOptions} options Image tile options.
 */

var _ol_source_UrlTile_ = function (options) {
  _source_tile_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tilePixelRatio: options.tilePixelRatio,
    wrapX: options.wrapX,
    transition: options.transition
  });
  /**
   * @protected
   * @type {ol.TileLoadFunctionType}
   */


  this.tileLoadFunction = options.tileLoadFunction;
  /**
   * @protected
   * @type {ol.TileUrlFunctionType}
   */

  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["default"].nullTileUrlFunction;
  /**
   * @protected
   * @type {!Array.<string>|null}
   */

  this.urls = null;

  if (options.urls) {
    this.setUrls(options.urls);
  } else if (options.url) {
    this.setUrl(options.url);
  }

  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }
  /**
   * @private
   * @type {Object.<number, boolean>}
   */


  this.tileLoadingKeys_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_UrlTile_, _source_tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @type {ol.TileUrlFunctionType|undefined}
 * @protected
 */


_ol_source_UrlTile_.prototype.fixedTileUrlFunction;
/**
 * Return the tile load function of the source.
 * @return {ol.TileLoadFunctionType} TileLoadFunction
 * @api
 */

_ol_source_UrlTile_.prototype.getTileLoadFunction = function () {
  return this.tileLoadFunction;
};
/**
 * Return the tile URL function of the source.
 * @return {ol.TileUrlFunctionType} TileUrlFunction
 * @api
 */


_ol_source_UrlTile_.prototype.getTileUrlFunction = function () {
  return this.tileUrlFunction;
};
/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */


_ol_source_UrlTile_.prototype.getUrls = function () {
  return this.urls;
};
/**
 * Handle tile change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_source_UrlTile_.prototype.handleTileChange = function (event) {
  var tile =
  /** @type {ol.Tile} */
  event.target;

  var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(tile);

  var tileState = tile.getState();
  var type;

  if (tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
    this.tileLoadingKeys_[uid] = true;
    type = _source_tileeventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADSTART;
  } else if (uid in this.tileLoadingKeys_) {
    delete this.tileLoadingKeys_[uid];
    type = tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _source_tileeventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADERROR : tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || tileState == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT ? _source_tileeventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADEND : undefined;
  }

  if (type != undefined) {
    this.dispatchEvent(new _source_tile_js__WEBPACK_IMPORTED_MODULE_3__["default"].Event(type, tile));
  }
};
/**
 * Set the tile load function of the source.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @api
 */


_ol_source_UrlTile_.prototype.setTileLoadFunction = function (tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};
/**
 * Set the tile URL function of the source.
 * @param {ol.TileUrlFunctionType} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */


_ol_source_UrlTile_.prototype.setTileUrlFunction = function (tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  this.tileCache.pruneExceptNewestZ();

  if (typeof opt_key !== 'undefined') {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};
/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */


_ol_source_UrlTile_.prototype.setUrl = function (url) {
  var urls = this.urls = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["default"].expandUrl(url);

  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["default"].createFromTemplates(urls, this.tileGrid), url);
};
/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */


_ol_source_UrlTile_.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["default"].createFromTemplates(urls, this.tileGrid), key);
};
/**
 * @inheritDoc
 */


_ol_source_UrlTile_.prototype.useTile = function (z, x, y) {
  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["default"].getKeyZXY(z, x, y);

  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_UrlTile_);

/***/ }),

/***/ "./node_modules/ol/source/vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/vector.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection.js */ "./node_modules/ol/collection.js");
/* harmony import */ var _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collectioneventtype.js */ "./node_modules/ol/collectioneventtype.js");
/* harmony import */ var _objecteventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objecteventtype.js */ "./node_modules/ol/objecteventtype.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/event.js */ "./node_modules/ol/events/event.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../source/source.js */ "./node_modules/ol/source/source.js");
/* harmony import */ var _source_state_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../source/state.js */ "./node_modules/ol/source/state.js");
/* harmony import */ var _source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/vectoreventtype.js */ "./node_modules/ol/source/vectoreventtype.js");
/* harmony import */ var _structs_rbush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../structs/rbush.js */ "./node_modules/ol/structs/rbush.js");
// FIXME bulk feature upload - suppress events
// FIXME make change-detection more refined (notably, geometry hint)


















/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @constructor
 * @extends {ol.source.Source}
 * @fires ol.source.Vector.Event
 * @param {olx.source.VectorOptions=} opt_options Vector source options.
 * @api
 */

var _ol_source_Vector_ = function (opt_options) {
  var options = opt_options || {};

  _source_source_js__WEBPACK_IMPORTED_MODULE_14__["default"].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: undefined,
    state: _source_state_js__WEBPACK_IMPORTED_MODULE_15__["default"].READY,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });
  /**
   * @private
   * @type {ol.FeatureLoader}
   */


  this.loader_ = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
  /**
   * @private
   * @type {ol.format.Feature|undefined}
   */

  this.format_ = options.format;
  /**
   * @private
   * @type {boolean}
   */

  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
  /**
   * @private
   * @type {string|ol.FeatureUrlFunction|undefined}
   */

  this.url_ = options.url;

  if (options.loader !== undefined) {
    this.loader_ = options.loader;
  } else if (this.url_ !== undefined) {
    _asserts_js__WEBPACK_IMPORTED_MODULE_5__["default"].assert(this.format_, 7); // `format` must be set when `url` is set
    // create a XHR feature loader for "url" and "format"


    this.loader_ = _featureloader_js__WEBPACK_IMPORTED_MODULE_10__["default"].xhr(this.url_,
    /** @type {ol.format.Feature} */
    this.format_);
  }
  /**
   * @private
   * @type {ol.LoadingStrategy}
   */


  this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__["default"].all;
  var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
  /**
   * @private
   * @type {ol.structs.RBush.<ol.Feature>}
   */

  this.featuresRtree_ = useSpatialIndex ? new _structs_rbush_js__WEBPACK_IMPORTED_MODULE_17__["default"]() : null;
  /**
   * @private
   * @type {ol.structs.RBush.<{extent: ol.Extent}>}
   */

  this.loadedExtentsRtree_ = new _structs_rbush_js__WEBPACK_IMPORTED_MODULE_17__["default"]();
  /**
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.nullGeometryFeatures_ = {};
  /**
   * A lookup of features by id (the return from feature.getId()).
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.idIndex_ = {};
  /**
   * A lookup of features without id (keyed by ol.getUid(feature)).
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.undefIdIndex_ = {};
  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */

  this.featureChangeKeys_ = {};
  /**
   * @private
   * @type {ol.Collection.<ol.Feature>}
   */

  this.featuresCollection_ = null;
  var collection, features;

  if (options.features instanceof _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    collection = options.features;
    features = collection.getArray();
  } else if (Array.isArray(options.features)) {
    features = options.features;
  }

  if (!useSpatialIndex && collection === undefined) {
    collection = new _collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](features);
  }

  if (features !== undefined) {
    this.addFeaturesInternal(features);
  }

  if (collection !== undefined) {
    this.bindFeaturesCollection_(collection);
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Vector_, _source_source_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead. A feature will not be added to the source if feature with
 * the same id is already there. The reason for this behavior is to avoid
 * feature duplication when using bbox or tile loading strategies.
 * @param {ol.Feature} feature Feature to add.
 * @api
 */


_ol_source_Vector_.prototype.addFeature = function (feature) {
  this.addFeatureInternal(feature);
  this.changed();
};
/**
 * Add a feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */


_ol_source_Vector_.prototype.addFeatureInternal = function (feature) {
  var featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }

  this.setupChangeEvents_(featureKey, feature);
  var geometry = feature.getGeometry();

  if (geometry) {
    var extent = geometry.getExtent();

    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }

  this.dispatchEvent(new _ol_source_Vector_.Event(_source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, feature));
};
/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @private
 */


_ol_source_Vector_.prototype.setupChangeEvents_ = function (featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(feature, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE, this.handleFeatureChange_, this), _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(feature, _objecteventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE, this.handleFeatureChange_, this)];
};
/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */


_ol_source_Vector_.prototype.addToIndex_ = function (featureKey, feature) {
  var valid = true;
  var id = feature.getId();

  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    _asserts_js__WEBPACK_IMPORTED_MODULE_5__["default"].assert(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source


    this.undefIdIndex_[featureKey] = feature;
  }

  return valid;
};
/**
 * Add a batch of features to the source.
 * @param {Array.<ol.Feature>} features Features to add.
 * @api
 */


_ol_source_Vector_.prototype.addFeatures = function (features) {
  this.addFeaturesInternal(features);
  this.changed();
};
/**
 * Add features without firing a `change` event.
 * @param {Array.<ol.Feature>} features Features.
 * @protected
 */


_ol_source_Vector_.prototype.addFeaturesInternal = function (features) {
  var featureKey, i, length, feature;
  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];

  for (i = 0, length = features.length; i < length; i++) {
    feature = features[i];
    featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

    if (this.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    feature = newFeatures[i];
    featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();
    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature);
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    this.dispatchEvent(new _ol_source_Vector_.Event(_source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, newFeatures[i]));
  }
};
/**
 * @param {!ol.Collection.<ol.Feature>} collection Collection.
 * @private
 */


_ol_source_Vector_.prototype.bindFeaturesCollection_ = function (collection) {
  var modifyingCollection = false;

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.push(evt.feature);
      modifyingCollection = false;
    }
  });

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(this, _source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.remove(evt.feature);
      modifyingCollection = false;
    }
  });

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(collection, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.addFeature(
      /** @type {ol.Feature} */
      evt.element);
      modifyingCollection = false;
    }
  }, this);

  _events_js__WEBPACK_IMPORTED_MODULE_6__["default"].listen(collection, _collectioneventtype_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.removeFeature(
      /** @type {ol.Feature} */
      evt.element);
      modifyingCollection = false;
    }
  }, this);

  this.featuresCollection_ = collection;
};
/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.
 * @api
 */


_ol_source_Vector_.prototype.clear = function (opt_fast) {
  if (opt_fast) {
    for (var featureId in this.featureChangeKeys_) {
      var keys = this.featureChangeKeys_[featureId];
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey);
    }

    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);

      for (var id in this.nullGeometryFeatures_) {
        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
      }
    }
  }

  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }

  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};
  var clearEvent = new _ol_source_Vector_.Event(_source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};
/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 *
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeature = function (callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};
/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 */


_ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback, opt_this) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function (feature) {
    var geometry = feature.getGeometry();

    if (geometry.intersectsCoordinate(coordinate)) {
      return callback.call(opt_this, feature);
    } else {
      return undefined;
    }
  });
};
/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link ol.source.Vector#forEachFeature}.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeatureInExtent = function (extent, callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};
/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeatureIntersectingExtent = function (extent, callback, opt_this) {
  return this.forEachFeatureInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   * @return {S|undefined} The return value from the last call to the callback.
   * @template S
   */
  function (feature) {
    var geometry = feature.getGeometry();

    if (geometry.intersectsExtent(extent)) {
      var result = callback.call(opt_this, feature);

      if (result) {
        return result;
      }
    }
  });
};
/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link ol.Collection} as `features`.
 * @return {ol.Collection.<ol.Feature>} The collection of features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesCollection = function () {
  return this.featuresCollection_;
};
/**
 * Get all features on the source in random order.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeatures = function () {
  var features;

  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else if (this.featuresRtree_) {
    features = this.featuresRtree_.getAll();

    if (!_obj_js__WEBPACK_IMPORTED_MODULE_13__["default"].isEmpty(this.nullGeometryFeatures_)) {
      _array_js__WEBPACK_IMPORTED_MODULE_4__["default"].extend(features, _obj_js__WEBPACK_IMPORTED_MODULE_13__["default"].getValues(this.nullGeometryFeatures_));
    }
  }

  return (
    /** @type {Array.<ol.Feature>} */
    features
  );
};
/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesAtCoordinate = function (coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
    features.push(feature);
  });
  return features;
};
/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesInExtent = function (extent) {
  return this.featuresRtree_.getInExtent(extent);
};
/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {ol.Feature} Closest feature.
 * @api
 */


_ol_source_Vector_.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
  // Find the closest feature using branch and bound.  We start searching an
  // infinite extent, and find the distance from the first feature found.  This
  // becomes the closest feature.  We then compute a smaller extent which any
  // closer feature must intersect.  We continue searching with this smaller
  // extent, trying to find a closer feature.  Every time we find a closer
  // feature, we update the extent being searched so that any even closer
  // feature must intersect it.  We continue until we run out of features.
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_11__["default"].TRUE;
  this.featuresRtree_.forEachInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   */
  function (feature) {
    if (filter(feature)) {
      var geometry = feature.getGeometry();
      var previousMinSquaredDistance = minSquaredDistance;
      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

      if (minSquaredDistance < previousMinSquaredDistance) {
        closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
        // searched while the R-Tree traversal using this same extent object
        // is still in progress.  This is safe because the new extent is
        // strictly contained by the old extent.

        var minDistance = Math.sqrt(minSquaredDistance);
        extent[0] = x - minDistance;
        extent[1] = y - minDistance;
        extent[2] = x + minDistance;
        extent[3] = y + minDistance;
      }
    }
  });
  return closestFeature;
};
/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_source_Vector_.prototype.getExtent = function (opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};
/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {ol.Feature} The feature (or `null` if not found).
 * @api
 */


_ol_source_Vector_.prototype.getFeatureById = function (id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};
/**
 * Get the format associated with this source.
 *
 * @return {ol.format.Feature|undefined} The feature format.
 * @api
 */


_ol_source_Vector_.prototype.getFormat = function () {
  return this.format_;
};
/**
 * @return {boolean} The source can have overlapping geometries.
 */


_ol_source_Vector_.prototype.getOverlaps = function () {
  return this.overlaps_;
};
/**
 * @override
 */


_ol_source_Vector_.prototype.getResolutions = function () {};
/**
 * Get the url associated with this source.
 *
 * @return {string|ol.FeatureUrlFunction|undefined} The url.
 * @api
 */


_ol_source_Vector_.prototype.getUrl = function () {
  return this.url_;
};
/**
 * @param {ol.events.Event} event Event.
 * @private
 */


_ol_source_Vector_.prototype.handleFeatureChange_ = function (event) {
  var feature =
  /** @type {ol.Feature} */
  event.target;

  var featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  var geometry = feature.getGeometry();

  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }

      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();

    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];

      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }

  var id = feature.getId();

  if (id !== undefined) {
    var sid = id.toString();

    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }

  this.changed();
  this.dispatchEvent(new _ol_source_Vector_.Event(_source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGEFEATURE, feature));
};
/**
 * @return {boolean} Is empty.
 */


_ol_source_Vector_.prototype.isEmpty = function () {
  return this.featuresRtree_.isEmpty() && _obj_js__WEBPACK_IMPORTED_MODULE_13__["default"].isEmpty(this.nullGeometryFeatures_);
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 */


_ol_source_Vector_.prototype.loadFeatures = function (extent, resolution, projection) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var i, ii;

  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
    /**
     * @param {{extent: ol.Extent}} object Object.
     * @return {boolean} Contains.
     */
    function (object) {
      return _extent_js__WEBPACK_IMPORTED_MODULE_9__["default"].containsExtent(object.extent, extentToLoad);
    });

    if (!alreadyLoaded) {
      this.loader_.call(this, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, {
        extent: extentToLoad.slice()
      });
    }
  }
};
/**
 * Remove an extent from the list of loaded extents.
 * @param {ol.Extent} extent Extent.
 * @api
 */


_ol_source_Vector_.prototype.removeLoadedExtent = function (extent) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var obj;
  loadedExtentsRtree.forEachInExtent(extent, function (object) {
    if (_extent_js__WEBPACK_IMPORTED_MODULE_9__["default"].equals(object.extent, extent)) {
      obj = object;
      return true;
    }
  });

  if (obj) {
    loadedExtentsRtree.remove(obj);
  }
};
/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link ol.source.Vector#clear source.clear()} method
 * instead.
 * @param {ol.Feature} feature Feature to remove.
 * @api
 */


_ol_source_Vector_.prototype.removeFeature = function (feature) {
  var featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }

  this.removeFeatureInternal(feature);
  this.changed();
};
/**
 * Remove feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */


_ol_source_Vector_.prototype.removeFeatureInternal = function (feature) {
  var featureKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(feature).toString();

  this.featureChangeKeys_[featureKey].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["default"].unlistenByKey);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();

  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }

  this.dispatchEvent(new _ol_source_Vector_.Event(_source_vectoreventtype_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, feature));
};
/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */


_ol_source_Vector_.prototype.removeFromIdIndex_ = function (feature) {
  var removed = false;

  for (var id in this.idIndex_) {
    if (this.idIndex_[id] === feature) {
      delete this.idIndex_[id];
      removed = true;
      break;
    }
  }

  return removed;
};
/**
 * Set the new loader of the source. The next loadFeatures call will use the
 * new loader.
 * @param {ol.FeatureLoader} loader The loader to set.
 * @api
 */


_ol_source_Vector_.prototype.setLoader = function (loader) {
  this.loader_ = loader;
};
/**
 * @classdesc
 * Events emitted by {@link ol.source.Vector} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Vector.Event}
 * @param {string} type Type.
 * @param {ol.Feature=} opt_feature Feature.
 */


_ol_source_Vector_.Event = function (type, opt_feature) {
  _events_event_js__WEBPACK_IMPORTED_MODULE_7__["default"].call(this, type);
  /**
   * The feature being added or removed.
   * @type {ol.Feature|undefined}
   * @api
   */


  this.feature = opt_feature;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Vector_.Event, _events_event_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Vector_);

/***/ }),

/***/ "./node_modules/ol/source/vectoreventtype.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/vectoreventtype.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_source_VectorEventType_ = {
  /**
   * Triggered when a feature is added to the source.
   * @event ol.source.Vector.Event#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol.source.Vector.Event#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol.source.Vector.Event#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link ol.source.Vector#clear source.clear()} for exceptions.
   * @event ol.source.Vector.Event#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_VectorEventType_);

/***/ }),

/***/ "./node_modules/ol/source/vectortile.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/source/vectortile.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _vectorimagetile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vectorimagetile.js */ "./node_modules/ol/vectorimagetile.js");
/* harmony import */ var _vectortile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vectortile.js */ "./node_modules/ol/vectortile.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_urltile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../source/urltile.js */ "./node_modules/ol/source/urltile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");








/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link ol.layer.VectorTile}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link ol.source.Vector} for vector sources that are suitable for feature
 * editing.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.VectorTileOptions} options Vector tile options.
 * @api
 */

var _ol_source_VectorTile_ = function (options) {
  var projection = options.projection || 'EPSG:3857';

  var extent = options.extent || _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["default"].extentFromProjection(projection);

  var tileGrid = options.tileGrid || _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["default"].createXYZ({
    extent: extent,
    maxZoom: options.maxZoom || 22,
    minZoom: options.minZoom,
    tileSize: options.tileSize || 512
  });

  _source_urltile_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,
    extent: extent,
    logo: options.logo,
    opaque: false,
    projection: projection,
    state: options.state,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _vectorimagetile_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultLoadFunction,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX === undefined ? true : options.wrapX,
    transition: options.transition
  });
  /**
   * @private
   * @type {ol.format.Feature}
   */


  this.format_ = options.format ? options.format : null;
  /**
   * @private
   * @type {Object.<string,ol.VectorTile>}
   */

  this.sourceTiles_ = {};
  /**
   * @private
   * @type {boolean}
   */

  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
  /**
   * @protected
   * @type {function(new: ol.VectorTile, ol.TileCoord, ol.TileState, string,
   *        ol.format.Feature, ol.TileLoadFunctionType)}
   */

  this.tileClass = options.tileClass ? options.tileClass : _vectortile_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  /**
   * @private
   * @type {Object.<string,ol.tilegrid.TileGrid>}
   */

  this.tileGrids_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_VectorTile_, _source_urltile_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @return {boolean} The source can have overlapping geometries.
 */


_ol_source_VectorTile_.prototype.getOverlaps = function () {
  return this.overlaps_;
};
/**
 * clear {@link ol.TileCache} and delete all source tiles
 * @api
 */


_ol_source_VectorTile_.prototype.clear = function () {
  this.tileCache.clear();
  this.sourceTiles_ = {};
};
/**
 * @inheritDoc
 */


_ol_source_VectorTile_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var tileCoordKey = _tilecoord_js__WEBPACK_IMPORTED_MODULE_6__["default"].getKeyZXY(z, x, y);

  if (this.tileCache.containsKey(tileCoordKey)) {
    return (
      /** @type {!ol.Tile} */
      this.tileCache.get(tileCoordKey)
    );
  } else {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tile = new _vectorimagetile_js__WEBPACK_IMPORTED_MODULE_2__["default"](tileCoord, urlTileCoord !== null ? _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY, this.getRevision(), this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction, this.tileGrid, this.getTileGridForProjection(projection), this.sourceTiles_, pixelRatio, projection, this.tileClass, this.handleTileChange.bind(this), this.tileOptions);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
/**
 * @inheritDoc
 */


_ol_source_VectorTile_.prototype.getTileGridForProjection = function (projection) {
  var code = projection.getCode();
  var tileGrid = this.tileGrids_[code];

  if (!tileGrid) {
    // A tile grid that matches the tile size of the source tile grid is more
    // likely to have 1:1 relationships between source tiles and rendered tiles.
    var sourceTileGrid = this.tileGrid;
    tileGrid = this.tileGrids_[code] = _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["default"].createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);
  }

  return tileGrid;
};
/**
 * @inheritDoc
 */


_ol_source_VectorTile_.prototype.getTilePixelRatio = function (pixelRatio) {
  return pixelRatio;
};
/**
 * @inheritDoc
 */


_ol_source_VectorTile_.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_4__["default"].toSize(this.getTileGridForProjection(projection).getTileSize(z));

  return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_VectorTile_);

/***/ }),

/***/ "./node_modules/ol/source/wmsservertype.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/wmsservertype.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
 *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
 *     specification that OpenLayers can make use of.
 * @enum {string}
 */
var _ol_source_WMSServerType_ = {
  CARMENTA_SERVER: 'carmentaserver',
  GEOSERVER: 'geoserver',
  MAPSERVER: 'mapserver',
  QGIS: 'qgis'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_WMSServerType_);

/***/ }),

/***/ "./node_modules/ol/source/wmts.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/wmts.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/wmtsrequestencoding.js */ "./node_modules/ol/source/wmtsrequestencoding.js");
/* harmony import */ var _tilegrid_wmts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid/wmts.js */ "./node_modules/ol/tilegrid/wmts.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");










/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.WMTSOptions} options WMTS options.
 * @api
 */

var _ol_source_WMTS_ = function (options) {
  // TODO: add support for TileMatrixLimits

  /**
   * @private
   * @type {string}
   */
  this.version_ = options.version !== undefined ? options.version : '1.0.0';
  /**
   * @private
   * @type {string}
   */

  this.format_ = options.format !== undefined ? options.format : 'image/jpeg';
  /**
   * @private
   * @type {!Object}
   */

  this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};
  /**
   * @private
   * @type {string}
   */

  this.layer_ = options.layer;
  /**
   * @private
   * @type {string}
   */

  this.matrixSet_ = options.matrixSet;
  /**
   * @private
   * @type {string}
   */

  this.style_ = options.style;
  var urls = options.urls;

  if (urls === undefined && options.url !== undefined) {
    urls = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].expandUrl(options.url);
  } // FIXME: should we guess this requestEncoding from options.url(s)
  //        structure? that would mean KVP only if a template is not provided.

  /**
   * @private
   * @type {ol.source.WMTSRequestEncoding}
   */


  this.requestEncoding_ = options.requestEncoding !== undefined ?
  /** @type {ol.source.WMTSRequestEncoding} */
  options.requestEncoding : _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP;
  var requestEncoding = this.requestEncoding_; // FIXME: should we create a default tileGrid?
  // we could issue a getCapabilities xhr to retrieve missing configuration

  var tileGrid = options.tileGrid; // context property names are lower case to allow for a case insensitive
  // replacement as some services use different naming conventions

  var context = {
    'layer': this.layer_,
    'style': this.style_,
    'tilematrixset': this.matrixSet_
  };

  if (requestEncoding == _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP) {
    _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign(context, {
      'Service': 'WMTS',
      'Request': 'GetTile',
      'Version': this.version_,
      'Format': this.format_
    });
  }

  var dimensions = this.dimensions_;
  /**
   * @param {string} template Template.
   * @return {ol.TileUrlFunctionType} Tile URL function.
   * @private
   */

  this.createFromWMTSTemplate_ = function (template) {
    // TODO: we may want to create our own appendParams function so that params
    // order conforms to wmts spec guidance, and so that we can avoid to escape
    // special template params
    template = requestEncoding == _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP ? _uri_js__WEBPACK_IMPORTED_MODULE_9__["default"].appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function (m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    return (
      /**
       * @param {ol.TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {ol.proj.Projection} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          var localContext = {
            'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
            'TileCol': tileCoord[1],
            'TileRow': -tileCoord[2] - 1
          };

          _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign(localContext, dimensions);

          var url = template;

          if (requestEncoding == _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP) {
            url = _uri_js__WEBPACK_IMPORTED_MODULE_9__["default"].appendParams(url, localContext);
          } else {
            url = url.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext[p];
            });
          }

          return url;
        }
      }
    );
  };

  var tileUrlFunction = urls && urls.length > 0 ? _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate_)) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].nullTileUrlFunction;

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileClass: options.tileClass,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: tileUrlFunction,
    urls: urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : false,
    transition: options.transition
  });

  this.setKey(this.getKeyForDimensions_());
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_WMTS_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * Set the URLs to use for requests.
 * URLs may contain OCG conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
 * @override
 */


_ol_source_WMTS_.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_1__["default"].createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate_.bind(this))), key);
};
/**
 * Get the dimensions, i.e. those passed to the constructor through the
 * "dimensions" option, and possibly updated using the updateDimensions
 * method.
 * @return {!Object} Dimensions.
 * @api
 */


_ol_source_WMTS_.prototype.getDimensions = function () {
  return this.dimensions_;
};
/**
 * Return the image format of the WMTS source.
 * @return {string} Format.
 * @api
 */


_ol_source_WMTS_.prototype.getFormat = function () {
  return this.format_;
};
/**
 * Return the layer of the WMTS source.
 * @return {string} Layer.
 * @api
 */


_ol_source_WMTS_.prototype.getLayer = function () {
  return this.layer_;
};
/**
 * Return the matrix set of the WMTS source.
 * @return {string} MatrixSet.
 * @api
 */


_ol_source_WMTS_.prototype.getMatrixSet = function () {
  return this.matrixSet_;
};
/**
 * Return the request encoding, either "KVP" or "REST".
 * @return {ol.source.WMTSRequestEncoding} Request encoding.
 * @api
 */


_ol_source_WMTS_.prototype.getRequestEncoding = function () {
  return this.requestEncoding_;
};
/**
 * Return the style of the WMTS source.
 * @return {string} Style.
 * @api
 */


_ol_source_WMTS_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Return the version of the WMTS source.
 * @return {string} Version.
 * @api
 */


_ol_source_WMTS_.prototype.getVersion = function () {
  return this.version_;
};
/**
 * @private
 * @return {string} The key for the current dimensions.
 */


_ol_source_WMTS_.prototype.getKeyForDimensions_ = function () {
  var i = 0;
  var res = [];

  for (var key in this.dimensions_) {
    res[i++] = key + '-' + this.dimensions_[key];
  }

  return res.join('/');
};
/**
 * Update the dimensions.
 * @param {Object} dimensions Dimensions.
 * @api
 */


_ol_source_WMTS_.prototype.updateDimensions = function (dimensions) {
  _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign(this.dimensions_, dimensions);

  this.setKey(this.getKeyForDimensions_());
};
/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {?olx.source.WMTSOptions} WMTS source options object or `null` if the layer was not found.
 * @api
 */


_ol_source_WMTS_.optionsFromCapabilities = function (wmtsCap, config) {
  var layers = wmtsCap['Contents']['Layer'];

  var l = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].find(layers, function (elt, index, array) {
    return elt['Identifier'] == config['layer'];
  });

  if (l === null) {
    return null;
  }

  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var idx, matrixSet, matrixLimits;

  if (l['TileMatrixSetLink'].length > 1) {
    if ('projection' in config) {
      idx = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].findIndex(l['TileMatrixSetLink'], function (elt, index, array) {
        var tileMatrixSet = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].find(tileMatrixSets, function (el) {
          return el['Identifier'] == elt['TileMatrixSet'];
        });

        var supportedCRS = tileMatrixSet['SupportedCRS'];

        var proj1 = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(supportedCRS);

        var proj2 = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(config['projection']);

        if (proj1 && proj2) {
          return _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].equivalent(proj1, proj2);
        } else {
          return supportedCRS == config['projection'];
        }
      });
    } else {
      idx = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].findIndex(l['TileMatrixSetLink'], function (elt, index, array) {
        return elt['TileMatrixSet'] == config['matrixSet'];
      });
    }
  } else {
    idx = 0;
  }

  if (idx < 0) {
    idx = 0;
  }

  matrixSet =
  /** @type {string} */
  l['TileMatrixSetLink'][idx]['TileMatrixSet'];
  matrixLimits =
  /** @type {Array.<Object>} */
  l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];
  var format =
  /** @type {string} */
  l['Format'][0];

  if ('format' in config) {
    format = config['format'];
  }

  idx = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].findIndex(l['Style'], function (elt, index, array) {
    if ('style' in config) {
      return elt['Title'] == config['style'];
    } else {
      return elt['isDefault'];
    }
  });

  if (idx < 0) {
    idx = 0;
  }

  var style =
  /** @type {string} */
  l['Style'][idx]['Identifier'];
  var dimensions = {};

  if ('Dimension' in l) {
    l['Dimension'].forEach(function (elt, index, array) {
      var key = elt['Identifier'];
      var value = elt['Default'];

      if (value === undefined) {
        value = elt['Value'][0];
      }

      dimensions[key] = value;
    });
  }

  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];

  var matrixSetObj = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].find(matrixSets, function (elt, index, array) {
    return elt['Identifier'] == matrixSet;
  });

  var projection;
  var code = matrixSetObj['SupportedCRS'];

  if (code) {
    projection = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(code);
  }

  if ('projection' in config) {
    var projConfig = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(config['projection']);

    if (projConfig) {
      if (!projection || _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].equivalent(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }

  var wgs84BoundingBox = l['WGS84BoundingBox'];
  var extent, wrapX;

  if (wgs84BoundingBox !== undefined) {
    var wgs84ProjectionExtent = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get('EPSG:4326').getExtent();

    wrapX = wgs84BoundingBox[0] == wgs84ProjectionExtent[0] && wgs84BoundingBox[2] == wgs84ProjectionExtent[2];
    extent = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].transformExtent(wgs84BoundingBox, 'EPSG:4326', projection);
    var projectionExtent = projection.getExtent();

    if (projectionExtent) {
      // If possible, do a sanity check on the extent - it should never be
      // bigger than the validity extent of the projection of a matrix set.
      if (!_extent_js__WEBPACK_IMPORTED_MODULE_3__["default"].containsExtent(projectionExtent, extent)) {
        extent = undefined;
      }
    }
  }

  var tileGrid = _tilegrid_wmts_js__WEBPACK_IMPORTED_MODULE_8__["default"].createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
  /** @type {!Array.<string>} */


  var urls = [];
  var requestEncoding = config['requestEncoding'];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';

  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];

    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]['Constraint']) {
        var constraint = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].find(gets[i]['Constraint'], function (element) {
          return element['name'] == 'GetEncoding';
        });

        var encodings = constraint['AllowedValues']['Value'];

        if (requestEncoding === '') {
          // requestEncoding not provided, use the first encoding from the list
          requestEncoding = encodings[0];
        }

        if (requestEncoding === _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP) {
          if (_array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(encodings, _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP)) {
            urls.push(
            /** @type {string} */
            gets[i]['href']);
          }
        } else {
          break;
        }
      } else if (gets[i]['href']) {
        requestEncoding = _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].KVP;
        urls.push(
        /** @type {string} */
        gets[i]['href']);
      }
    }
  }

  if (urls.length === 0) {
    requestEncoding = _source_wmtsrequestencoding_js__WEBPACK_IMPORTED_MODULE_7__["default"].REST;
    l['ResourceURL'].forEach(function (element) {
      if (element['resourceType'] === 'tile') {
        format = element['format'];
        urls.push(
        /** @type {string} */
        element['template']);
      }
    });
  }

  return {
    urls: urls,
    layer: config['layer'],
    matrixSet: matrixSet,
    format: format,
    projection: projection,
    requestEncoding: requestEncoding,
    tileGrid: tileGrid,
    style: style,
    dimensions: dimensions,
    wrapX: wrapX,
    crossOrigin: config['crossOrigin']
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_WMTS_);

/***/ }),

/***/ "./node_modules/ol/source/wmtsrequestencoding.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/source/wmtsrequestencoding.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Request encoding. One of 'KVP', 'REST'.
 * @enum {string}
 */
var _ol_source_WMTSRequestEncoding_ = {
  KVP: 'KVP',
  // see spec §8
  REST: 'REST' // see spec §10

};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_WMTSRequestEncoding_);

/***/ }),

/***/ "./node_modules/ol/source/xyz.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/xyz.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");



/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link ol.source.TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.XYZOptions=} opt_options XYZ options.
 * @api
 */

var _ol_source_XYZ_ = function (opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : _tilegrid_js__WEBPACK_IMPORTED_MODULE_2__["default"].createXYZ({
    extent: _tilegrid_js__WEBPACK_IMPORTED_MODULE_2__["default"].extentFromProjection(projection),
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileSize: options.tileSize
  });

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    opaque: options.opaque,
    projection: projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_XYZ_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (_ol_source_XYZ_);

/***/ }),

/***/ "./node_modules/ol/source/zoomify.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/zoomify.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagetile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagetile.js */ "./node_modules/ol/imagetile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/tileimage.js */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tilegrid/tilegrid.js */ "./node_modules/ol/tilegrid/tilegrid.js");










/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.ZoomifyOptions=} opt_options Options.
 * @api
 */

var _ol_source_Zoomify_ = function (opt_options) {
  var options = opt_options || {};
  var size = options.size;
  var tierSizeCalculation = options.tierSizeCalculation !== undefined ? options.tierSizeCalculation : _ol_source_Zoomify_.TierSizeCalculation_.DEFAULT;
  var imageWidth = size[0];
  var imageHeight = size[1];
  var extent = options.extent || [0, -size[1], size[0], 0];
  var tierSizeInTiles = [];
  var tileSize = options.tileSize || _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_TILE_SIZE;
  var tileSizeForTierSizeCalculation = tileSize;

  switch (tierSizeCalculation) {
    case _ol_source_Zoomify_.TierSizeCalculation_.DEFAULT:
      while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
        tierSizeInTiles.push([Math.ceil(imageWidth / tileSizeForTierSizeCalculation), Math.ceil(imageHeight / tileSizeForTierSizeCalculation)]);
        tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
      }

      break;

    case _ol_source_Zoomify_.TierSizeCalculation_.TRUNCATED:
      var width = imageWidth;
      var height = imageHeight;

      while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
        tierSizeInTiles.push([Math.ceil(width / tileSizeForTierSizeCalculation), Math.ceil(height / tileSizeForTierSizeCalculation)]);
        width >>= 1;
        height >>= 1;
      }

      break;

    default:
      _asserts_js__WEBPACK_IMPORTED_MODULE_4__["default"].assert(false, 53); // Unknown `tierSizeCalculation` configured


      break;
  }

  tierSizeInTiles.push([1, 1]);
  tierSizeInTiles.reverse();
  var resolutions = [1];
  var tileCountUpToTier = [0];
  var i, ii;

  for (i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
    resolutions.push(1 << i);
    tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
  }

  resolutions.reverse();
  var tileGrid = new _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    tileSize: tileSize,
    extent: extent,
    origin: _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"].getTopLeft(extent),
    resolutions: resolutions
  });
  var url = options.url;

  if (url && url.indexOf('{TileGroup}') == -1 && url.indexOf('{tileIndex}') == -1) {
    url += '{TileGroup}/{z}-{x}-{y}.jpg';
  }

  var urls = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["default"].expandUrl(url);
  /**
   * @param {string} template Template.
   * @return {ol.TileUrlFunctionType} Tile URL function.
   */


  function createFromTemplate(template) {
    return (
      /**
       * @param {ol.TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {ol.proj.Projection} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          var tileCoordZ = tileCoord[0];
          var tileCoordX = tileCoord[1];
          var tileCoordY = -tileCoord[2] - 1;
          var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
          var tileSize = tileGrid.getTileSize(tileCoordZ);
          var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileSize | 0;
          var localContext = {
            'z': tileCoordZ,
            'x': tileCoordX,
            'y': tileCoordY,
            'tileIndex': tileIndex,
            'TileGroup': 'TileGroup' + tileGroup
          };
          return template.replace(/\{(\w+?)\}/g, function (m, p) {
            return localContext[p];
          });
        }
      }
    );
  }

  var tileUrlFunction = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_3__["default"].createFromTileUrlFunctions(urls.map(createFromTemplate));

  var ZoomifyTileClass = _ol_source_Zoomify_.Tile_.bind(null, tileGrid);

  _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__["default"].call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileClass: ZoomifyTileClass,
    tileGrid: tileGrid,
    tileUrlFunction: tileUrlFunction,
    transition: options.transition
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Zoomify_, _source_tileimage_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @constructor
 * @extends {ol.ImageTile}
 * @param {ol.tilegrid.TileGrid} tileGrid TileGrid that the tile belongs to.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @param {olx.TileOptions=} opt_options Tile options.
 * @private
 */


_ol_source_Zoomify_.Tile_ = function (tileGrid, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
  _imagetile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options);
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
   */


  this.zoomifyImage_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.tileSize_ = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"].toSize(tileGrid.getTileSize(tileCoord[0]));
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_source_Zoomify_.Tile_, _imagetile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_source_Zoomify_.Tile_.prototype.getImage = function () {
  if (this.zoomifyImage_) {
    return this.zoomifyImage_;
  }

  var image = _imagetile_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.getImage.call(this);

  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
    var tileSize = this.tileSize_;

    if (image.width == tileSize[0] && image.height == tileSize[1]) {
      this.zoomifyImage_ = image;
      return image;
    } else {
      var context = _dom_js__WEBPACK_IMPORTED_MODULE_5__["default"].createCanvasContext2D(tileSize[0], tileSize[1]);

      context.drawImage(image, 0, 0);
      this.zoomifyImage_ = context.canvas;
      return context.canvas;
    }
  } else {
    return image;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_source_Zoomify_.TierSizeCalculation_ = {
  DEFAULT: 'default',
  TRUNCATED: 'truncated'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_source_Zoomify_);

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */


/**
 * @classdesc
 * Class to create objects that can be used with {@link
 * ol.geom.Polygon.circular}.
 *
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 *
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 *
 * @constructor
 * @param {number} radius Radius.
 * @api
 */

var _ol_Sphere_ = function (radius) {
  /**
   * @type {number}
   */
  this.radius = radius;
};
/**
 * Returns the geodesic area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @return {number} Area.
 * @api
 */


_ol_Sphere_.prototype.geodesicArea = function (coordinates) {
  return _ol_Sphere_.getArea_(coordinates, this.radius);
};
/**
 * Returns the distance from c1 to c2 using the haversine formula.
 *
 * @param {ol.Coordinate} c1 Coordinate 1.
 * @param {ol.Coordinate} c2 Coordinate 2.
 * @return {number} Haversine distance.
 * @api
 */


_ol_Sphere_.prototype.haversineDistance = function (c1, c2) {
  return _ol_Sphere_.getDistance_(c1, c2, this.radius);
};
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @return {ol.Coordinate} The target point.
 */


_ol_Sphere_.prototype.offset = function (c1, distance, bearing) {
  var lat1 = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(c1[1]);

  var lon1 = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(c1[0]);

  var dByR = distance / this.radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toDegrees(lon), _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toDegrees(lat)];
};
/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */


_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the length
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */

_ol_Sphere_.getLength = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
      {
        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();
        length = _ol_Sphere_.getLength_(coordinates, radius);
        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength_(coordinates[i], radius);
        }

        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += _ol_Sphere_.getLength_(coords[j], radius);
          }
        }

        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {ol.geom.GeometryCollection} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
};
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */


_ol_Sphere_.getLength_ = function (coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
};
/**
 * Get the great circle distance between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} radius The sphere radius to use.
 * @return {number} The great circle distance between the points (in meters).
 */


_ol_Sphere_.getDistance_ = function (c1, c2, radius) {
  var lat1 = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(c1[1]);

  var lat2 = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(c2[1]);

  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


_ol_Sphere_.getArea = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING:
      {
        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON:
      {
        coordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getCoordinates();
        area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));
        }

        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));
          }
        }

        break;
      }

    case _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {ol.geom.GeometryCollection} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += _ol_Sphere_.getArea(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
};
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */


_ol_Sphere_.getArea_ = function (coordinates, radius) {
  var area = 0,
      len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0],
        y2 = coordinates[i][1];
    area += _math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(x2 - x1) * (2 + Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(y1)) + Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Sphere_);

/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_string_ = {};
/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
*/

_ol_string_.padNumber = function (number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
};
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */


_ol_string_.compareVersions = function (v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_string_);

/***/ }),

/***/ "./node_modules/ol/structs/linkedlist.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/structs/linkedlist.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Creates an empty linked list structure.
 *
 * @constructor
 * @struct
 * @param {boolean=} opt_circular The last item is connected to the first one,
 * and the first item to the last one. Default is true.
 */
var _ol_structs_LinkedList_ = function (opt_circular) {
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.first_ = undefined;
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */

  this.last_ = undefined;
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */

  this.head_ = undefined;
  /**
   * @private
   * @type {boolean}
   */

  this.circular_ = opt_circular === undefined ? true : opt_circular;
  /**
   * @private
   * @type {number}
   */

  this.length_ = 0;
};
/**
 * Inserts an item into the linked list right after the current one.
 *
 * @param {?} data Item data.
 */


_ol_structs_LinkedList_.prototype.insertItem = function (data) {
  /** @type {ol.LinkedListItem} */
  var item = {
    prev: undefined,
    next: undefined,
    data: data
  };
  var head = this.head_; //Initialize the list.

  if (!head) {
    this.first_ = item;
    this.last_ = item;

    if (this.circular_) {
      item.next = item;
      item.prev = item;
    }
  } else {
    //Link the new item to the adjacent ones.
    var next = head.next;
    item.prev = head;
    item.next = next;
    head.next = item;

    if (next) {
      next.prev = item;
    }

    if (head === this.last_) {
      this.last_ = item;
    }
  }

  this.head_ = item;
  this.length_++;
};
/**
 * Removes the current item from the list. Sets the cursor to the next item,
 * if possible.
 */


_ol_structs_LinkedList_.prototype.removeItem = function () {
  var head = this.head_;

  if (head) {
    var next = head.next;
    var prev = head.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    this.head_ = next || prev;

    if (this.first_ === this.last_) {
      this.head_ = undefined;
      this.first_ = undefined;
      this.last_ = undefined;
    } else if (this.first_ === head) {
      this.first_ = this.head_;
    } else if (this.last_ === head) {
      this.last_ = prev ? this.head_.prev : this.head_;
    }

    this.length_--;
  }
};
/**
 * Sets the cursor to the first item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.firstItem = function () {
  this.head_ = this.first_;

  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
* Sets the cursor to the last item, and returns the associated data.
*
* @return {?} Item data.
*/


_ol_structs_LinkedList_.prototype.lastItem = function () {
  this.head_ = this.last_;

  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
 * Sets the cursor to the next item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.nextItem = function () {
  if (this.head_ && this.head_.next) {
    this.head_ = this.head_.next;
    return this.head_.data;
  }

  return undefined;
};
/**
 * Returns the next item's data without moving the cursor.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getNextItem = function () {
  if (this.head_ && this.head_.next) {
    return this.head_.next.data;
  }

  return undefined;
};
/**
 * Sets the cursor to the previous item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.prevItem = function () {
  if (this.head_ && this.head_.prev) {
    this.head_ = this.head_.prev;
    return this.head_.data;
  }

  return undefined;
};
/**
 * Returns the previous item's data without moving the cursor.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getPrevItem = function () {
  if (this.head_ && this.head_.prev) {
    return this.head_.prev.data;
  }

  return undefined;
};
/**
 * Returns the current item's data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getCurrItem = function () {
  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
 * Sets the first item of the list. This only works for circular lists, and sets
 * the last item accordingly.
 */


_ol_structs_LinkedList_.prototype.setFirstItem = function () {
  if (this.circular_ && this.head_) {
    this.first_ = this.head_;
    this.last_ = this.head_.prev;
  }
};
/**
 * Concatenates two lists.
 * @param {ol.structs.LinkedList} list List to merge into the current list.
 */


_ol_structs_LinkedList_.prototype.concat = function (list) {
  if (list.head_) {
    if (this.head_) {
      var end = this.head_.next;
      this.head_.next = list.first_;
      list.first_.prev = this.head_;
      end.prev = list.last_;
      list.last_.next = end;
      this.length_ += list.length_;
    } else {
      this.head_ = list.head_;
      this.first_ = list.first_;
      this.last_ = list.last_;
      this.length_ = list.length_;
    }

    list.head_ = undefined;
    list.first_ = undefined;
    list.last_ = undefined;
    list.length_ = 0;
  }
};
/**
 * Returns the current length of the list.
 *
 * @return {number} Length.
 */


_ol_structs_LinkedList_.prototype.getLength = function () {
  return this.length_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_structs_LinkedList_);

/***/ }),

/***/ "./node_modules/ol/structs/lrucache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/lrucache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");




/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @template T
 * @param {number=} opt_highWaterMark High water mark.
 */

var _ol_structs_LRUCache_ = function (opt_highWaterMark) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
  /**
   * @type {number}
   */


  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
  /**
   * @private
   * @type {number}
   */

  this.count_ = 0;
  /**
   * @private
   * @type {!Object.<string, ol.LRUCacheEntry>}
   */

  this.entries_ = {};
  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */

  this.oldest_ = null;
  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */

  this.newest_ = null;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_structs_LRUCache_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @return {boolean} Can expire cache.
 */


_ol_structs_LRUCache_.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_structs_LRUCache_.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CLEAR);
};
/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */


_ol_structs_LRUCache_.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};
/**
 * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */


_ol_structs_LRUCache_.prototype.forEach = function (f, opt_this) {
  var entry = this.oldest_;

  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};
/**
 * @param {string} key Key.
 * @return {T} Value.
 */


_ol_structs_LRUCache_.prototype.get = function (key) {
  var entry = this.entries_[key];

  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache


  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ =
    /** @type {ol.LRUCacheEntry} */
    this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }

  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};
/**
 * Remove an entry from the cache.
 * @param {string} key The entry key.
 * @return {T} The removed entry.
 */


_ol_structs_LRUCache_.prototype.remove = function (key) {
  var entry = this.entries_[key];

  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache


  if (entry === this.newest_) {
    this.newest_ =
    /** @type {ol.LRUCacheEntry} */
    entry.older;

    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else if (entry === this.oldest_) {
    this.oldest_ =
    /** @type {ol.LRUCacheEntry} */
    entry.newer;

    if (this.oldest_) {
      this.oldest_.older = null;
    }
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }

  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};
/**
 * @return {number} Count.
 */


_ol_structs_LRUCache_.prototype.getCount = function () {
  return this.count_;
};
/**
 * @return {Array.<string>} Keys.
 */


_ol_structs_LRUCache_.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry;

  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }

  return keys;
};
/**
 * @return {Array.<T>} Values.
 */


_ol_structs_LRUCache_.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry;

  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }

  return values;
};
/**
 * @return {T} Last value.
 */


_ol_structs_LRUCache_.prototype.peekLast = function () {
  return this.oldest_.value_;
};
/**
 * @return {string} Last key.
 */


_ol_structs_LRUCache_.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};
/**
 * Get the key of the newest item in the cache.  Throws if the cache is empty.
 * @return {string} The newest key.
 */


_ol_structs_LRUCache_.prototype.peekFirstKey = function () {
  return this.newest_.key_;
};
/**
 * @return {T} value Value.
 */


_ol_structs_LRUCache_.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];

  if (entry.newer) {
    entry.newer.older = null;
  }

  this.oldest_ =
  /** @type {ol.LRUCacheEntry} */
  entry.newer;

  if (!this.oldest_) {
    this.newest_ = null;
  }

  --this.count_;
  return entry.value_;
};
/**
 * @param {string} key Key.
 * @param {T} value Value.
 */


_ol_structs_LRUCache_.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`

  this.entries_[key].value_ = value;
};
/**
 * @param {string} key Key.
 * @param {T} value Value.
 */


_ol_structs_LRUCache_.prototype.set = function (key, value) {
  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already


  var entry =
  /** @type {ol.LRUCacheEntry} */
  {
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };

  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }

  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};
/**
 * Prune the cache.
 */


_ol_structs_LRUCache_.prototype.prune = function () {
  while (this.canExpireCache()) {
    this.pop();
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_structs_LRUCache_);

/***/ }),

/***/ "./node_modules/ol/structs/priorityqueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/priorityqueue.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");


/**
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py
 *
 * @constructor
 * @param {function(T): number} priorityFunction Priority function.
 * @param {function(T): string} keyFunction Key function.
 * @struct
 * @template T
 */

var _ol_structs_PriorityQueue_ = function (priorityFunction, keyFunction) {
  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;
  /**
   * @type {function(T): string}
   * @private
   */

  this.keyFunction_ = keyFunction;
  /**
   * @type {Array.<T>}
   * @private
   */

  this.elements_ = [];
  /**
   * @type {Array.<number>}
   * @private
   */

  this.priorities_ = [];
  /**
   * @type {Object.<string, boolean>}
   * @private
   */

  this.queuedElements_ = {};
};
/**
 * @const
 * @type {number}
 */


_ol_structs_PriorityQueue_.DROP = Infinity;
/**
 * FIXME empty description for jsdoc
 */

_ol_structs_PriorityQueue_.prototype.clear = function () {
  this.elements_.length = 0;
  this.priorities_.length = 0;

  _obj_js__WEBPACK_IMPORTED_MODULE_1__["default"].clear(this.queuedElements_);
};
/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */


_ol_structs_PriorityQueue_.prototype.dequeue = function () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];

  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }

  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};
/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */


_ol_structs_PriorityQueue_.prototype.enqueue = function (element) {
  _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue


  var priority = this.priorityFunction_(element);

  if (priority != _ol_structs_PriorityQueue_.DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }

  return false;
};
/**
 * @return {number} Count.
 */


_ol_structs_PriorityQueue_.prototype.getCount = function () {
  return this.elements_.length;
};
/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getLeftChildIndex_ = function (index) {
  return index * 2 + 1;
};
/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getRightChildIndex_ = function (index) {
  return index * 2 + 2;
};
/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getParentIndex_ = function (index) {
  return index - 1 >> 1;
};
/**
 * Make this a heap. O(N).
 * @private
 */


_ol_structs_PriorityQueue_.prototype.heapify_ = function () {
  var i;

  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};
/**
 * @return {boolean} Is empty.
 */


_ol_structs_PriorityQueue_.prototype.isEmpty = function () {
  return this.elements_.length === 0;
};
/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */


_ol_structs_PriorityQueue_.prototype.isKeyQueued = function (key) {
  return key in this.queuedElements_;
};
/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */


_ol_structs_PriorityQueue_.prototype.isQueued = function (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};
/**
 * @param {number} index The index of the node to move down.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.siftUp_ = function (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < count >> 1) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);
    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};
/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.siftDown_ = function (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);

    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }

  elements[index] = element;
  priorities[index] = priority;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_structs_PriorityQueue_.prototype.reprioritize = function () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;

  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);

    if (priority == _ol_structs_PriorityQueue_.DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }

  elements.length = index;
  priorities.length = index;
  this.heapify_();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_structs_PriorityQueue_);

/***/ }),

/***/ "./node_modules/ol/structs/rbush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/rbush.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");




/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */

var _ol_structs_RBush_ = function (opt_maxEntries) {
  /**
   * @private
   */
  this.rbush_ = rbush__WEBPACK_IMPORTED_MODULE_1___default()(opt_maxEntries);
  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, ol.RBushEntry>}
   */

  this.items_ = {};
};
/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */


_ol_structs_RBush_.prototype.insert = function (extent, value) {
  /** @type {ol.RBushEntry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };
  this.rbush_.insert(item);
  this.items_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(value)] = item;
};
/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */


_ol_structs_RBush_.prototype.load = function (extents, values) {
  var items = new Array(values.length);

  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];
    /** @type {ol.RBushEntry} */

    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(value)] = item;
  }

  this.rbush_.load(items);
};
/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */


_ol_structs_RBush_.prototype.remove = function (value) {
  var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(value); // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.


  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};
/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */


_ol_structs_RBush_.prototype.update = function (extent, value) {
  var item = this.items_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(value)];

  var bbox = [item.minX, item.minY, item.maxX, item.maxY];

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};
/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */


_ol_structs_RBush_.prototype.getAll = function () {
  var items = this.rbush_.all();
  return items.map(function (item) {
    return item.value;
  });
};
/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */


_ol_structs_RBush_.prototype.getInExtent = function (extent) {
  /** @type {ol.RBushEntry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function (item) {
    return item.value;
  });
};
/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEach = function (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};
/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEachInExtent = function (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};
/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEach_ = function (values, callback, opt_this) {
  var result;

  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);

    if (result) {
      return result;
    }
  }

  return result;
};
/**
 * @return {boolean} Is empty.
 */


_ol_structs_RBush_.prototype.isEmpty = function () {
  return _obj_js__WEBPACK_IMPORTED_MODULE_3__["default"].isEmpty(this.items_);
};
/**
 * Remove all values from the RBush.
 */


_ol_structs_RBush_.prototype.clear = function () {
  this.rbush_.clear();
  this.items_ = {};
};
/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_structs_RBush_.prototype.getExtent = function (opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};
/**
 * @param {ol.structs.RBush} rbush R-Tree.
 */


_ol_structs_RBush_.prototype.concat = function (rbush) {
  this.rbush_.load(rbush.rbush_.all());

  for (var i in rbush.items_) {
    this.items_[i | 0] = rbush.items_[i | 0];
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_structs_RBush_);

/***/ }),

/***/ "./node_modules/ol/style.js":
/*!**********************************!*\
  !*** ./node_modules/ol/style.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_iconimagecache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style/iconimagecache.js */ "./node_modules/ol/style/iconimagecache.js");

var _ol_style_ = {};
/**
 * The {@link ol.style.IconImageCache} for {@link ol.style.Icon} images.
 * @api
 */

_ol_style_.iconImageCache = new _style_iconimagecache_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_);

/***/ }),

/***/ "./node_modules/ol/style/atlas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/atlas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");

/**
 * This class facilitates the creation of image atlases.
 *
 * Images added to an atlas will be rendered onto a single
 * atlas canvas. The distribution of images on the canvas is
 * managed with the bin packing algorithm described in:
 * http://www.blackpawn.com/texts/lightmaps/
 *
 * @constructor
 * @struct
 * @param {number} size The size in pixels of the sprite image.
 * @param {number} space The space in pixels between images.
 *    Because texture coordinates are float values, the edges of
 *    images might not be completely correct (in a way that the
 *    edges overlap when being rendered). To avoid this we add a
 *    padding around each image.
 */

var _ol_style_Atlas_ = function (size, space) {
  /**
   * @private
   * @type {number}
   */
  this.space_ = space;
  /**
   * @private
   * @type {Array.<ol.AtlasBlock>}
   */

  this.emptyBlocks_ = [{
    x: 0,
    y: 0,
    width: size,
    height: size
  }];
  /**
   * @private
   * @type {Object.<string, ol.AtlasInfo>}
   */

  this.entries_ = {};
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.context_ = _dom_js__WEBPACK_IMPORTED_MODULE_0__["default"].createCanvasContext2D(size, size);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = this.context_.canvas;
};
/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The atlas info.
 */


_ol_style_Atlas_.prototype.get = function (id) {
  return this.entries_[id] || null;
};
/**
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback`.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry.
 */


_ol_style_Atlas_.prototype.add = function (id, width, height, renderCallback, opt_this) {
  var block, i, ii;

  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {
    block = this.emptyBlocks_[i];

    if (block.width >= width + this.space_ && block.height >= height + this.space_) {
      // we found a block that is big enough for our entry
      var entry = {
        offsetX: block.x + this.space_,
        offsetY: block.y + this.space_,
        image: this.canvas_
      };
      this.entries_[id] = entry; // render the image on the atlas image

      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_); // split the block after the insertion, either horizontally or vertically

      this.split_(i, block, width + this.space_, height + this.space_);
      return entry;
    }
  } // there is no space for the new entry in this atlas


  return null;
};
/**
 * @private
 * @param {number} index The index of the block.
 * @param {ol.AtlasBlock} block The block to split.
 * @param {number} width The width of the entry to insert.
 * @param {number} height The height of the entry to insert.
 */


_ol_style_Atlas_.prototype.split_ = function (index, block, width, height) {
  var deltaWidth = block.width - width;
  var deltaHeight = block.height - height;
  /** @type {ol.AtlasBlock} */

  var newBlock1;
  /** @type {ol.AtlasBlock} */

  var newBlock2;

  if (deltaWidth > deltaHeight) {
    // split vertically
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: block.height
    }; // block below the inserted entry

    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  } else {
    // split horizontally
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: height
    }; // block below the inserted entry

    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: block.width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  }
};
/**
 * Remove the old block and insert new blocks at the same array position.
 * The new blocks are inserted at the same position, so that splitted
 * blocks (that are potentially smaller) are filled first.
 * @private
 * @param {number} index The index of the block to remove.
 * @param {ol.AtlasBlock} newBlock1 The 1st block to add.
 * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.
 */


_ol_style_Atlas_.prototype.updateBlocks_ = function (index, newBlock1, newBlock2) {
  var args = [index, 1];

  if (newBlock1.width > 0 && newBlock1.height > 0) {
    args.push(newBlock1);
  }

  if (newBlock2.width > 0 && newBlock2.height > 0) {
    args.push(newBlock2);
  }

  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Atlas_);

/***/ }),

/***/ "./node_modules/ol/style/atlasmanager.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/atlasmanager.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _style_atlas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/atlas.js */ "./node_modules/ol/style/atlas.js");


/**
 * Manages the creation of image atlases.
 *
 * Images added to this manager will be inserted into an atlas, which
 * will be used for rendering.
 * The `size` given in the constructor is the size for the first
 * atlas. After that, when new atlases are created, they will have
 * twice the size as the latest atlas (until `maxSize` is reached).
 *
 * If an application uses many images or very large images, it is recommended
 * to set a higher `size` value to avoid the creation of too many atlases.
 *
 * @constructor
 * @struct
 * @api
 * @param {olx.style.AtlasManagerOptions=} opt_options Options.
 */

var _ol_style_AtlasManager_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * The size in pixels of the latest atlas image.
   * @private
   * @type {number}
   */

  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].INITIAL_ATLAS_SIZE;
  /**
   * The maximum size in pixels of atlas images.
   * @private
   * @type {number}
   */

  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ATLAS_SIZE != -1 ? _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].MAX_ATLAS_SIZE : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_MAX_TEXTURE_SIZE !== undefined ? _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_MAX_TEXTURE_SIZE : 2048;
  /**
   * The size in pixels between images.
   * @private
   * @type {number}
   */

  this.space_ = options.space !== undefined ? options.space : 1;
  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */

  this.atlases_ = [new _style_atlas_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.currentSize_, this.space_)];
  /**
   * The size in pixels of the latest atlas image for hit-detection images.
   * @private
   * @type {number}
   */

  this.currentHitSize_ = this.currentSize_;
  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */

  this.hitAtlases_ = [new _style_atlas_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.currentHitSize_, this.space_)];
};
/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlas manager.
 */


_ol_style_AtlasManager_.prototype.getInfo = function (id) {
  /** @type {?ol.AtlasInfo} */
  var info = this.getInfo_(this.atlases_, id);

  if (!info) {
    return null;
  }

  var hitInfo =
  /** @type {ol.AtlasInfo} */
  this.getInfo_(this.hitAtlases_, id);
  return this.mergeInfos_(info, hitInfo);
};
/**
 * @private
 * @param {Array.<ol.style.Atlas>} atlases The atlases to search.
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry,
 *    or `null` if the entry is not part of the atlases.
 */


_ol_style_AtlasManager_.prototype.getInfo_ = function (atlases, id) {
  var atlas, info, i, ii;

  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.get(id);

    if (info) {
      return info;
    }
  }

  return null;
};
/**
 * @private
 * @param {ol.AtlasInfo} info The info for the real image.
 * @param {ol.AtlasInfo} hitInfo The info for the hit-detection
 *    image.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlases.
 */


_ol_style_AtlasManager_.prototype.mergeInfos_ = function (info, hitInfo) {
  return (
    /** @type {ol.AtlasManagerInfo} */
    {
      offsetX: info.offsetX,
      offsetY: info.offsetY,
      image: info.image,
      hitImage: hitInfo.image
    }
  );
};
/**
 * Add an image to the atlas manager.
 *
 * If an entry for the given id already exists, the entry will
 * be overridden (but the space on the atlas graphic will not be freed).
 *
 * If `renderHitCallback` is provided, the image (or the hit-detection version
 * of the image) will be rendered into a separate hit-detection atlas image.
 *
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {function(CanvasRenderingContext2D, number, number)=}
 *    opt_renderHitCallback Called to render a hit-detection image onto a hit
 *    detection atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasManagerInfo}  The position and atlas image for the
 *    entry, or `null` if the image is too big.
 */


_ol_style_AtlasManager_.prototype.add = function (id, width, height, renderCallback, opt_renderHitCallback, opt_this) {
  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {
    return null;
  }
  /** @type {?ol.AtlasInfo} */


  var info = this.add_(false, id, width, height, renderCallback, opt_this);

  if (!info) {
    return null;
  } // even if no hit-detection entry is requested, we insert a fake entry into
  // the hit-detection atlas, to make sure that the offset is the same for
  // the original image and the hit-detection image.


  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;
  var hitInfo =
  /** @type {ol.AtlasInfo} */
  this.add_(true, id, width, height, renderHitCallback, opt_this);
  return this.mergeInfos_(info, hitInfo);
};
/**
 * @private
 * @param {boolean} isHitAtlas If the hit-detection atlases are used.
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasInfo}  The position and atlas image for the entry,
 *    or `null` if the image is too big.
 */


_ol_style_AtlasManager_.prototype.add_ = function (isHitAtlas, id, width, height, renderCallback, opt_this) {
  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;
  var atlas, info, i, ii;

  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.add(id, width, height, renderCallback, opt_this);

    if (info) {
      return info;
    } else if (!info && i === ii - 1) {
      // the entry could not be added to one of the existing atlases,
      // create a new atlas that is twice as big and try to add to this one.
      var size;

      if (isHitAtlas) {
        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);
        this.currentHitSize_ = size;
      } else {
        size = Math.min(this.currentSize_ * 2, this.maxSize_);
        this.currentSize_ = size;
      }

      atlas = new _style_atlas_js__WEBPACK_IMPORTED_MODULE_1__["default"](size, this.space_);
      atlases.push(atlas); // run the loop another time

      ++ii;
    }
  }

  return null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_AtlasManager_);

/***/ }),

/***/ "./node_modules/ol/style/circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/circle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _style_regularshape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/regularshape.js */ "./node_modules/ol/style/regularshape.js");


/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */

var _ol_style_Circle_ = function (opt_options) {
  var options = opt_options || {};

  _style_regularshape_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, {
    points: Infinity,
    fill: options.fill,
    radius: options.radius,
    snapToPixel: options.snapToPixel,
    stroke: options.stroke,
    atlasManager: options.atlasManager
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_style_Circle_, _style_regularshape_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */


_ol_style_Circle_.prototype.clone = function () {
  var style = new _ol_style_Circle_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    radius: this.getRadius(),
    snapToPixel: this.getSnapToPixel(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */


_ol_style_Circle_.prototype.setRadius = function (radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Circle_);

/***/ }),

/***/ "./node_modules/ol/style/fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/fill.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");


/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */

var _ol_style_Fill_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */

  this.color_ = options.color !== undefined ? options.color : null;
  /**
   * @private
   * @type {string|undefined}
   */

  this.checksum_ = undefined;
};
/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */


_ol_style_Fill_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Fill_({
    color: color && color.slice ? color.slice() : color || undefined
  });
};
/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */


_ol_style_Fill_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */


_ol_style_Fill_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
/**
 * @return {string} The checksum.
 */


_ol_style_Fill_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? _color_js__WEBPACK_IMPORTED_MODULE_1__["default"].asString(this.color_) : '-');
    }
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Fill_);

/***/ }),

/***/ "./node_modules/ol/style/icon.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/icon.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/iconanchorunits.js */ "./node_modules/ol/style/iconanchorunits.js");
/* harmony import */ var _style_iconimage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/iconimage.js */ "./node_modules/ol/style/iconimage.js");
/* harmony import */ var _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/iconorigin.js */ "./node_modules/ol/style/iconorigin.js");
/* harmony import */ var _style_image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/image.js */ "./node_modules/ol/style/image.js");










/**
 * @classdesc
 * Set icon style for vector features.
 *
 * @constructor
 * @param {olx.style.IconOptions=} opt_options Options.
 * @extends {ol.style.Image}
 * @api
 */

var _ol_style_Icon_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {Array.<number>}
   */

  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.normalizedAnchor_ = null;
  /**
   * @private
   * @type {ol.style.IconOrigin}
   */

  this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT;
  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */

  this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION;
  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */

  this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION;
  /**
   * @private
   * @type {?string}
   */

  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @type {Image|HTMLCanvasElement}
   */

  var image = options.img !== undefined ? options.img : null;
  /**
   * @type {ol.Size}
   */

  var imgSize = options.imgSize !== undefined ? options.imgSize : null;
  /**
   * @type {string|undefined}
   */

  var src = options.src;

  _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time


  _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided


  if ((src === undefined || src.length === 0) && image) {
    src = image.src || _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(image).toString();
  }

  _asserts_js__WEBPACK_IMPORTED_MODULE_2__["default"].assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

  /**
   * @type {ol.ImageState}
   */


  var imageState = options.src !== undefined ? _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _imagestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  /**
   * @private
   * @type {ol.Color}
   */

  this.color_ = options.color !== undefined ? _color_js__WEBPACK_IMPORTED_MODULE_3__["default"].asArray(options.color) : null;
  /**
   * @private
   * @type {ol.style.IconImage}
   */

  this.iconImage_ = _style_iconimage_js__WEBPACK_IMPORTED_MODULE_7__["default"].get(image,
  /** @type {string} */
  src, imgSize, this.crossOrigin_, imageState, this.color_);
  /**
   * @private
   * @type {Array.<number>}
   */

  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
  /**
   * @private
   * @type {ol.style.IconOrigin}
   */

  this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.origin_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = options.size !== undefined ? options.size : null;
  /**
   * @type {number}
   */

  var opacity = options.opacity !== undefined ? options.opacity : 1;
  /**
   * @type {boolean}
   */

  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
  /**
   * @type {number}
   */

  var rotation = options.rotation !== undefined ? options.rotation : 0;
  /**
   * @type {number}
   */

  var scale = options.scale !== undefined ? options.scale : 1;
  /**
   * @type {boolean}
   */

  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  _style_image_js__WEBPACK_IMPORTED_MODULE_9__["default"].call(this, {
    opacity: opacity,
    rotation: rotation,
    scale: scale,
    snapToPixel: snapToPixel,
    rotateWithView: rotateWithView
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_style_Icon_, _style_image_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
 * @return {ol.style.Icon} The cloned style.
 * @api
 */


_ol_style_Icon_.prototype.clone = function () {
  return new _ol_style_Icon_({
    anchor: this.anchor_.slice(),
    anchorOrigin: this.anchorOrigin_,
    anchorXUnits: this.anchorXUnits_,
    anchorYUnits: this.anchorYUnits_,
    crossOrigin: this.crossOrigin_,
    color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
    src: this.getSrc(),
    offset: this.offset_.slice(),
    offsetOrigin: this.offsetOrigin_,
    size: this.size_ !== null ? this.size_.slice() : undefined,
    opacity: this.getOpacity(),
    scale: this.getScale(),
    snapToPixel: this.getSnapToPixel(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getAnchor = function () {
  if (this.normalizedAnchor_) {
    return this.normalizedAnchor_;
  }

  var anchor = this.anchor_;
  var size = this.getSize();

  if (this.anchorXUnits_ == _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION || this.anchorYUnits_ == _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
    if (!size) {
      return null;
    }

    anchor = this.anchor_.slice();

    if (this.anchorXUnits_ == _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
      anchor[0] *= size[0];
    }

    if (this.anchorYUnits_ == _style_iconanchorunits_js__WEBPACK_IMPORTED_MODULE_6__["default"].FRACTION) {
      anchor[1] *= size[1];
    }
  }

  if (this.anchorOrigin_ != _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT) {
    if (!size) {
      return null;
    }

    if (anchor === this.anchor_) {
      anchor = this.anchor_.slice();
    }

    if (this.anchorOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_RIGHT || this.anchorOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
      anchor[0] = -anchor[0] + size[0];
    }

    if (this.anchorOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_LEFT || this.anchorOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
      anchor[1] = -anchor[1] + size[1];
    }
  }

  this.normalizedAnchor_ = anchor;
  return this.normalizedAnchor_;
};
/**
 * Get the icon color.
 * @return {ol.Color} Color.
 * @api
 */


_ol_style_Icon_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Get the image icon.
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 * @override
 * @api
 */


_ol_style_Icon_.prototype.getImage = function (pixelRatio) {
  return this.iconImage_.getImage(pixelRatio);
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getImageSize = function () {
  return this.iconImage_.getSize();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getHitDetectionImageSize = function () {
  return this.getImageSize();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getImageState = function () {
  return this.iconImage_.getImageState();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.iconImage_.getHitDetectionImage(pixelRatio);
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getOrigin = function () {
  if (this.origin_) {
    return this.origin_;
  }

  var offset = this.offset_;

  if (this.offsetOrigin_ != _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_LEFT) {
    var size = this.getSize();
    var iconImageSize = this.iconImage_.getSize();

    if (!size || !iconImageSize) {
      return null;
    }

    offset = offset.slice();

    if (this.offsetOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].TOP_RIGHT || this.offsetOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
      offset[0] = iconImageSize[0] - size[0] - offset[0];
    }

    if (this.offsetOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_LEFT || this.offsetOrigin_ == _style_iconorigin_js__WEBPACK_IMPORTED_MODULE_8__["default"].BOTTOM_RIGHT) {
      offset[1] = iconImageSize[1] - size[1] - offset[1];
    }
  }

  this.origin_ = offset;
  return this.origin_;
};
/**
 * Get the image URL.
 * @return {string|undefined} Image src.
 * @api
 */


_ol_style_Icon_.prototype.getSrc = function () {
  return this.iconImage_.getSrc();
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getSize = function () {
  return !this.size_ ? this.iconImage_.getSize() : this.size_;
};
/**
 * @override
 */


_ol_style_Icon_.prototype.listenImageChange = function (listener, thisArg) {
  return _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(this.iconImage_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, listener, thisArg);
};
/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * @override
 * @api
 */


_ol_style_Icon_.prototype.load = function () {
  this.iconImage_.load();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.unlistenImageChange = function (listener, thisArg) {
  _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlisten(this.iconImage_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, listener, thisArg);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Icon_);

/***/ }),

/***/ "./node_modules/ol/style/iconanchorunits.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/style/iconanchorunits.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _ol_style_IconAnchorUnits_ = {
  FRACTION: 'fraction',
  PIXELS: 'pixels'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_IconAnchorUnits_);

/***/ }),

/***/ "./node_modules/ol/style/iconimage.js":
/*!********************************************!*\
  !*** ./node_modules/ol/style/iconimage.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style.js */ "./node_modules/ol/style.js");







/**
 * @constructor
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string|undefined} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @extends {ol.events.EventTarget}
 */

var _ol_style_IconImage_ = function (image, src, size, crossOrigin, imageState, color) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this);
  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */


  this.hitDetectionImage_ = null;
  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */

  this.image_ = !image ? new Image() : image;

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ = color ?
  /** @type {HTMLCanvasElement} */
  document.createElement('CANVAS') : null;
  /**
   * @private
   * @type {ol.Color}
   */

  this.color_ = color;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.imageListenerKeys_ = null;
  /**
   * @private
   * @type {ol.ImageState}
   */

  this.imageState_ = imageState;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = size;
  /**
   * @private
   * @type {string|undefined}
   */

  this.src_ = src;
  /**
   * @private
   * @type {boolean}
   */

  this.tainting_ = false;

  if (this.imageState_ == _imagestate_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADED) {
    this.determineTainting_();
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_style_IconImage_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */


_ol_style_IconImage_.get = function (image, src, size, crossOrigin, imageState, color) {
  var iconImageCache = _style_js__WEBPACK_IMPORTED_MODULE_6__["default"].iconImageCache;
  var iconImage = iconImageCache.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new _ol_style_IconImage_(image, src, size, crossOrigin, imageState, color);
    iconImageCache.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.determineTainting_ = function () {
  var context = _dom_js__WEBPACK_IMPORTED_MODULE_1__["default"].createCanvasContext2D(1, 1);

  try {
    context.drawImage(this.image_, 0, 0);
    context.getImageData(0, 0, 1, 1);
  } catch (e) {
    this.tainting_ = true;
  }
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.dispatchChangeEvent_ = function () {
  this.dispatchEvent(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE);
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.handleImageError_ = function () {
  this.imageState_ = _imagestate_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERROR;
  this.unlistenImage_();
  this.dispatchChangeEvent_();
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.handleImageLoad_ = function () {
  this.imageState_ = _imagestate_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADED;

  if (this.size_) {
    this.image_.width = this.size_[0];
    this.image_.height = this.size_[1];
  }

  this.size_ = [this.image_.width, this.image_.height];
  this.unlistenImage_();
  this.determineTainting_();
  this.replaceColor_();
  this.dispatchChangeEvent_();
};
/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 */


_ol_style_IconImage_.prototype.getImage = function (pixelRatio) {
  return this.canvas_ ? this.canvas_ : this.image_;
};
/**
 * @return {ol.ImageState} Image state.
 */


_ol_style_IconImage_.prototype.getImageState = function () {
  return this.imageState_;
};
/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image element.
 */


_ol_style_IconImage_.prototype.getHitDetectionImage = function (pixelRatio) {
  if (!this.hitDetectionImage_) {
    if (this.tainting_) {
      var width = this.size_[0];
      var height = this.size_[1];

      var context = _dom_js__WEBPACK_IMPORTED_MODULE_1__["default"].createCanvasContext2D(width, height);

      context.fillRect(0, 0, width, height);
      this.hitDetectionImage_ = context.canvas;
    } else {
      this.hitDetectionImage_ = this.image_;
    }
  }

  return this.hitDetectionImage_;
};
/**
 * @return {ol.Size} Image size.
 */


_ol_style_IconImage_.prototype.getSize = function () {
  return this.size_;
};
/**
 * @return {string|undefined} Image src.
 */


_ol_style_IconImage_.prototype.getSrc = function () {
  return this.src_;
};
/**
 * Load not yet loaded URI.
 */


_ol_style_IconImage_.prototype.load = function () {
  if (this.imageState_ == _imagestate_js__WEBPACK_IMPORTED_MODULE_5__["default"].IDLE) {
    this.imageState_ = _imagestate_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADING;
    this.imageListenerKeys_ = [_events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR, this.handleImageError_, this), _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listenOnce(this.image_, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD, this.handleImageLoad_, this)];

    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
  }
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.replaceColor_ = function () {
  if (this.tainting_ || this.color_ === null) {
    return;
  }

  this.canvas_.width = this.image_.width;
  this.canvas_.height = this.image_.height;
  var ctx = this.canvas_.getContext('2d');
  ctx.drawImage(this.image_, 0, 0);
  var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
  var data = imgData.data;
  var r = this.color_[0] / 255.0;
  var g = this.color_[1] / 255.0;
  var b = this.color_[2] / 255.0;

  for (var i = 0, ii = data.length; i < ii; i += 4) {
    data[i] *= r;
    data[i + 1] *= g;
    data[i + 2] *= b;
  }

  ctx.putImageData(imgData, 0, 0);
};
/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */


_ol_style_IconImage_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_2__["default"].unlistenByKey);
  this.imageListenerKeys_ = null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_IconImage_);

/***/ }),

/***/ "./node_modules/ol/style/iconimagecache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/iconimagecache.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");

/**
 * Singleton class. Available through {@link ol.style.iconImageCache}.
 * @constructor
 */

var _ol_style_IconImageCache_ = function () {
  /**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */
  this.cache_ = {};
  /**
   * @type {number}
   * @private
   */

  this.cacheSize_ = 0;
  /**
   * @type {number}
   * @private
   */

  this.maxCacheSize_ = 32;
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */


_ol_style_IconImageCache_.getKey = function (src, crossOrigin, color) {
  var colorString = color ? _color_js__WEBPACK_IMPORTED_MODULE_0__["default"].asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_style_IconImageCache_.prototype.clear = function () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_style_IconImageCache_.prototype.expire = function () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;

    for (key in this.cache_) {
      iconImage = this.cache_[key];

      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */


_ol_style_IconImageCache_.prototype.get = function (src, crossOrigin, color) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);

  return key in this.cache_ ? this.cache_[key] : null;
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */


_ol_style_IconImageCache_.prototype.set = function (src, crossOrigin, color, iconImage) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);

  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};
/**
 * Set the cache size of the icon cache. Default is `32`. Change this value when
 * your map uses more than 32 different icon images and you are not caching icon
 * styles on the application level.
 * @param {number} maxCacheSize Cache max size.
 * @api
 */


_ol_style_IconImageCache_.prototype.setSize = function (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_IconImageCache_);

/***/ }),

/***/ "./node_modules/ol/style/iconorigin.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/style/iconorigin.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _ol_style_IconOrigin_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_IconOrigin_);

/***/ }),

/***/ "./node_modules/ol/style/image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */
var _ol_style_Image_ = function (options) {
  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;
  /**
   * @private
   * @type {boolean}
   */

  this.rotateWithView_ = options.rotateWithView;
  /**
   * @private
   * @type {number}
   */

  this.rotation_ = options.rotation;
  /**
   * @private
   * @type {number}
   */

  this.scale_ = options.scale;
  /**
   * @private
   * @type {boolean}
   */

  this.snapToPixel_ = options.snapToPixel;
};
/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */


_ol_style_Image_.prototype.getOpacity = function () {
  return this.opacity_;
};
/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */


_ol_style_Image_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};
/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */


_ol_style_Image_.prototype.getRotation = function () {
  return this.rotation_;
};
/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */


_ol_style_Image_.prototype.getScale = function () {
  return this.scale_;
};
/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */


_ol_style_Image_.prototype.getSnapToPixel = function () {
  return this.snapToPixel_;
};
/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */


_ol_style_Image_.prototype.getAnchor = function () {};
/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */


_ol_style_Image_.prototype.getImage = function (pixelRatio) {};
/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */


_ol_style_Image_.prototype.getHitDetectionImage = function (pixelRatio) {};
/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */


_ol_style_Image_.prototype.getImageState = function () {};
/**
 * @abstract
 * @return {ol.Size} Image size.
 */


_ol_style_Image_.prototype.getImageSize = function () {};
/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */


_ol_style_Image_.prototype.getHitDetectionImageSize = function () {};
/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */


_ol_style_Image_.prototype.getOrigin = function () {};
/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */


_ol_style_Image_.prototype.getSize = function () {};
/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */


_ol_style_Image_.prototype.setOpacity = function (opacity) {
  this.opacity_ = opacity;
};
/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */


_ol_style_Image_.prototype.setRotateWithView = function (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};
/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */


_ol_style_Image_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */


_ol_style_Image_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};
/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */


_ol_style_Image_.prototype.setSnapToPixel = function (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};
/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */


_ol_style_Image_.prototype.listenImageChange = function (listener, thisArg) {};
/**
 * Load not yet loaded URI.
 * @abstract
 */


_ol_style_Image_.prototype.load = function () {};
/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */


_ol_style_Image_.prototype.unlistenImageChange = function (listener, thisArg) {};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Image_);

/***/ }),

/***/ "./node_modules/ol/style/regularshape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/regularshape.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _imagestate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../imagestate.js */ "./node_modules/ol/imagestate.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _style_image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/image.js */ "./node_modules/ol/style/image.js");







/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */

var _ol_style_RegularShape_ = function (options) {
  /**
   * @private
   * @type {Array.<string>}
   */
  this.checksums_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.hitDetectionCanvas_ = null;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fill_ = options.fill !== undefined ? options.fill : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.origin_ = [0, 0];
  /**
   * @private
   * @type {number}
   */

  this.points_ = options.points;
  /**
   * @protected
   * @type {number}
   */

  this.radius_ =
  /** @type {number} */
  options.radius !== undefined ? options.radius : options.radius1;
  /**
   * @private
   * @type {number|undefined}
   */

  this.radius2_ = options.radius2;
  /**
   * @private
   * @type {number}
   */

  this.angle_ = options.angle !== undefined ? options.angle : 0;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.hitDetectionImageSize_ = null;
  /**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */

  this.atlasManager_ = options.atlasManager;
  this.render_(this.atlasManager_);
  /**
   * @type {boolean}
   */

  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;
  /**
   * @type {boolean}
   */

  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  _style_image_js__WEBPACK_IMPORTED_MODULE_6__["default"].call(this, {
    opacity: 1,
    rotateWithView: rotateWithView,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: 1,
    snapToPixel: snapToPixel
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_style_RegularShape_, _style_image_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */


_ol_style_RegularShape_.prototype.clone = function () {
  var style = new _ol_style_RegularShape_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    points: this.getPoints(),
    radius: this.getRadius(),
    radius2: this.getRadius2(),
    angle: this.getAngle(),
    snapToPixel: this.getSnapToPixel(),
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getAnchor = function () {
  return this.anchor_;
};
/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */


_ol_style_RegularShape_.prototype.getAngle = function () {
  return this.angle_;
};
/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_RegularShape_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.hitDetectionCanvas_;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getImageSize = function () {
  return this.imageSize_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getHitDetectionImageSize = function () {
  return this.hitDetectionImageSize_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getImageState = function () {
  return _imagestate_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getOrigin = function () {
  return this.origin_;
};
/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */


_ol_style_RegularShape_.prototype.getPoints = function () {
  return this.points_;
};
/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */


_ol_style_RegularShape_.prototype.getRadius = function () {
  return this.radius_;
};
/**
 * Get the secondary radius for the shape.
 * @return {number|undefined} Radius2.
 * @api
 */


_ol_style_RegularShape_.prototype.getRadius2 = function () {
  return this.radius2_;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getSize = function () {
  return this.size_;
};
/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_RegularShape_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.listenImageChange = function (listener, thisArg) {};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.load = function () {};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.unlistenImageChange = function (listener, thisArg) {};
/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */


_ol_style_RegularShape_.prototype.render_ = function (atlasManager) {
  var imageSize;
  var lineCap = '';
  var lineJoin = '';
  var miterLimit = 0;
  var lineDash = null;
  var lineDashOffset = 0;
  var strokeStyle;
  var strokeWidth = 0;

  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();

    if (strokeStyle === null) {
      strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultStrokeStyle;
    }

    strokeStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();

    if (strokeWidth === undefined) {
      strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultLineWidth;
    }

    lineDash = this.stroke_.getLineDash();
    lineDashOffset = this.stroke_.getLineDashOffset();

    if (!_has_js__WEBPACK_IMPORTED_MODULE_3__["default"].CANVAS_LINE_DASH) {
      lineDash = null;
      lineDashOffset = 0;
    }

    lineJoin = this.stroke_.getLineJoin();

    if (lineJoin === undefined) {
      lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultLineJoin;
    }

    lineCap = this.stroke_.getLineCap();

    if (lineCap === undefined) {
      lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultLineCap;
    }

    miterLimit = this.stroke_.getMiterLimit();

    if (miterLimit === undefined) {
      miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultMiterLimit;
    }
  }

  var size = 2 * (this.radius_ + strokeWidth) + 1;
  /** @type {ol.RegularShapeRenderOptions} */

  var renderOptions = {
    strokeStyle: strokeStyle,
    strokeWidth: strokeWidth,
    size: size,
    lineCap: lineCap,
    lineDash: lineDash,
    lineDashOffset: lineDashOffset,
    lineJoin: lineJoin,
    miterLimit: miterLimit
  };

  if (atlasManager === undefined) {
    // no atlas manager is used, create a new canvas
    var context = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(size, size);

    this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer

    size = this.canvas_.width;
    imageSize = size;
    this.draw_(renderOptions, context, 0, 0);
    this.createHitDetectionCanvas_(renderOptions);
  } else {
    // an atlas manager is used, add the symbol to an atlas
    size = Math.round(size);
    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;

    if (hasCustomHitDetectionImage) {
      // render the hit-detection image into a separate atlas image
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }

    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);
    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;

    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }

  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */


_ol_style_RegularShape_.prototype.draw_ = function (renderOptions, context, x, y) {
  var i, angle0, radiusC; // reset transform

  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

  context.translate(x, y);
  context.beginPath();
  var points = this.points_;

  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

    if (radius2 !== this.radius_) {
      points = 2 * points;
    }

    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  if (this.fill_) {
    var color = this.fill_.getColor();

    if (color === null) {
      color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultFillStyle;
    }

    context.fillStyle = _colorlike_js__WEBPACK_IMPORTED_MODULE_1__["default"].asColorLike(color);
    context.fill();
  }

  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;

    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }

    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }

  context.closePath();
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */


_ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function (renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];

  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  } // if no fill style is set, create an extra hit-detection image with a
  // default fill style


  var context = _dom_js__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvasContext2D(renderOptions.size, renderOptions.size);

  this.hitDetectionCanvas_ = context.canvas;
  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */


_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

  context.translate(x, y);
  context.beginPath();
  var points = this.points_;

  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

    if (radius2 !== this.radius_) {
      points = 2 * points;
    }

    var i, radiusC, angle0;

    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["default"].defaultFillStyle;
  context.fill();

  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;

    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }

    context.stroke();
  }

  context.closePath();
};
/**
 * @return {string} The checksum.
 */


_ol_style_RegularShape_.prototype.getChecksum = function () {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';
  var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];

  if (recalculate) {
    var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }

  return this.checksums_[0];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_RegularShape_);

/***/ }),

/***/ "./node_modules/ol/style/stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/stroke.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */

var _ol_style_Stroke_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */

  this.color_ = options.color !== undefined ? options.color : null;
  /**
   * @private
   * @type {string|undefined}
   */

  this.lineCap_ = options.lineCap;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lineDashOffset_ = options.lineDashOffset;
  /**
   * @private
   * @type {string|undefined}
   */

  this.lineJoin_ = options.lineJoin;
  /**
   * @private
   * @type {number|undefined}
   */

  this.miterLimit_ = options.miterLimit;
  /**
   * @private
   * @type {number|undefined}
   */

  this.width_ = options.width;
  /**
   * @private
   * @type {string|undefined}
   */

  this.checksum_ = undefined;
};
/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */


_ol_style_Stroke_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Stroke_({
    color: color && color.slice ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};
/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */


_ol_style_Stroke_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */


_ol_style_Stroke_.prototype.getLineCap = function () {
  return this.lineCap_;
};
/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */


_ol_style_Stroke_.prototype.getLineDash = function () {
  return this.lineDash_;
};
/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */


_ol_style_Stroke_.prototype.getLineDashOffset = function () {
  return this.lineDashOffset_;
};
/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */


_ol_style_Stroke_.prototype.getLineJoin = function () {
  return this.lineJoin_;
};
/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */


_ol_style_Stroke_.prototype.getMiterLimit = function () {
  return this.miterLimit_;
};
/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */


_ol_style_Stroke_.prototype.getWidth = function () {
  return this.width_;
};
/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */


_ol_style_Stroke_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */


_ol_style_Stroke_.prototype.setLineCap = function (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};
/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */


_ol_style_Stroke_.prototype.setLineDash = function (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};
/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */


_ol_style_Stroke_.prototype.setLineDashOffset = function (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};
/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */


_ol_style_Stroke_.prototype.setLineJoin = function (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};
/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */


_ol_style_Stroke_.prototype.setMiterLimit = function (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};
/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */


_ol_style_Stroke_.prototype.setWidth = function (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};
/**
 * @return {string} The checksum.
 */


_ol_style_Stroke_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';

    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }

    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Stroke_);

/***/ }),

/***/ "./node_modules/ol/style/style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/style.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _style_circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/circle.js */ "./node_modules/ol/style/circle.js");
/* harmony import */ var _style_fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style/fill.js */ "./node_modules/ol/style/fill.js");
/* harmony import */ var _style_stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/stroke.js */ "./node_modules/ol/style/stroke.js");





/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */

var _ol_style_Style_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */

  this.geometry_ = null;
  /**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */

  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }
  /**
   * @private
   * @type {ol.style.Fill}
   */


  this.fill_ = options.fill !== undefined ? options.fill : null;
  /**
   * @private
   * @type {ol.style.Image}
   */

  this.image_ = options.image !== undefined ? options.image : null;
  /**
   * @private
   * @type {ol.StyleRenderFunction|null}
   */

  this.renderer_ = options.renderer !== undefined ? options.renderer : null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {ol.style.Text}
   */

  this.text_ = options.text !== undefined ? options.text : null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.zIndex_ = options.zIndex;
};
/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */


_ol_style_Style_.prototype.clone = function () {
  var geometry = this.getGeometry();

  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }

  return new _ol_style_Style_({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};
/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {ol.StyleRenderFunction|null} Custom renderer function.
 * @api
 */


_ol_style_Style_.prototype.getRenderer = function () {
  return this.renderer_;
};
/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {ol.StyleRenderFunction|null} renderer Custom renderer function.
 * @api
 */


_ol_style_Style_.prototype.setRenderer = function (renderer) {
  this.renderer_ = renderer;
};
/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */


_ol_style_Style_.prototype.getGeometry = function () {
  return this.geometry_;
};
/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */


_ol_style_Style_.prototype.getGeometryFunction = function () {
  return this.geometryFunction_;
};
/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Style_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Style_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};
/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */


_ol_style_Style_.prototype.getImage = function () {
  return this.image_;
};
/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */


_ol_style_Style_.prototype.setImage = function (image) {
  this.image_ = image;
};
/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Style_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Style_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};
/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */


_ol_style_Style_.prototype.getText = function () {
  return this.text_;
};
/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */


_ol_style_Style_.prototype.setText = function (text) {
  this.text_ = text;
};
/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */


_ol_style_Style_.prototype.getZIndex = function () {
  return this.zIndex_;
};
/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */


_ol_style_Style_.prototype.setGeometry = function (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function (feature) {
      return (
        /** @type {ol.geom.Geometry} */
        feature.get(geometry)
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function () {
      return (
        /** @type {ol.geom.Geometry} */
        geometry
      );
    };
  }

  this.geometry_ = geometry;
};
/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */


_ol_style_Style_.prototype.setZIndex = function (zIndex) {
  this.zIndex_ = zIndex;
};
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */


_ol_style_Style_.createFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(obj instanceof _ol_style_Style_, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`


      styles = [obj];
    }

    styleFunction = function () {
      return styles;
    };
  }

  return styleFunction;
};
/**
 * @type {Array.<ol.style.Style>}
 * @private
 */


_ol_style_Style_.default_ = null;
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */

_ol_style_Style_.defaultFunction = function (feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (ol.style.Circle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!_ol_style_Style_.default_) {
    var fill = new _style_fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _style_stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    _ol_style_Style_.default_ = [new _ol_style_Style_({
      image: new _style_circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return _ol_style_Style_.default_;
};
/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */


_ol_style_Style_.createDefaultEditing = function () {
  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = [new _ol_style_Style_({
    fill: new _style_fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] = styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = [new _ol_style_Style_({
    stroke: new _style_stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: white,
      width: width + 2
    })
  }), new _ol_style_Style_({
    stroke: new _style_stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: blue,
      width: width
    })
  })];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] = styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE] = styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING]);
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = [new _ol_style_Style_({
    image: new _style_circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      radius: width * 2,
      fill: new _style_fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        color: blue
      }),
      stroke: new _style_stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] = styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT];
  styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION] = styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING], styles[_geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT]);
  return styles;
};
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */


_ol_style_Style_.defaultGeometryFunction = function (feature) {
  return feature.getGeometry();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Style_);

/***/ }),

/***/ "./node_modules/ol/style/text.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/text.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_fill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/fill.js */ "./node_modules/ol/style/fill.js");
/* harmony import */ var _style_textplacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/textplacement.js */ "./node_modules/ol/style/textplacement.js");


/**
 * @classdesc
 * Set text style for vector features.
 *
 * @constructor
 * @param {olx.style.TextOptions=} opt_options Options.
 * @api
 */

var _ol_style_Text_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {string|undefined}
   */

  this.font_ = options.font;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = options.rotation;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.rotateWithView_ = options.rotateWithView;
  /**
   * @private
   * @type {number|undefined}
   */

  this.scale_ = options.scale;
  /**
   * @private
   * @type {string|undefined}
   */

  this.text_ = options.text;
  /**
   * @private
   * @type {string|undefined}
   */

  this.textAlign_ = options.textAlign;
  /**
   * @private
   * @type {string|undefined}
   */

  this.textBaseline_ = options.textBaseline;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fill_ = options.fill !== undefined ? options.fill : new _style_fill_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    color: _ol_style_Text_.DEFAULT_FILL_COLOR_
  });
  /**
   * @private
   * @type {number}
   */

  this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
  /**
   * @private
   * @type {ol.style.TextPlacement|string}
   */

  this.placement_ = options.placement !== undefined ? options.placement : _style_textplacement_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT; //TODO Use options.overflow directly after removing @deprecated exceedLength

  var overflow = options.overflow === undefined ? options.exceedLength : options.overflow;
  /**
   * @private
   * @type {boolean}
   */

  this.overflow_ = overflow !== undefined ? overflow : false;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {number}
   */

  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
  /**
   * @private
   * @type {number}
   */

  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.padding_ = options.padding === undefined ? null : options.padding;
};
/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 * @private
 */


_ol_style_Text_.DEFAULT_FILL_COLOR_ = '#333';
/**
 * Clones the style.
 * @return {ol.style.Text} The cloned style.
 * @api
 */

_ol_style_Text_.prototype.clone = function () {
  return new _ol_style_Text_({
    font: this.getFont(),
    placement: this.getPlacement(),
    maxAngle: this.getMaxAngle(),
    overflow: this.getOverflow(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    scale: this.getScale(),
    text: this.getText(),
    textAlign: this.getTextAlign(),
    textBaseline: this.getTextBaseline(),
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    offsetX: this.getOffsetX(),
    offsetY: this.getOffsetY()
  });
};
/**
 * Get the `overflow` configuration.
 * @return {boolean} Let text overflow the length of the path they follow.
 * @api
 */


_ol_style_Text_.prototype.getOverflow = function () {
  return this.overflow_;
};
/**
 * Get the font name.
 * @return {string|undefined} Font.
 * @api
 */


_ol_style_Text_.prototype.getFont = function () {
  return this.font_;
};
/**
 * Get the maximum angle between adjacent characters.
 * @return {number} Angle in radians.
 * @api
 */


_ol_style_Text_.prototype.getMaxAngle = function () {
  return this.maxAngle_;
};
/**
 * Get the label placement.
 * @return {ol.style.TextPlacement|string} Text placement.
 * @api
 */


_ol_style_Text_.prototype.getPlacement = function () {
  return this.placement_;
};
/**
 * Get the x-offset for the text.
 * @return {number} Horizontal text offset.
 * @api
 */


_ol_style_Text_.prototype.getOffsetX = function () {
  return this.offsetX_;
};
/**
 * Get the y-offset for the text.
 * @return {number} Vertical text offset.
 * @api
 */


_ol_style_Text_.prototype.getOffsetY = function () {
  return this.offsetY_;
};
/**
 * Get the fill style for the text.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Text_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * Determine whether the text rotates with the map.
 * @return {boolean|undefined} Rotate with map.
 * @api
 */


_ol_style_Text_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};
/**
 * Get the text rotation.
 * @return {number|undefined} Rotation.
 * @api
 */


_ol_style_Text_.prototype.getRotation = function () {
  return this.rotation_;
};
/**
 * Get the text scale.
 * @return {number|undefined} Scale.
 * @api
 */


_ol_style_Text_.prototype.getScale = function () {
  return this.scale_;
};
/**
 * Get the stroke style for the text.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Text_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * Get the text to be rendered.
 * @return {string|undefined} Text.
 * @api
 */


_ol_style_Text_.prototype.getText = function () {
  return this.text_;
};
/**
 * Get the text alignment.
 * @return {string|undefined} Text align.
 * @api
 */


_ol_style_Text_.prototype.getTextAlign = function () {
  return this.textAlign_;
};
/**
 * Get the text baseline.
 * @return {string|undefined} Text baseline.
 * @api
 */


_ol_style_Text_.prototype.getTextBaseline = function () {
  return this.textBaseline_;
};
/**
 * Get the background fill style for the text.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Text_.prototype.getBackgroundFill = function () {
  return this.backgroundFill_;
};
/**
 * Get the background stroke style for the text.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Text_.prototype.getBackgroundStroke = function () {
  return this.backgroundStroke_;
};
/**
 * Get the padding for the text.
 * @return {Array.<number>} Padding.
 * @api
 */


_ol_style_Text_.prototype.getPadding = function () {
  return this.padding_;
};
/**
 * Set the `overflow` property.
 *
 * @param {boolean} overflow Let text overflow the path that it follows.
 * @api
 */


_ol_style_Text_.prototype.setOverflow = function (overflow) {
  this.overflow_ = overflow;
};
/**
 * Set the font.
 *
 * @param {string|undefined} font Font.
 * @api
 */


_ol_style_Text_.prototype.setFont = function (font) {
  this.font_ = font;
};
/**
 * Set the maximum angle between adjacent characters.
 *
 * @param {number} maxAngle Angle in radians.
 * @api
 */


_ol_style_Text_.prototype.setMaxAngle = function (maxAngle) {
  this.maxAngle_ = maxAngle;
};
/**
 * Set the x offset.
 *
 * @param {number} offsetX Horizontal text offset.
 * @api
 */


_ol_style_Text_.prototype.setOffsetX = function (offsetX) {
  this.offsetX_ = offsetX;
};
/**
 * Set the y offset.
 *
 * @param {number} offsetY Vertical text offset.
 * @api
 */


_ol_style_Text_.prototype.setOffsetY = function (offsetY) {
  this.offsetY_ = offsetY;
};
/**
 * Set the text placement.
 *
 * @param {ol.style.TextPlacement|string} placement Placement.
 * @api
 */


_ol_style_Text_.prototype.setPlacement = function (placement) {
  this.placement_ = placement;
};
/**
 * Set the fill.
 *
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Text_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};
/**
 * Set the rotation.
 *
 * @param {number|undefined} rotation Rotation.
 * @api
 */


_ol_style_Text_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number|undefined} scale Scale.
 * @api
 */


_ol_style_Text_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};
/**
 * Set the stroke.
 *
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Text_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};
/**
 * Set the text.
 *
 * @param {string|undefined} text Text.
 * @api
 */


_ol_style_Text_.prototype.setText = function (text) {
  this.text_ = text;
};
/**
 * Set the text alignment.
 *
 * @param {string|undefined} textAlign Text align.
 * @api
 */


_ol_style_Text_.prototype.setTextAlign = function (textAlign) {
  this.textAlign_ = textAlign;
};
/**
 * Set the text baseline.
 *
 * @param {string|undefined} textBaseline Text baseline.
 * @api
 */


_ol_style_Text_.prototype.setTextBaseline = function (textBaseline) {
  this.textBaseline_ = textBaseline;
};
/**
 * Set the background fill.
 *
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Text_.prototype.setBackgroundFill = function (fill) {
  this.backgroundFill_ = fill;
};
/**
 * Set the background stroke.
 *
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Text_.prototype.setBackgroundStroke = function (stroke) {
  this.backgroundStroke_ = stroke;
};
/**
 * Set the padding (`[top, right, bottom, left]`).
 *
 * @param {!Array.<number>} padding Padding.
 * @api
 */


_ol_style_Text_.prototype.setPadding = function (padding) {
  this.padding_ = padding;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Text_);

/***/ }),

/***/ "./node_modules/ol/style/textplacement.js":
/*!************************************************!*\
  !*** ./node_modules/ol/style/textplacement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link ol.geom.LineString},
 * {@link ol.geom.Polygon}, {@link ol.geom.MultiLineString} or
 * {@link ol.geom.MultiPolygon}.
 * @enum {string}
 */
var _ol_style_TextPlacement_ = {
  POINT: 'point',
  LINE: 'line'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_TextPlacement_);

/***/ }),

/***/ "./node_modules/ol/tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/tile.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/eventtarget.js */ "./node_modules/ol/events/eventtarget.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");





/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {olx.TileOptions=} opt_options Tile options.
 */

var _ol_Tile_ = function (tileCoord, state, opt_options) {
  _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this);

  var options = opt_options ? opt_options : {};
  /**
   * @type {ol.TileCoord}
   */

  this.tileCoord = tileCoord;
  /**
   * @protected
   * @type {ol.TileState}
   */

  this.state = state;
  /**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {ol.Tile}
   */

  this.interimTile = null;
  /**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */

  this.key = '';
  /**
   * The duration for the opacity transition.
   * @type {number}
   */

  this.transition_ = options.transition === undefined ? 250 : options.transition;
  /**
   * Lookup of start times for rendering transitions.  If the start time is
   * equal to -1, the transition is complete.
   * @type {Object.<number, number>}
   */

  this.transitionStarts_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_Tile_, _events_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @protected
 */


_ol_Tile_.prototype.changed = function () {
  this.dispatchEvent(_events_eventtype_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE);
};
/**
 * @return {string} Key.
 */


_ol_Tile_.prototype.getKey = function () {
  return this.key + '/' + this.tileCoord;
};
/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!ol.Tile} Best tile for rendering.
 */


_ol_Tile_.prototype.getInterimTile = function () {
  if (!this.interimTile) {
    //empty chain
    return this;
  }

  var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
  // decreasing order of creation time, there is no need to search the remainder
  // of the list (all those tiles correspond to older requests and will be
  // cleaned up by refreshInterimChain)

  do {
    if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return tile;
    }

    tile = tile.interimTile;
  } while (tile); // we can not find a better tile


  return this;
};
/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */


_ol_Tile_.prototype.refreshInterimChain = function () {
  if (!this.interimTile) {
    return;
  }

  var tile = this.interimTile;
  var prev = this;

  do {
    if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      //we have a loaded tile, we can discard the rest of the list
      //we would could abort any LOADING tile request
      //older than this tile (i.e. any LOADING tile following this entry in the chain)
      tile.interimTile = null;
      break;
    } else if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      //keep this LOADING tile any loaded tiles later in the chain are
      //older than this tile, so we're still interested in the request
      prev = tile;
    } else if (tile.getState() == _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      //the head of the list is the most current tile, we don't need
      //to start any other requests for this chain
      prev.interimTile = tile.interimTile;
    } else {
      prev = tile;
    }

    tile = prev.interimTile;
  } while (tile);
};
/**
 * Get the tile coordinate for this tile.
 * @return {ol.TileCoord} The tile coordinate.
 * @api
 */


_ol_Tile_.prototype.getTileCoord = function () {
  return this.tileCoord;
};
/**
 * @return {ol.TileState} State.
 */


_ol_Tile_.prototype.getState = function () {
  return this.state;
};
/**
 * @param {ol.TileState} state State.
 */


_ol_Tile_.prototype.setState = function (state) {
  this.state = state;
  this.changed();
};
/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */


_ol_Tile_.prototype.load = function () {};
/**
 * Get the alpha value for rendering.
 * @param {number} id An id for the renderer.
 * @param {number} time The render frame time.
 * @return {number} A number between 0 and 1.
 */


_ol_Tile_.prototype.getAlpha = function (id, time) {
  if (!this.transition_) {
    return 1;
  }

  var start = this.transitionStarts_[id];

  if (!start) {
    start = time;
    this.transitionStarts_[id] = start;
  } else if (start === -1) {
    return 1;
  }

  var delta = time - start + 1000 / 60; // avoid rendering at 0

  if (delta >= this.transition_) {
    return 1;
  }

  return _easing_js__WEBPACK_IMPORTED_MODULE_2__["default"].easeIn(delta / this.transition_);
};
/**
 * Determine if a tile is in an alpha transition.  A tile is considered in
 * transition if tile.getAlpha() has not yet been called or has been called
 * and returned 1.
 * @param {number} id An id for the renderer.
 * @return {boolean} The tile is in transition.
 */


_ol_Tile_.prototype.inTransition = function (id) {
  if (!this.transition_) {
    return false;
  }

  return this.transitionStarts_[id] !== -1;
};
/**
 * Mark a transition as complete.
 * @param {number} id An id for the renderer.
 */


_ol_Tile_.prototype.endTransition = function (id) {
  if (this.transition_) {
    this.transitionStarts_[id] = -1;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_Tile_);

/***/ }),

/***/ "./node_modules/ol/tilecache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecache.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./structs/lrucache.js */ "./node_modules/ol/structs/lrucache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");



/**
 * @constructor
 * @extends {ol.structs.LRUCache.<ol.Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */

var _ol_TileCache_ = function (opt_highWaterMark) {
  _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, opt_highWaterMark);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_TileCache_, _structs_lrucache_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */


_ol_TileCache_.prototype.expireCache = function (usedTiles) {
  var tile, zKey;

  while (this.canExpireCache()) {
    tile = this.peekLast();
    zKey = tile.tileCoord[0].toString();

    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this.pop().dispose();
    }
  }
};
/**
 * Prune all tiles from the cache that don't have the same z as the newest tile.
 */


_ol_TileCache_.prototype.pruneExceptNewestZ = function () {
  if (this.getCount() === 0) {
    return;
  }

  var key = this.peekFirstKey();

  var tileCoord = _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["default"].fromKey(key);

  var z = tileCoord[0];
  this.forEach(function (tile) {
    if (tile.tileCoord[0] !== z) {
      this.remove(_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["default"].getKey(tile.tileCoord));
      tile.dispose();
    }
  }, this);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_TileCache_);

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_tilecoord_ = {};
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.
 * @return {ol.TileCoord} Tile coordinate.
 */

_ol_tilecoord_.createOrUpdate = function (z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
};
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */


_ol_tilecoord_.getKeyZXY = function (z, x, y) {
  return z + '/' + x + '/' + y;
};
/**
 * Get the key for a tile coord.
 * @param {ol.TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */


_ol_tilecoord_.getKey = function (tileCoord) {
  return _ol_tilecoord_.getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
};
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {ol.TileCoord} The tile coord.
 */


_ol_tilecoord_.fromKey = function (key) {
  return key.split('/').map(Number);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */


_ol_tilecoord_.hash = function (tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
};
/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */


_ol_tilecoord_.quadKey = function (tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;

  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;

    if (tileCoord[1] & mask) {
      charCode += 1;
    }

    if (tileCoord[2] & mask) {
      charCode += 2;
    }

    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }

  return digits.join('');
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */


_ol_tilecoord_.withinExtentAndZ = function (tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var extent = tileGrid.getExtent();
  var tileRange;

  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_tilecoord_);

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_corner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent/corner.js */ "./node_modules/ol/extent/corner.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/units.js */ "./node_modules/ol/proj/units.js");
/* harmony import */ var _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tilegrid/tilegrid.js */ "./node_modules/ol/tilegrid/tilegrid.js");








var _ol_tilegrid_ = {};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.
 */

_ol_tilegrid_.getForProjection = function (projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = _ol_tilegrid_.createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
};
/**
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCoord} Tile coordinate.
 */


_ol_tilegrid_.wrapX = function (tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);

  var projectionExtent = _ol_tilegrid_.extentFromProjection(projection);

  if (!_extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].containsCoordinate(projectionExtent, center)) {
    var worldWidth = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getWidth(projectionExtent);

    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.TOP_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */


_ol_tilegrid_.createForExtent = function (extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_corner_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT;

  var resolutions = _ol_tilegrid_.resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    extent: extent,
    origin: _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCorner(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
};
/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.
 * @return {!ol.tilegrid.TileGrid} Tile grid instance.
 * @api
 */


_ol_tilegrid_.createXYZ = function (opt_options) {
  var options =
  /** @type {olx.tilegrid.TileGridOptions} */
  {};

  _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].assign(options, opt_options !== undefined ? opt_options :
  /** @type {olx.tilegrid.XYZOptions} */
  {});

  if (options.extent === undefined) {
    options.extent = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get('EPSG:3857').getExtent();
  }

  options.resolutions = _ol_tilegrid_.resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;
  return new _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__["default"](options);
};
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */


_ol_tilegrid_.resolutionsFromExtent = function (extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_MAX_ZOOM;

  var height = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHeight(extent);

  var width = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].getWidth(extent);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_1__["default"].toSize(opt_tileSize !== undefined ? opt_tileSize : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_TILE_SIZE);

  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
};
/**
 * @param {ol.ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.BOTTOM_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */


_ol_tilegrid_.createForProjection = function (projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = _ol_tilegrid_.extentFromProjection(projection);

  return _ol_tilegrid_.createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
};
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {ol.ProjectionLike} projection Projection.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_.extentFromProjection = function (projection) {
  projection = _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].get(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_5__["default"].METERS_PER_UNIT[_proj_units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = _extent_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdate(-half, -half, half, half);
  }

  return extent;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_tilegrid_);

/***/ }),

/***/ "./node_modules/ol/tilegrid/tilegrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/tilegrid.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _tilerange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilerange.js */ "./node_modules/ol/tilerange.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");








/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {olx.tilegrid.TileGridOptions} options Tile grid options.
 * @struct
 * @api
 */

var _ol_tilegrid_TileGrid_ = function (options) {
  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
  /**
   * @private
   * @type {!Array.<number>}
   */

  this.resolutions_ = options.resolutions;

  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(_array_js__WEBPACK_IMPORTED_MODULE_3__["default"].isSorted(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order
  // check if we've got a consistent zoom factor and origin


  var zoomFactor;

  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }
  /**
   * @private
   * @type {number|undefined}
   */


  this.zoomFactor_ = zoomFactor;
  /**
   * @protected
   * @type {number}
   */

  this.maxZoom = this.resolutions_.length - 1;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.origin_ = options.origin !== undefined ? options.origin : null;
  /**
   * @private
   * @type {Array.<ol.Coordinate>}
   */

  this.origins_ = null;

  if (options.origins !== undefined) {
    this.origins_ = options.origins;

    _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal

  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].getTopLeft(extent);
  }

  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|ol.Size>}
   */


  this.tileSizes_ = null;

  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;

    _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal

  }
  /**
   * @private
   * @type {number|ol.Size}
   */


  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_TILE_SIZE : null;

  _asserts_js__WEBPACK_IMPORTED_MODULE_1__["default"].assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {ol.Extent}
   */


  this.extent_ = extent !== undefined ? extent : null;
  /**
   * @private
   * @type {Array.<ol.TileRange>}
   */

  this.fullTileRanges_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"](Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};
/**
 * @private
 * @type {ol.TileCoord}
 */


_ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];
/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.
 * @api
 */

_ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */


_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;

  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }

  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdate(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }

    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }

    --z;
  }

  return false;
};
/**
 * Get the extent for this tile grid, if it was configured.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_TileGrid_.prototype.getExtent = function () {
  return this.extent_;
};
/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getMaxZoom = function () {
  return this.maxZoom;
};
/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getMinZoom = function () {
  return this.minZoom;
};
/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {ol.Coordinate} Origin.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};
/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};
/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.TileRange} Tile range.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }

    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }

  return null;
};
/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_6__["default"].toSize(this.getTileSize(z), this.tmpSize_);

  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {ol.Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */


_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var tileCoord = _ol_tilegrid_TileGrid_.tmpTileCoord_;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return _tilerange_js__WEBPACK_IMPORTED_MODULE_2__["default"].createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {ol.Coordinate} Tile center.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_6__["default"].toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);

  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};
/**
 * Get the extent of a tile coordinate.
 *
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Extent=} opt_extent Temporary extent object.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_6__["default"].toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);

  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"].createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};
/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_6__["default"].toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.  This method is for integer zoom
 * levels.  The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);

  var tileSize = _size_js__WEBPACK_IMPORTED_MODULE_6__["default"].toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["default"].createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};
/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * @param {number} z Z.
 * @return {number|ol.Size} Tile size.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};
/**
 * @param {number} z Zoom level.
 * @return {ol.TileRange} Extent tile range for the specified zoom level.
 */


_ol_tilegrid_TileGrid_.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};
/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = _array_js__WEBPACK_IMPORTED_MODULE_3__["default"].linearFindNearest(this.resolutions_, resolution, opt_direction || 0);

  return _math_js__WEBPACK_IMPORTED_MODULE_5__["default"].clamp(z, this.minZoom, this.maxZoom);
};
/**
 * @param {!ol.Extent} extent Extent for this tile grid.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);

  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }

  this.fullTileRanges_ = fullTileRanges;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_tilegrid_TileGrid_);

/***/ }),

/***/ "./node_modules/ol/tilegrid/wmts.js":
/*!******************************************!*\
  !*** ./node_modules/ol/tilegrid/wmts.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilegrid/tilegrid.js */ "./node_modules/ol/tilegrid/tilegrid.js");




/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 *
 * @constructor
 * @extends {ol.tilegrid.TileGrid}
 * @param {olx.tilegrid.WMTSOptions} options WMTS options.
 * @struct
 * @api
 */

var _ol_tilegrid_WMTS_ = function (options) {
  /**
   * @private
   * @type {!Array.<string>}
   */
  this.matrixIds_ = options.matrixIds; // FIXME: should the matrixIds become optional?

  _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__["default"].call(this, {
    extent: options.extent,
    origin: options.origin,
    origins: options.origins,
    resolutions: options.resolutions,
    tileSize: options.tileSize,
    tileSizes: options.tileSizes,
    sizes: options.sizes
  });
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_tilegrid_WMTS_, _tilegrid_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {number} z Z.
 * @return {string} MatrixId..
 */


_ol_tilegrid_WMTS_.prototype.getMatrixId = function (z) {
  return this.matrixIds_[z];
};
/**
 * Get the list of matrix identifiers.
 * @return {Array.<string>} MatrixIds.
 * @api
 */


_ol_tilegrid_WMTS_.prototype.getMatrixIds = function () {
  return this.matrixIds_;
};
/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {ol.Extent=} opt_extent An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array.<Object>=} opt_matrixLimits An optional object representing
 *     the available matrices for tileGrid.
 * @return {ol.tilegrid.WMTS} WMTS tileGrid instance.
 * @api
 */


_ol_tilegrid_WMTS_.createFromCapabilitiesMatrixSet = function (matrixSet, opt_extent, opt_matrixLimits) {
  /** @type {!Array.<number>} */
  var resolutions = [];
  /** @type {!Array.<string>} */

  var matrixIds = [];
  /** @type {!Array.<ol.Coordinate>} */

  var origins = [];
  /** @type {!Array.<ol.Size>} */

  var tileSizes = [];
  /** @type {!Array.<ol.Size>} */

  var sizes = [];
  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];
  var supportedCRSPropName = 'SupportedCRS';
  var matrixIdsPropName = 'TileMatrix';
  var identifierPropName = 'Identifier';
  var scaleDenominatorPropName = 'ScaleDenominator';
  var topLeftCornerPropName = 'TopLeftCorner';
  var tileWidthPropName = 'TileWidth';
  var tileHeightPropName = 'TileHeight';
  var code = matrixSet[supportedCRSPropName];

  var projection = _proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].get(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || _proj_js__WEBPACK_IMPORTED_MODULE_2__["default"].get(code);

  var metersPerUnit = projection.getMetersPerUnit(); // swap origin x and y coordinates if axis orientation is lat/long

  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  matrixSet[matrixIdsPropName].sort(function (a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });
  matrixSet[matrixIdsPropName].forEach(function (elt, index, array) {
    var matrixAvailable; // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.

    if (matrixLimits.length > 0) {
      matrixAvailable = _array_js__WEBPACK_IMPORTED_MODULE_1__["default"].find(matrixLimits, function (elt_ml, index_ml, array_ml) {
        return elt[identifierPropName] == elt_ml[matrixIdsPropName];
      });
    } else {
      matrixAvailable = true;
    }

    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28E-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];

      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }

      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]); // top-left origin, so height is negative

      sizes.push([elt['MatrixWidth'], -elt['MatrixHeight']]);
    }
  });
  return new _ol_tilegrid_WMTS_({
    extent: opt_extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes
  });
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_tilegrid_WMTS_);

/***/ }),

/***/ "./node_modules/ol/tilequeue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilequeue.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./structs/priorityqueue.js */ "./node_modules/ol/structs/priorityqueue.js");





/**
 * @constructor
 * @extends {ol.structs.PriorityQueue.<Array>}
 * @param {ol.TilePriorityFunction} tilePriorityFunction
 *     Tile priority function.
 * @param {function(): ?} tileChangeCallback
 *     Function called on each tile change event.
 * @struct
 */

var _ol_TileQueue_ = function (tilePriorityFunction, tileChangeCallback) {
  _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_4__["default"].call(this,
  /**
   * @param {Array} element Element.
   * @return {number} Priority.
   */
  function (element) {
    return tilePriorityFunction.apply(null, element);
  },
  /**
   * @param {Array} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (
      /** @type {ol.Tile} */
      element[0].getKey()
    );
  });
  /**
   * @private
   * @type {function(): ?}
   */


  this.tileChangeCallback_ = tileChangeCallback;
  /**
   * @private
   * @type {number}
   */

  this.tilesLoading_ = 0;
  /**
   * @private
   * @type {!Object.<string,boolean>}
   */

  this.tilesLoadingKeys_ = {};
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_TileQueue_, _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @inheritDoc
 */


_ol_TileQueue_.prototype.enqueue = function (element) {
  var added = _structs_priorityqueue_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.enqueue.call(this, element);

  if (added) {
    var tile = element[0];

    _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].listen(tile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleTileChange, this);
  }

  return added;
};
/**
 * @return {number} Number of tiles loading.
 */


_ol_TileQueue_.prototype.getTilesLoading = function () {
  return this.tilesLoading_;
};
/**
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_TileQueue_.prototype.handleTileChange = function (event) {
  var tile =
  /** @type {ol.Tile} */
  event.target;
  var state = tile.getState();

  if (state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR || state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY || state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) {
    _events_js__WEBPACK_IMPORTED_MODULE_2__["default"].unlisten(tile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleTileChange, this);

    var tileKey = tile.getKey();

    if (tileKey in this.tilesLoadingKeys_) {
      delete this.tilesLoadingKeys_[tileKey];
      --this.tilesLoading_;
    }

    this.tileChangeCallback_();
  }
};
/**
 * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
 * @param {number} maxNewLoads Maximum number of new tiles to load.
 */


_ol_TileQueue_.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
  var newLoads = 0;
  var abortedTiles = false;
  var state, tile, tileKey;

  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
    tile =
    /** @type {ol.Tile} */
    this.dequeue()[0];
    tileKey = tile.getKey();
    state = tile.getState();

    if (state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) {
      abortedTiles = true;
    } else if (state === _tilestate_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
      this.tilesLoadingKeys_[tileKey] = true;
      ++this.tilesLoading_;
      ++newLoads;
      tile.load();
    }
  }

  if (newLoads === 0 && abortedTiles) {
    // Do not stop the render loop when all wanted tiles were aborted due to
    // a small, saturated tile cache.
    this.tileChangeCallback_();
  }
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_TileQueue_);

/***/ }),

/***/ "./node_modules/ol/tilerange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilerange.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var _ol_TileRange_ = function (minX, maxX, minY, maxY) {
  /**
   * @type {number}
   */
  this.minX = minX;
  /**
   * @type {number}
   */

  this.maxX = maxX;
  /**
   * @type {number}
   */

  this.minY = minY;
  /**
   * @type {number}
   */

  this.maxY = maxY;
};
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {ol.TileRange|undefined} tileRange TileRange.
 * @return {ol.TileRange} Tile range.
 */


_ol_TileRange_.createOrUpdate = function (minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new _ol_TileRange_(minX, maxX, minY, maxY);
  }
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */


_ol_TileRange_.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */


_ol_TileRange_.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};
/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */


_ol_TileRange_.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */


_ol_TileRange_.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 */


_ol_TileRange_.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }

  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }

  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }

  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};
/**
 * @return {number} Height.
 */


_ol_TileRange_.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};
/**
 * @return {ol.Size} Size.
 */


_ol_TileRange_.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};
/**
 * @return {number} Width.
 */


_ol_TileRange_.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */


_ol_TileRange_.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_TileRange_);

/***/ }),

/***/ "./node_modules/ol/tilestate.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilestate.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {number}
 */
var _ol_TileState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_TileState_);

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");



var _ol_TileUrlFunction_ = {};
/**
 * @param {string} template Template.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */

_ol_TileUrlFunction_.createFromTemplate = function (template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {
          var y = -tileCoord[2] - 1;
          return y.toString();
        }).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);

          _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(range, 55); // The {-y} placeholder requires a tile grid with extent


          var y = range.getHeight() + tileCoord[2];
          return y.toString();
        });
      }
    }
  );
};
/**
 * @param {Array.<string>} templates Templates.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */


_ol_TileUrlFunction_.createFromTemplates = function (templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);

  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = _ol_TileUrlFunction_.createFromTemplate(templates[i], tileGrid);
  }

  return _ol_TileUrlFunction_.createFromTileUrlFunctions(tileUrlFunctions);
};
/**
 * @param {Array.<ol.TileUrlFunctionType>} tileUrlFunctions Tile URL Functions.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */


_ol_TileUrlFunction_.createFromTileUrlFunctions = function (tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }

  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash(tileCoord);

        var index = _math_js__WEBPACK_IMPORTED_MODULE_1__["default"].modulo(h, tileUrlFunctions.length);

        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */


_ol_TileUrlFunction_.nullTileUrlFunction = function (tileCoord, pixelRatio, projection) {
  return undefined;
};
/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */


_ol_TileUrlFunction_.expandUrl = function (url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_TileUrlFunction_);

/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _ol_transform_ = {};
/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3x3 martrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {ol.Transform}
 */

_ol_transform_.tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!ol.Transform} Identity transform.
 */

_ol_transform_.create = function () {
  return [1, 0, 0, 1, 0, 0];
};
/**
 * Resets the given transform to an identity transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Transform.
 */


_ol_transform_.reset = function (transform) {
  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);
};
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!ol.Transform} transform1 Transform parameters of matrix 1.
 * @param {!ol.Transform} transform2 Transform parameters of matrix 2.
 * @return {!ol.Transform} transform1 multiplied with transform2.
 */


_ol_transform_.multiply = function (transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
};
/**
 * Set the transform components a-f on a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!ol.Transform} Matrix with transform applied.
 */


_ol_transform_.set = function (transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
};
/**
 * Set transform on one matrix from another matrix.
 * @param {!ol.Transform} transform1 Matrix to set transform to.
 * @param {!ol.Transform} transform2 Matrix to set transform from.
 * @return {!ol.Transform} transform1 with transform from transform2 applied.
 */


_ol_transform_.setFromArray = function (transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
};
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {ol.Transform} transform The transformation.
 * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.
 * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be
 *     chained together.
 */


_ol_transform_.apply = function (transform, coordinate) {
  var x = coordinate[0],
      y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
};
/**
 * Applies rotation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!ol.Transform} The rotated transform.
 */


_ol_transform_.rotate = function (transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));
};
/**
 * Applies scale to a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!ol.Transform} The scaled transform.
 */


_ol_transform_.scale = function (transform, x, y) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));
};
/**
 * Applies translation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!ol.Transform} The translated transform.
 */


_ol_transform_.translate = function (transform, dx, dy) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));
};
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!ol.Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!ol.Transform} The composite transform.
 */


_ol_transform_.compose = function (transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
};
/**
 * Invert the given transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Inverse of the transform.
 */


_ol_transform_.invert = function (transform) {
  var det = _ol_transform_.determinant(transform);

  _asserts_js__WEBPACK_IMPORTED_MODULE_0__["default"].assert(det !== 0, 32); // Transformation matrix cannot be inverted


  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];
  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;
  return transform;
};
/**
 * Returns the determinant of the given matrix.
 * @param {!ol.Transform} mat Matrix.
 * @return {number} Determinant.
 */


_ol_transform_.determinant = function (mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_transform_);

/***/ }),

/***/ "./node_modules/ol/uri.js":
/*!********************************!*\
  !*** ./node_modules/ol/uri.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_uri_ = {};
/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */

_ol_uri_.appendParams = function (uri, params) {
  var keyParams = []; // Skip any null or undefined parameter values

  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&'); // remove any trailing ? or &

  uri = uri.replace(/[?&]$/, ''); // append ? or & depending on whether uri has existing parameters

  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
  return uri + qs;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_uri_);

/***/ }),

/***/ "./node_modules/ol/vec/mat4.js":
/*!*************************************!*\
  !*** ./node_modules/ol/vec/mat4.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_vec_Mat4_ = {};
/**
 * @return {Array.<number>} 4x4 matrix representing a 3D identity transform.
 */

_ol_vec_Mat4_.create = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * @param {Array.<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {ol.Transform} transform Transformation matrix.
 * @return {Array.<number>} 2D transformation matrix as flattened 4x4 matrix.
 */


_ol_vec_Mat4_.fromTransform = function (mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_vec_Mat4_);

/***/ }),

/***/ "./node_modules/ol/vectorimagetile.js":
/*!********************************************!*\
  !*** ./node_modules/ol/vectorimagetile.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilestate.js */ "./node_modules/ol/tilestate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events/eventtype.js */ "./node_modules/ol/events/eventtype.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./featureloader.js */ "./node_modules/ol/featureloader.js");








/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {number} sourceRevision Source revision.
 * @param {ol.format.Feature} format Feature format.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @param {ol.TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
 * @param {ol.TileUrlFunctionType} tileUrlFunction Tile url function.
 * @param {ol.tilegrid.TileGrid} sourceTileGrid Tile grid of the source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid of the renderer.
 * @param {Object.<string,ol.VectorTile>} sourceTiles Source tiles.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {function(new: ol.VectorTile, ol.TileCoord, ol.TileState, string,
 *     ol.format.Feature, ol.TileLoadFunctionType)} tileClass Class to
 *     instantiate for source tiles.
 * @param {function(this: ol.source.VectorTile, ol.events.Event)} handleTileChange
 *     Function to call when a source tile's state changes.
 * @param {olx.TileOptions=} opt_options Tile options.
 */

var _ol_VectorImageTile_ = function (tileCoord, state, sourceRevision, format, tileLoadFunction, urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection, tileClass, handleTileChange, opt_options) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, state, opt_options);
  /**
   * @private
   * @type {Object.<string, CanvasRenderingContext2D>}
   */


  this.context_ = {};
  /**
   * @private
   * @type {ol.FeatureLoader}
   */

  this.loader_;
  /**
   * @private
   * @type {Object.<string, ol.TileReplayState>}
   */

  this.replayState_ = {};
  /**
   * @private
   * @type {Object.<string,ol.VectorTile>}
   */

  this.sourceTiles_ = sourceTiles;
  /**
   * Keys of source tiles used by this tile. Use with {@link #getTile}.
   * @type {Array.<string>}
   */

  this.tileKeys = [];
  /**
   * @type {number}
   */

  this.sourceRevision_ = sourceRevision;
  /**
   * @type {ol.TileCoord}
   */

  this.wrappedTileCoord = urlTileCoord;
  /**
   * @type {Array.<ol.EventsKey>}
   */

  this.loadListenerKeys_ = [];
  /**
   * @type {Array.<ol.EventsKey>}
   */

  this.sourceTileListenerKeys_ = [];

  if (urlTileCoord) {
    var extent = tileGrid.getTileCoordExtent(urlTileCoord);
    var resolution = tileGrid.getResolution(tileCoord[0]);
    var sourceZ = sourceTileGrid.getZForResolution(resolution);
    sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
      var sharedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(extent, sourceTileGrid.getTileCoordExtent(sourceTileCoord));

      var sourceExtent = sourceTileGrid.getExtent();

      if (sourceExtent) {
        sharedExtent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(sharedExtent, sourceExtent);
      }

      if (_extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getWidth(sharedExtent) / resolution >= 0.5 && _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"].getHeight(sharedExtent) / resolution >= 0.5) {
        // only include source tile if overlap is at least 1 pixel
        var sourceTileKey = sourceTileCoord.toString();
        var sourceTile = sourceTiles[sourceTileKey];

        if (!sourceTile) {
          var tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);
          sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord, tileUrl == undefined ? _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY : _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE, tileUrl == undefined ? '' : tileUrl, format, tileLoadFunction);
          this.sourceTileListenerKeys_.push(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(sourceTile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, handleTileChange));
        }

        sourceTile.consumers++;
        this.tileKeys.push(sourceTileKey);
      }
    }.bind(this));
  }
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_VectorImageTile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_VectorImageTile_.prototype.disposeInternal = function () {
  for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {
    var sourceTileKey = this.tileKeys[i];
    var sourceTile = this.getTile(sourceTileKey);
    sourceTile.consumers--;

    if (sourceTile.consumers == 0) {
      delete this.sourceTiles_[sourceTileKey];
      sourceTile.dispose();
    }
  }

  this.tileKeys.length = 0;
  this.sourceTiles_ = null;
  this.loadListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
  this.loadListenerKeys_.length = 0;

  if (this.interimTile) {
    this.interimTile.dispose();
  }

  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT;
  this.changed();
  this.sourceTileListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
  this.sourceTileListenerKeys_.length = 0;

  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.disposeInternal.call(this);
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @return {CanvasRenderingContext2D} The rendering context.
 */


_ol_VectorImageTile_.prototype.getContext = function (layer) {
  var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString();

  if (!(key in this.context_)) {
    this.context_[key] = _dom_js__WEBPACK_IMPORTED_MODULE_3__["default"].createCanvasContext2D();
  }

  return this.context_[key];
};
/**
 * Get the Canvas for this tile.
 * @param {ol.layer.Layer} layer Layer.
 * @return {HTMLCanvasElement} Canvas.
 */


_ol_VectorImageTile_.prototype.getImage = function (layer) {
  return this.getReplayState(layer).renderedTileRevision == -1 ? null : this.getContext(layer).canvas;
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @return {ol.TileReplayState} The replay state.
 */


_ol_VectorImageTile_.prototype.getReplayState = function (layer) {
  var key = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer).toString();

  if (!(key in this.replayState_)) {
    this.replayState_[key] = {
      dirty: false,
      renderedRenderOrder: null,
      renderedRevision: -1,
      renderedTileRevision: -1
    };
  }

  return this.replayState_[key];
};
/**
 * @inheritDoc
 */


_ol_VectorImageTile_.prototype.getKey = function () {
  return this.tileKeys.join('/') + '-' + this.sourceRevision_;
};
/**
 * @param {string} tileKey Key (tileCoord) of the source tile.
 * @return {ol.VectorTile} Source tile.
 */


_ol_VectorImageTile_.prototype.getTile = function (tileKey) {
  return this.sourceTiles_[tileKey];
};
/**
 * @inheritDoc
 */


_ol_VectorImageTile_.prototype.load = function () {
  // Source tiles with LOADED state - we just count them because once they are
  // loaded, we're no longer listening to state changes.
  var leftToLoad = 0; // Source tiles with ERROR state - we track them because they can still have
  // an ERROR state after another load attempt.

  var errorSourceTiles = {};

  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING);
  }

  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
    this.tileKeys.forEach(function (sourceTileKey) {
      var sourceTile = this.getTile(sourceTileKey);

      if (sourceTile.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
        sourceTile.setLoader(this.loader_);
        sourceTile.load();
      }

      if (sourceTile.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
        var key = _events_js__WEBPACK_IMPORTED_MODULE_4__["default"].listen(sourceTile, _events_eventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, function (e) {
          var state = sourceTile.getState();

          if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
            var uid = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(sourceTile);

            if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
              errorSourceTiles[uid] = true;
            } else {
              --leftToLoad;
              delete errorSourceTiles[uid];
            }

            if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
              this.finishLoading_();
            }
          }
        }.bind(this));

        this.loadListenerKeys_.push(key);
        ++leftToLoad;
      }
    }.bind(this));
  }

  if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
    setTimeout(this.finishLoading_.bind(this), 0);
  }
};
/**
 * @private
 */


_ol_VectorImageTile_.prototype.finishLoading_ = function () {
  var loaded = this.tileKeys.length;
  var empty = 0;

  for (var i = loaded - 1; i >= 0; --i) {
    var state = this.getTile(this.tileKeys[i]).getState();

    if (state != _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      --loaded;
    }

    if (state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
      ++empty;
    }
  }

  if (loaded == this.tileKeys.length) {
    this.loadListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["default"].unlistenByKey);
    this.loadListenerKeys_.length = 0;
    this.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED);
  } else {
    this.setState(empty == this.tileKeys.length ? _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY : _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
  }
};
/**
 * Sets the loader for a tile.
 * @param {ol.VectorTile} tile Vector tile.
 * @param {string} url URL.
 */


_ol_VectorImageTile_.defaultLoadFunction = function (tile, url) {
  var loader = _featureloader_js__WEBPACK_IMPORTED_MODULE_7__["default"].loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));

  tile.setLoader(loader);
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_VectorImageTile_);

/***/ }),

/***/ "./node_modules/ol/vectortile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/vectortile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tile.js */ "./node_modules/ol/tile.js");
/* harmony import */ var _tilestate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilestate.js */ "./node_modules/ol/tilestate.js");



/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Data source url.
 * @param {ol.format.Feature} format Feature format.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @param {olx.TileOptions=} opt_options Tile options.
 */

var _ol_VectorTile_ = function (tileCoord, state, src, format, tileLoadFunction, opt_options) {
  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, tileCoord, state, opt_options);
  /**
   * @type {number}
   */


  this.consumers = 0;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = null;
  /**
   * @private
   * @type {ol.format.Feature}
   */

  this.format_ = format;
  /**
   * @private
   * @type {Array.<ol.Feature>}
   */

  this.features_ = null;
  /**
   * @private
   * @type {ol.FeatureLoader}
   */

  this.loader_;
  /**
   * Data projection
   * @private
   * @type {ol.proj.Projection}
   */

  this.projection_;
  /**
   * @private
   * @type {Object.<string, ol.render.ReplayGroup>}
   */

  this.replayGroups_ = {};
  /**
   * @private
   * @type {ol.TileLoadFunctionType}
   */

  this.tileLoadFunction_ = tileLoadFunction;
  /**
   * @private
   * @type {string}
   */

  this.url_ = src;
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_VectorTile_, _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @inheritDoc
 */


_ol_VectorTile_.prototype.disposeInternal = function () {
  this.features_ = null;
  this.replayGroups_ = {};
  this.state = _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT;
  this.changed();

  _tile_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.disposeInternal.call(this);
};
/**
 * Gets the extent of the vector tile.
 * @return {ol.Extent} The extent.
 * @api
 */


_ol_VectorTile_.prototype.getExtent = function () {
  return this.extent_ || _ol_VectorTile_.DEFAULT_EXTENT;
};
/**
 * Get the feature format assigned for reading this tile's features.
 * @return {ol.format.Feature} Feature format.
 * @api
 */


_ol_VectorTile_.prototype.getFormat = function () {
  return this.format_;
};
/**
 * Get the features for this tile. Geometries will be in the projection returned
 * by {@link ol.VectorTile#getProjection}.
 * @return {Array.<ol.Feature|ol.render.Feature>} Features.
 * @api
 */


_ol_VectorTile_.prototype.getFeatures = function () {
  return this.features_;
};
/**
 * @inheritDoc
 */


_ol_VectorTile_.prototype.getKey = function () {
  return this.url_;
};
/**
 * Get the feature projection of features returned by
 * {@link ol.VectorTile#getFeatures}.
 * @return {ol.proj.Projection} Feature projection.
 * @api
 */


_ol_VectorTile_.prototype.getProjection = function () {
  return this.projection_;
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @param {string} key Key.
 * @return {ol.render.ReplayGroup} Replay group.
 */


_ol_VectorTile_.prototype.getReplayGroup = function (layer, key) {
  return this.replayGroups_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer) + ',' + key];
};
/**
 * @inheritDoc
 */


_ol_VectorTile_.prototype.load = function () {
  if (this.state == _tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
    this.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING);
    this.tileLoadFunction_(this, this.url_);
    this.loader_(null, NaN, null);
  }
};
/**
 * Handler for successful tile load.
 * @param {Array.<ol.Feature>} features The loaded features.
 * @param {ol.proj.Projection} dataProjection Data projection.
 * @param {ol.Extent} extent Extent.
 */


_ol_VectorTile_.prototype.onLoad = function (features, dataProjection, extent) {
  this.setProjection(dataProjection);
  this.setFeatures(features);
  this.setExtent(extent);
};
/**
 * Handler for tile load errors.
 */


_ol_VectorTile_.prototype.onError = function () {
  this.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR);
};
/**
 * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.
 * Sets the extent of the vector tile. This is only required for tiles in
 * projections with `tile-pixels` as units. The extent should be set to
 * `[0, 0, tilePixelSize, tilePixelSize]`, where `tilePixelSize` is calculated
 * by multiplying the tile size with the tile pixel ratio. For sources using
 * {@link ol.format.MVT} as feature format, the
 * {@link ol.format.MVT#getLastExtent} method will return the correct extent.
 * The default is `[0, 0, 4096, 4096]`.
 * @param {ol.Extent} extent The extent.
 * @api
 */


_ol_VectorTile_.prototype.setExtent = function (extent) {
  this.extent_ = extent;
};
/**
 * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.
 * Sets the features for the tile.
 * @param {Array.<ol.Feature>} features Features.
 * @api
 */


_ol_VectorTile_.prototype.setFeatures = function (features) {
  this.features_ = features;
  this.setState(_tilestate_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED);
};
/**
 * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.
 * Sets the projection of the features that were added with
 * {@link ol.VectorTile#setFeatures}.
 * @param {ol.proj.Projection} projection Feature projection.
 * @api
 */


_ol_VectorTile_.prototype.setProjection = function (projection) {
  this.projection_ = projection;
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @param {string} key Key.
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 */


_ol_VectorTile_.prototype.setReplayGroup = function (layer, key, replayGroup) {
  this.replayGroups_[_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(layer) + ',' + key] = replayGroup;
};
/**
 * Set the feature loader for reading this tile's features.
 * @param {ol.FeatureLoader} loader Feature loader.
 * @api
 */


_ol_VectorTile_.prototype.setLoader = function (loader) {
  this.loader_ = loader;
};
/**
 * @const
 * @type {ol.Extent}
 */


_ol_VectorTile_.DEFAULT_EXTENT = [0, 0, 4096, 4096];
/* harmony default export */ __webpack_exports__["default"] = (_ol_VectorTile_);

/***/ }),

/***/ "./node_modules/ol/view.js":
/*!*********************************!*\
  !*** ./node_modules/ol/view.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object.js */ "./node_modules/ol/object.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _viewhint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./viewhint.js */ "./node_modules/ol/viewhint.js");
/* harmony import */ var _viewproperty_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./viewproperty.js */ "./node_modules/ol/viewproperty.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geom/geometrytype.js */ "./node_modules/ol/geom/geometrytype.js");
/* harmony import */ var _geom_polygon_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./geom/polygon.js */ "./node_modules/ol/geom/polygon.js");
/* harmony import */ var _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geom/simplegeometry.js */ "./node_modules/ol/geom/simplegeometry.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_units_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./proj/units.js */ "./node_modules/ol/proj/units.js");



















/**
 * @classdesc
 * An ol.View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.ViewOptions=} opt_options View options.
 * @api
 */

var _ol_View_ = function (opt_options) {
  _object_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);

  var options = _obj_js__WEBPACK_IMPORTED_MODULE_16__["default"].assign({}, opt_options);
  /**
   * @private
   * @type {Array.<number>}
   */


  this.hints_ = [0, 0];
  /**
   * @private
   * @type {Array.<Array.<ol.ViewAnimation>>}
   */

  this.animations_ = [];
  /**
   * @private
   * @type {number|undefined}
   */

  this.updateAnimationKey_;
  this.updateAnimations_ = this.updateAnimations_.bind(this);
  /**
   * @private
   * @const
   * @type {ol.proj.Projection}
   */

  this.projection_ = _proj_js__WEBPACK_IMPORTED_MODULE_17__["default"].createProjection(options.projection, 'EPSG:3857');
  this.applyOptions_(options);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_View_, _object_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Set up the view with the given options.
 * @param {olx.ViewOptions} options View options.
 */


_ol_View_.prototype.applyOptions_ = function (options) {
  /**
   * @type {Object.<string, *>}
   */
  var properties = {};
  properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER] = options.center !== undefined ? options.center : null;

  var resolutionConstraintInfo = _ol_View_.createResolutionConstraint_(options);
  /**
   * @private
   * @type {number}
   */


  this.maxResolution_ = resolutionConstraintInfo.maxResolution;
  /**
   * @private
   * @type {number}
   */

  this.minResolution_ = resolutionConstraintInfo.minResolution;
  /**
   * @private
   * @type {number}
   */

  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
  /**
   * @private
   * @type {Array.<number>|undefined}
   */

  this.resolutions_ = options.resolutions;
  /**
   * @private
   * @type {number}
   */

  this.minZoom_ = resolutionConstraintInfo.minZoom;

  var centerConstraint = _ol_View_.createCenterConstraint_(options);

  var resolutionConstraint = resolutionConstraintInfo.constraint;

  var rotationConstraint = _ol_View_.createRotationConstraint_(options);
  /**
   * @private
   * @type {ol.Constraints}
   */


  this.constraints_ = {
    center: centerConstraint,
    resolution: resolutionConstraint,
    rotation: rotationConstraint
  };

  if (options.resolution !== undefined) {
    properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION] = options.resolution;
  } else if (options.zoom !== undefined) {
    properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);

    if (this.resolutions_) {
      // in case map zoom is out of min/max zoom range
      properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION] = _math_js__WEBPACK_IMPORTED_MODULE_15__["default"].clamp(Number(this.getResolution() || properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION]), this.minResolution_, this.maxResolution_);
    }
  }

  properties[_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].ROTATION] = options.rotation !== undefined ? options.rotation : 0;
  this.setProperties(properties);
  /**
   * @private
   * @type {olx.ViewOptions}
   */

  this.options_ = options;
};
/**
 * Get an updated version of the view options used to construct the view.  The
 * current resolution (or zoom), center, and rotation are applied to any stored
 * options.  The provided options can be uesd to apply new min/max zoom or
 * resolution limits.
 * @param {olx.ViewOptions} newOptions New options to be applied.
 * @return {olx.ViewOptions} New options updated with the current view state.
 */


_ol_View_.prototype.getUpdatedOptions_ = function (newOptions) {
  var options = _obj_js__WEBPACK_IMPORTED_MODULE_16__["default"].assign({}, this.options_); // preserve resolution (or zoom)


  if (options.resolution !== undefined) {
    options.resolution = this.getResolution();
  } else {
    options.zoom = this.getZoom();
  } // preserve center


  options.center = this.getCenter(); // preserve rotation

  options.rotation = this.getRotation();
  return _obj_js__WEBPACK_IMPORTED_MODULE_16__["default"].assign({}, options, newOptions);
};
/**
 * Animate the view.  The view's center, zoom (or resolution), and rotation
 * can be animated for smooth transitions between view states.  For example,
 * to animate the view to a new zoom level:
 *
 *     view.animate({zoom: view.getZoom() + 1});
 *
 * By default, the animation lasts one second and uses in-and-out easing.  You
 * can customize this behavior by including `duration` (in milliseconds) and
 * `easing` options (see {@link ol.easing}).
 *
 * To chain together multiple animations, call the method with multiple
 * animation objects.  For example, to first zoom and then pan:
 *
 *     view.animate({zoom: 10}, {center: [0, 0]});
 *
 * If you provide a function as the last argument to the animate method, it
 * will get called at the end of an animation series.  The callback will be
 * called with `true` if the animation series completed on its own or `false`
 * if it was cancelled.
 *
 * Animations are cancelled by user interactions (e.g. dragging the map) or by
 * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
 * (or another method that calls one of these).
 *
 * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation
 *     options.  Multiple animations can be run in series by passing multiple
 *     options objects.  To run multiple animations in parallel, call the method
 *     multiple times.  An optional callback can be provided as a final
 *     argument.  The callback will be called with a boolean indicating whether
 *     the animation completed without being cancelled.
 * @api
 */


_ol_View_.prototype.animate = function (var_args) {
  var animationCount = arguments.length;
  var callback;

  if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
    callback = arguments[animationCount - 1];
    --animationCount;
  }

  if (!this.isDef()) {
    // if view properties are not yet set, shortcut to the final state
    var state = arguments[animationCount - 1];

    if (state.center) {
      this.setCenter(state.center);
    }

    if (state.zoom !== undefined) {
      this.setZoom(state.zoom);
    }

    if (state.rotation !== undefined) {
      this.setRotation(state.rotation);
    }

    if (callback) {
      callback(true);
    }

    return;
  }

  var start = Date.now();
  var center = this.getCenter().slice();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  var series = [];

  for (var i = 0; i < animationCount; ++i) {
    var options =
    /** @type {olx.AnimationOptions} */
    arguments[i];
    var animation =
    /** @type {ol.ViewAnimation} */
    {
      start: start,
      complete: false,
      anchor: options.anchor,
      duration: options.duration !== undefined ? options.duration : 1000,
      easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_10__["default"].inAndOut
    };

    if (options.center) {
      animation.sourceCenter = center;
      animation.targetCenter = options.center;
      center = animation.targetCenter;
    }

    if (options.zoom !== undefined) {
      animation.sourceResolution = resolution;
      animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);
      resolution = animation.targetResolution;
    } else if (options.resolution) {
      animation.sourceResolution = resolution;
      animation.targetResolution = options.resolution;
      resolution = animation.targetResolution;
    }

    if (options.rotation !== undefined) {
      animation.sourceRotation = rotation;
      var delta = _math_js__WEBPACK_IMPORTED_MODULE_15__["default"].modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
      animation.targetRotation = rotation + delta;
      rotation = animation.targetRotation;
    }

    animation.callback = callback; // check if animation is a no-op

    if (_ol_View_.isNoopAnimation(animation)) {
      animation.complete = true; // we still push it onto the series for callback handling
    } else {
      start += animation.duration;
    }

    series.push(animation);
  }

  this.animations_.push(series);
  this.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, 1);
  this.updateAnimations_();
};
/**
 * Determine if the view is being animated.
 * @return {boolean} The view is being animated.
 * @api
 */


_ol_View_.prototype.getAnimating = function () {
  return this.hints_[_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING] > 0;
};
/**
 * Determine if the user is interacting with the view, such as panning or zooming.
 * @return {boolean} The view is being interacted with.
 * @api
 */


_ol_View_.prototype.getInteracting = function () {
  return this.hints_[_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING] > 0;
};
/**
 * Cancel any ongoing animations.
 * @api
 */


_ol_View_.prototype.cancelAnimations = function () {
  this.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -this.hints_[_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING]);

  for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
    var series = this.animations_[i];

    if (series[0].callback) {
      series[0].callback(false);
    }
  }

  this.animations_.length = 0;
};
/**
 * Update all animations.
 */


_ol_View_.prototype.updateAnimations_ = function () {
  if (this.updateAnimationKey_ !== undefined) {
    cancelAnimationFrame(this.updateAnimationKey_);
    this.updateAnimationKey_ = undefined;
  }

  if (!this.getAnimating()) {
    return;
  }

  var now = Date.now();
  var more = false;

  for (var i = this.animations_.length - 1; i >= 0; --i) {
    var series = this.animations_[i];
    var seriesComplete = true;

    for (var j = 0, jj = series.length; j < jj; ++j) {
      var animation = series[j];

      if (animation.complete) {
        continue;
      }

      var elapsed = now - animation.start;
      var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

      if (fraction >= 1) {
        animation.complete = true;
        fraction = 1;
      } else {
        seriesComplete = false;
      }

      var progress = animation.easing(fraction);

      if (animation.sourceCenter) {
        var x0 = animation.sourceCenter[0];
        var y0 = animation.sourceCenter[1];
        var x1 = animation.targetCenter[0];
        var y1 = animation.targetCenter[1];
        var x = x0 + progress * (x1 - x0);
        var y = y0 + progress * (y1 - y0);
        this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER, [x, y]);
      }

      if (animation.sourceResolution && animation.targetResolution) {
        var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

        if (animation.anchor) {
          this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER, this.calculateCenterZoom(resolution, animation.anchor));
        }

        this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION, resolution);
      }

      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
        var rotation = progress === 1 ? _math_js__WEBPACK_IMPORTED_MODULE_15__["default"].modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

        if (animation.anchor) {
          this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER, this.calculateCenterRotate(rotation, animation.anchor));
        }

        this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].ROTATION, rotation);
      }

      more = true;

      if (!animation.complete) {
        break;
      }
    }

    if (seriesComplete) {
      this.animations_[i] = null;
      this.setHint(_viewhint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -1);
      var callback = series[0].callback;

      if (callback) {
        callback(true);
      }
    }
  } // prune completed series


  this.animations_ = this.animations_.filter(Boolean);

  if (more && this.updateAnimationKey_ === undefined) {
    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
  }
};
/**
 * @param {number} rotation Target rotation.
 * @param {ol.Coordinate} anchor Rotation anchor.
 * @return {ol.Coordinate|undefined} Center for rotation and anchor.
 */


_ol_View_.prototype.calculateCenterRotate = function (rotation, anchor) {
  var center;
  var currentCenter = this.getCenter();

  if (currentCenter !== undefined) {
    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];

    _coordinate_js__WEBPACK_IMPORTED_MODULE_9__["default"].rotate(center, rotation - this.getRotation());

    _coordinate_js__WEBPACK_IMPORTED_MODULE_9__["default"].add(center, anchor);
  }

  return center;
};
/**
 * @param {number} resolution Target resolution.
 * @param {ol.Coordinate} anchor Zoom anchor.
 * @return {ol.Coordinate|undefined} Center for resolution and anchor.
 */


_ol_View_.prototype.calculateCenterZoom = function (resolution, anchor) {
  var center;
  var currentCenter = this.getCenter();
  var currentResolution = this.getResolution();

  if (currentCenter !== undefined && currentResolution !== undefined) {
    var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
    var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
    center = [x, y];
  }

  return center;
};
/**
 * @private
 * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.
 */


_ol_View_.prototype.getSizeFromViewport_ = function () {
  var size = [100, 100];
  var selector = '.ol-viewport[data-view="' + _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(this) + '"]';
  var element = document.querySelector(selector);

  if (element) {
    var metrics = getComputedStyle(element);
    size[0] = parseInt(metrics.width, 10);
    size[1] = parseInt(metrics.height, 10);
  }

  return size;
};
/**
 * Get the constrained center of this view.
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Constrained center.
 * @api
 */


_ol_View_.prototype.constrainCenter = function (center) {
  return this.constraints_.center(center);
};
/**
 * Get the constrained resolution of this view.
 * @param {number|undefined} resolution Resolution.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @param {number=} opt_direction Direction. Default is `0`.
 * @return {number|undefined} Constrained resolution.
 * @api
 */


_ol_View_.prototype.constrainResolution = function (resolution, opt_delta, opt_direction) {
  var delta = opt_delta || 0;
  var direction = opt_direction || 0;
  return this.constraints_.resolution(resolution, delta, direction);
};
/**
 * Get the constrained rotation of this view.
 * @param {number|undefined} rotation Rotation.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @return {number|undefined} Constrained rotation.
 * @api
 */


_ol_View_.prototype.constrainRotation = function (rotation, opt_delta) {
  var delta = opt_delta || 0;
  return this.constraints_.rotation(rotation, delta);
};
/**
 * Get the view center.
 * @return {ol.Coordinate|undefined} The center of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.getCenter = function () {
  return (
    /** @type {ol.Coordinate|undefined} */
    this.get(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER)
  );
};
/**
 * @return {ol.Constraints} Constraints.
 */


_ol_View_.prototype.getConstraints = function () {
  return this.constraints_;
};
/**
 * @param {Array.<number>=} opt_hints Destination array.
 * @return {Array.<number>} Hint.
 */


_ol_View_.prototype.getHints = function (opt_hints) {
  if (opt_hints !== undefined) {
    opt_hints[0] = this.hints_[0];
    opt_hints[1] = this.hints_[1];
    return opt_hints;
  } else {
    return this.hints_.slice();
  }
};
/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the
 * first map that uses this view will be used.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_View_.prototype.calculateExtent = function (opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var center =
  /** @type {!ol.Coordinate} */
  this.getCenter();

  _asserts_js__WEBPACK_IMPORTED_MODULE_8__["default"].assert(center, 1); // The view center is not defined


  var resolution =
  /** @type {!number} */
  this.getResolution();

  _asserts_js__WEBPACK_IMPORTED_MODULE_8__["default"].assert(resolution !== undefined, 2); // The view resolution is not defined


  var rotation =
  /** @type {!number} */
  this.getRotation();

  _asserts_js__WEBPACK_IMPORTED_MODULE_8__["default"].assert(rotation !== undefined, 3); // The view rotation is not defined


  return _extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getForViewAndSize(center, resolution, rotation, size);
};
/**
 * Get the maximum resolution of the view.
 * @return {number} The maximum resolution of the view.
 * @api
 */


_ol_View_.prototype.getMaxResolution = function () {
  return this.maxResolution_;
};
/**
 * Get the minimum resolution of the view.
 * @return {number} The minimum resolution of the view.
 * @api
 */


_ol_View_.prototype.getMinResolution = function () {
  return this.minResolution_;
};
/**
 * Get the maximum zoom level for the view.
 * @return {number} The maximum zoom level.
 * @api
 */


_ol_View_.prototype.getMaxZoom = function () {
  return (
    /** @type {number} */
    this.getZoomForResolution(this.minResolution_)
  );
};
/**
 * Set a new maximum zoom level for the view.
 * @param {number} zoom The maximum zoom level.
 * @api
 */


_ol_View_.prototype.setMaxZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({
    maxZoom: zoom
  }));
};
/**
 * Get the minimum zoom level for the view.
 * @return {number} The minimum zoom level.
 * @api
 */


_ol_View_.prototype.getMinZoom = function () {
  return (
    /** @type {number} */
    this.getZoomForResolution(this.maxResolution_)
  );
};
/**
 * Set a new minimum zoom level for the view.
 * @param {number} zoom The minimum zoom level.
 * @api
 */


_ol_View_.prototype.setMinZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({
    minZoom: zoom
  }));
};
/**
 * Get the view projection.
 * @return {ol.proj.Projection} The projection of the view.
 * @api
 */


_ol_View_.prototype.getProjection = function () {
  return this.projection_;
};
/**
 * Get the view resolution.
 * @return {number|undefined} The resolution of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.getResolution = function () {
  return (
    /** @type {number|undefined} */
    this.get(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION)
  );
};
/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * @return {Array.<number>|undefined} The resolutions of the view.
 * @api
 */


_ol_View_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * Get the resolution for a provided extent (in map units) and size (in pixels).
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size=} opt_size Box pixel size.
 * @return {number} The resolution at which the provided extent will render at
 *     the given size.
 * @api
 */


_ol_View_.prototype.getResolutionForExtent = function (extent, opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var xResolution = _extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getWidth(extent) / size[0];
  var yResolution = _extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getHeight(extent) / size[1];
  return Math.max(xResolution, yResolution);
};
/**
 * Return a function that returns a value between 0 and 1 for a
 * resolution. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Resolution for value function.
 */


_ol_View_.prototype.getResolutionForValueFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} value Value.
     * @return {number} Resolution.
     */
    function (value) {
      var resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    }
  );
};
/**
 * Get the view rotation.
 * @return {number} The rotation of the view in radians.
 * @observable
 * @api
 */


_ol_View_.prototype.getRotation = function () {
  return (
    /** @type {number} */
    this.get(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].ROTATION)
  );
};
/**
 * Return a function that returns a resolution for a value between
 * 0 and 1. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Value for resolution function.
 */


_ol_View_.prototype.getValueForResolutionFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} resolution Resolution.
     * @return {number} Value.
     */
    function (resolution) {
      var value = Math.log(maxResolution / resolution) / Math.log(power) / max;
      return value;
    }
  );
};
/**
 * @return {olx.ViewState} View state.
 */


_ol_View_.prototype.getState = function () {
  var center =
  /** @type {ol.Coordinate} */
  this.getCenter();
  var projection = this.getProjection();
  var resolution =
  /** @type {number} */
  this.getResolution();
  var rotation = this.getRotation();
  return (
    /** @type {olx.ViewState} */
    {
      center: center.slice(),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation,
      zoom: this.getZoom()
    }
  );
};
/**
 * Get the current zoom level.  If you configured your view with a resolutions
 * array (this is rare), this method may return non-integer zoom levels (so
 * the zoom level is not safe to use as an index into a resolutions array).
 * @return {number|undefined} Zoom.
 * @api
 */


_ol_View_.prototype.getZoom = function () {
  var zoom;
  var resolution = this.getResolution();

  if (resolution !== undefined) {
    zoom = this.getZoomForResolution(resolution);
  }

  return zoom;
};
/**
 * Get the zoom level for a resolution.
 * @param {number} resolution The resolution.
 * @return {number|undefined} The zoom level for the provided resolution.
 * @api
 */


_ol_View_.prototype.getZoomForResolution = function (resolution) {
  var offset = this.minZoom_ || 0;
  var max, zoomFactor;

  if (this.resolutions_) {
    var nearest = _array_js__WEBPACK_IMPORTED_MODULE_7__["default"].linearFindNearest(this.resolutions_, resolution, 1);

    offset = nearest;
    max = this.resolutions_[nearest];

    if (nearest == this.resolutions_.length - 1) {
      zoomFactor = 2;
    } else {
      zoomFactor = max / this.resolutions_[nearest + 1];
    }
  } else {
    max = this.maxResolution_;
    zoomFactor = this.zoomFactor_;
  }

  return offset + Math.log(max / resolution) / Math.log(zoomFactor);
};
/**
 * Get the resolution for a zoom level.
 * @param {number} zoom Zoom level.
 * @return {number} The view resolution for the provided zoom level.
 * @api
 */


_ol_View_.prototype.getResolutionForZoom = function (zoom) {
  return (
    /** @type {number} */
    this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)
  );
};
/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or
 *     extent to fit the view to.
 * @param {olx.view.FitOptions=} opt_options Options.
 * @api
 */


_ol_View_.prototype.fit = function (geometryOrExtent, opt_options) {
  var options = opt_options || {};
  var size = options.size;

  if (!size) {
    size = this.getSizeFromViewport_();
  }
  /** @type {ol.geom.SimpleGeometry} */


  var geometry;

  if (!(geometryOrExtent instanceof _geom_simplegeometry_js__WEBPACK_IMPORTED_MODULE_14__["default"])) {
    _asserts_js__WEBPACK_IMPORTED_MODULE_8__["default"].assert(Array.isArray(geometryOrExtent), 24); // Invalid extent or geometry provided as `geometry`


    _asserts_js__WEBPACK_IMPORTED_MODULE_8__["default"].assert(!_extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`


    geometry = _geom_polygon_js__WEBPACK_IMPORTED_MODULE_13__["default"].fromExtent(geometryOrExtent);
  } else if (geometryOrExtent.getType() === _geom_geometrytype_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    geometryOrExtent = geometryOrExtent.getExtent();
    geometry = _geom_polygon_js__WEBPACK_IMPORTED_MODULE_13__["default"].fromExtent(geometryOrExtent);
    geometry.rotate(this.getRotation(), _extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getCenter(geometryOrExtent));
  } else {
    geometry = geometryOrExtent;
  }

  var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
  var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;
  var nearest = options.nearest !== undefined ? options.nearest : false;
  var minResolution;

  if (options.minResolution !== undefined) {
    minResolution = options.minResolution;
  } else if (options.maxZoom !== undefined) {
    minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);
  } else {
    minResolution = 0;
  }

  var coords = geometry.getFlatCoordinates(); // calculate rotated extent

  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var minRotX = +Infinity;
  var minRotY = +Infinity;
  var maxRotX = -Infinity;
  var maxRotY = -Infinity;
  var stride = geometry.getStride();

  for (var i = 0, ii = coords.length; i < ii; i += stride) {
    var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
    var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
    minRotX = Math.min(minRotX, rotX);
    minRotY = Math.min(minRotY, rotY);
    maxRotX = Math.max(maxRotX, rotX);
    maxRotY = Math.max(maxRotY, rotY);
  } // calculate resolution


  var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
  resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);

  if (constrainResolution) {
    var constrainedResolution = this.constrainResolution(resolution, 0, 0);

    if (!nearest && constrainedResolution < resolution) {
      constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);
    }

    resolution = constrainedResolution;
  } // calculate center


  sinAngle = -sinAngle; // go back to original rotation

  var centerRotX = (minRotX + maxRotX) / 2;
  var centerRotY = (minRotY + maxRotY) / 2;
  centerRotX += (padding[1] - padding[3]) / 2 * resolution;
  centerRotY += (padding[0] - padding[2]) / 2 * resolution;
  var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
  var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
  var center = [centerX, centerY];
  var callback = options.callback ? options.callback : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].nullFunction;

  if (options.duration !== undefined) {
    this.animate({
      resolution: resolution,
      center: center,
      duration: options.duration,
      easing: options.easing
    }, callback);
  } else {
    this.setResolution(resolution);
    this.setCenter(center);
    setTimeout(callback.bind(undefined, true), 0);
  }
};
/**
 * Center on coordinate and view position.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Size} size Box pixel size.
 * @param {ol.Pixel} position Position on the view to center on.
 * @api
 */


_ol_View_.prototype.centerOn = function (coordinate, size, position) {
  // calculate rotated position
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  var resolution = this.getResolution();
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

  sinAngle = -sinAngle; // go back to original rotation

  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  this.setCenter([centerX, centerY]);
};
/**
 * @return {boolean} Is defined.
 */


_ol_View_.prototype.isDef = function () {
  return !!this.getCenter() && this.getResolution() !== undefined;
};
/**
 * Rotate the view around a given coordinate.
 * @param {number} rotation New rotation value for the view.
 * @param {ol.Coordinate=} opt_anchor The rotation center.
 * @api
 */


_ol_View_.prototype.rotate = function (rotation, opt_anchor) {
  if (opt_anchor !== undefined) {
    var center = this.calculateCenterRotate(rotation, opt_anchor);
    this.setCenter(center);
  }

  this.setRotation(rotation);
};
/**
 * Set the center of the current view.
 * @param {ol.Coordinate|undefined} center The center of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.setCenter = function (center) {
  this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].CENTER, center);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * @param {ol.ViewHint} hint Hint.
 * @param {number} delta Delta.
 * @return {number} New value.
 */


_ol_View_.prototype.setHint = function (hint, delta) {
  this.hints_[hint] += delta;
  this.changed();
  return this.hints_[hint];
};
/**
 * Set the resolution for this view.
 * @param {number|undefined} resolution The resolution of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.setResolution = function (resolution) {
  this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESOLUTION, resolution);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * Set the rotation for this view.
 * @param {number} rotation The rotation of the view in radians.
 * @observable
 * @api
 */


_ol_View_.prototype.setRotation = function (rotation) {
  this.set(_viewproperty_js__WEBPACK_IMPORTED_MODULE_6__["default"].ROTATION, rotation);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * Zoom to a specific zoom level.
 * @param {number} zoom Zoom level.
 * @api
 */


_ol_View_.prototype.setZoom = function (zoom) {
  this.setResolution(this.getResolutionForZoom(zoom));
};
/**
 * @param {olx.ViewOptions} options View options.
 * @private
 * @return {ol.CenterConstraintType} The constraint.
 */


_ol_View_.createCenterConstraint_ = function (options) {
  if (options.extent !== undefined) {
    return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_1__["default"].createExtent(options.extent);
  } else {
    return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_1__["default"].none;
  }
};
/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,
 *     minResolution: number, zoomFactor: number}} The constraint.
 */


_ol_View_.createResolutionConstraint_ = function (options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_3__["default"].createSnapToResolutions(resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = _proj_js__WEBPACK_IMPORTED_MODULE_17__["default"].createProjection(options.projection, 'EPSG:3857');

    var extent = projection.getExtent();
    var size = !extent ? // use an extent that can fit the whole world if need be
    360 * _proj_js__WEBPACK_IMPORTED_MODULE_17__["default"].METERS_PER_UNIT[_proj_units_js__WEBPACK_IMPORTED_MODULE_18__["default"].DEGREES] / projection.getMetersPerUnit() : Math.max(_extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getWidth(extent), _extent_js__WEBPACK_IMPORTED_MODULE_11__["default"].getHeight(extent));
    var defaultMaxResolution = size / _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    resolutionConstraint = _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_3__["default"].createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
};
/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_View_.createRotationConstraint_ = function (options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["default"].createSnapToZero();
    } else if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["default"].none;
    } else if (typeof constrainRotation === 'number') {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["default"].createSnapToN(constrainRotation);
    } else {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["default"].none;
    }
  } else {
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["default"].disable;
  }
};
/**
 * Determine if an animation involves no view change.
 * @param {ol.ViewAnimation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */


_ol_View_.isNoopAnimation = function (animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["default"].equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_View_);

/***/ }),

/***/ "./node_modules/ol/viewhint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/viewhint.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {number}
 */
var _ol_ViewHint_ = {
  ANIMATING: 0,
  INTERACTING: 1
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_ViewHint_);

/***/ }),

/***/ "./node_modules/ol/viewproperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/viewproperty.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_ViewProperty_ = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_ViewProperty_);

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ol_webgl_ = {};
/**
 * Constants taken from goog.webgl
 */

/**
 * @const
 * @type {number}
 */

_ol_webgl_.ONE = 1;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.SRC_ALPHA = 0x0302;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TRIANGLES = 0x0004;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TRIANGLE_STRIP = 0x0005;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ARRAY_BUFFER = 0x8892;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STREAM_DRAW = 0x88E0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STATIC_DRAW = 0x88E4;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.DYNAMIC_DRAW = 0x88E8;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.CULL_FACE = 0x0B44;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.BLEND = 0x0BE2;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STENCIL_TEST = 0x0B90;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.DEPTH_TEST = 0x0B71;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.SCISSOR_TEST = 0x0C11;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_BYTE = 0x1401;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_SHORT = 0x1403;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_INT = 0x1405;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FLOAT = 0x1406;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.RGBA = 0x1908;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FRAGMENT_SHADER = 0x8B30;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.VERTEX_SHADER = 0x8B31;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.LINK_STATUS = 0x8B82;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.LINEAR = 0x2601;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_WRAP_S = 0x2802;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_WRAP_T = 0x2803;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_2D = 0x0DE1;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE0 = 0x84C0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.CLAMP_TO_EDGE = 0x812F;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COMPILE_STATUS = 0x8B81;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FRAMEBUFFER = 0x8D40;
/** end of goog.webgl constants
 */

/**
 * @const
 * @private
 * @type {Array.<string>}
 */

_ol_webgl_.CONTEXT_IDS_ = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */

_ol_webgl_.getContext = function (canvas, opt_attributes) {
  var context,
      i,
      ii = _ol_webgl_.CONTEXT_IDS_.length;

  for (i = 0; i < ii; ++i) {
    try {
      context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);

      if (context) {
        return (
          /** @type {!WebGLRenderingContext} */
          context
        );
      }
    } catch (e) {// pass
    }
  }

  return null;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_);

/***/ }),

/***/ "./node_modules/ol/webgl/buffer.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/webgl/buffer.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/webgl.js");

/**
 * @constructor
 * @param {Array.<number>=} opt_arr Array.
 * @param {number=} opt_usage Usage.
 * @struct
 */

var _ol_webgl_Buffer_ = function (opt_arr, opt_usage) {
  /**
   * @private
   * @type {Array.<number>}
   */
  this.arr_ = opt_arr !== undefined ? opt_arr : [];
  /**
   * @private
   * @type {number}
   */

  this.usage_ = opt_usage !== undefined ? opt_usage : _ol_webgl_Buffer_.Usage_.STATIC_DRAW;
};
/**
 * @return {Array.<number>} Array.
 */


_ol_webgl_Buffer_.prototype.getArray = function () {
  return this.arr_;
};
/**
 * @return {number} Usage.
 */


_ol_webgl_Buffer_.prototype.getUsage = function () {
  return this.usage_;
};
/**
 * @enum {number}
 * @private
 */


_ol_webgl_Buffer_.Usage_ = {
  STATIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__["default"].STATIC_DRAW,
  STREAM_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__["default"].STREAM_DRAW,
  DYNAMIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__["default"].DYNAMIC_DRAW
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_Buffer_);

/***/ }),

/***/ "./node_modules/ol/webgl/context.js":
/*!******************************************!*\
  !*** ./node_modules/ol/webgl/context.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../disposable.js */ "./node_modules/ol/disposable.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl/contexteventtype.js */ "./node_modules/ol/webgl/contexteventtype.js");







/**
 * @classdesc
 * A WebGL context for accessing low-level WebGL capabilities.
 *
 * @constructor
 * @extends {ol.Disposable}
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {WebGLRenderingContext} gl GL.
 */

var _ol_webgl_Context_ = function (canvas, gl) {
  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = canvas;
  /**
   * @private
   * @type {WebGLRenderingContext}
   */

  this.gl_ = gl;
  /**
   * @private
   * @type {Object.<string, ol.WebglBufferCacheEntry>}
   */

  this.bufferCache_ = {};
  /**
   * @private
   * @type {Object.<string, WebGLShader>}
   */

  this.shaderCache_ = {};
  /**
   * @private
   * @type {Object.<string, WebGLProgram>}
   */

  this.programCache_ = {};
  /**
   * @private
   * @type {WebGLProgram}
   */

  this.currentProgram_ = null;
  /**
   * @private
   * @type {WebGLFramebuffer}
   */

  this.hitDetectionFramebuffer_ = null;
  /**
   * @private
   * @type {WebGLTexture}
   */

  this.hitDetectionTexture_ = null;
  /**
   * @private
   * @type {WebGLRenderbuffer}
   */

  this.hitDetectionRenderbuffer_ = null;
  /**
   * @type {boolean}
   */

  this.hasOESElementIndexUint = _array_js__WEBPACK_IMPORTED_MODULE_2__["default"].includes(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].WEBGL_EXTENSIONS, 'OES_element_index_uint'); // use the OES_element_index_uint extension if available

  if (this.hasOESElementIndexUint) {
    gl.getExtension('OES_element_index_uint');
  }

  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(this.canvas_, _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].LOST, this.handleWebGLContextLost, this);

  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].listen(this.canvas_, _webgl_contexteventtype_js__WEBPACK_IMPORTED_MODULE_6__["default"].RESTORED, this.handleWebGLContextRestored, this);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_webgl_Context_, _disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Just bind the buffer if it's in the cache. Otherwise create
 * the WebGL buffer, bind it, populate it, and add an entry to
 * the cache.
 * @param {number} target Target.
 * @param {ol.webgl.Buffer} buf Buffer.
 */


_ol_webgl_Context_.prototype.bindBuffer = function (target, buf) {
  var gl = this.getGL();
  var arr = buf.getArray();
  var bufferKey = String(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(buf));

  if (bufferKey in this.bufferCache_) {
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    gl.bindBuffer(target, bufferCacheEntry.buffer);
  } else {
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    var
    /** @type {ArrayBufferView} */
    arrayBuffer;

    if (target == _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].ARRAY_BUFFER) {
      arrayBuffer = new Float32Array(arr);
    } else if (target == _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].ELEMENT_ARRAY_BUFFER) {
      arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);
    }

    gl.bufferData(target, arrayBuffer, buf.getUsage());
    this.bufferCache_[bufferKey] = {
      buf: buf,
      buffer: buffer
    };
  }
};
/**
 * @param {ol.webgl.Buffer} buf Buffer.
 */


_ol_webgl_Context_.prototype.deleteBuffer = function (buf) {
  var gl = this.getGL();
  var bufferKey = String(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(buf));
  var bufferCacheEntry = this.bufferCache_[bufferKey];

  if (!gl.isContextLost()) {
    gl.deleteBuffer(bufferCacheEntry.buffer);
  }

  delete this.bufferCache_[bufferKey];
};
/**
 * @inheritDoc
 */


_ol_webgl_Context_.prototype.disposeInternal = function () {
  _events_js__WEBPACK_IMPORTED_MODULE_3__["default"].unlistenAll(this.canvas_);

  var gl = this.getGL();

  if (!gl.isContextLost()) {
    var key;

    for (key in this.bufferCache_) {
      gl.deleteBuffer(this.bufferCache_[key].buffer);
    }

    for (key in this.programCache_) {
      gl.deleteProgram(this.programCache_[key]);
    }

    for (key in this.shaderCache_) {
      gl.deleteShader(this.shaderCache_[key]);
    } // delete objects for hit-detection


    gl.deleteFramebuffer(this.hitDetectionFramebuffer_);
    gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);
    gl.deleteTexture(this.hitDetectionTexture_);
  }
};
/**
 * @return {HTMLCanvasElement} Canvas.
 */


_ol_webgl_Context_.prototype.getCanvas = function () {
  return this.canvas_;
};
/**
 * Get the WebGL rendering context
 * @return {WebGLRenderingContext} The rendering context.
 * @api
 */


_ol_webgl_Context_.prototype.getGL = function () {
  return this.gl_;
};
/**
 * Get the frame buffer for hit detection.
 * @return {WebGLFramebuffer} The hit detection frame buffer.
 */


_ol_webgl_Context_.prototype.getHitDetectionFramebuffer = function () {
  if (!this.hitDetectionFramebuffer_) {
    this.initHitDetectionFramebuffer_();
  }

  return this.hitDetectionFramebuffer_;
};
/**
 * Get shader from the cache if it's in the cache. Otherwise, create
 * the WebGL shader, compile it, and add entry to cache.
 * @param {ol.webgl.Shader} shaderObject Shader object.
 * @return {WebGLShader} Shader.
 */


_ol_webgl_Context_.prototype.getShader = function (shaderObject) {
  var shaderKey = String(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(shaderObject));

  if (shaderKey in this.shaderCache_) {
    return this.shaderCache_[shaderKey];
  } else {
    var gl = this.getGL();
    var shader = gl.createShader(shaderObject.getType());
    gl.shaderSource(shader, shaderObject.getSource());
    gl.compileShader(shader);
    this.shaderCache_[shaderKey] = shader;
    return shader;
  }
};
/**
 * Get the program from the cache if it's in the cache. Otherwise create
 * the WebGL program, attach the shaders to it, and add an entry to the
 * cache.
 * @param {ol.webgl.Fragment} fragmentShaderObject Fragment shader.
 * @param {ol.webgl.Vertex} vertexShaderObject Vertex shader.
 * @return {WebGLProgram} Program.
 */


_ol_webgl_Context_.prototype.getProgram = function (fragmentShaderObject, vertexShaderObject) {
  var programKey = _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(fragmentShaderObject) + '/' + _index_js__WEBPACK_IMPORTED_MODULE_0__["default"].getUid(vertexShaderObject);

  if (programKey in this.programCache_) {
    return this.programCache_[programKey];
  } else {
    var gl = this.getGL();
    var program = gl.createProgram();
    gl.attachShader(program, this.getShader(fragmentShaderObject));
    gl.attachShader(program, this.getShader(vertexShaderObject));
    gl.linkProgram(program);
    this.programCache_[programKey] = program;
    return program;
  }
};
/**
 * FIXME empy description for jsdoc
 */


_ol_webgl_Context_.prototype.handleWebGLContextLost = function () {
  _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].clear(this.bufferCache_);

  _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].clear(this.shaderCache_);

  _obj_js__WEBPACK_IMPORTED_MODULE_4__["default"].clear(this.programCache_);

  this.currentProgram_ = null;
  this.hitDetectionFramebuffer_ = null;
  this.hitDetectionTexture_ = null;
  this.hitDetectionRenderbuffer_ = null;
};
/**
 * FIXME empy description for jsdoc
 */


_ol_webgl_Context_.prototype.handleWebGLContextRestored = function () {};
/**
 * Creates a 1x1 pixel framebuffer for the hit-detection.
 * @private
 */


_ol_webgl_Context_.prototype.initHitDetectionFramebuffer_ = function () {
  var gl = this.gl_;
  var framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  var texture = _ol_webgl_Context_.createEmptyTexture(gl, 1, 1);

  var renderbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  this.hitDetectionFramebuffer_ = framebuffer;
  this.hitDetectionTexture_ = texture;
  this.hitDetectionRenderbuffer_ = renderbuffer;
};
/**
 * Use a program.  If the program is already in use, this will return `false`.
 * @param {WebGLProgram} program Program.
 * @return {boolean} Changed.
 * @api
 */


_ol_webgl_Context_.prototype.useProgram = function (program) {
  if (program == this.currentProgram_) {
    return false;
  } else {
    var gl = this.getGL();
    gl.useProgram(program);
    this.currentProgram_ = program;
    return true;
  }
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 * @private
 */


_ol_webgl_Context_.createTexture_ = function (gl, opt_wrapS, opt_wrapT) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  if (opt_wrapS !== undefined) {
    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXTURE_WRAP_S, opt_wrapS);
  }

  if (opt_wrapT !== undefined) {
    gl.texParameteri(_webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXTURE_2D, _webgl_js__WEBPACK_IMPORTED_MODULE_5__["default"].TEXTURE_WRAP_T, opt_wrapT);
  }

  return texture;
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */


_ol_webgl_Context_.createEmptyTexture = function (gl, width, height, opt_wrapS, opt_wrapT) {
  var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */


_ol_webgl_Context_.createTexture = function (gl, image, opt_wrapS, opt_wrapT) {
  var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  return texture;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_Context_);

/***/ }),

/***/ "./node_modules/ol/webgl/contexteventtype.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/webgl/contexteventtype.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @enum {string}
 */
var _ol_webgl_ContextEventType_ = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_ContextEventType_);

/***/ }),

/***/ "./node_modules/ol/webgl/fragment.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/webgl/fragment.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/shader.js */ "./node_modules/ol/webgl/shader.js");



/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */

var _ol_webgl_Fragment_ = function (source) {
  _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, source);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_webgl_Fragment_, _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @inheritDoc
 */


_ol_webgl_Fragment_.prototype.getType = function () {
  return _webgl_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRAGMENT_SHADER;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_Fragment_);

/***/ }),

/***/ "./node_modules/ol/webgl/shader.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/webgl/shader.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

/**
 * @constructor
 * @abstract
 * @param {string} source Source.
 * @struct
 */

var _ol_webgl_Shader_ = function (source) {
  /**
   * @private
   * @type {string}
   */
  this.source_ = source;
};
/**
 * @abstract
 * @return {number} Type.
 */


_ol_webgl_Shader_.prototype.getType = function () {};
/**
 * @return {string} Source.
 */


_ol_webgl_Shader_.prototype.getSource = function () {
  return this.source_;
};
/**
 * @return {boolean} Is animated?
 */


_ol_webgl_Shader_.prototype.isAnimated = _functions_js__WEBPACK_IMPORTED_MODULE_0__["default"].FALSE;
/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_Shader_);

/***/ }),

/***/ "./node_modules/ol/webgl/vertex.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/webgl/vertex.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl.js */ "./node_modules/ol/webgl.js");
/* harmony import */ var _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/shader.js */ "./node_modules/ol/webgl/shader.js");



/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */

var _ol_webgl_Vertex_ = function (source) {
  _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(this, source);
};

_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(_ol_webgl_Vertex_, _webgl_shader_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @inheritDoc
 */


_ol_webgl_Vertex_.prototype.getType = function () {
  return _webgl_js__WEBPACK_IMPORTED_MODULE_1__["default"].VERTEX_SHADER;
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_webgl_Vertex_);

/***/ }),

/***/ "./node_modules/ol/xml.js":
/*!********************************!*\
  !*** ./node_modules/ol/xml.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");

var _ol_xml_ = {};
/**
 * This document should be used when creating nodes for XML serializations. This
 * document is also used by {@link ol.xml.createElementNS} and
 * {@link ol.xml.setAttributeNS}
 * @const
 * @type {Document}
 */

_ol_xml_.DOCUMENT = document.implementation.createDocument('', '', null);
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Node} Node.
 */

_ol_xml_.createElementNS = function (namespaceURI, qualifiedName) {
  return _ol_xml_.DOCUMENT.createElementNS(namespaceURI, qualifiedName);
};
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */


_ol_xml_.getAllTextContent = function (node, normalizeWhitespace) {
  return _ol_xml_.getAllTextContent_(node, normalizeWhitespace, []).join('');
};
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<string>} accumulator Accumulator.
 * @private
 * @return {Array.<string>} Accumulator.
 */


_ol_xml_.getAllTextContent_ = function (node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;

    for (n = node.firstChild; n; n = n.nextSibling) {
      _ol_xml_.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }

  return accumulator;
};
/**
 * @param {?} value Value.
 * @return {boolean} Is document.
 */


_ol_xml_.isDocument = function (value) {
  return value instanceof Document;
};
/**
 * @param {?} value Value.
 * @return {boolean} Is node.
 */


_ol_xml_.isNode = function (value) {
  return value instanceof Node;
};
/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */


_ol_xml_.getAttributeNS = function (node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
};
/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @param {string|number} value Value.
 */


_ol_xml_.setAttributeNS = function (node, namespaceURI, name, value) {
  node.setAttributeNS(namespaceURI, name, value);
};
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */


_ol_xml_.parse = function (xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
};
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}
 *     valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeArrayExtender = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this, node, objectStack);

      if (value !== undefined) {
        var array =
        /** @type {Array.<*>} */
        objectStack[objectStack.length - 1];

        _array_js__WEBPACK_IMPORTED_MODULE_0__["default"].extend(array, value);
      }
    }
  );
};
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeArrayPusher = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    }
  );
};
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeReplacer = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
};
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeObjectPropertyPusher = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        var array;

        if (property in object) {
          array = object[property];
        } else {
          array = object[property] = [];
        }

        array.push(value);
      }
    }
  );
};
/**
 * Make an object property setter function.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeObjectPropertySetter = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        object[property] = value;
      }
    }
  );
};
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */


_ol_xml_.makeChildAppender = function (nodeWriter, opt_this) {
  return function (node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
};
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link ol.xml.serialize}. This can be used by the parent writer to have the
 * 'nodeWriter' called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */


_ol_xml_.makeArraySerializer = function (nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = _ol_xml_.makeSimpleNodeFactory(node.localName);
    }

    _ol_xml_.serialize(serializersNS, nodeFactory, value, objectStack);
  };
};
/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string=} opt_nodeName Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.
 */


_ol_xml_.makeSimpleNodeFactory = function (opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return (
    /**
     * @param {*} value Value.
     * @param {Array.<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
      var context = objectStack[objectStack.length - 1];
      var node = context.node;
      var nodeName = fixedNodeName;

      if (nodeName === undefined) {
        nodeName = opt_nodeName;
      }

      var namespaceURI = opt_namespaceURI;

      if (opt_namespaceURI === undefined) {
        namespaceURI = node.namespaceURI;
      }

      return _ol_xml_.createElementNS(namespaceURI,
      /** @type {string} */
      nodeName);
    }
  );
};
/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 */


_ol_xml_.OBJECT_PROPERTY_NODE_FACTORY = _ol_xml_.makeSimpleNodeFactory();
/**
 * Create an array of `values` to be used with {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array.<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array.<V>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 * @template V
 */

_ol_xml_.makeSequence = function (object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);

  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }

  return sequence;
};
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */


_ol_xml_.makeStructureNS = function (namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;

  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }

  return structureNS;
};
/**
 * Parse a node using the parsers and object stack.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 */


_ol_xml_.parseNode = function (parsersNS, node, objectStack, opt_this) {
  var n;

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];

    if (parsers !== undefined) {
      var parser = parsers[n.localName];

      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
};
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 * @return {T} Object.
 * @template T
 */


_ol_xml_.pushParseAndPop = function (object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);

  _ol_xml_.parseNode(parsersNS, node, objectStack, opt_this);

  return objectStack.pop();
};
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */


_ol_xml_.serialize = function (serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;

  for (var i = 0; i < length; ++i) {
    value = values[i];

    if (value !== undefined) {
      node = nodeFactory.call(opt_this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);

      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
};
/**
 * @param {O} object Object.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */


_ol_xml_.pushSerializeAndPop = function (object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);

  _ol_xml_.serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);

  return objectStack.pop();
};

/* harmony default export */ __webpack_exports__["default"] = (_ol_xml_);

/***/ }),

/***/ "./node_modules/pica/dist/pica.js":
/*!****************************************!*\
  !*** ./node_modules/pica/dist/pica.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* pica 4.2.0 nodeca/pica */
(function (f) {
  if (true) {
    module.exports = f();
  } else { var g; }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return require(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }

        return n[i].exports;
      }

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);

      return o;
    }

    return r;
  }()({
    1: [function (require, module, exports) {
      // Collection of math functions
      //
      // 1. Combine components together
      // 2. Has async init to load wasm modules
      //
      'use strict';

      var inherits = require('inherits');

      var Multimath = require('multimath');

      var mm_unsharp_mask = require('multimath/lib/unsharp_mask');

      var mm_resize = require('./mm_resize');

      function MathLib(requested_features) {
        var __requested_features = requested_features || [];

        var features = {
          js: __requested_features.indexOf('js') >= 0,
          wasm: __requested_features.indexOf('wasm') >= 0
        };
        Multimath.call(this, features);
        this.features = {
          js: features.js,
          wasm: features.wasm && this.has_wasm
        };
        this.use(mm_unsharp_mask);
        this.use(mm_resize);
      }

      inherits(MathLib, Multimath);

      MathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
        var result = this.resize(options, cache);

        if (options.unsharpAmount) {
          this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);
        }

        return result;
      };

      module.exports = MathLib;
    }, {
      "./mm_resize": 4,
      "inherits": 15,
      "multimath": 16,
      "multimath/lib/unsharp_mask": 19
    }],
    2: [function (require, module, exports) {
      // Resize convolvers, pure JS implementation
      //
      'use strict'; // Precision of fixed FP values
      //var FIXED_FRAC_BITS = 14;

      function clampTo8(i) {
        return i < 0 ? 0 : i > 255 ? 255 : i;
      } // Convolve image in horizontal directions and transpose output. In theory,
      // transpose allow:
      //
      // - use the same convolver for both passes (this fails due different
      //   types of input array and temporary buffer)
      // - making vertical pass by horisonltal lines inprove CPU cache use.
      //
      // But in real life this doesn't work :)
      //


      function convolveHorizontally(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0,
            destOffset = 0; // For each row

        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0; // Apply precomputed filters to each destination row point

          for (destX = 0; destX < destW; destX++) {
            // Get the filter that determines the current output pixel.
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a

            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)
              // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.

              a = a + filterVal * src[srcPtr + 3] | 0;
              b = b + filterVal * src[srcPtr + 2] | 0;
              g = g + filterVal * src[srcPtr + 1] | 0;
              r = r + filterVal * src[srcPtr] | 0;
              srcPtr = srcPtr + 4 | 0;
            } // Bring this value back in range. All of the filter scaling factors
            // are in fixed point with FIXED_FRAC_BITS bits of fractional part.
            //
            // (!) Add 1/2 of value before clamping to get proper rounding. In other
            // case brightness loss will be noticeable if you resize image with white
            // border and place it on white background.
            //


            dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset] = clampTo8(r + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            destOffset = destOffset + srcH * 4 | 0;
          }

          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      } // Technically, convolvers are the same. But input array and temporary
      // buffer can be of different type (especially, in old browsers). So,
      // keep code in separate functions to avoid deoptimizations & speed loss.


      function convolveVertically(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a;
        var filterPtr, filterShift, filterSize;
        var srcPtr, srcY, destX, filterVal;
        var srcOffset = 0,
            destOffset = 0; // For each row

        for (srcY = 0; srcY < srcH; srcY++) {
          filterPtr = 0; // Apply precomputed filters to each destination row point

          for (destX = 0; destX < destW; destX++) {
            // Get the filter that determines the current output pixel.
            filterShift = filters[filterPtr++];
            filterSize = filters[filterPtr++];
            srcPtr = srcOffset + filterShift * 4 | 0;
            r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a

            for (; filterSize > 0; filterSize--) {
              filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)
              // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.

              a = a + filterVal * src[srcPtr + 3] | 0;
              b = b + filterVal * src[srcPtr + 2] | 0;
              g = g + filterVal * src[srcPtr + 1] | 0;
              r = r + filterVal * src[srcPtr] | 0;
              srcPtr = srcPtr + 4 | 0;
            } // Bring this value back in range. All of the filter scaling factors
            // are in fixed point with FIXED_FRAC_BITS bits of fractional part.
            //
            // (!) Add 1/2 of value before clamping to get proper rounding. In other
            // case brightness loss will be noticeable if you resize image with white
            // border and place it on white background.
            //


            dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            dest[destOffset] = clampTo8(r + (1 << 13) >> 14
            /*FIXED_FRAC_BITS*/
            );
            destOffset = destOffset + srcH * 4 | 0;
          }

          destOffset = (srcY + 1) * 4 | 0;
          srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
      }

      module.exports = {
        convolveHorizontally: convolveHorizontally,
        convolveVertically: convolveVertically
      };
    }, {}],
    3: [function (require, module, exports) {
      // This is autogenerated file from math.wasm, don't edit.
      //
      'use strict';
      /* eslint-disable max-len */

      module.exports = 'AGFzbQEAAAABFAJgBn9/f39/fwBgB39/f39/f38AAg8BA2VudgZtZW1vcnkCAAEDAwIAAQQEAXAAAAcZAghjb252b2x2ZQAACmNvbnZvbHZlSFYAAQkBAArmAwLBAwEQfwJAIANFDQAgBEUNACAFQQRqIRVBACEMQQAhDQNAIA0hDkEAIRFBACEHA0AgB0ECaiESAn8gBSAHQQF0IgdqIgZBAmouAQAiEwRAQQAhCEEAIBNrIRQgFSAHaiEPIAAgDCAGLgEAakECdGohEEEAIQlBACEKQQAhCwNAIBAoAgAiB0EYdiAPLgEAIgZsIAtqIQsgB0H/AXEgBmwgCGohCCAHQRB2Qf8BcSAGbCAKaiEKIAdBCHZB/wFxIAZsIAlqIQkgD0ECaiEPIBBBBGohECAUQQFqIhQNAAsgEiATagwBC0EAIQtBACEKQQAhCUEAIQggEgshByABIA5BAnRqIApBgMAAakEOdSIGQf8BIAZB/wFIG0EQdEGAgPwHcUEAIAZBAEobIAtBgMAAakEOdSIGQf8BIAZB/wFIG0EYdEEAIAZBAEobciAJQYDAAGpBDnUiBkH/ASAGQf8BSBtBCHRBgP4DcUEAIAZBAEobciAIQYDAAGpBDnUiBkH/ASAGQf8BSBtB/wFxQQAgBkEAShtyNgIAIA4gA2ohDiARQQFqIhEgBEcNAAsgDCACaiEMIA1BAWoiDSADRw0ACwsLIQACQEEAIAIgAyAEIAUgABAAIAJBACAEIAUgBiABEAALCw==';
    }, {}],
    4: [function (require, module, exports) {
      'use strict';

      module.exports = {
        name: 'resize',
        fn: require('./resize'),
        wasm_fn: require('./resize_wasm'),
        wasm_src: require('./convolve_wasm_base64')
      };
    }, {
      "./convolve_wasm_base64": 3,
      "./resize": 5,
      "./resize_wasm": 8
    }],
    5: [function (require, module, exports) {
      'use strict';

      var createFilters = require('./resize_filter_gen');

      var convolveHorizontally = require('./convolve').convolveHorizontally;

      var convolveVertically = require('./convolve').convolveVertically;

      function resetAlpha(dst, width, height) {
        var ptr = 3,
            len = width * height * 4 | 0;

        while (ptr < len) {
          dst[ptr] = 0xFF;
          ptr = ptr + 4 | 0;
        }
      }

      module.exports = function resize(options) {
        var src = options.src;
        var srcW = options.width;
        var srcH = options.height;
        var destW = options.toWidth;
        var destH = options.toHeight;
        var scaleX = options.scaleX || options.toWidth / options.width;
        var scaleY = options.scaleY || options.toHeight / options.height;
        var offsetX = options.offsetX || 0;
        var offsetY = options.offsetY || 0;
        var dest = options.dest || new Uint8Array(destW * destH * 4);
        var quality = typeof options.quality === 'undefined' ? 3 : options.quality;
        var alpha = options.alpha || false;
        var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),
            filtersY = createFilters(quality, srcH, destH, scaleY, offsetY);
        var tmp = new Uint8Array(destW * srcH * 4); // To use single function we need src & tmp of the same type.
        // But src can be CanvasPixelArray, and tmp - Uint8Array. So, keep
        // vertical and horizontal passes separately to avoid deoptimization.

        convolveHorizontally(src, tmp, srcW, srcH, destW, filtersX);
        convolveVertically(tmp, dest, srcH, destW, destH, filtersY); // That's faster than doing checks in convolver.
        // !!! Note, canvas data is not premultipled. We don't need other
        // alpha corrections.

        if (!alpha) resetAlpha(dest, destW, destH);
        return dest;
      };
    }, {
      "./convolve": 2,
      "./resize_filter_gen": 6
    }],
    6: [function (require, module, exports) {
      // Calculate convolution filters for each destination point,
      // and pack data to Int16Array:
      //
      // [ shift, length, data..., shift2, length2, data..., ... ]
      //
      // - shift - offset in src image
      // - length - filter length (in src points)
      // - data - filter values sequence
      //
      'use strict';

      var FILTER_INFO = require('./resize_filter_info'); // Precision of fixed FP values


      var FIXED_FRAC_BITS = 14;

      function toFixedPoint(num) {
        return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));
      }

      module.exports = function resizeFilterGen(quality, srcSize, destSize, scale, offset) {
        var filterFunction = FILTER_INFO[quality].filter;
        var scaleInverted = 1.0 / scale;
        var scaleClamped = Math.min(1.0, scale); // For upscale
        // Filter window (averaging interval), scaled to src image

        var srcWindow = FILTER_INFO[quality].win / scaleClamped;
        var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;
        var leftNotEmpty, rightNotEmpty, filterShift, filterSize;
        var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);
        var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);
        var packedFilterPtr = 0;
        var slowCopy = !packedFilter.subarray || !packedFilter.set; // For each destination pixel calculate source range and built filter values

        for (destPixel = 0; destPixel < destSize; destPixel++) {
          // Scaling should be done relative to central pixel point
          srcPixel = (destPixel + 0.5) * scaleInverted + offset;
          srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));
          srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));
          filterElementSize = srcLast - srcFirst + 1;
          floatFilter = new Float32Array(filterElementSize);
          fxpFilter = new Int16Array(filterElementSize);
          total = 0.0; // Fill filter values for calculated range

          for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {
            floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);
            total += floatVal;
            floatFilter[idx] = floatVal;
          } // Normalize filter, convert to fixed point and accumulate conversion error


          filterTotal = 0;

          for (idx = 0; idx < floatFilter.length; idx++) {
            filterVal = floatFilter[idx] / total;
            filterTotal += filterVal;
            fxpFilter[idx] = toFixedPoint(filterVal);
          } // Compensate normalization error, to minimize brightness drift


          fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal); //
          // Now pack filter to useable form
          //
          // 1. Trim heading and tailing zero values, and compensate shitf/length
          // 2. Put all to single array in this format:
          //
          //    [ pos shift, data length, value1, value2, value3, ... ]
          //

          leftNotEmpty = 0;

          while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {
            leftNotEmpty++;
          }

          if (leftNotEmpty < fxpFilter.length) {
            rightNotEmpty = fxpFilter.length - 1;

            while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {
              rightNotEmpty--;
            }

            filterShift = srcFirst + leftNotEmpty;
            filterSize = rightNotEmpty - leftNotEmpty + 1;
            packedFilter[packedFilterPtr++] = filterShift; // shift

            packedFilter[packedFilterPtr++] = filterSize; // size

            if (!slowCopy) {
              packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);
              packedFilterPtr += filterSize;
            } else {
              // fallback for old IE < 11, without subarray/set methods
              for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {
                packedFilter[packedFilterPtr++] = fxpFilter[idx];
              }
            }
          } else {
            // zero data, write header only
            packedFilter[packedFilterPtr++] = 0; // shift

            packedFilter[packedFilterPtr++] = 0; // size
          }
        }

        return packedFilter;
      };
    }, {
      "./resize_filter_info": 7
    }],
    7: [function (require, module, exports) {
      // Filter definitions to build tables for
      // resizing convolvers.
      //
      // Presets for quality 0..3. Filter functions + window size
      //
      'use strict';

      module.exports = [{
        // Nearest neibor (Box)
        win: 0.5,
        filter: function filter(x) {
          return x >= -0.5 && x < 0.5 ? 1.0 : 0.0;
        }
      }, {
        // Hamming
        win: 1.0,
        filter: function filter(x) {
          if (x <= -1.0 || x >= 1.0) {
            return 0.0;
          }

          if (x > -1.19209290E-07 && x < 1.19209290E-07) {
            return 1.0;
          }

          var xpi = x * Math.PI;
          return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));
        }
      }, {
        // Lanczos, win = 2
        win: 2.0,
        filter: function filter(x) {
          if (x <= -2.0 || x >= 2.0) {
            return 0.0;
          }

          if (x > -1.19209290E-07 && x < 1.19209290E-07) {
            return 1.0;
          }

          var xpi = x * Math.PI;
          return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);
        }
      }, {
        // Lanczos, win = 3
        win: 3.0,
        filter: function filter(x) {
          if (x <= -3.0 || x >= 3.0) {
            return 0.0;
          }

          if (x > -1.19209290E-07 && x < 1.19209290E-07) {
            return 1.0;
          }

          var xpi = x * Math.PI;
          return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);
        }
      }];
    }, {}],
    8: [function (require, module, exports) {
      'use strict';

      var createFilters = require('./resize_filter_gen');

      function resetAlpha(dst, width, height) {
        var ptr = 3,
            len = width * height * 4 | 0;

        while (ptr < len) {
          dst[ptr] = 0xFF;
          ptr = ptr + 4 | 0;
        }
      }

      function asUint8Array(src) {
        return new Uint8Array(src.buffer, 0, src.byteLength);
      }

      var IS_LE = true; // should not crash everything on module load in old browsers

      try {
        IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
      } catch (__) {}

      function copyInt16asLE(src, target, target_offset) {
        if (IS_LE) {
          target.set(asUint8Array(src), target_offset);
          return;
        }

        for (var ptr = target_offset, i = 0; i < src.length; i++) {
          var data = src[i];
          target[ptr++] = data & 0xFF;
          target[ptr++] = data >> 8 & 0xFF;
        }
      }

      module.exports = function resize_wasm(options) {
        var src = options.src;
        var srcW = options.width;
        var srcH = options.height;
        var destW = options.toWidth;
        var destH = options.toHeight;
        var scaleX = options.scaleX || options.toWidth / options.width;
        var scaleY = options.scaleY || options.toHeight / options.height;
        var offsetX = options.offsetX || 0.0;
        var offsetY = options.offsetY || 0.0;
        var dest = options.dest || new Uint8Array(destW * destH * 4);
        var quality = typeof options.quality === 'undefined' ? 3 : options.quality;
        var alpha = options.alpha || false;
        var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),
            filtersY = createFilters(quality, srcH, destH, scaleY, offsetY); // destination is 0 too.

        var src_offset = 0; // buffer between convolve passes

        var tmp_offset = this.__align(src_offset + Math.max(src.byteLength, dest.byteLength));

        var filtersX_offset = this.__align(tmp_offset + srcH * destW * 4);

        var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);

        var alloc_bytes = filtersY_offset + filtersY.byteLength;

        var instance = this.__instance('resize', alloc_bytes); //
        // Fill memory block with data to process
        //


        var mem = new Uint8Array(this.__memory.buffer);
        var mem32 = new Uint32Array(this.__memory.buffer); // 32-bit copy is much faster in chrome

        var src32 = new Uint32Array(src.buffer);
        mem32.set(src32); // We should guarantee LE bytes order. Filters are not big, so
        // speed difference is not significant vs direct .set()

        copyInt16asLE(filtersX, mem, filtersX_offset);
        copyInt16asLE(filtersY, mem, filtersY_offset); //
        // Now call webassembly method
        // emsdk does method names with '_'

        var fn = instance.exports.convolveHV || instance.exports._convolveHV;
        fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH); //
        // Copy data back to typed array
        //
        // 32-bit copy is much faster in chrome

        var dest32 = new Uint32Array(dest.buffer);
        dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW)); // That's faster than doing checks in convolver.
        // !!! Note, canvas data is not premultipled. We don't need other
        // alpha corrections.

        if (!alpha) resetAlpha(dest, destW, destH);
        return dest;
      };
    }, {
      "./resize_filter_gen": 6
    }],
    9: [function (require, module, exports) {
      'use strict';

      var GC_INTERVAL = 100;

      function Pool(create, idle) {
        this.create = create;
        this.available = [];
        this.acquired = {};
        this.lastId = 1;
        this.timeoutId = 0;
        this.idle = idle || 2000;
      }

      Pool.prototype.acquire = function () {
        var _this = this;

        var resource = void 0;

        if (this.available.length !== 0) {
          resource = this.available.pop();
        } else {
          resource = this.create();
          resource.id = this.lastId++;

          resource.release = function () {
            return _this.release(resource);
          };
        }

        this.acquired[resource.id] = resource;
        return resource;
      };

      Pool.prototype.release = function (resource) {
        var _this2 = this;

        delete this.acquired[resource.id];
        resource.lastUsed = Date.now();
        this.available.push(resource);

        if (this.timeoutId === 0) {
          this.timeoutId = setTimeout(function () {
            return _this2.gc();
          }, GC_INTERVAL);
        }
      };

      Pool.prototype.gc = function () {
        var _this3 = this;

        var now = Date.now();
        this.available = this.available.filter(function (resource) {
          if (now - resource.lastUsed > _this3.idle) {
            resource.destroy();
            return false;
          }

          return true;
        });

        if (this.available.length !== 0) {
          this.timeoutId = setTimeout(function () {
            return _this3.gc();
          }, GC_INTERVAL);
        } else {
          this.timeoutId = 0;
        }
      };

      module.exports = Pool;
    }, {}],
    10: [function (require, module, exports) {
      // Add intermediate resizing steps when scaling down by a very large factor.
      //
      // For example, when resizing 10000x10000 down to 10x10, it'll resize it to
      // 300x300 first.
      //
      // It's needed because tiler has issues when the entire tile is scaled down
      // to a few pixels (1024px source tile with border size 3 should result in
      // at least 3+3+2 = 8px target tile, so max scale factor is 128 here).
      //
      // Also, adding intermediate steps can speed up processing if we use lower
      // quality algorithms for first stages.
      //
      'use strict'; // min size = 0 results in infinite loop,
      // min size = 1 can consume large amount of memory

      var MIN_INNER_TILE_SIZE = 2;

      module.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
        var scaleX = toWidth / fromWidth;
        var scaleY = toHeight / fromHeight; // derived from createRegions equation:
        // innerTileWidth = pixelFloor(srcTileSize * scaleX) - 2 * destTileBorder;

        var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize; // refuse to scale image multiple times by less than twice each time,
        // it could only happen because of invalid options

        if (minScale > 0.5) return [[toWidth, toHeight]];
        var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale)); // no additional resizes are necessary,
        // stageCount can be zero or be negative when enlarging the image

        if (stageCount <= 1) return [[toWidth, toHeight]];
        var result = [];

        for (var i = 0; i < stageCount; i++) {
          var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));
          var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
          result.push([width, height]);
        }

        return result;
      };
    }, {}],
    11: [function (require, module, exports) {
      // Split original image into multiple 1024x1024 chunks to reduce memory usage
      // (images have to be unpacked into typed arrays for resizing) and allow
      // parallel processing of multiple tiles at a time.
      //
      'use strict';
      /*
       * pixelFloor and pixelCeil are modified versions of Math.floor and Math.ceil
       * functions which take into account floating point arithmetic errors.
       * Those errors can cause undesired increments/decrements of sizes and offsets:
       * Math.ceil(36 / (36 / 500)) = 501
       * pixelCeil(36 / (36 / 500)) = 500
       */

      var PIXEL_EPSILON = 1e-5;

      function pixelFloor(x) {
        var nearest = Math.round(x);

        if (Math.abs(x - nearest) < PIXEL_EPSILON) {
          return nearest;
        }

        return Math.floor(x);
      }

      function pixelCeil(x) {
        var nearest = Math.round(x);

        if (Math.abs(x - nearest) < PIXEL_EPSILON) {
          return nearest;
        }

        return Math.ceil(x);
      }

      module.exports = function createRegions(options) {
        var scaleX = options.toWidth / options.width;
        var scaleY = options.toHeight / options.height;
        var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;
        var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder; // prevent infinite loop, this should never happen

        if (innerTileWidth < 1 || innerTileHeight < 1) {
          throw new Error('Internal error in pica: target tile width/height is too small.');
        }

        var x, y;
        var innerX, innerY, toTileWidth, toTileHeight;
        var tiles = [];
        var tile; // we go top-to-down instead of left-to-right to make image displayed from top to
        // doesn in the browser

        for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {
          for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {
            x = innerX - options.destTileBorder;

            if (x < 0) {
              x = 0;
            }

            toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;

            if (x + toTileWidth >= options.toWidth) {
              toTileWidth = options.toWidth - x;
            }

            y = innerY - options.destTileBorder;

            if (y < 0) {
              y = 0;
            }

            toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;

            if (y + toTileHeight >= options.toHeight) {
              toTileHeight = options.toHeight - y;
            }

            tile = {
              toX: x,
              toY: y,
              toWidth: toTileWidth,
              toHeight: toTileHeight,
              toInnerX: innerX,
              toInnerY: innerY,
              toInnerWidth: innerTileWidth,
              toInnerHeight: innerTileHeight,
              offsetX: x / scaleX - pixelFloor(x / scaleX),
              offsetY: y / scaleY - pixelFloor(y / scaleY),
              scaleX: scaleX,
              scaleY: scaleY,
              x: pixelFloor(x / scaleX),
              y: pixelFloor(y / scaleY),
              width: pixelCeil(toTileWidth / scaleX),
              height: pixelCeil(toTileHeight / scaleY)
            };
            tiles.push(tile);
          }
        }

        return tiles;
      };
    }, {}],
    12: [function (require, module, exports) {
      'use strict';

      function objClass(obj) {
        return Object.prototype.toString.call(obj);
      }

      module.exports.isCanvas = function isCanvas(element) {
        //return (element.nodeName && element.nodeName.toLowerCase() === 'canvas') ||
        var cname = objClass(element);
        return cname === '[object HTMLCanvasElement]'
        /* browser */
        || cname === '[object Canvas]'
        /* node-canvas */
        ;
      };

      module.exports.isImage = function isImage(element) {
        //return element.nodeName && element.nodeName.toLowerCase() === 'img';
        return objClass(element) === '[object HTMLImageElement]';
      };

      module.exports.limiter = function limiter(concurrency) {
        var active = 0,
            queue = [];

        function roll() {
          if (active < concurrency && queue.length) {
            active++;
            queue.shift()();
          }
        }

        return function limit(fn) {
          return new Promise(function (resolve, reject) {
            queue.push(function () {
              fn().then(function (result) {
                resolve(result);
                active--;
                roll();
              }, function (err) {
                reject(err);
                active--;
                roll();
              });
            });
            roll();
          });
        };
      };

      module.exports.cib_quality_name = function cib_quality_name(num) {
        switch (num) {
          case 0:
            return 'pixelated';

          case 1:
            return 'low';

          case 2:
            return 'medium';
        }

        return 'high';
      };

      module.exports.cib_support = function cib_support() {
        return Promise.resolve().then(function () {
          if (typeof createImageBitmap === 'undefined' || typeof document === 'undefined') {
            return false;
          }

          var c = document.createElement('canvas');
          c.width = 100;
          c.height = 100;
          return createImageBitmap(c, 0, 0, 100, 100, {
            resizeWidth: 10,
            resizeHeight: 10,
            resizeQuality: 'high'
          }).then(function (bitmap) {
            var status = bitmap.width === 10; // Branch below is filtered on upper level. We do not call resize
            // detection for basic ImageBitmap.
            //
            // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap
            // old Crome 51 has ImageBitmap without .close(). Then this code
            // will throw and return 'false' as expected.
            //

            bitmap.close();
            c = null;
            return status;
          });
        }).catch(function () {
          return false;
        });
      };
    }, {}],
    13: [function (require, module, exports) {
      // Web Worker wrapper for image resize function
      'use strict';

      module.exports = function () {
        var MathLib = require('./mathlib');

        var mathLib = void 0;
        /* eslint-disable no-undef */

        onmessage = function onmessage(ev) {
          var opts = ev.data.opts;
          if (!mathLib) mathLib = new MathLib(ev.data.features); // Use multimath's sync auto-init. Avoid Promise use in old browsers,
          // because polyfills are not propagated to webworker.

          var result = mathLib.resizeAndUnsharp(opts);
          postMessage({
            result: result
          }, [result.buffer]);
        };
      };
    }, {
      "./mathlib": 1
    }],
    14: [function (require, module, exports) {
      // Calculate Gaussian blur of an image using IIR filter
      // The method is taken from Intel's white paper and code example attached to it:
      // https://software.intel.com/en-us/articles/iir-gaussian-blur-filter
      // -implementation-using-intel-advanced-vector-extensions
      var a0, a1, a2, a3, b1, b2, left_corner, right_corner;

      function gaussCoef(sigma) {
        if (sigma < 0.5) {
          sigma = 0.5;
        }

        var a = Math.exp(0.726 * 0.726) / sigma,
            g1 = Math.exp(-a),
            g2 = Math.exp(-2 * a),
            k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
        a0 = k;
        a1 = k * (a - 1) * g1;
        a2 = k * (a + 1) * g1;
        a3 = -k * g2;
        b1 = 2 * g1;
        b2 = -g2;
        left_corner = (a0 + a1) / (1 - b1 - b2);
        right_corner = (a2 + a3) / (1 - b1 - b2); // Attempt to force type to FP32.

        return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
      }

      function convolveMono16(src, out, line, coeff, width, height) {
        // takes src image and writes the blurred and transposed result into out
        var prev_src, curr_src, curr_out, prev_out, prev_prev_out;
        var src_index, out_index, line_index;
        var i, j;
        var coeff_a0, coeff_a1, coeff_b1, coeff_b2;

        for (i = 0; i < height; i++) {
          src_index = i * width;
          out_index = i;
          line_index = 0; // left to right

          prev_src = src[src_index];
          prev_prev_out = prev_src * coeff[6];
          prev_out = prev_prev_out;
          coeff_a0 = coeff[0];
          coeff_a1 = coeff[1];
          coeff_b1 = coeff[4];
          coeff_b2 = coeff[5];

          for (j = 0; j < width; j++) {
            curr_src = src[src_index];
            curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
            prev_prev_out = prev_out;
            prev_out = curr_out;
            prev_src = curr_src;
            line[line_index] = prev_out;
            line_index++;
            src_index++;
          }

          src_index--;
          line_index--;
          out_index += height * (width - 1); // right to left

          prev_src = src[src_index];
          prev_prev_out = prev_src * coeff[7];
          prev_out = prev_prev_out;
          curr_src = prev_src;
          coeff_a0 = coeff[2];
          coeff_a1 = coeff[3];

          for (j = width - 1; j >= 0; j--) {
            curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
            prev_prev_out = prev_out;
            prev_out = curr_out;
            prev_src = curr_src;
            curr_src = src[src_index];
            out[out_index] = line[line_index] + prev_out;
            src_index--;
            line_index--;
            out_index -= height;
          }
        }
      }

      function blurMono16(src, width, height, radius) {
        // Quick exit on zero radius
        if (!radius) {
          return;
        }

        var out = new Uint16Array(src.length),
            tmp_line = new Float32Array(Math.max(width, height));
        var coeff = gaussCoef(radius);
        convolveMono16(src, out, tmp_line, coeff, width, height, radius);
        convolveMono16(out, src, tmp_line, coeff, height, width, radius);
      }

      module.exports = blurMono16;
    }, {}],
    15: [function (require, module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;

          var TempCtor = function () {};

          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }, {}],
    16: [function (require, module, exports) {
      'use strict';

      var assign = require('object-assign');

      var base64decode = require('./lib/base64decode');

      var hasWebAssembly = require('./lib/wa_detect');

      var DEFAULT_OPTIONS = {
        js: true,
        wasm: true
      };

      function MultiMath(options) {
        if (!(this instanceof MultiMath)) return new MultiMath(options);
        var opts = assign({}, DEFAULT_OPTIONS, options || {});
        this.options = opts;
        this.__cache = {};
        this.has_wasm = hasWebAssembly();
        this.__init_promise = null;
        this.__modules = opts.modules || {};
        this.__memory = null;
        this.__wasm = {};
        this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;

        if (!this.options.js && !this.options.wasm) {
          throw new Error('mathlib: at least "js" or "wasm" should be enabled');
        }
      }

      MultiMath.prototype.use = function (module) {
        this.__modules[module.name] = module; // Pin the best possible implementation

        if (!this.has_wasm || !this.options.wasm || !module.wasm_fn) {
          this[module.name] = module.fn;
        } else {
          this[module.name] = module.wasm_fn;
        }

        return this;
      };

      MultiMath.prototype.init = function () {
        if (this.__init_promise) return this.__init_promise;

        if (!this.options.js && this.options.wasm && !this.has_wasm) {
          return Promise.reject(new Error('mathlib: only "wasm" was enabled, but it\'s not supported'));
        }

        var self = this;
        this.__init_promise = Promise.all(Object.keys(self.__modules).map(function (name) {
          var module = self.__modules[name];
          if (!self.has_wasm || !self.options.wasm || !module.wasm_fn) return null; // If already compiled - exit

          if (self.__wasm[name]) return null; // Compile wasm source

          return WebAssembly.compile(self.__base64decode(module.wasm_src)).then(function (m) {
            self.__wasm[name] = m;
          });
        })).then(function () {
          return self;
        });
        return this.__init_promise;
      }; ////////////////////////////////////////////////////////////////////////////////
      // Methods below are for internal use from plugins
      // Simple decode base64 to typed array. Useful to load embedded webassembly
      // code. You probably don't need to call this method directly.
      //


      MultiMath.prototype.__base64decode = base64decode; // Increase current memory to include specified number of bytes. Do nothing if
      // size is already ok. You probably don't need to call this method directly,
      // because it will be invoked from `.__instance()`.
      //

      MultiMath.prototype.__reallocate = function mem_grow_to(bytes) {
        if (!this.__memory) {
          this.__memory = new WebAssembly.Memory({
            initial: Math.ceil(bytes / (64 * 1024))
          });
          return this.__memory;
        }

        var mem_size = this.__memory.buffer.byteLength;

        if (mem_size < bytes) {
          this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));
        }

        return this.__memory;
      }; // Returns instantinated webassembly item by name, with specified memory size
      // and environment.
      // - use cache if available
      // - do sync module init, if async init was not called earlier
      // - allocate memory if not enougth
      // - can export functions to webassembly via "env_extra",
      //   for example, { exp: Math.exp }
      //


      MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
        if (memsize) this.__reallocate(memsize); // If .init() was not called, do sync compile

        if (!this.__wasm[name]) {
          var module = this.__modules[name];
          this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));
        }

        if (!this.__cache[name]) {
          var env_base = {
            memoryBase: 0,
            memory: this.__memory,
            tableBase: 0,
            table: new WebAssembly.Table({
              initial: 0,
              element: 'anyfunc'
            })
          };
          this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
            env: assign(env_base, env_extra || {})
          });
        }

        return this.__cache[name];
      }; // Helper to calculate memory aligh for pointers. Webassembly does not require
      // this, but you may wish to experiment. Default base = 8;
      //


      MultiMath.prototype.__align = function align(number, base) {
        base = base || 8;
        var reminder = number % base;
        return number + (reminder ? base - reminder : 0);
      };

      module.exports = MultiMath;
    }, {
      "./lib/base64decode": 17,
      "./lib/wa_detect": 23,
      "object-assign": 24
    }],
    17: [function (require, module, exports) {
      // base64 decode str -> Uint8Array, to load WA modules
      //
      'use strict';

      var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      module.exports = function base64decode(str) {
        var input = str.replace(/[\r\n=]/g, ''),
            // remove CR/LF & padding to simplify scan
        max = input.length;
        var out = new Uint8Array(max * 3 >> 2); // Collect by 6*4 bits (3 bytes)

        var bits = 0;
        var ptr = 0;

        for (var idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            out[ptr++] = bits >> 16 & 0xFF;
            out[ptr++] = bits >> 8 & 0xFF;
            out[ptr++] = bits & 0xFF;
          }

          bits = bits << 6 | BASE64_MAP.indexOf(input.charAt(idx));
        } // Dump tail


        var tailbits = max % 4 * 6;

        if (tailbits === 0) {
          out[ptr++] = bits >> 16 & 0xFF;
          out[ptr++] = bits >> 8 & 0xFF;
          out[ptr++] = bits & 0xFF;
        } else if (tailbits === 18) {
          out[ptr++] = bits >> 10 & 0xFF;
          out[ptr++] = bits >> 2 & 0xFF;
        } else if (tailbits === 12) {
          out[ptr++] = bits >> 4 & 0xFF;
        }

        return out;
      };
    }, {}],
    18: [function (require, module, exports) {
      // Calculates 16-bit precision HSL lightness from 8-bit rgba buffer
      //
      'use strict';

      module.exports = function hsl_l16_js(img, width, height) {
        var size = width * height;
        var out = new Uint16Array(size);
        var r, g, b, min, max;

        for (var i = 0; i < size; i++) {
          r = img[4 * i];
          g = img[4 * i + 1];
          b = img[4 * i + 2];
          max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;
          min = r <= g && r <= b ? r : g <= b && g <= r ? g : b;
          out[i] = (max + min) * 257 >> 1;
        }

        return out;
      };
    }, {}],
    19: [function (require, module, exports) {
      'use strict';

      module.exports = {
        name: 'unsharp_mask',
        fn: require('./unsharp_mask'),
        wasm_fn: require('./unsharp_mask_wasm'),
        wasm_src: require('./unsharp_mask_wasm_base64')
      };
    }, {
      "./unsharp_mask": 20,
      "./unsharp_mask_wasm": 21,
      "./unsharp_mask_wasm_base64": 22
    }],
    20: [function (require, module, exports) {
      // Unsharp mask filter
      //
      // http://stackoverflow.com/a/23322820/1031804
      // USM(O) = O + (2 * (Amount / 100) * (O - GB))
      // GB - gaussian blur.
      //
      // Image is converted from RGB to HSL, unsharp mask is applied to the
      // lightness channel and then image is converted back to RGB.
      //
      'use strict';

      var glur_mono16 = require('glur/mono16');

      var hsl_l16 = require('./hsl_l16');

      module.exports = function unsharp(img, width, height, amount, radius, threshold) {
        var r, g, b;
        var h, s, l;
        var min, max;
        var m1, m2, hShifted;
        var diff, iTimes4;

        if (amount === 0 || radius < 0.5) {
          return;
        }

        if (radius > 2.0) {
          radius = 2.0;
        }

        var lightness = hsl_l16(img, width, height);
        var blured = new Uint16Array(lightness); // copy, because blur modify src

        glur_mono16(blured, width, height, radius);
        var amountFp = amount / 100 * 0x1000 + 0.5 | 0;
        var thresholdFp = threshold * 257 | 0;
        var size = width * height;
        /* eslint-disable indent */

        for (var i = 0; i < size; i++) {
          diff = 2 * (lightness[i] - blured[i]);

          if (Math.abs(diff) >= thresholdFp) {
            iTimes4 = i * 4;
            r = img[iTimes4];
            g = img[iTimes4 + 1];
            b = img[iTimes4 + 2]; // convert RGB to HSL
            // take RGB, 8-bit unsigned integer per each channel
            // save HSL, H and L are 16-bit unsigned integers, S is 12-bit unsigned integer
            // math is taken from here: http://www.easyrgb.com/index.php?X=MATH&H=18
            // and adopted to be integer (fixed point in fact) for sake of performance

            max = r >= g && r >= b ? r : g >= r && g >= b ? g : b; // min and max are in [0..0xff]

            min = r <= g && r <= b ? r : g <= r && g <= b ? g : b;
            l = (max + min) * 257 >> 1; // l is in [0..0xffff] that is caused by multiplication by 257

            if (min === max) {
              h = s = 0;
            } else {
              s = l <= 0x7fff ? (max - min) * 0xfff / (max + min) | 0 : (max - min) * 0xfff / (2 * 0xff - max - min) | 0; // s is in [0..0xfff]
              // h could be less 0, it will be fixed in backward conversion to RGB, |h| <= 0xffff / 6

              h = r === max ? (g - b) * 0xffff / (6 * (max - min)) | 0 : g === max ? 0x5555 + ((b - r) * 0xffff / (6 * (max - min)) | 0) // 0x5555 == 0xffff / 3
              : 0xaaaa + ((r - g) * 0xffff / (6 * (max - min)) | 0); // 0xaaaa == 0xffff * 2 / 3
            } // add unsharp mask mask to the lightness channel


            l += amountFp * diff + 0x800 >> 12;

            if (l > 0xffff) {
              l = 0xffff;
            } else if (l < 0) {
              l = 0;
            } // convert HSL back to RGB
            // for information about math look above


            if (s === 0) {
              r = g = b = l >> 8;
            } else {
              m2 = l <= 0x7fff ? l * (0x1000 + s) + 0x800 >> 12 : l + ((0xffff - l) * s + 0x800 >> 12);
              m1 = 2 * l - m2 >> 8;
              m2 >>= 8; // save result to RGB channels
              // R channel

              hShifted = h + 0x5555 & 0xffff; // 0x5555 == 0xffff / 3

              r = hShifted >= 0xaaaa ? m1 // 0xaaaa == 0xffff * 2 / 3
              : hShifted >= 0x7fff ? m1 + ((m2 - m1) * 6 * (0xaaaa - hShifted) + 0x8000 >> 16) : hShifted >= 0x2aaa ? m2 // 0x2aaa == 0xffff / 6
              : m1 + ((m2 - m1) * 6 * hShifted + 0x8000 >> 16); // G channel

              hShifted = h & 0xffff;
              g = hShifted >= 0xaaaa ? m1 // 0xaaaa == 0xffff * 2 / 3
              : hShifted >= 0x7fff ? m1 + ((m2 - m1) * 6 * (0xaaaa - hShifted) + 0x8000 >> 16) : hShifted >= 0x2aaa ? m2 // 0x2aaa == 0xffff / 6
              : m1 + ((m2 - m1) * 6 * hShifted + 0x8000 >> 16); // B channel

              hShifted = h - 0x5555 & 0xffff;
              b = hShifted >= 0xaaaa ? m1 // 0xaaaa == 0xffff * 2 / 3
              : hShifted >= 0x7fff ? m1 + ((m2 - m1) * 6 * (0xaaaa - hShifted) + 0x8000 >> 16) : hShifted >= 0x2aaa ? m2 // 0x2aaa == 0xffff / 6
              : m1 + ((m2 - m1) * 6 * hShifted + 0x8000 >> 16);
            }

            img[iTimes4] = r;
            img[iTimes4 + 1] = g;
            img[iTimes4 + 2] = b;
          }
        }
      };
    }, {
      "./hsl_l16": 18,
      "glur/mono16": 14
    }],
    21: [function (require, module, exports) {
      'use strict';

      module.exports = function unsharp(img, width, height, amount, radius, threshold) {
        if (amount === 0 || radius < 0.5) {
          return;
        }

        if (radius > 2.0) {
          radius = 2.0;
        }

        var pixels = width * height;
        var img_bytes_cnt = pixels * 4;
        var hsl_bytes_cnt = pixels * 2;
        var blur_bytes_cnt = pixels * 2;
        var blur_line_byte_cnt = Math.max(width, height) * 4; // float32 array

        var blur_coeffs_byte_cnt = 8 * 4; // float32 array

        var img_offset = 0;
        var hsl_offset = img_bytes_cnt;
        var blur_offset = hsl_offset + hsl_bytes_cnt;
        var blur_tmp_offset = blur_offset + blur_bytes_cnt;
        var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;
        var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;

        var instance = this.__instance('unsharp_mask', img_bytes_cnt + hsl_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {
          exp: Math.exp
        }); // 32-bit copy is much faster in chrome


        var img32 = new Uint32Array(img.buffer);
        var mem32 = new Uint32Array(this.__memory.buffer);
        mem32.set(img32); // HSL

        var fn = instance.exports.hsl_l16 || instance.exports._hsl_l16;
        fn(img_offset, hsl_offset, width, height); // BLUR

        fn = instance.exports.blurMono16 || instance.exports._blurMono16;
        fn(hsl_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius); // UNSHARP

        fn = instance.exports.unsharp || instance.exports._unsharp;
        fn(img_offset, img_offset, hsl_offset, blur_offset, width, height, amount, threshold); // 32-bit copy is much faster in chrome

        img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
      };
    }, {}],
    22: [function (require, module, exports) {
      // This is autogenerated file from math.wasm, don't edit.
      //
      'use strict';
      /* eslint-disable max-len */

      module.exports = 'AGFzbQEAAAABMQZgAXwBfGACfX8AYAZ/f39/f38AYAh/f39/f39/fQBgBH9/f38AYAh/f39/f39/fwACGQIDZW52A2V4cAAAA2VudgZtZW1vcnkCAAEDBgUBAgMEBQQEAXAAAAdMBRZfX2J1aWxkX2dhdXNzaWFuX2NvZWZzAAEOX19nYXVzczE2X2xpbmUAAgpibHVyTW9ubzE2AAMHaHNsX2wxNgAEB3Vuc2hhcnAABQkBAAqJEAXZAQEGfAJAIAFE24a6Q4Ia+z8gALujIgOaEAAiBCAEoCIGtjgCECABIANEAAAAAAAAAMCiEAAiBbaMOAIUIAFEAAAAAAAA8D8gBKEiAiACoiAEIAMgA6CiRAAAAAAAAPA/oCAFoaMiArY4AgAgASAEIANEAAAAAAAA8L+gIAKioiIHtjgCBCABIAQgA0QAAAAAAADwP6AgAqKiIgO2OAIIIAEgBSACoiIEtow4AgwgASACIAegIAVEAAAAAAAA8D8gBqGgIgKjtjgCGCABIAMgBKEgAqO2OAIcCwu3AwMDfwR9CHwCQCADKgIUIQkgAyoCECEKIAMqAgwhCyADKgIIIQwCQCAEQX9qIgdBAEgiCA0AIAIgAC8BALgiDSADKgIYu6IiDiAJuyIQoiAOIAq7IhGiIA0gAyoCBLsiEqIgAyoCALsiEyANoqCgoCIPtjgCACACQQRqIQIgAEECaiEAIAdFDQAgBCEGA0AgAiAOIBCiIA8iDiARoiANIBKiIBMgAC8BALgiDaKgoKAiD7Y4AgAgAkEEaiECIABBAmohACAGQX9qIgZBAUoNAAsLAkAgCA0AIAEgByAFbEEBdGogAEF+ai8BACIIuCINIAu7IhGiIA0gDLsiEqKgIA0gAyoCHLuiIg4gCrsiE6KgIA4gCbsiFKKgIg8gAkF8aioCALugqzsBACAHRQ0AIAJBeGohAiAAQXxqIQBBACAFQQF0ayEHIAEgBSAEQQF0QXxqbGohBgNAIAghAyAALwEAIQggBiANIBGiIAO4Ig0gEqKgIA8iECAToqAgDiAUoqAiDyACKgIAu6CrOwEAIAYgB2ohBiAAQX5qIQAgAkF8aiECIBAhDiAEQX9qIgRBAUoNAAsLCwvfAgIDfwZ8AkAgB0MAAAAAWw0AIARE24a6Q4Ia+z8gB0MAAAA/l7ujIgyaEAAiDSANoCIPtjgCECAEIAxEAAAAAAAAAMCiEAAiDraMOAIUIAREAAAAAAAA8D8gDaEiCyALoiANIAwgDKCiRAAAAAAAAPA/oCAOoaMiC7Y4AgAgBCANIAxEAAAAAAAA8L+gIAuioiIQtjgCBCAEIA0gDEQAAAAAAADwP6AgC6KiIgy2OAIIIAQgDiALoiINtow4AgwgBCALIBCgIA5EAAAAAAAA8D8gD6GgIgujtjgCGCAEIAwgDaEgC6O2OAIcIAYEQCAFQQF0IQogBiEJIAIhCANAIAAgCCADIAQgBSAGEAIgACAKaiEAIAhBAmohCCAJQX9qIgkNAAsLIAVFDQAgBkEBdCEIIAUhAANAIAIgASADIAQgBiAFEAIgAiAIaiECIAFBAmohASAAQX9qIgANAAsLC7wBAQV/IAMgAmwiAwRAQQAgA2shBgNAIAAoAgAiBEEIdiIHQf8BcSECAn8gBEH/AXEiAyAEQRB2IgRB/wFxIgVPBEAgAyIIIAMgAk8NARoLIAQgBCAHIAIgA0kbIAIgBUkbQf8BcQshCAJAIAMgAk0EQCADIAVNDQELIAQgByAEIAMgAk8bIAIgBUsbQf8BcSEDCyAAQQRqIQAgASADIAhqQYECbEEBdjsBACABQQJqIQEgBkEBaiIGDQALCwvTBgEKfwJAIAazQwAAgEWUQwAAyEKVu0QAAAAAAADgP6CqIQ0gBSAEbCILBEAgB0GBAmwhDgNAQQAgAi8BACADLwEAayIGQQF0IgdrIAcgBkEASBsgDk8EQCAAQQJqLQAAIQUCfyAALQAAIgYgAEEBai0AACIESSIJRQRAIAYiCCAGIAVPDQEaCyAFIAUgBCAEIAVJGyAGIARLGwshCAJ/IAYgBE0EQCAGIgogBiAFTQ0BGgsgBSAFIAQgBCAFSxsgCRsLIgogCGoiD0GBAmwiEEEBdiERQQAhDAJ/QQAiCSAIIApGDQAaIAggCmsiCUH/H2wgD0H+AyAIayAKayAQQYCABEkbbSEMIAYgCEYEQCAEIAVrQf//A2wgCUEGbG0MAQsgBSAGayAGIARrIAQgCEYiBhtB//8DbCAJQQZsbUHVqgFBqtUCIAYbagshCSARIAcgDWxBgBBqQQx1aiIGQQAgBkEAShsiBkH//wMgBkH//wNIGyEGAkACfwJAIAxB//8DcSIFBEAgBkH//wFKDQEgBUGAIGogBmxBgBBqQQx2DAILIAZBCHYiBiEFIAYhBAwCCyAFIAZB//8Dc2xBgBBqQQx2IAZqCyIFQQh2IQcgBkEBdCAFa0EIdiIGIQQCQCAJQdWqAWpB//8DcSIFQanVAksNACAFQf//AU8EQEGq1QIgBWsgByAGa2xBBmxBgIACakEQdiAGaiEEDAELIAchBCAFQanVAEsNACAFIAcgBmtsQQZsQYCAAmpBEHYgBmohBAsCfyAGIgUgCUH//wNxIghBqdUCSw0AGkGq1QIgCGsgByAGa2xBBmxBgIACakEQdiAGaiAIQf//AU8NABogByIFIAhBqdUASw0AGiAIIAcgBmtsQQZsQYCAAmpBEHYgBmoLIQUgCUGr1QJqQf//A3EiCEGp1QJLDQAgCEH//wFPBEBBqtUCIAhrIAcgBmtsQQZsQYCAAmpBEHYgBmohBgwBCyAIQanVAEsEQCAHIQYMAQsgCCAHIAZrbEEGbEGAgAJqQRB2IAZqIQYLIAEgBDoAACABQQFqIAU6AAAgAUECaiAGOgAACyADQQJqIQMgAkECaiECIABBBGohACABQQRqIQEgC0F/aiILDQALCwsL';
    }, {}],
    23: [function (require, module, exports) {
      // Detect WebAssembly support.
      // - Check global WebAssembly object
      // - Try to load simple module (can be disabled via CSP)
      //
      'use strict';

      var wa;

      module.exports = function hasWebAssembly() {
        // use cache if called before;
        if (typeof wa !== 'undefined') return wa;
        wa = false;
        if (typeof WebAssembly === 'undefined') return wa; // If WebAssenbly is disabled, code can throw on compile

        try {
          // https://github.com/brion/min-wasm-fail/blob/master/min-wasm-fail.in.js
          // Additional check that WA internals are correct

          /* eslint-disable comma-spacing, max-len */
          var bin = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);
          var module = new WebAssembly.Module(bin);
          var instance = new WebAssembly.Instance(module, {}); // test storing to and loading from a non-zero location via a parameter.
          // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations

          if (instance.exports.test(4) !== 0) wa = true;
          return wa;
        } catch (__) {}

        return wa;
      };
    }, {}],
    24: [function (require, module, exports) {
      /*
      object-assign
      (c) Sindre Sorhus
      @license MIT
      */
      'use strict';
      /* eslint-disable no-unused-vars */

      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          } // Detect buggy property enumeration order in older V8 versions.
          // https://bugs.chromium.org/p/v8/issues/detail?id=4118


          var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

          test1[5] = 'de';

          if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


          var test2 = {};

          for (var i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
          }

          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });

          if (order2.join('') !== '0123456789') {
            return false;
          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


          var test3 = {};
          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
          });

          if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
            return false;
          }

          return true;
        } catch (err) {
          // We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;

        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);

            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };
    }, {}],
    25: [function (require, module, exports) {
      var bundleFn = arguments[3];
      var sources = arguments[4];
      var cache = arguments[5];
      var stringify = JSON.stringify;

      module.exports = function (fn, options) {
        var wkey;
        var cacheKeys = Object.keys(cache);

        for (var i = 0, l = cacheKeys.length; i < l; i++) {
          var key = cacheKeys[i];
          var exp = cache[key].exports; // Using babel as a transpiler to use esmodule, the export will always
          // be an object with the default export as a property of it. To ensure
          // the existing api and babel esmodule exports are both supported we
          // check for both

          if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
          }
        }

        if (!wkey) {
          wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
          var wcache = {};

          for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
          }

          sources[wkey] = ['function(require,module,exports){' + fn + '(self); }', wcache];
        }

        var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var scache = {};
        scache[wkey] = wkey;
        sources[skey] = ['function(require,module,exports){' + // try to call default if defined to also support babel esmodule exports
        'var f = require(' + stringify(wkey) + ');' + '(f.default ? f.default : f)(self);' + '}', scache];
        var workerSources = {};
        resolveSources(skey);

        function resolveSources(key) {
          workerSources[key] = true;

          for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];

            if (!workerSources[depKey]) {
              resolveSources(depKey);
            }
          }
        }

        var src = '(' + bundleFn + ')({' + Object.keys(workerSources).map(function (key) {
          return stringify(key) + ':[' + sources[key][0] + ',' + stringify(sources[key][1]) + ']';
        }).join(',') + '},{},[' + stringify(skey) + '])';
        var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
        var blob = new Blob([src], {
          type: 'text/javascript'
        });

        if (options && options.bare) {
          return blob;
        }

        var workerUrl = URL.createObjectURL(blob);
        var worker = new Worker(workerUrl);
        worker.objectURL = workerUrl;
        return worker;
      };
    }, {}],
    "/": [function (require, module, exports) {
      'use strict';

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var assign = require('object-assign');

      var webworkify = require('webworkify');

      var MathLib = require('./lib/mathlib');

      var Pool = require('./lib/pool');

      var utils = require('./lib/utils');

      var worker = require('./lib/worker');

      var createStages = require('./lib/stepper');

      var createRegions = require('./lib/tiler'); // Deduplicate pools & limiters with the same configs
      // when user creates multiple pica instances.


      var singletones = {};
      var NEED_SAFARI_FIX = false;

      try {
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
          NEED_SAFARI_FIX = navigator.userAgent.indexOf('Safari') >= 0;
        }
      } catch (e) {}

      var concurrency = 1;

      if (typeof navigator !== 'undefined') {
        concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);
      }

      var DEFAULT_PICA_OPTS = {
        tile: 1024,
        concurrency: concurrency,
        features: ['js', 'wasm', 'ww'],
        idle: 2000
      };
      var DEFAULT_RESIZE_OPTS = {
        quality: 3,
        alpha: false,
        unsharpAmount: 0,
        unsharpRadius: 0.0,
        unsharpThreshold: 0
      };
      var CAN_NEW_IMAGE_DATA = void 0;
      var CAN_CREATE_IMAGE_BITMAP = void 0;

      function workerFabric() {
        return {
          value: webworkify(worker),
          destroy: function destroy() {
            this.value.terminate();

            if (typeof window !== 'undefined') {
              var url = window.URL || window.webkitURL || window.mozURL || window.msURL;

              if (url && url.revokeObjectURL && this.value.objectURL) {
                url.revokeObjectURL(this.value.objectURL);
              }
            }
          }
        };
      } ////////////////////////////////////////////////////////////////////////////////
      // API methods


      function Pica(options) {
        if (!(this instanceof Pica)) return new Pica(options);
        this.options = assign({}, DEFAULT_PICA_OPTS, options || {});
        var limiter_key = 'lk_' + this.options.concurrency; // Share limiters to avoid multiple parallel workers when user creates
        // multiple pica instances.

        this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency);
        if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit; // List of supported features, according to options & browser/node.js

        this.features = {
          js: false,
          // pure JS implementation, can be disabled for testing
          wasm: false,
          // webassembly implementation for heavy functions
          cib: false,
          // resize via createImageBitmap (only FF at this moment)
          ww: false // webworkers

        };
        this.__workersPool = null; // Store requested features for webworkers

        this.__requested_features = [];
        this.__mathlib = null;
      }

      Pica.prototype.init = function () {
        var _this = this;

        if (this.__initPromise) return this.__initPromise; // Test if we can create ImageData without canvas and memory copy

        if (CAN_NEW_IMAGE_DATA !== false && CAN_NEW_IMAGE_DATA !== true) {
          CAN_NEW_IMAGE_DATA = false;

          if (typeof ImageData !== 'undefined' && typeof Uint8ClampedArray !== 'undefined') {
            try {
              /* eslint-disable no-new */
              new ImageData(new Uint8ClampedArray(400), 10, 10);
              CAN_NEW_IMAGE_DATA = true;
            } catch (__) {}
          }
        } // ImageBitmap can be effective in 2 places:
        //
        // 1. Threaded jpeg unpack (basic)
        // 2. Built-in resize (blocked due problem in chrome, see issue #89)
        //
        // For basic use we also need ImageBitmap wo support .close() method,
        // see https://developer.mozilla.org/ru/docs/Web/API/ImageBitmap


        if (CAN_CREATE_IMAGE_BITMAP !== false && CAN_CREATE_IMAGE_BITMAP !== true) {
          CAN_CREATE_IMAGE_BITMAP = false;

          if (typeof ImageBitmap !== 'undefined') {
            if (ImageBitmap.prototype && ImageBitmap.prototype.close) {
              CAN_CREATE_IMAGE_BITMAP = true;
            } else {
              this.debug('ImageBitmap does not support .close(), disabled');
            }
          }
        }

        var features = this.options.features.slice();

        if (features.indexOf('all') >= 0) {
          features = ['cib', 'wasm', 'js', 'ww'];
        }

        this.__requested_features = features;
        this.__mathlib = new MathLib(features); // Check WebWorker support if requested

        if (features.indexOf('ww') >= 0) {
          if (typeof window !== 'undefined' && 'Worker' in window) {
            // IE <= 11 don't allow to create webworkers from string. We should check it.
            // https://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11
            try {
              var wkr = require('webworkify')(function () {});

              wkr.terminate();
              this.features.ww = true; // pool uniqueness depends on pool config + webworker config

              var wpool_key = 'wp_' + JSON.stringify(this.options);

              if (singletones[wpool_key]) {
                this.__workersPool = singletones[wpool_key];
              } else {
                this.__workersPool = new Pool(workerFabric, this.options.idle);
                singletones[wpool_key] = this.__workersPool;
              }
            } catch (__) {}
          }
        }

        var initMath = this.__mathlib.init().then(function (mathlib) {
          // Copy detected features
          assign(_this.features, mathlib.features);
        });

        var checkCibResize = void 0;

        if (!CAN_CREATE_IMAGE_BITMAP) {
          checkCibResize = Promise.resolve(false);
        } else {
          checkCibResize = utils.cib_support().then(function (status) {
            if (_this.features.cib && features.indexOf('cib') < 0) {
              _this.debug('createImageBitmap() resize supported, but disabled by config');

              return;
            }

            if (features.indexOf('cib') >= 0) _this.features.cib = status;
          });
        } // Init math lib. That's async because can load some


        this.__initPromise = Promise.all([initMath, checkCibResize]).then(function () {
          return _this;
        });
        return this.__initPromise;
      };

      Pica.prototype.resize = function (from, to, options) {
        var _this2 = this;

        this.debug('Start resize...');
        var opts = assign({}, DEFAULT_RESIZE_OPTS);

        if (!isNaN(options)) {
          opts = assign(opts, {
            quality: options
          });
        } else if (options) {
          opts = assign(opts, options);
        }

        opts.toWidth = to.width;
        opts.toHeight = to.height;
        opts.width = from.naturalWidth || from.width;
        opts.height = from.naturalHeight || from.height; // Prevent stepper from infinite loop

        if (to.width === 0 || to.height === 0) {
          return Promise.reject(new Error('Invalid output size: ' + to.width + 'x' + to.height));
        }

        if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;
        var canceled = false;
        var cancelToken = null;

        if (opts.cancelToken) {
          // Wrap cancelToken to avoid successive resolve & set flag
          cancelToken = opts.cancelToken.then(function (data) {
            canceled = true;
            throw data;
          }, function (err) {
            canceled = true;
            throw err;
          });
        }

        var DEST_TILE_BORDER = 3; // Max possible filter window size

        var destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));
        return this.init().then(function () {
          if (canceled) return cancelToken; // if createImageBitmap supports resize, just do it and return

          if (_this2.features.cib) {
            var toCtx = to.getContext('2d', {
              alpha: Boolean(opts.alpha)
            });

            _this2.debug('Resize via createImageBitmap()');

            return createImageBitmap(from, {
              resizeWidth: opts.toWidth,
              resizeHeight: opts.toHeight,
              resizeQuality: utils.cib_quality_name(opts.quality)
            }).then(function (imageBitmap) {
              if (canceled) return cancelToken; // if no unsharp - draw directly to output canvas

              if (!opts.unsharpAmount) {
                toCtx.drawImage(imageBitmap, 0, 0);
                imageBitmap.close();
                toCtx = null;

                _this2.debug('Finished!');

                return to;
              }

              _this2.debug('Unsharp result');

              var tmpCanvas = document.createElement('canvas');
              tmpCanvas.width = opts.toWidth;
              tmpCanvas.height = opts.toHeight;
              var tmpCtx = tmpCanvas.getContext('2d', {
                alpha: Boolean(opts.alpha)
              });
              tmpCtx.drawImage(imageBitmap, 0, 0);
              imageBitmap.close();
              var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);

              _this2.__mathlib.unsharp(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);

              toCtx.putImageData(iData, 0, 0);
              iData = tmpCtx = tmpCanvas = toCtx = null;

              _this2.debug('Finished!');

              return to;
            });
          } //
          // No easy way, let's resize manually via arrays
          //
          // Share cache between calls:
          //
          // - wasm instance
          // - wasm memory object
          //


          var cache = {}; // Call resizer in webworker or locally, depending on config

          var invokeResize = function invokeResize(opts) {
            return Promise.resolve().then(function () {
              if (!_this2.features.ww) return _this2.__mathlib.resizeAndUnsharp(opts, cache);
              return new Promise(function (resolve, reject) {
                var w = _this2.__workersPool.acquire();

                if (cancelToken) cancelToken.catch(function (err) {
                  return reject(err);
                });

                w.value.onmessage = function (ev) {
                  w.release();
                  if (ev.data.err) reject(ev.data.err);else resolve(ev.data.result);
                };

                w.value.postMessage({
                  opts: opts,
                  features: _this2.__requested_features,
                  preload: {
                    wasm_nodule: _this2.__mathlib.__
                  }
                }, [opts.src.buffer]);
              });
            });
          };

          var tileAndResize = function tileAndResize(from, to, opts) {
            var srcCtx = void 0;
            var srcImageBitmap = void 0;
            var toCtx = void 0;

            var processTile = function processTile(tile) {
              return _this2.__limit(function () {
                if (canceled) return cancelToken;
                var srcImageData = void 0; // Extract tile RGBA buffer, depending on input type

                if (utils.isCanvas(from)) {
                  _this2.debug('Get tile pixel data'); // If input is Canvas - extract region data directly


                  srcImageData = srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height);
                } else {
                  // If input is Image or decoded to ImageBitmap,
                  // draw region to temporary canvas and extract data from it
                  //
                  // Note! Attempt to reuse this canvas causes significant slowdown in chrome
                  //
                  _this2.debug('Draw tile imageBitmap/image to temporary canvas');

                  var tmpCanvas = document.createElement('canvas');
                  tmpCanvas.width = tile.width;
                  tmpCanvas.height = tile.height;
                  var tmpCtx = tmpCanvas.getContext('2d', {
                    alpha: Boolean(opts.alpha)
                  });
                  tmpCtx.globalCompositeOperation = 'copy';
                  tmpCtx.drawImage(srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);

                  _this2.debug('Get tile pixel data');

                  srcImageData = tmpCtx.getImageData(0, 0, tile.width, tile.height);
                  tmpCtx = tmpCanvas = null;
                }

                var o = {
                  src: srcImageData.data,
                  width: tile.width,
                  height: tile.height,
                  toWidth: tile.toWidth,
                  toHeight: tile.toHeight,
                  scaleX: tile.scaleX,
                  scaleY: tile.scaleY,
                  offsetX: tile.offsetX,
                  offsetY: tile.offsetY,
                  quality: opts.quality,
                  alpha: opts.alpha,
                  unsharpAmount: opts.unsharpAmount,
                  unsharpRadius: opts.unsharpRadius,
                  unsharpThreshold: opts.unsharpThreshold
                };

                _this2.debug('Invoke resize math');

                return Promise.resolve().then(function () {
                  return invokeResize(o);
                }).then(function (result) {
                  if (canceled) return cancelToken;
                  srcImageData = null;
                  var toImageData = void 0;

                  _this2.debug('Convert raw rgba tile result to ImageData');

                  if (CAN_NEW_IMAGE_DATA) {
                    // this branch is for modern browsers
                    // If `new ImageData()` & Uint8ClampedArray suported
                    toImageData = new ImageData(new Uint8ClampedArray(result), tile.toWidth, tile.toHeight);
                  } else {
                    // fallback for `node-canvas` and old browsers
                    // (IE11 has ImageData but does not support `new ImageData()`)
                    toImageData = toCtx.createImageData(tile.toWidth, tile.toHeight);

                    if (toImageData.data.set) {
                      toImageData.data.set(result);
                    } else {
                      // IE9 don't have `.set()`
                      for (var i = toImageData.data.length - 1; i >= 0; i--) {
                        toImageData.data[i] = result[i];
                      }
                    }
                  }

                  _this2.debug('Draw tile');

                  if (NEED_SAFARI_FIX) {
                    // Safari draws thin white stripes between tiles without this fix
                    toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);
                  } else {
                    toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);
                  }

                  return null;
                });
              });
            }; // Need to normalize data source first. It can be canvas or image.
            // If image - try to decode in background if possible


            return Promise.resolve().then(function () {
              toCtx = to.getContext('2d', {
                alpha: Boolean(opts.alpha)
              });

              if (utils.isCanvas(from)) {
                srcCtx = from.getContext('2d', {
                  alpha: Boolean(opts.alpha)
                });
                return null;
              }

              if (utils.isImage(from)) {
                // try do decode image in background for faster next operations
                if (!CAN_CREATE_IMAGE_BITMAP) return null;

                _this2.debug('Decode image via createImageBitmap');

                return createImageBitmap(from).then(function (imageBitmap) {
                  srcImageBitmap = imageBitmap;
                });
              }

              throw new Error('".from" should be image or canvas');
            }).then(function () {
              if (canceled) return cancelToken;

              _this2.debug('Calculate tiles'); //
              // Here we are with "normalized" source,
              // follow to tiling
              //


              var regions = createRegions({
                width: opts.width,
                height: opts.height,
                srcTileSize: _this2.options.tile,
                toWidth: opts.toWidth,
                toHeight: opts.toHeight,
                destTileBorder: destTileBorder
              });
              var jobs = regions.map(function (tile) {
                return processTile(tile);
              });

              function cleanup() {
                if (srcImageBitmap) {
                  srcImageBitmap.close();
                  srcImageBitmap = null;
                }
              }

              _this2.debug('Process tiles');

              return Promise.all(jobs).then(function () {
                _this2.debug('Finished!');

                cleanup();
                return to;
              }, function (err) {
                cleanup();
                throw err;
              });
            });
          };

          var processStages = function processStages(stages, from, to, opts) {
            if (canceled) return cancelToken;

            var _stages$shift = stages.shift(),
                _stages$shift2 = _slicedToArray(_stages$shift, 2),
                toWidth = _stages$shift2[0],
                toHeight = _stages$shift2[1];

            var isLastStage = stages.length === 0;
            opts = assign({}, opts, {
              toWidth: toWidth,
              toHeight: toHeight,
              // only use user-defined quality for the last stage,
              // use simpler (Hamming) filter for the first stages where
              // scale factor is large enough (more than 2-3)
              quality: isLastStage ? opts.quality : Math.min(1, opts.quality)
            });
            var tmpCanvas = void 0;

            if (!isLastStage) {
              // create temporary canvas
              tmpCanvas = document.createElement('canvas');
              tmpCanvas.width = toWidth;
              tmpCanvas.height = toHeight;
            }

            return tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function () {
              if (isLastStage) return to;
              opts.width = toWidth;
              opts.height = toHeight;
              return processStages(stages, tmpCanvas, to, opts);
            });
          };

          var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this2.options.tile, destTileBorder);
          return processStages(stages, from, to, opts);
        });
      }; // RGBA buffer resize
      //


      Pica.prototype.resizeBuffer = function (options) {
        var _this3 = this;

        var opts = assign({}, DEFAULT_RESIZE_OPTS, options);
        return this.init().then(function () {
          return _this3.__mathlib.resizeAndUnsharp(opts);
        });
      };

      Pica.prototype.toBlob = function (canvas, mimeType, quality) {
        mimeType = mimeType || 'image/png';
        return new Promise(function (resolve) {
          if (canvas.toBlob) {
            canvas.toBlob(function (blob) {
              return resolve(blob);
            }, mimeType, quality);
            return;
          } // Fallback for old browsers


          var asString = atob(canvas.toDataURL(mimeType, quality).split(',')[1]);
          var len = asString.length;
          var asBuffer = new Uint8Array(len);

          for (var i = 0; i < len; i++) {
            asBuffer[i] = asString.charCodeAt(i);
          }

          resolve(new Blob([asBuffer], {
            type: mimeType
          }));
        });
      };

      Pica.prototype.debug = function () {};

      module.exports = Pica;
    }, {
      "./lib/mathlib": 1,
      "./lib/pool": 9,
      "./lib/stepper": 10,
      "./lib/tiler": 11,
      "./lib/utils": 12,
      "./lib/worker": 13,
      "object-assign": 24,
      "webworkify": 25
    }]
  }, {}, [])("/");
});

/***/ }),

/***/ "./node_modules/pixelworks/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pixelworks/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Processor = __webpack_require__(/*! ./processor */ "./node_modules/pixelworks/lib/processor.js");

exports.Processor = Processor;

/***/ }),

/***/ "./node_modules/pixelworks/lib/processor.js":
/*!**************************************************!*\
  !*** ./node_modules/pixelworks/lib/processor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var newImageData = __webpack_require__(/*! ./util */ "./node_modules/pixelworks/lib/util.js").newImageData;
/**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(Object):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */


function createMinion(operation) {
  var workerHasImageData = true;

  try {
    new ImageData(10, 10);
  } catch (_) {
    workerHasImageData = false;
  }

  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    } else {
      return {
        data: data,
        width: width,
        height: height
      };
    }
  }

  return function (data) {
    // bracket notation for minification support
    var buffers = data['buffers'];
    var meta = data['meta'];
    var imageOps = data['imageOps'];
    var width = data['width'];
    var height = data['height'];
    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;
    var output, b;

    if (imageOps) {
      var images = new Array(numBuffers);

      for (b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
      }

      output = operation(images, meta).data;
    } else {
      output = new Uint8ClampedArray(numBytes);
      var arrays = new Array(numBuffers);
      var pixels = new Array(numBuffers);

      for (b = 0; b < numBuffers; ++b) {
        arrays[b] = new Uint8ClampedArray(buffers[b]);
        pixels[b] = [0, 0, 0, 0];
      }

      for (var i = 0; i < numBytes; i += 4) {
        for (var j = 0; j < numBuffers; ++j) {
          var array = arrays[j];
          pixels[j][0] = array[i];
          pixels[j][1] = array[i + 1];
          pixels[j][2] = array[i + 2];
          pixels[j][3] = array[i + 3];
        }

        var pixel = operation(pixels, meta);
        output[i] = pixel[0];
        output[i + 1] = pixel[1];
        output[i + 2] = pixel[2];
        output[i + 3] = pixel[3];
      }
    }

    return output.buffer;
  };
}
/**
 * Create a worker for running operations.
 * @param {Object} config Configuration.
 * @param {function(MessageEvent)} onMessage Called with a message event.
 * @return {Worker} The worker.
 */


function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function (name) {
    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';
  });
  var lines = lib.concat(['var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener("message", function(event) {', '  var buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);
  var blob = new Blob(lines, {
    type: 'text/javascript'
  });
  var source = URL.createObjectURL(blob);
  var worker = new Worker(source);
  worker.addEventListener('message', onMessage);
  return worker;
}
/**
 * Create a faux worker for running operations.
 * @param {Object} config Configuration.
 * @param {function(MessageEvent)} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */


function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  return {
    postMessage: function (data) {
      setTimeout(function () {
        onMessage({
          'data': {
            'buffer': minion(data),
            'meta': data['meta']
          }
        });
      }, 0);
    }
  };
}
/**
 * A processor runs pixel or image operations in workers.
 * @param {Object} config Configuration.
 */


function Processor(config) {
  this._imageOps = !!config.imageOps;
  var threads;

  if (config.threads === 0) {
    threads = 0;
  } else if (this._imageOps) {
    threads = 1;
  } else {
    threads = config.threads || 1;
  }

  var workers = [];

  if (threads) {
    for (var i = 0; i < threads; ++i) {
      workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));
    }
  } else {
    workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));
  }

  this._workers = workers;
  this._queue = [];
  this._maxQueueLength = config.queue || Infinity;
  this._running = 0;
  this._dataLookup = {};
  this._job = null;
}
/**
 * Run operation on input data.
 * @param {Array.<Array|ImageData>} inputs Array of pixels or image data
 *     (depending on the operation type).
 * @param {Object} meta A user data object.  This is passed to all operations
 *     and must be serializable.
 * @param {function(Error, ImageData, Object)} callback Called when work
 *     completes.  The first argument is any error.  The second is the ImageData
 *     generated by operations.  The third is the user data object.
 */


Processor.prototype.process = function (inputs, meta, callback) {
  this._enqueue({
    inputs: inputs,
    meta: meta,
    callback: callback
  });

  this._dispatch();
};
/**
 * Stop responding to any completed work and destroy the processor.
 */


Processor.prototype.destroy = function () {
  for (var key in this) {
    this[key] = null;
  }

  this._destroyed = true;
};
/**
 * Add a job to the queue.
 * @param {Object} job The job.
 */


Processor.prototype._enqueue = function (job) {
  this._queue.push(job);

  while (this._queue.length > this._maxQueueLength) {
    this._queue.shift().callback(null, null);
  }
};
/**
 * Dispatch a job.
 */


Processor.prototype._dispatch = function () {
  if (this._running === 0 && this._queue.length > 0) {
    var job = this._job = this._queue.shift();

    var width = job.inputs[0].width;
    var height = job.inputs[0].height;
    var buffers = job.inputs.map(function (input) {
      return input.data.buffer;
    });
    var threads = this._workers.length;
    this._running = threads;

    if (threads === 1) {
      this._workers[0].postMessage({
        'buffers': buffers,
        'meta': job.meta,
        'imageOps': this._imageOps,
        'width': width,
        'height': height
      }, buffers);
    } else {
      var length = job.inputs[0].data.length;
      var segmentLength = 4 * Math.ceil(length / 4 / threads);

      for (var i = 0; i < threads; ++i) {
        var offset = i * segmentLength;
        var slices = [];

        for (var j = 0, jj = buffers.length; j < jj; ++j) {
          slices.push(buffers[i].slice(offset, offset + segmentLength));
        }

        this._workers[i].postMessage({
          'buffers': slices,
          'meta': job.meta,
          'imageOps': this._imageOps,
          'width': width,
          'height': height
        }, slices);
      }
    }
  }
};
/**
 * Handle messages from the worker.
 * @param {number} index The worker index.
 * @param {MessageEvent} event The message event.
 */


Processor.prototype._onWorkerMessage = function (index, event) {
  if (this._destroyed) {
    return;
  }

  this._dataLookup[index] = event.data;
  --this._running;

  if (this._running === 0) {
    this._resolveJob();
  }
};
/**
 * Resolve a job.  If there are no more worker threads, the processor callback
 * will be called.
 */


Processor.prototype._resolveJob = function () {
  var job = this._job;
  var threads = this._workers.length;
  var data, meta;

  if (threads === 1) {
    data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);
    meta = this._dataLookup[0]['meta'];
  } else {
    var length = job.inputs[0].data.length;
    data = new Uint8ClampedArray(length);
    meta = new Array(length);
    var segmentLength = 4 * Math.ceil(length / 4 / threads);

    for (var i = 0; i < threads; ++i) {
      var buffer = this._dataLookup[i]['buffer'];
      var offset = i * segmentLength;
      data.set(new Uint8ClampedArray(buffer), offset);
      meta[i] = this._dataLookup[i]['meta'];
    }
  }

  this._job = null;
  this._dataLookup = {};
  job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);

  this._dispatch();
};

module.exports = Processor;

/***/ }),

/***/ "./node_modules/pixelworks/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/pixelworks/lib/util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasImageData = true;

try {
  new ImageData(10, 10);
} catch (_) {
  hasImageData = false;
}

var context = document.createElement('canvas').getContext('2d');

function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  } else {
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    return imageData;
  }
}

exports.newImageData = newImageData;

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/proj4/lib/Point.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/Point.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mgrs */ "./node_modules/mgrs/mgrs.js");


function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }

  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if (typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }

  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function (mgrsStr) {
  return new Point(Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["toPoint"])(mgrsStr));
};

Point.prototype.toMGRS = function (accuracy) {
  return Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["forward"])([this.x, this.y], accuracy);
};

/* harmony default export */ __webpack_exports__["default"] = (Point);

/***/ }),

/***/ "./node_modules/proj4/lib/Proj.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/Proj.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parseCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseCode */ "./node_modules/proj4/lib/parseCode.js");
/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extend */ "./node_modules/proj4/lib/extend.js");
/* harmony import */ var _projections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projections */ "./node_modules/proj4/lib/projections.js");
/* harmony import */ var _deriveConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deriveConstants */ "./node_modules/proj4/lib/deriveConstants.js");
/* harmony import */ var _constants_Datum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants/Datum */ "./node_modules/proj4/lib/constants/Datum.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./datum */ "./node_modules/proj4/lib/datum.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./match */ "./node_modules/proj4/lib/match.js");








function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }

  callback = callback || function (error) {
    if (error) {
      throw error;
    }
  };

  var json = Object(_parseCode__WEBPACK_IMPORTED_MODULE_0__["default"])(srsCode);

  if (typeof json !== 'object') {
    callback(srsCode);
    return;
  }

  var ourProj = Projection.projections.get(json.projName);

  if (!ourProj) {
    callback(srsCode);
    return;
  }

  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Object(_match__WEBPACK_IMPORTED_MODULE_6__["default"])(_constants_Datum__WEBPACK_IMPORTED_MODULE_4__["default"], json.datumCode);

    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }

  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  var sphere_ = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["sphere"])(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["eccentricity"])(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var datumObj = json.datum || Object(_datum__WEBPACK_IMPORTED_MODULE_5__["default"])(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);
  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, json); // transfer everything over from the projection because we don't know what we'll need

  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, ourProj); // transfer all the methods from the projection
  // copy the 4 things over we calulated in deriveConstants.sphere

  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere; // copy the 3 things we calculated in deriveConstants.eccentricity

  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2; // add in the datum object

  this.datum = datumObj; // init the projection

  this.init(); // legecy callback from back in the day when it went to spatialreference.org

  callback(null, this);
}

Projection.projections = _projections__WEBPACK_IMPORTED_MODULE_2__["default"];
Projection.projections.start();
/* harmony default export */ __webpack_exports__["default"] = (Projection);

/***/ }),

/***/ "./node_modules/proj4/lib/adjust_axis.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/adjust_axis.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (crs, denorm, point) {
  var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
  var v, t, i;
  var out = {};

  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }

    if (i === 0) {
      v = xin;
      t = 'x';
    } else if (i === 1) {
      v = yin;
      t = 'y';
    } else {
      v = zin;
      t = 'z';
    }

    switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;

      case 'w':
        out[t] = -v;
        break;

      case 'n':
        out[t] = v;
        break;

      case 's':
        out[t] = -v;
        break;

      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }

        break;

      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }

        break;

      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
    }
  }

  return out;
});

/***/ }),

/***/ "./node_modules/proj4/lib/checkSanity.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/checkSanity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (point) {
  checkCoord(point.x);
  checkCoord(point.y);
});

function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }

    throw new TypeError('coordinates must be finite numbers');
  }

  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_lat.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_lat.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "./node_modules/proj4/lib/common/sign.js");


/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return Math.abs(x) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] ? x : x - Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * Math.PI;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_lon.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_lon.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "./node_modules/proj4/lib/common/sign.js");


/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return Math.abs(x) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] ? x : x - Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_zone.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_zone.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");

/* harmony default export */ __webpack_exports__["default"] = (function (zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((Object(_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }

  return zone;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/asinhy.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/asinhy.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hypot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hypot */ "./node_modules/proj4/lib/common/hypot.js");
/* harmony import */ var _log1py__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log1py */ "./node_modules/proj4/lib/common/log1py.js");


/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  var y = Math.abs(x);
  y = Object(_log1py__WEBPACK_IMPORTED_MODULE_1__["default"])(y * (1 + y / (Object(_hypot__WEBPACK_IMPORTED_MODULE_0__["default"])(1, y) + 1)));
  return x < 0 ? -y : y;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/asinz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/asinz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }

  return Math.asin(x);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/clens.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/clens.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/clens_cmplx.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/clens_cmplx.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sinh */ "./node_modules/proj4/lib/common/sinh.js");
/* harmony import */ var _cosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cosh */ "./node_modules/proj4/lib/common/cosh.js");


/* harmony default export */ __webpack_exports__["default"] = (function (pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = Object(_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(arg_i);
  var cosh_arg_i = Object(_cosh__WEBPACK_IMPORTED_MODULE_1__["default"])(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/cosh.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/cosh.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/e0fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e0fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/e1fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e1fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/e2fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e2fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/e3fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e3fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x * x * x * (35 / 3072);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/gN.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/common/gN.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/gatg.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/gatg.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return B + h * Math.sin(2 * B);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/hypot.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/hypot.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/imlfn.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/imlfn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;

  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");


  return NaN;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/iqsfnz.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/iqsfnz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

/* harmony default export */ __webpack_exports__["default"] = (function (eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));

  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return -1 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      return _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  } //var phi = 0.5* q/(1-eccent*eccent);


  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;

  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");


  return NaN;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/log1py.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/log1py.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/mlfn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/mlfn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/msfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/msfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/phi2z.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/phi2z.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

/* harmony default export */ __webpack_exports__["default"] = (function (eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts);

  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("phi2z has NoConvergence");


  return -9999;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_enfn.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_enfn.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;
/* harmony default export */ __webpack_exports__["default"] = (function (es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_inv_mlfn.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_inv_mlfn.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pj_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pj_mlfn */ "./node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");


var MAX_ITER = 20;
/* harmony default export */ __webpack_exports__["default"] = (function (arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;

  for (var i = MAX_ITER; i; --i) {
    /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s; //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;

    t = (Object(_pj_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;

    if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      return phi;
    }
  } //..reportError("cass:pj_inv_mlfn: Convergence error");


  return phi;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_mlfn.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_mlfn.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/qsfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/qsfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (eccent, sinphi) {
  var con;

  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/sign.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/sign.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x < 0 ? -1 : 1;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/sinh.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/sinh.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/srat.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/srat.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/toPoint.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/toPoint.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array) {
  var out = {
    x: array[0],
    y: array[1]
  };

  if (array.length > 2) {
    out.z = array[2];
  }

  if (array.length > 3) {
    out.m = array[3];
  }

  return out;
});

/***/ }),

/***/ "./node_modules/proj4/lib/common/tsfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/tsfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

/* harmony default export */ __webpack_exports__["default"] = (function (eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi)) / con;
});

/***/ }),

/***/ "./node_modules/proj4/lib/constants/Datum.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/constants/Datum.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

/***/ }),

/***/ "./node_modules/proj4/lib/constants/Ellipsoid.js":
/*!*******************************************************!*\
  !*** ./node_modules/proj4/lib/constants/Ellipsoid.js ***!
  \*******************************************************/
/*! exports provided: default, WGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84", function() { return WGS84; });
var exports = {};

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

/***/ }),

/***/ "./node_modules/proj4/lib/constants/PrimeMeridian.js":
/*!***********************************************************!*\
  !*** ./node_modules/proj4/lib/constants/PrimeMeridian.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};

exports.greenwich = 0.0; //"0dE",

exports.lisbon = -9.131906111111; //"9d07'54.862\"W",

exports.paris = 2.337229166667; //"2d20'14.025\"E",

exports.bogota = -74.080916666667; //"74d04'51.3\"W",

exports.madrid = -3.687938888889; //"3d41'16.58\"W",

exports.rome = 12.452333333333; //"12d27'8.4\"E",

exports.bern = 7.439583333333; //"7d26'22.5\"E",

exports.jakarta = 106.807719444444; //"106d48'27.79\"E",

exports.ferro = -17.666666666667; //"17d40'W",

exports.brussels = 4.367975; //"4d22'4.71\"E",

exports.stockholm = 18.058277777778; //"18d3'29.8\"E",

exports.athens = 23.7163375; //"23d42'58.815\"E",

exports.oslo = 10.722916666667; //"10d43'22.5\"E"

/***/ }),

/***/ "./node_modules/proj4/lib/constants/units.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/constants/units.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  ft: {
    to_meter: 0.3048
  },
  'us-ft': {
    to_meter: 1200 / 3937
  }
});

/***/ }),

/***/ "./node_modules/proj4/lib/constants/values.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/constants/values.js ***!
  \****************************************************/
/*! exports provided: PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_3PARAM", function() { return PJD_3PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_7PARAM", function() { return PJD_7PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_WGS84", function() { return PJD_WGS84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_NODATUM", function() { return PJD_NODATUM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEC_TO_RAD", function() { return SEC_TO_RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_PI", function() { return HALF_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIXTH", function() { return SIXTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA4", function() { return RA4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA6", function() { return RA6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSLN", function() { return EPSLN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D2R", function() { return D2R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R2D", function() { return R2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FORTPI", function() { return FORTPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TWO_PI", function() { return TWO_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPI", function() { return SPI; });
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4; // WGS84 or equivalent

var PJD_NODATUM = 5; // WGS84 or equivalent

var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI / 2; // ellipoid pj_set_ell.c

var SIXTH = 0.1666666666666666667;
/* 1/6 */

var RA4 = 0.04722222222222222222;
/* 17/360 */

var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10; // you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2; // SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.

var SPI = 3.14159265359;

/***/ }),

/***/ "./node_modules/proj4/lib/core.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/core.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj */ "./node_modules/proj4/lib/Proj.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "./node_modules/proj4/lib/transform.js");


var wgs84 = Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])('WGS84');

function transformer(from, to, coords) {
  var transformedArray, out, keys;

  if (Array.isArray(coords)) {
    transformedArray = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords);

    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords);
    keys = Object.keys(coords);

    if (keys.length === 2) {
      return out;
    }

    keys.forEach(function (key) {
      if (key === 'x' || key === 'y') {
        return;
      }

      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof _Proj__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    return item;
  }

  if (item.oProj) {
    return item.oProj;
  }

  return Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])(item);
}

function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;

  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }

  toProj = checkProj(toProj);

  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function (coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function (coords) {
        return transformer(toProj, fromProj, coords);
      }
    };

    if (single) {
      obj.oProj = toProj;
    }

    return obj;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (proj4);

/***/ }),

/***/ "./node_modules/proj4/lib/datum.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/datum.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");


function datum(datumCode, datum_params, a, b, es, ep2) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"];
  } else {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_WGS84"];
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);

    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"];
    }

    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"];
        out.datum_params[3] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[4] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[5] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[6] = out.datum_params[6] / 1000000.0 + 1.0;
      }
    }
  }

  out.a = a; //datum object also uses these values

  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ __webpack_exports__["default"] = (datum);

/***/ }),

/***/ "./node_modules/proj4/lib/datumUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/proj4/lib/datumUtils.js ***!
  \**********************************************/
/*! exports provided: compareDatums, geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareDatums", function() { return compareDatums; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geodeticToGeocentric", function() { return geodeticToGeocentric; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToGeodetic", function() { return geocentricToGeodetic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToWgs84", function() { return geocentricToWgs84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricFromWgs84", function() { return geocentricFromWgs84; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");



function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */

function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn;
  /*  Earth radius at location  */

  var Sin_Lat;
  /*  Math.sin(Latitude)  */

  var Sin2_Lat;
  /*  Square of Math.sin(Latitude)  */

  var Cos_Lat;
  /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */

  if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude > -1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude < 1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return {
      x: -Infinity,
      y: -Infinity,
      z: p.z
    };
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    /* Latitude out of range */
    return {
      x: Infinity,
      y: Infinity,
      z: p.z
    };
  }

  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }

  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */

  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  /* distance between semi-minor axis and location */

  var RR;
  /* distance between center and location */

  var CT;
  /* sin of geocentric latitude */

  var ST;
  /* cos of geocentric latitude */

  var RX;
  var RK;
  var RN;
  /* Earth radius at location */

  var CPHI0;
  /* cos of start or old geodetic latitude in iterations */

  var SPHI0;
  /* sin of start or old geodetic latitude in iterations */

  var CPHI;
  /* cos of searched geodetic latitude */

  var SPHI;
  /* sin of searched geodetic latitude */

  var SDPHI;
  /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */

  var iter;
  /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied

  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);
  /*      special cases for latitude and longitude */

  if (P / a < genau) {
    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;
    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */

    if (RR / a < genau) {
      Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }
  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */


  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */

  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);
    /*  ellipsoidal (geodetic) height */

    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  /*      ellipsoidal (geodetic) latitude */


  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/

function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6]; // if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)

function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF; //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()

}

/***/ }),

/***/ "./node_modules/proj4/lib/datum_transform.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/datum_transform.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datumUtils */ "./node_modules/proj4/lib/datumUtils.js");



function checkParams(type) {
  return type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"];
}

/* harmony default export */ __webpack_exports__["default"] = (function (source, dest, point) {
  // Short cut if the datums are identical.
  if (Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["compareDatums"])(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest


  if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"] || dest.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"]) {
    return point;
  } // If this datum requires grid shifts, then apply it to geodetic coordinates.
  // Do we need to go through geocentric coordinates?


  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  } // Convert to geocentric coordinates.


  point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geodeticToGeocentric"])(point, source.es, source.a); // Convert between datums

  if (checkParams(source.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToWgs84"])(point, source.datum_type, source.datum_params);
  }

  if (checkParams(dest.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricFromWgs84"])(point, dest.datum_type, dest.datum_params);
  }

  return Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToGeodetic"])(point, dest.es, dest.a, dest.b);
});

/***/ }),

/***/ "./node_modules/proj4/lib/defs.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/defs.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ "./node_modules/proj4/lib/global.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projString */ "./node_modules/proj4/lib/projString.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wkt-parser */ "./node_modules/wkt-parser/index.js");




function defs(name) {
  /*global console*/
  var that = this;

  if (arguments.length === 2) {
    var def = arguments[1];

    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = Object(_projString__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[1]);
      } else {
        defs[name] = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_2__["default"])(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function (v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        } else {
          defs(v);
        }
      });
    } else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    } else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    } else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    } else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    } else {
      console.log(name);
    }

    return;
  }
}

Object(_global__WEBPACK_IMPORTED_MODULE_0__["default"])(defs);
/* harmony default export */ __webpack_exports__["default"] = (defs);

/***/ }),

/***/ "./node_modules/proj4/lib/deriveConstants.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/deriveConstants.js ***!
  \***************************************************/
/*! exports provided: eccentricity, sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eccentricity", function() { return eccentricity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sphere", function() { return sphere; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/Ellipsoid */ "./node_modules/proj4/lib/constants/Ellipsoid.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./match */ "./node_modules/proj4/lib/match.js");



function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric

  var b2 = b * b; // used in geocentric

  var es = (a2 - b2) / a2; // e ^ 2

  var e = 0;

  if (R_A) {
    a *= 1 - es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["SIXTH"] + es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["RA4"] + es * _constants_values__WEBPACK_IMPORTED_MODULE_0__["RA6"]));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }

  var ep2 = (a2 - b2) / b2; // used in geocentric

  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) {
    // do we have an ellipsoid?
    var ellipse = Object(_match__WEBPACK_IMPORTED_MODULE_2__["default"])(_constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["default"], ellps);

    if (!ellipse) {
      ellipse = _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["WGS84"];
    }

    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }

  if (rf === 0 || Math.abs(a - b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    sphere = true;
    b = a;
  }

  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}

/***/ }),

/***/ "./node_modules/proj4/lib/extend.js":
/*!******************************************!*\
  !*** ./node_modules/proj4/lib/extend.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (destination, source) {
  destination = destination || {};
  var value, property;

  if (!source) {
    return destination;
  }

  for (property in source) {
    value = source[property];

    if (value !== undefined) {
      destination[property] = value;
    }
  }

  return destination;
});

/***/ }),

/***/ "./node_modules/proj4/lib/global.js":
/*!******************************************!*\
  !*** ./node_modules/proj4/lib/global.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857

  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});

/***/ }),

/***/ "./node_modules/proj4/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/proj4/lib/core.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proj */ "./node_modules/proj4/lib/Proj.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point */ "./node_modules/proj4/lib/Point.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/toPoint */ "./node_modules/proj4/lib/common/toPoint.js");
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defs */ "./node_modules/proj4/lib/defs.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform */ "./node_modules/proj4/lib/transform.js");
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mgrs */ "./node_modules/mgrs/mgrs.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./version */ "./node_modules/proj4/lib/version.js");
/* harmony import */ var _projs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../projs */ "./node_modules/proj4/projs.js");









_core__WEBPACK_IMPORTED_MODULE_0__["default"].defaultDatum = 'WGS84'; //default datum

_core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj = _Proj__WEBPACK_IMPORTED_MODULE_1__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].WGS84 = new _core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj('WGS84');
_core__WEBPACK_IMPORTED_MODULE_0__["default"].Point = _Point__WEBPACK_IMPORTED_MODULE_2__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].toPoint = _common_toPoint__WEBPACK_IMPORTED_MODULE_3__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].defs = _defs__WEBPACK_IMPORTED_MODULE_4__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].transform = _transform__WEBPACK_IMPORTED_MODULE_5__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].mgrs = mgrs__WEBPACK_IMPORTED_MODULE_6__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].version = _version__WEBPACK_IMPORTED_MODULE_7__["default"];
Object(_projs__WEBPACK_IMPORTED_MODULE_8__["default"])(_core__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (_core__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/proj4/lib/match.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/match.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return match; });
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }

  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;

  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');

    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

/***/ }),

/***/ "./node_modules/proj4/lib/parseCode.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/parseCode.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defs */ "./node_modules/proj4/lib/defs.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wkt-parser */ "./node_modules/wkt-parser/index.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projString */ "./node_modules/proj4/lib/projString.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ "./node_modules/proj4/lib/match.js");





function testObj(code) {
  return typeof code === 'string';
}

function testDef(code) {
  return code in _defs__WEBPACK_IMPORTED_MODULE_0__["default"];
}

var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];

function testWKT(code) {
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}

var codes = ['3857', '900913', '3785', '102113'];

function checkMercator(item) {
  var auth = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(item, 'authority');

  if (!auth) {
    return;
  }

  var code = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}

function checkProjStr(item) {
  var ext = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(item, 'extension');

  if (!ext) {
    return;
  }

  return Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(ext, 'proj4');
}

function testProj(code) {
  return code[0] === '+';
}

function parse(code) {
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return _defs__WEBPACK_IMPORTED_MODULE_0__["default"][code];
    }

    if (testWKT(code)) {
      var out = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_1__["default"])(code); // test of spetial case, due to this being a very common and often malformed

      if (checkMercator(out)) {
        return _defs__WEBPACK_IMPORTED_MODULE_0__["default"]['EPSG:3857'];
      }

      var maybeProjStr = checkProjStr(out);

      if (maybeProjStr) {
        return Object(_projString__WEBPACK_IMPORTED_MODULE_2__["default"])(maybeProjStr);
      }

      return out;
    }

    if (testProj(code)) {
      return Object(_projString__WEBPACK_IMPORTED_MODULE_2__["default"])(code);
    }
  } else {
    return code;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parse);

/***/ }),

/***/ "./node_modules/proj4/lib/projString.js":
/*!**********************************************!*\
  !*** ./node_modules/proj4/lib/projString.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/PrimeMeridian */ "./node_modules/proj4/lib/constants/PrimeMeridian.js");
/* harmony import */ var _constants_units__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/units */ "./node_modules/proj4/lib/constants/units.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ "./node_modules/proj4/lib/match.js");




/* harmony default export */ __webpack_exports__["default"] = (function (defData) {
  var self = {};
  var paramObj = defData.split('+').map(function (v) {
    return v.trim();
  }).filter(function (a) {
    return a;
  }).reduce(function (p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function (v) {
      self.rf = parseFloat(v);
    },
    lat_0: function (v) {
      self.lat0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_1: function (v) {
      self.lat1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_2: function (v) {
      self.lat2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_ts: function (v) {
      self.lat_ts = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_0: function (v) {
      self.long0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_1: function (v) {
      self.long1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_2: function (v) {
      self.long2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    alpha: function (v) {
      self.alpha = parseFloat(v) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lonc: function (v) {
      self.longc = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    x_0: function (v) {
      self.x0 = parseFloat(v);
    },
    y_0: function (v) {
      self.y0 = parseFloat(v);
    },
    k_0: function (v) {
      self.k0 = parseFloat(v);
    },
    k: function (v) {
      self.k0 = parseFloat(v);
    },
    a: function (v) {
      self.a = parseFloat(v);
    },
    b: function (v) {
      self.b = parseFloat(v);
    },
    r_a: function () {
      self.R_A = true;
    },
    zone: function (v) {
      self.zone = parseInt(v, 10);
    },
    south: function () {
      self.utmSouth = true;
    },
    towgs84: function (v) {
      self.datum_params = v.split(",").map(function (a) {
        return parseFloat(a);
      });
    },
    to_meter: function (v) {
      self.to_meter = parseFloat(v);
    },
    units: function (v) {
      self.units = v;
      var unit = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_units__WEBPACK_IMPORTED_MODULE_2__["default"], v);

      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function (v) {
      self.from_greenwich = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    pm: function (v) {
      var pm = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__["default"], v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    nadgrids: function (v) {
      if (v === '@null') {
        self.datumCode = 'none';
      } else {
        self.nadgrids = v;
      }
    },
    axis: function (v) {
      var legalAxis = "ewnsud";

      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };

  for (paramName in paramObj) {
    paramVal = paramObj[paramName];

    if (paramName in params) {
      paramOutname = params[paramName];

      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      } else {
        self[paramOutname] = paramVal;
      }
    } else {
      self[paramName] = paramVal;
    }
  }

  if (typeof self.datumCode === 'string' && self.datumCode !== "WGS84") {
    self.datumCode = self.datumCode.toLowerCase();
  }

  return self;
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/projections.js ***!
  \***********************************************/
/*! exports provided: add, get, start, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });
/* harmony import */ var _projections_merc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projections/merc */ "./node_modules/proj4/lib/projections/merc.js");
/* harmony import */ var _projections_longlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projections/longlat */ "./node_modules/proj4/lib/projections/longlat.js");


var projs = [_projections_merc__WEBPACK_IMPORTED_MODULE_0__["default"], _projections_longlat__WEBPACK_IMPORTED_MODULE_1__["default"]];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;

  if (!proj.names) {
    console.log(i);
    return true;
  }

  projStore[len] = proj;
  proj.names.forEach(function (n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}


function get(name) {
  if (!name) {
    return false;
  }

  var n = name.toLowerCase();

  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
}
function start() {
  projs.forEach(add);
}
/* harmony default export */ __webpack_exports__["default"] = ({
  start: start,
  add: add,
  get: get
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/aea.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/aea.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, phi1z, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "phi1z", function() { return phi1z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");





function init() {
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return;
  }

  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs2 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }

  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;

  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  con = rh1 * this.ns0 / this.a;

  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/

function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_3__["default"])(0.5 * qs);

  if (eccent < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return phi;
  }

  var eccnts = eccent * eccent;

  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;

    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }

  return null;
}
var names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  phi1z: phi1z
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/aeqd.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/aeqd.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/gN */ "./node_modules/proj4/lib/common/gN.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/proj4/lib/common/imlfn.js");










function init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;

  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.cos(dlon);
      return p;
    } else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);

    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      Nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));

      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }

      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }
}
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;

  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);

    if (rh > 2 * _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] * this.a) {
      return;
    }

    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;

    if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      lat = this.lat0;
    } else {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_8__["default"])(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];

      if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        if (this.lat0 >= 0) {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);

    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
}
var names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/cass.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/cass.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/gN */ "./node_modules/proj4/lib/common/gN.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");










function init() {
  if (!this.sphere) {
    this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
    this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
    this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function forward(p) {
  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml1, this.e0, this.e1, this.e2, this.e3);

    if (Math.abs(Math.abs(phi1) - _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
      p.x = this.long0;
      p.y = _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"];

      if (y < 0) {
        p.y *= -1;
      }

      return p;
    }

    var nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam + this.long0);
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(phi);
  return p;
}
var names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/cea.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/cea.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/iqsfnz */ "./node_modules/proj4/lib/common/iqsfnz.js");




/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/

function init() {
  //no-op
  if (!this.sphere) {
    this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/

  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = Object(_common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, 2 * p.y * this.k0 / this.a);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["cea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/eqc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/eqc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/proj4/lib/common/adjust_lat.js");


function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
} // forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var dlat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
} // inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function inverse(p) {
  var x = p.x;
  var y = p.y;
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/eqdc.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/eqdc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");










function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    return;
  }

  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
  this.ml1 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
    this.ml2 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }

  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  /* Forward equations
      -----------------*/

  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }

  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
/* Inverse equations
  -----------------*/

function inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;

  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml, this.e0, this.e1, this.e2, this.e3);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/etmerc.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/etmerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/sinh */ "./node_modules/proj4/lib/common/sinh.js");
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/hypot */ "./node_modules/proj4/lib/common/hypot.js");
/* harmony import */ var _common_asinhy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinhy */ "./node_modules/proj4/lib/common/asinhy.js");
/* harmony import */ var _common_gatg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/gatg */ "./node_modules/proj4/lib/common/gatg.js");
/* harmony import */ var _common_clens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/clens */ "./node_modules/proj4/lib/common/clens.js");
/* harmony import */ var _common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/clens_cmplx */ "./node_modules/proj4/lib/common/clens_cmplx.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js







function init() {
  if (this.es === undefined || this.es <= 0) {
    throw new Error('incorrect elliptical usage');
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + Object(_common_clens__WEBPACK_IMPORTED_MODULE_4__["default"])(this.gtu, 2 * Z));
}
function forward(p) {
  var Ce = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(p.x - this.long0);
  var Cn = p.y;
  Cn = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Cn, cos_Cn * cos_Ce));
  Ce = Object(_common_asinhy__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.tan(Ce));
  var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(Object(_common_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(Ce + this.long0);
    lat = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/gauss.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/gauss.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_srat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/srat */ "./node_modules/proj4/lib/common/srat.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

var MAX_ITER = 20;

function init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / (Math.pow(Math.tan(0.5 * this.lat0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * sphi, this.ratexp));
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(lat), this.ratexp)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
  p.x = this.C * lon;
  return p;
}
function inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / this.K, 1 / this.C);

  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(p.y), -0.5 * this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];

    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }

    p.y = lat;
  }
  /* convergence failed */


  if (!i) {
    return null;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["gauss"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/gnom.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/gnom.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");



/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */

function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0); // Approximation for projecting points to the horizon (infinity)

  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}
/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh;
  /* Rho */

  var sinc, cosc;
  var c;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["gnom"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/krovak.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/krovak.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");

function init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);

  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }

  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */


  if (!this.k0) {
    this.k0 = 0.9999;
  }

  this.s45 = 0.785398163397448;
  /* 45 */

  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
/* ellipsoid */

/* calculate xy from lat/lon */

/* Constants, identical to inverse transform function */

function forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  /* Transformation */

  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  return p;
}
/* calculate lat/lon from xy */

function inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  /* Transformation */

  /* revert y, x*/

  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;

  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);

    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }

    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);

  if (iter >= 15) {
    return null;
  }

  return p;
}
var names = ["Krovak", "krovak"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/laea.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/laea.js ***!
  \****************************************************/
/*! exports provided: S_POLE, N_POLE, EQUIT, OBLIQ, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S_POLE", function() { return S_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N_POLE", function() { return N_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQUIT", function() { return EQUIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBLIQ", function() { return OBLIQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");



/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/

function init() {
  var t = Math.abs(this.lat0);

  if (Math.abs(t - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }

  if (this.es > 0) {
    var sinphi;
    this.qp = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);

    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;

      case this.S_POLE:
        this.dd = 1;
        break;

      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;

      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function forward(p) {
  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;

      if (y <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }

      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }

      if (Math.abs(phi + this.phi0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }

      y = _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }

    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;

      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;

      case this.N_POLE:
        b = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phi;
        q = this.qp - q;
        break;

      case this.S_POLE:
        b = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
        q = this.qp + q;
        break;
    }

    if (Math.abs(b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      return null;
    }

    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);

        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }

        x = this.xmf * b * cosb * sinlam;
        break;

      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }

        break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
        rh,
        sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;

    if (phi > 1) {
      return null;
    }

    phi = 2 * Math.asin(phi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }

    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"] ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;

      case this.OBLIQ:
        phi = Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"] ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;

      case this.N_POLE:
        y = -y;
        phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;
        break;

      case this.S_POLE:
        phi -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
        break;
    }

    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);

      if (rho < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }

      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);

      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }

      q = x * x + y * y;

      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }

      ab = 1 - q / this.qp;

      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }

    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(this.long0 + lam);
  p.y = phi;
  return p;
}
/* determine latitude from authalic latitude */

var P00 = 0.33333333333333333333;
var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}

var names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/lcc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/lcc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/sign */ "./node_modules/proj4/lib/common/sign.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");






function init() {
  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined


  if (!this.k0) {
    this.k0 = 1;
  }

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0; // Standard Parallels cannot be equal and on opposite sides of the equator

  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin1, cos1);
  var ts1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin2, cos2);
  var ts2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat2, sin2);
  var ts0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }

  if (isNaN(this.ns)) {
    this.ns = sin1;
  }

  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);

  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
} // Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function forward(p) {
  var lon = p.x;
  var lat = p.y; // singular cases :

  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    lat = Object(_common_sign__WEBPACK_IMPORTED_MODULE_2__["default"])(lat) * (_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"] - 2 * _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]);
  }

  var con = Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]);
  var ts, rh1;

  if (con > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;

    if (con <= 0) {
      return null;
    }

    rh1 = 0;
  }

  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
} // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function inverse(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;

  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }

  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"];
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/longlat.js":
/*!*******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/longlat.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
function init() {//no-op for longlat
}

function identity(pt) {
  return pt;
}



var names = ["longlat", "identity"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/merc.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/merc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");





function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;

  if (!('x0' in this)) {
    this.x0 = 0;
  }

  if (!('y0' in this)) {
    this.y0 = 0;
  }

  this.e = Math.sqrt(this.es);

  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y; // convert to radians

  if (lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 90 && lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -90 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 180 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -180) {
    return null;
  }

  var x, y;

  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_4__["FORTPI"] + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }

    p.x = x;
    p.y = y;
    return p;
  }
}
/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/

function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/mill.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/mill.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");

/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/

function init() {} //no-op

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/moll.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/moll.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

function init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/

function forward(p) {
  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;
  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/

  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;

    if (Math.abs(delta_theta) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      break;
    }
  }

  theta /= 2;
  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/

  if (Math.PI / 2 - Math.abs(lat) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    delta_lon = 0;
  }

  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var theta;
  var arg;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/

  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }

  theta = Math.asin(arg);
  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));

  if (lon < -Math.PI) {
    lon = -Math.PI;
  }

  if (lon > Math.PI) {
    lon = Math.PI;
  }

  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;

  if (Math.abs(arg) > 1) {
    arg = 1;
  }

  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Mollweide", "moll"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/nzmg.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/nzmg.js ***!
  \****************************************************/
/*! exports provided: iterations, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterations", function() { return iterations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");

/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */

var iterations = 1;
function init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}
/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */

function forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0; // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.

  var d_phi = delta_lat / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;

  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  } // 2. Calculate theta


  var th_re = d_psi;
  var th_im = d_lambda; // 3. Calculate z

  var th_n_re = 1;
  var th_n_im = 0; // theta^0

  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;

  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  } // 4. Calculate easting and northing


  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */

function inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0; // 1. Calculate z

  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a; // 2a. Calculate theta - first approximation gives km accuracy

  var z_n_re = 1;
  var z_n_im = 0; // z^0

  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;

  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  } // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy


  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    } // Complex division


    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  } // 3. Calculate d_phi              ...                                    // and d_lambda


  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;

  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  } // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.


  var lat = this.lat0 + d_phi * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/omerc.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/omerc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");




/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/

function init() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }

  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;
  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));

  if (dl * dl < 1) {
    dl = 1;
  }

  var fl;
  var gl;

  if (!isNaN(this.longc)) {
    //Central point and azimuth method
    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    } else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }

    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
  } else {
    //2 points method
    var t1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat2, Math.sin(this.lat2));

    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    } else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }

    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * dlon12) / pl) / this.bl;
    this.long0 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0);
    var dlon10 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  } else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    } else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }
}
/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
  var us, vs;
  var con;

  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    if (lat > 0) {
      con = -1;
    } else {
      con = 1;
    }

    vs = this.al / this.bl * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__["FORTPI"] + con * this.gamma0 * 0.5));
    us = -1 * con * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"] * this.al / this.bl;
  } else {
    var t = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * dlon);
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;

    if (Math.abs(Math.abs(ul) - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      vs = Number.POSITIVE_INFINITY;
    } else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }

    if (Math.abs(Math.cos(this.bl * dlon)) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      us = this.al * this.bl * dlon;
    } else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  } else {
    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }

  return p;
}
function inverse(p) {
  var us, vs;

  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  } else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }

  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);

  if (Math.abs(up - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  } else if (Math.abs(up + 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = -1 * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  } else {
    p.y = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, ts);
    p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }

  return p;
}
var names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/ortho.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/ortho.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");



function init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh;
  /* height above ellipsoid      */

  var z;
  /* angle          */

  var sinz, cosz;
  /* sin of z and cos of z      */

  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;

  if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }

  lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_2__["HALF_PI"];

  if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    if (this.lat0 >= 0) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["ortho"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/poly.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/poly.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/proj4/lib/common/e3fn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/proj4/lib/common/mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/gN */ "./node_modules/proj4/lib/common/gN.js");









var MAX_ITER = 20;
function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles

  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
  this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}
/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(lon - this.long0);
  el = dlon * Math.sin(lat);

  if (this.sphere) {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__["default"])(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_8__["default"])(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;

      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;

        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      }

      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lat = 0;
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;

      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;

        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      } //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);


      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Polyconic", "poly"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/qsc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/qsc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

/* constants */

var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  /* Determine the cube face from the center of projection. */

  if (this.lat0 >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */


  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
} // QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function forward(p) {
  var xy = {
    x: 0,
    y: 0
  };
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */

  var area = {
    value: 0
  }; // move lon according to projection's lon

  p.x -= this.long0;
  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */

  if (this.es !== 0) {
    //if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */


  lon = p.x; //lon = lp.lam;

  if (this.face === FACE_ENUM.TOP) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - lat;

    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || lon <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0.0 ? lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
    } else if (lon > -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) && lon <= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + lat;

    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon < _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0.0 ? -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }

    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */


  mu = Math.atan(12 / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] * (theta + Math.acos(Math.sin(theta) * Math.cos(_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  /* Apply the result to the real area. */

  if (area.value === AREA_ENUM.AREA_1) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  }
  /* Now compute x, y from mu and nu */


  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
} // QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function inverse(p) {
  var lp = {
    lam: 0,
    phi: 0
  };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {
    value: 0
  };
  /* de-offset */

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */

  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);

  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0.0 ? mu + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : mu - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  }
  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */


  t = _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));

  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }
  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */


  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0.0 ? theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta;
      }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta < 0.0 ? -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
      }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;

    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }

    t += s * s;

    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */


    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */


    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */


    lp.phi = Math.acos(-s) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    lp.lam = Math.atan2(r, q);

    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
  }
  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */


  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));

    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */

function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;

  if (phi < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);

    if (Math.abs(theta) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && theta <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || theta <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0.0 ? theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  }

  return theta;
}
/* Helper function: shift the longitude. */


function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;

  if (slon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon += _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  } else if (slon > +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  }

  return slon;
}

var names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/robin.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/robin.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039


var COEFS_X = [[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06], [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06], [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07], [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06], [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06], [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08], [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06], [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06], [0.9216, -0.00467746, -0.00010457, 4.81243e-06], [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06], [0.8679, -0.00609363, -0.000113898, 3.32484e-06], [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07], [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07], [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06], [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06], [0.6732, -0.00986209, -0.000199569, 1.91974e-05], [0.6213, -0.010418, 8.83923e-05, 6.24051e-06], [0.5722, -0.00906601, 0.000182, 6.24051e-06], [0.5322, -0.00677797, 0.000275608, 6.24051e-06]];
var COEFS_Y = [[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11], [0.0620, 0.0124, -1.26793e-09, 4.22642e-10], [0.1240, 0.0124, 5.07171e-09, -1.60604e-09], [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09], [0.2480, 0.0124002, 7.10039e-08, -2.24e-08], [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08], [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07], [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07], [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07], [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07], [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07], [0.6769, 0.011713, -3.20223e-05, -5.16405e-07], [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07], [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06], [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09], [0.8936, 0.00969686, -6.4636e-05, -8.547e-06], [0.9394, 0.00840947, -0.000192841, -4.2106e-06], [0.9761, 0.00616527, -0.000256, -4.2106e-06], [1.0000, 0.00328947, -0.000319159, -4.2106e-06]];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"] / 5; // rad to 5-degree interval

var RC1 = 1 / C1;
var NODES = 18;

var poly3_val = function (coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function (coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
  var x = start;

  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;

    if (Math.abs(upd) < max_err) {
      break;
    }
  }

  return x;
}

function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward(ll) {
  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);

  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }

  dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"] * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };

  if (ll.y < 0) {
    xy.y = -xy.y;
  }

  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };

  if (ll.y >= 1) {
    // pathologic case
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] : _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else {
    // find table interval
    var i = Math.floor(ll.y * NODES);

    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }

    for (;;) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    } // linear interpolation in 5 degree interval


    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]); // find t so that poly3_val(coefs, t) = ll.y

    t = newton_rapshon(function (x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"], 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];

    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }

  ll.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(ll.x + this.long0);
  return ll;
}
var names = ["Robinson", "robin"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/sinu.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/sinu.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_enfn */ "./node_modules/proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/pj_mlfn */ "./node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "./node_modules/proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");



var MAX_ITER = 20;




function init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/
  if (!this.sphere) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/

function forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);

      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;

        if (Math.abs(V) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
          break;
        }
      }
    }

    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__["default"])(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));

    if (this.m) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])(Math.sin(lat) / this.n);
    }

    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon + this.long0);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat);
  } else {
    lat = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__["default"])(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);

    if (s < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)); //temp = this.long0 + p.x / (this.a * Math.cos(lat));

      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(temp);
    } else if (s - _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"] < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      lon = this.long0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Sinusoidal", "sinu"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/somerc.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/somerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
function init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K; // spheric latitude

  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4); // spheric longitude

  var I = this.alpha * (p.x - this.lambda0); // psoeudo equatorial rotation

  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;

  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    } //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));


    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}
var names = ["somerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/stere.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/stere.js ***!
  \*****************************************************/
/*! exports provided: ssfn_, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssfn_", function() { return ssfn_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/sign */ "./node_modules/proj4/lib/common/sign.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/proj4/lib/common/phi2z.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");






function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);

  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * (1 + Object(_common_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      } else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }

    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));

    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * this.cons * Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }

    this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
} // Stereographic forward equations--mapping lat,long to x,y

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"] && Math.abs(lat + this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }

  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    cosX = Math.cos(X);
    sinX = Math.sin(X);

    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0); //trace(p.toString());

      return p;
    } else if (Math.abs(this.sinlat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    } else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }

    p.x = A * cosX * Math.sin(dlon) + this.x0;
  } //trace(p.toString());


  return p;
} //* Stereographic inverse equations--mapping x,y to lat/long

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);

  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;

    if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      p.x = lon;
      p.y = lat;
      return p;
    }

    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);

    if (Math.abs(this.coslat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat; //trace(p.toString());

        return p;
      }

      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);
      lon = this.con * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;

      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }

      lat = -1 * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + Chi)));
    }
  }

  p.x = lon;
  p.y = lat; //trace(p.toString());

  return p;
}
var names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  ssfn_: ssfn_
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/sterea.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/sterea.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _gauss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gauss */ "./node_modules/proj4/lib/projections/gauss.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");


function init() {
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].init.apply(this);

  if (!this.rc) {
    return;
  }

  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;

  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward(p) {
  var sinc, cosc, cosl, k;
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x - this.long0);
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].inverse.apply(this, [p]);
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x + this.long0);
  return p;
}
var names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/tmerc.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/tmerc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/pj_enfn */ "./node_modules/proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/pj_mlfn */ "./node_modules/proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "./node_modules/proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/sign */ "./node_modules/proj4/lib/common/sign.js");
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js






function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
    this.ml0 = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if (Math.abs(Math.abs(b) - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if (b - 1 > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */

function inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.atan2(g, h) + this.long0);
    }
  } else {
    // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(con, this.es, this.en);

    if (Math.abs(phi) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] * Object(_common_sign__WEBPACK_IMPORTED_MODULE_5__["default"])(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/utm.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/utm.js ***!
  \***************************************************/
/*! exports provided: dependsOn, init, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dependsOn", function() { return dependsOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_zone */ "./node_modules/proj4/lib/common/adjust_zone.js");
/* harmony import */ var _etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./etmerc */ "./node_modules/proj4/lib/projections/etmerc.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");


var dependsOn = 'etmerc';

function init() {
  var zone = Object(_common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__["default"])(this.zone, this.long0);

  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }

  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * _constants_values__WEBPACK_IMPORTED_MODULE_2__["D2R"];
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;
  _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].init.apply(this);
  this.forward = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].forward;
  this.inverse = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].inverse;
}
var names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  names: names,
  dependsOn: dependsOn
});

/***/ }),

/***/ "./node_modules/proj4/lib/projections/vandg.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/vandg.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/proj4/lib/common/asinz.js");



/* Initialize the Van Der Grinten projection
  ----------------------------------------*/

function init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }

  var theta = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_2__["default"])(2 * Math.abs(lat / Math.PI));

  if (Math.abs(dlon) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"] || Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    x = this.x0;

    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    } //  return(OK);

  }

  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);

  if (dlon < 0) {
    con = -con;
  }

  x = this.x0 + con; //con = Math.abs(con / (Math.PI * this.R));

  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);

  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  } else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/

function inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  /* inverse equations
    -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;

  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }

  th1 = Math.acos(con) / 3;

  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    lon = this.long0;
  } else {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ "./node_modules/proj4/lib/transform.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/transform.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/proj4/lib/constants/values.js");
/* harmony import */ var _datum_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datum_transform */ "./node_modules/proj4/lib/datum_transform.js");
/* harmony import */ var _adjust_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adjust_axis */ "./node_modules/proj4/lib/adjust_axis.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Proj */ "./node_modules/proj4/lib/Proj.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/toPoint */ "./node_modules/proj4/lib/common/toPoint.js");
/* harmony import */ var _checkSanity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./checkSanity */ "./node_modules/proj4/lib/checkSanity.js");







function checkNotWGS(source, dest) {
  return (source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && source.datumCode !== 'WGS84';
}

function transform(source, dest, point) {
  var wgs84;

  if (Array.isArray(point)) {
    point = Object(_common_toPoint__WEBPACK_IMPORTED_MODULE_4__["default"])(point);
  }

  Object(_checkSanity__WEBPACK_IMPORTED_MODULE_5__["default"])(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84

  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new _Proj__WEBPACK_IMPORTED_MODULE_3__["default"]('WGS84');
    point = transform(source, wgs84, point);
    source = wgs84;
  } // DGR, 2010/11/12


  if (source.axis !== 'enu') {
    point = Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__["default"])(source, false, point);
  } // Transform source points to long/lat, if they aren't already.


  if (source.projName === 'longlat') {
    point = {
      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"],
      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"]
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter
      };
    }

    point = source.inverse(point); // Convert Cartesian to longlat
  } // Adjust for the prime meridian if necessary


  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  } // Convert datums if needed, and if possible.


  point = Object(_datum_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(source.datum, dest.datum, point); // Adjust for the prime meridian if necessary

  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"],
      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"]
    };
  } else {
    // else project
    point = dest.forward(point);

    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter
      };
    }
  } // DGR, 2010/11/12


  if (dest.axis !== 'enu') {
    return Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__["default"])(dest, true, point);
  }

  return point;
}

/***/ }),

/***/ "./node_modules/proj4/lib/version.js":
/*!*******************************************!*\
  !*** ./node_modules/proj4/lib/version.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./node_modules/proj4/package.json");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_package_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _package_json__WEBPACK_IMPORTED_MODULE_0__["version"]; });



/***/ }),

/***/ "./node_modules/proj4/package.json":
/*!*****************************************!*\
  !*** ./node_modules/proj4/package.json ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {"_from":"proj4@^2.5.0","_id":"proj4@2.5.0","_inBundle":false,"_integrity":"sha512-XZTRT7OPdLzgvtTqL8DG2cEj8lYdovztOwiwpwRSYayOty5Ipf3H68dh/fiL+HKDEyetmQSMhkkMGiJoyziz3w==","_location":"/proj4","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"proj4@^2.5.0","name":"proj4","escapedName":"proj4","rawSpec":"^2.5.0","saveSpec":null,"fetchSpec":"^2.5.0"},"_requiredBy":["/","/cartoview-sdk"],"_resolved":"https://registry.npmjs.org/proj4/-/proj4-2.5.0.tgz","_shasum":"e3a88ce7e7a07221aaccbc6760dd2eafee745f03","_spec":"proj4@^2.5.0","_where":"/Users/hishamkaram/Projects-Active/geonode_oauth_client/cartoview/static/basic_viewer","author":"","bugs":{"url":"https://github.com/proj4js/proj4js/issues"},"bundleDependencies":false,"contributors":[{"name":"Mike Adair","email":"madair@dmsolutions.ca"},{"name":"Richard Greenwood","email":"rich@greenwoodmap.com"},{"name":"Calvin Metcalf","email":"calvin.metcalf@gmail.com"},{"name":"Richard Marsden","url":"http://www.winwaed.com"},{"name":"T. Mittan"},{"name":"D. Steinwand"},{"name":"S. Nelson"}],"dependencies":{"mgrs":"1.0.0","wkt-parser":"^1.2.0"},"deprecated":false,"description":"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.","devDependencies":{"chai":"~4.1.2","curl-amd":"github:cujojs/curl","grunt":"^1.0.1","grunt-cli":"~1.2.0","grunt-contrib-connect":"~1.0.2","grunt-contrib-jshint":"~1.1.0","grunt-contrib-uglify":"~3.1.0","grunt-mocha-phantomjs":"~4.0.0","grunt-rollup":"^6.0.0","istanbul":"~0.4.5","mocha":"~4.0.0","rollup":"^0.50.0","rollup-plugin-json":"^2.3.0","rollup-plugin-node-resolve":"^3.0.0","tin":"~0.5.0"},"directories":{"test":"test","doc":"docs"},"homepage":"https://github.com/proj4js/proj4js#readme","license":"MIT","main":"dist/proj4-src.js","module":"lib/index.js","name":"proj4","repository":{"type":"git","url":"git://github.com/proj4js/proj4js.git"},"scripts":{"build":"grunt","build:tmerc":"grunt build:tmerc","test":"npm run build && istanbul test _mocha test/test.js"},"version":"2.5.0"}

/***/ }),

/***/ "./node_modules/proj4/projs.js":
/*!*************************************!*\
  !*** ./node_modules/proj4/projs.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/projections/tmerc */ "./node_modules/proj4/lib/projections/tmerc.js");
/* harmony import */ var _lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/projections/etmerc */ "./node_modules/proj4/lib/projections/etmerc.js");
/* harmony import */ var _lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/projections/utm */ "./node_modules/proj4/lib/projections/utm.js");
/* harmony import */ var _lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/projections/sterea */ "./node_modules/proj4/lib/projections/sterea.js");
/* harmony import */ var _lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/projections/stere */ "./node_modules/proj4/lib/projections/stere.js");
/* harmony import */ var _lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/projections/somerc */ "./node_modules/proj4/lib/projections/somerc.js");
/* harmony import */ var _lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/projections/omerc */ "./node_modules/proj4/lib/projections/omerc.js");
/* harmony import */ var _lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/projections/lcc */ "./node_modules/proj4/lib/projections/lcc.js");
/* harmony import */ var _lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/projections/krovak */ "./node_modules/proj4/lib/projections/krovak.js");
/* harmony import */ var _lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/projections/cass */ "./node_modules/proj4/lib/projections/cass.js");
/* harmony import */ var _lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/projections/laea */ "./node_modules/proj4/lib/projections/laea.js");
/* harmony import */ var _lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/projections/aea */ "./node_modules/proj4/lib/projections/aea.js");
/* harmony import */ var _lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/projections/gnom */ "./node_modules/proj4/lib/projections/gnom.js");
/* harmony import */ var _lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/projections/cea */ "./node_modules/proj4/lib/projections/cea.js");
/* harmony import */ var _lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/projections/eqc */ "./node_modules/proj4/lib/projections/eqc.js");
/* harmony import */ var _lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/projections/poly */ "./node_modules/proj4/lib/projections/poly.js");
/* harmony import */ var _lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/projections/nzmg */ "./node_modules/proj4/lib/projections/nzmg.js");
/* harmony import */ var _lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/projections/mill */ "./node_modules/proj4/lib/projections/mill.js");
/* harmony import */ var _lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/projections/sinu */ "./node_modules/proj4/lib/projections/sinu.js");
/* harmony import */ var _lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/projections/moll */ "./node_modules/proj4/lib/projections/moll.js");
/* harmony import */ var _lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/projections/eqdc */ "./node_modules/proj4/lib/projections/eqdc.js");
/* harmony import */ var _lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/projections/vandg */ "./node_modules/proj4/lib/projections/vandg.js");
/* harmony import */ var _lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/projections/aeqd */ "./node_modules/proj4/lib/projections/aeqd.js");
/* harmony import */ var _lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/projections/ortho */ "./node_modules/proj4/lib/projections/ortho.js");
/* harmony import */ var _lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/projections/qsc */ "./node_modules/proj4/lib/projections/qsc.js");
/* harmony import */ var _lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/projections/robin */ "./node_modules/proj4/lib/projections/robin.js");


























/* harmony default export */ __webpack_exports__["default"] = (function (proj4) {
  proj4.Proj.projections.add(_lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__["default"]);
  proj4.Proj.projections.add(_lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__["default"]);
  proj4.Proj.projections.add(_lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__["default"]);
  proj4.Proj.projections.add(_lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__["default"]);
  proj4.Proj.projections.add(_lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__["default"]);
  proj4.Proj.projections.add(_lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__["default"]);
  proj4.Proj.projections.add(_lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__["default"]);
  proj4.Proj.projections.add(_lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__["default"]);
  proj4.Proj.projections.add(_lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__["default"]);
  proj4.Proj.projections.add(_lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__["default"]);
  proj4.Proj.projections.add(_lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__["default"]);
  proj4.Proj.projections.add(_lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__["default"]);
  proj4.Proj.projections.add(_lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__["default"]);
  proj4.Proj.projections.add(_lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__["default"]);
  proj4.Proj.projections.add(_lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__["default"]);
  proj4.Proj.projections.add(_lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__["default"]);
  proj4.Proj.projections.add(_lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__["default"]);
  proj4.Proj.projections.add(_lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__["default"]);
  proj4.Proj.projections.add(_lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__["default"]);
  proj4.Proj.projections.add(_lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__["default"]);
  proj4.Proj.projections.add(_lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__["default"]);
  proj4.Proj.projections.add(_lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__["default"]);
  proj4.Proj.projections.add(_lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__["default"]);
  proj4.Proj.projections.add(_lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__["default"]);
});

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() : undefined;
})(this, function () {
  'use strict';

  function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {
    while (right > left) {
      if (right - left > 600) {
        var n = right - left + 1;
        var m = k - left + 1;
        var z = Math.log(n);
        var s = 0.5 * Math.exp(2 * z / 3);
        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        quickselectStep(arr, k, newLeft, newRight, compare);
      }

      var t = arr[k];
      var i = left;
      var j = right;
      swap(arr, left, k);
      if (compare(arr[right], t) > 0) swap(arr, left, right);

      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;

        while (compare(arr[i], t) < 0) i++;

        while (compare(arr[j], t) > 0) j--;
      }

      if (compare(arr[left], t) === 0) swap(arr, left, j);else {
        j++;
        swap(arr, j, right);
      }
      if (j <= k) left = j + 1;
      if (k <= j) right = j - 1;
    }
  }

  function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }

  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }

  return quickselect;
});

/***/ }),

/***/ "./node_modules/randomcolor/randomColor.js":
/*!*************************************************!*\
  !*** ./node_modules/randomcolor/randomColor.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {// randomColor by David Merfield under the CC0 license
// https://github.com/davidmerfield/randomColor/
;

(function (root, factory) {
  // Support CommonJS
  if (true) {
    var randomColor = factory(); // Support NodeJS & Component, which allow module.exports to be a function

    if ( true && module && module.exports) {
      exports = module.exports = randomColor;
    } // Support CommonJS 1.1.1 spec


    exports.randomColor = randomColor; // Support AMD
  } else {}
})(this, function () {
  // Seed to get repeatable colors
  var seed = null; // Shared color dictionary

  var colorDictionary = {}; // Populate the color dictionary

  loadColorBounds(); // check if a range is taken

  var colorRanges = [];

  var randomColor = function (options) {
    options = options || {}; // Check if there is a seed and ensure it's an
    // integer. Otherwise, reset the seed value.

    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
      seed = options.seed; // A string was passed as a seed
    } else if (typeof options.seed === 'string') {
      seed = stringToInteger(options.seed); // Something was passed as a seed but it wasn't an integer or string
    } else if (options.seed !== undefined && options.seed !== null) {
      throw new TypeError('The seed value must be an integer or string'); // No seed, reset the value outside.
    } else {
      seed = null;
    }

    var H, S, B; // Check if we need to generate multiple colors

    if (options.count !== null && options.count !== undefined) {
      var totalColors = options.count,
          colors = []; // Value false at index i means the range i is not taken yet.

      for (var i = 0; i < options.count; i++) {
        colorRanges.push(false);
      }

      options.count = null;

      while (totalColors > colors.length) {
        // Since we're generating multiple colors,
        // incremement the seed. Otherwise we'd just
        // generate the same color each time...
        if (seed && options.seed) options.seed += 1;
        colors.push(randomColor(options));
      }

      options.count = totalColors;
      return colors;
    } // First we pick a hue (H)


    H = pickHue(options); // Then use H to determine saturation (S)

    S = pickSaturation(H, options); // Then use S and H to determine brightness (B).

    B = pickBrightness(H, S, options); // Then we return the HSB color in the desired format

    return setFormat([H, S, B], options);
  };

  function pickHue(options) {
    if (colorRanges.length > 0) {
      var hueRange = getRealHueRange(options.hue);
      var hue = randomWithin(hueRange); //Each of colorRanges.length ranges has a length equal approximatelly one step

      var step = (hueRange[1] - hueRange[0]) / colorRanges.length;
      var j = parseInt((hue - hueRange[0]) / step); //Check if the range j is taken

      if (colorRanges[j] === true) {
        j = (j + 2) % colorRanges.length;
      } else {
        colorRanges[j] = true;
      }

      var min = (hueRange[0] + j * step) % 359,
          max = (hueRange[0] + (j + 1) * step) % 359;
      hueRange = [min, max];
      hue = randomWithin(hueRange);

      if (hue < 0) {
        hue = 360 + hue;
      }

      return hue;
    } else {
      var hueRange = getHueRange(options.hue);
      hue = randomWithin(hueRange); // Instead of storing red as two seperate ranges,
      // we group them, using negative numbers

      if (hue < 0) {
        hue = 360 + hue;
      }

      return hue;
    }
  }

  function pickSaturation(hue, options) {
    if (options.hue === 'monochrome') {
      return 0;
    }

    if (options.luminosity === 'random') {
      return randomWithin([0, 100]);
    }

    var saturationRange = getSaturationRange(hue);
    var sMin = saturationRange[0],
        sMax = saturationRange[1];

    switch (options.luminosity) {
      case 'bright':
        sMin = 55;
        break;

      case 'dark':
        sMin = sMax - 10;
        break;

      case 'light':
        sMax = 55;
        break;
    }

    return randomWithin([sMin, sMax]);
  }

  function pickBrightness(H, S, options) {
    var bMin = getMinimumBrightness(H, S),
        bMax = 100;

    switch (options.luminosity) {
      case 'dark':
        bMax = bMin + 20;
        break;

      case 'light':
        bMin = (bMax + bMin) / 2;
        break;

      case 'random':
        bMin = 0;
        bMax = 100;
        break;
    }

    return randomWithin([bMin, bMax]);
  }

  function setFormat(hsv, options) {
    switch (options.format) {
      case 'hsvArray':
        return hsv;

      case 'hslArray':
        return HSVtoHSL(hsv);

      case 'hsl':
        var hsl = HSVtoHSL(hsv);
        return 'hsl(' + hsl[0] + ', ' + hsl[1] + '%, ' + hsl[2] + '%)';

      case 'hsla':
        var hslColor = HSVtoHSL(hsv);
        var alpha = options.alpha || Math.random();
        return 'hsla(' + hslColor[0] + ', ' + hslColor[1] + '%, ' + hslColor[2] + '%, ' + alpha + ')';

      case 'rgbArray':
        return HSVtoRGB(hsv);

      case 'rgb':
        var rgb = HSVtoRGB(hsv);
        return 'rgb(' + rgb.join(', ') + ')';

      case 'rgba':
        var rgbColor = HSVtoRGB(hsv);
        var alpha = options.alpha || Math.random();
        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';

      default:
        return HSVtoHex(hsv);
    }
  }

  function getMinimumBrightness(H, S) {
    var lowerBounds = getColorInfo(H).lowerBounds;

    for (var i = 0; i < lowerBounds.length - 1; i++) {
      var s1 = lowerBounds[i][0],
          v1 = lowerBounds[i][1];
      var s2 = lowerBounds[i + 1][0],
          v2 = lowerBounds[i + 1][1];

      if (S >= s1 && S <= s2) {
        var m = (v2 - v1) / (s2 - s1),
            b = v1 - m * s1;
        return m * S + b;
      }
    }

    return 0;
  }

  function getHueRange(colorInput) {
    if (typeof parseInt(colorInput) === 'number') {
      var number = parseInt(colorInput);

      if (number < 360 && number > 0) {
        return [number, number];
      }
    }

    if (typeof colorInput === 'string') {
      if (colorDictionary[colorInput]) {
        var color = colorDictionary[colorInput];

        if (color.hueRange) {
          return color.hueRange;
        }
      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorInput)[0];
        return [hue, hue];
      }
    }

    return [0, 360];
  }

  function getSaturationRange(hue) {
    return getColorInfo(hue).saturationRange;
  }

  function getColorInfo(hue) {
    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) {
      hue -= 360;
    }

    for (var colorName in colorDictionary) {
      var color = colorDictionary[colorName];

      if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) {
        return colorDictionary[colorName];
      }
    }

    return 'Color not found';
  }

  function randomWithin(range) {
    if (seed === null) {
      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
      var golden_ratio = 0.618033988749895;
      var r = Math.random();
      r += golden_ratio;
      r %= 1;
      return Math.floor(range[0] + r * (range[1] + 1 - range[0]));
    } else {
      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/
      var max = range[1] || 1;
      var min = range[0] || 0;
      seed = (seed * 9301 + 49297) % 233280;
      var rnd = seed / 233280.0;
      return Math.floor(min + rnd * (max - min));
    }
  }

  function HSVtoHex(hsv) {
    var rgb = HSVtoRGB(hsv);

    function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length == 1 ? '0' + hex : hex;
    }

    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
    return hex;
  }

  function defineColor(name, hueRange, lowerBounds) {
    var sMin = lowerBounds[0][0],
        sMax = lowerBounds[lowerBounds.length - 1][0],
        bMin = lowerBounds[lowerBounds.length - 1][1],
        bMax = lowerBounds[0][1];
    colorDictionary[name] = {
      hueRange: hueRange,
      lowerBounds: lowerBounds,
      saturationRange: [sMin, sMax],
      brightnessRange: [bMin, bMax]
    };
  }

  function loadColorBounds() {
    defineColor('monochrome', null, [[0, 0], [100, 0]]);
    defineColor('red', [-26, 18], [[20, 100], [30, 92], [40, 89], [50, 85], [60, 78], [70, 70], [80, 60], [90, 55], [100, 50]]);
    defineColor('orange', [19, 46], [[20, 100], [30, 93], [40, 88], [50, 86], [60, 85], [70, 70], [100, 70]]);
    defineColor('yellow', [47, 62], [[25, 100], [40, 94], [50, 89], [60, 86], [70, 84], [80, 82], [90, 80], [100, 75]]);
    defineColor('green', [63, 178], [[30, 100], [40, 90], [50, 85], [60, 81], [70, 74], [80, 64], [90, 50], [100, 40]]);
    defineColor('blue', [179, 257], [[20, 100], [30, 86], [40, 80], [50, 74], [60, 60], [70, 52], [80, 44], [90, 39], [100, 35]]);
    defineColor('purple', [258, 282], [[20, 100], [30, 87], [40, 79], [50, 70], [60, 65], [70, 59], [80, 52], [90, 45], [100, 42]]);
    defineColor('pink', [283, 334], [[20, 100], [30, 90], [40, 86], [60, 84], [80, 80], [90, 75], [100, 73]]);
  }

  function HSVtoRGB(hsv) {
    // this doesn't work for the values of 0 and 360
    // here's the hacky fix
    var h = hsv[0];

    if (h === 0) {
      h = 1;
    }

    if (h === 360) {
      h = 359;
    } // Rebase the h,s,v values


    h = h / 360;
    var s = hsv[1] / 100,
        v = hsv[2] / 100;
    var h_i = Math.floor(h * 6),
        f = h * 6 - h_i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        r = 256,
        g = 256,
        b = 256;

    switch (h_i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    var result = [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
    return result;
  }

  function HexToHSB(hex) {
    hex = hex.replace(/^#/, '');
    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;
    var red = parseInt(hex.substr(0, 2), 16) / 255,
        green = parseInt(hex.substr(2, 2), 16) / 255,
        blue = parseInt(hex.substr(4, 2), 16) / 255;
    var cMax = Math.max(red, green, blue),
        delta = cMax - Math.min(red, green, blue),
        saturation = cMax ? delta / cMax : 0;

    switch (cMax) {
      case red:
        return [60 * ((green - blue) / delta % 6) || 0, saturation, cMax];

      case green:
        return [60 * ((blue - red) / delta + 2) || 0, saturation, cMax];

      case blue:
        return [60 * ((red - green) / delta + 4) || 0, saturation, cMax];
    }
  }

  function HSVtoHSL(hsv) {
    var h = hsv[0],
        s = hsv[1] / 100,
        v = hsv[2] / 100,
        k = (2 - s) * v;
    return [h, Math.round(s * v / (k < 1 ? k : 2 - k) * 10000) / 100, k / 2 * 100];
  }

  function stringToInteger(string) {
    var total = 0;

    for (var i = 0; i !== string.length; i++) {
      if (total >= Number.MAX_SAFE_INTEGER) break;
      total += string.charCodeAt(i);
    }

    return total;
  } // get The range of given hue when options.count!=0


  function getRealHueRange(colorHue) {
    if (!isNaN(colorHue)) {
      var number = parseInt(colorHue);

      if (number < 360 && number > 0) {
        return getColorInfo(colorHue).hueRange;
      }
    } else if (typeof colorHue === 'string') {
      if (colorDictionary[colorHue]) {
        var color = colorDictionary[colorHue];

        if (color.hueRange) {
          return color.hueRange;
        }
      } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorHue)[0];
        return getColorInfo(hue).hueRange;
      }
    }

    return [0, 360];
  }

  return randomColor;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

  this._maxEntries = Math.max(4, maxEntries || 9);
  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

  if (format) {
    this._initFormat(format);
  }

  this.clear();
}

rbush.prototype = {
  all: function () {
    return this._all(this.data, []);
  },
  search: function (bbox) {
    var node = this.data,
        result = [],
        toBBox = this.toBBox;
    if (!intersects(bbox, node)) return result;
    var nodesToSearch = [],
        i,
        len,
        child,
        childBBox;

    while (node) {
      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;

        if (intersects(bbox, childBBox)) {
          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
        }
      }

      node = nodesToSearch.pop();
    }

    return result;
  },
  collides: function (bbox) {
    var node = this.data,
        toBBox = this.toBBox;
    if (!intersects(bbox, node)) return false;
    var nodesToSearch = [],
        i,
        len,
        child,
        childBBox;

    while (node) {
      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        childBBox = node.leaf ? toBBox(child) : child;

        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }

      node = nodesToSearch.pop();
    }

    return false;
  },
  load: function (data) {
    if (!(data && data.length)) return this;

    if (data.length < this._minEntries) {
      for (var i = 0, len = data.length; i < len; i++) {
        this.insert(data[i]);
      }

      return this;
    } // recursively build the tree with the given data from stratch using OMT algorithm


    var node = this._build(data.slice(), 0, data.length - 1, 0);

    if (!this.data.children.length) {
      // save as is if tree is empty
      this.data = node;
    } else if (this.data.height === node.height) {
      // split root if trees have the same height
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        // swap trees if inserted one is bigger
        var tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      } // insert the small tree into the large tree at appropriate level


      this._insert(node, this.data.height - node.height - 1, true);
    }

    return this;
  },
  insert: function (item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  },
  clear: function () {
    this.data = createNode([]);
    return this;
  },
  remove: function (item, equalsFn) {
    if (!item) return this;
    var node = this.data,
        bbox = this.toBBox(item),
        path = [],
        indexes = [],
        i,
        parent,
        index,
        goingUp; // depth-first iterative tree traversal

    while (node || path.length) {
      if (!node) {
        // go up
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }

      if (node.leaf) {
        // check current node
        index = findItem(item, node.children, equalsFn);

        if (index !== -1) {
          // item found, remove the item and condense tree upwards
          node.children.splice(index, 1);
          path.push(node);

          this._condense(path);

          return this;
        }
      }

      if (!goingUp && !node.leaf && contains(node, bbox)) {
        // go down
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        // go right
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null; // nothing found

    }

    return this;
  },
  toBBox: function (item) {
    return item;
  },
  compareMinX: compareNodeMinX,
  compareMinY: compareNodeMinY,
  toJSON: function () {
    return this.data;
  },
  fromJSON: function (data) {
    this.data = data;
    return this;
  },
  _all: function (node, result) {
    var nodesToSearch = [];

    while (node) {
      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
      node = nodesToSearch.pop();
    }

    return result;
  },
  _build: function (items, left, right, height) {
    var N = right - left + 1,
        M = this._maxEntries,
        node;

    if (N <= M) {
      // reached leaf level; return leaf
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }

    if (!height) {
      // target height of the bulk-loaded tree
      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

      M = Math.ceil(N / Math.pow(M, height - 1));
    }

    node = createNode([]);
    node.leaf = false;
    node.height = height; // split the items into M mostly square tiles

    var N2 = Math.ceil(N / M),
        N1 = N2 * Math.ceil(Math.sqrt(M)),
        i,
        j,
        right2,
        right3;
    multiSelect(items, left, right, N1, this.compareMinX);

    for (i = left; i <= right; i += N1) {
      right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);

      for (j = i; j <= right2; j += N2) {
        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

        node.children.push(this._build(items, j, right3, height - 1));
      }
    }

    calcBBox(node, this.toBBox);
    return node;
  },
  _chooseSubtree: function (bbox, node, level, path) {
    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      minArea = minEnlargement = Infinity;

      for (i = 0, len = node.children.length; i < len; i++) {
        child = node.children[i];
        area = bboxArea(child);
        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          // otherwise choose one with the smallest area
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }

      node = targetNode || node.children[0];
    }

    return node;
  },
  _insert: function (item, level, isNode) {
    var toBBox = this.toBBox,
        bbox = isNode ? item : toBBox(item),
        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


    node.children.push(item);
    extend(node, bbox); // split on node overflow; propagate upwards if necessary

    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);

        level--;
      } else break;
    } // adjust bboxes along the insertion path


    this._adjustParentBBoxes(bbox, insertPath, level);
  },
  // split overflowed node into two
  _split: function (insertPath, level) {
    var node = insertPath[level],
        M = node.children.length,
        m = this._minEntries;

    this._chooseSplitAxis(node, m, M);

    var splitIndex = this._chooseSplitIndex(node, m, M);

    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
  },
  _splitRoot: function (node, newNode) {
    // split root node
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  },
  _chooseSplitIndex: function (node, m, M) {
    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
    minOverlap = minArea = Infinity;

    for (i = m; i <= M - m; i++) {
      bbox1 = distBBox(node, 0, i, this.toBBox);
      bbox2 = distBBox(node, i, M, this.toBBox);
      overlap = intersectionArea(bbox1, bbox2);
      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        // otherwise choose distribution with minimum area
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }

    return index;
  },
  // sorts node children by the best axis for split
  _chooseSplitAxis: function (node, m, M) {
    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
        xMargin = this._allDistMargin(node, m, M, compareMinX),
        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
    // otherwise it's already sorted by minY


    if (xMargin < yMargin) node.children.sort(compareMinX);
  },
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin: function (node, m, M, compare) {
    node.children.sort(compare);
    var toBBox = this.toBBox,
        leftBBox = distBBox(node, 0, m, toBBox),
        rightBBox = distBBox(node, M - m, M, toBBox),
        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
        i,
        child;

    for (i = m; i < M - m; i++) {
      child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }

    for (i = M - m - 1; i >= m; i--) {
      child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }

    return margin;
  },
  _adjustParentBBoxes: function (bbox, path, level) {
    // adjust bboxes along the given tree path
    for (var i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  },
  _condense: function (path) {
    // go through the path, removing empty nodes and updating bboxes
    for (var i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  },
  _initFormat: function (format) {
    // data format (minX, minY, maxX, maxY accessors)
    // uses eval-type function compilation instead of just accepting a toBBox function
    // because the algorithms are very sensitive to sorting functions performance,
    // so they should be dead simple and without inner calls
    var compareArr = ['return a', ' - b', ';'];
    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
  }
};

function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);

  for (var i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }

  return -1;
} // calculate node's bbox from bboxes of its children


function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
} // min bounding rectangle of node children from k to p-1


function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;

  for (var i = k, child; i < p; i++) {
    child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }

  return destNode;
}

function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}

function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}

function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}

function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}

function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}

function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
  var minX = Math.max(a.minX, b.minX),
      minY = Math.max(a.minY, b.minY),
      maxX = Math.min(a.maxX, b.maxX),
      maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}

function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}

function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}

function createNode(children) {
  return {
    children: children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach


function multiSelect(arr, left, right, n, compare) {
  var stack = [left, right],
      mid;

  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

/***/ }),

/***/ "./node_modules/react-image/umd/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-image/umd/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (a, b) {
   true ? module.exports = b(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@babel/runtime/helpers/objectSpread.js"), __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"), __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"), __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"), __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"), __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"), __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"), __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"), __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"), __webpack_require__(/*! react */ "./node_modules/react/index.js"), __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js")) : undefined;
})(this, function (a, b, c, d, e, f, g, h, j, k, l) {
  'use strict';

  a = a && a.hasOwnProperty("default") ? a["default"] : a, b = b && b.hasOwnProperty("default") ? b["default"] : b, c = c && c.hasOwnProperty("default") ? c["default"] : c, d = d && d.hasOwnProperty("default") ? d["default"] : d, e = e && e.hasOwnProperty("default") ? e["default"] : e, f = f && f.hasOwnProperty("default") ? f["default"] : f, g = g && g.hasOwnProperty("default") ? g["default"] : g, h = h && h.hasOwnProperty("default") ? h["default"] : h, j = j && j.hasOwnProperty("default") ? j["default"] : j;

  var m = "default" in k ? k["default"] : k,
      n = {},
      o = {
    loader: l.node,
    unloader: l.node,
    decode: l.bool,
    src: l.oneOfType([l.string, l.array]),
    container: l.func,
    loaderContainer: l.func,
    unloaderContainer: l.func
  },
      p = function (i) {
    function k(a) {
      var b;
      c(this, k), b = e(this, f(k).call(this, a)), j(g(b), "srcToArray", function (a) {
        return (Array.isArray(a) ? a : [a]).filter(function (a) {
          return a;
        });
      }), j(g(b), "onLoad", function () {
        n[b.sourceList[b.state.currentIndex]] = !0, b.i && b.setState({
          isLoaded: !0
        });
      }), j(g(b), "onError", function () {
        if (n[b.sourceList[b.state.currentIndex]] = !1, !b.i) return !1;

        for (var a, c = b.state.currentIndex + 1; c < b.sourceList.length; c++) {
          if (a = b.sourceList[c], !(a in n)) {
            b.setState({
              currentIndex: c
            });
            break;
          }

          if (!0 === n[a]) return b.setState({
            currentIndex: c,
            isLoading: !1,
            isLoaded: !0
          }), !0;
          !1 === n[a];
        }

        return c === b.sourceList.length ? b.setState({
          isLoading: !1
        }) : void b.loadImg();
      }), j(g(b), "loadImg", function () {
        b.i = new Image(), b.i.src = b.sourceList[b.state.currentIndex], b.props.decode && b.i.decode ? b.i.decode().then(b.onLoad).catch(b.onError) : b.i.onload = b.onLoad, b.i.onerror = b.onError;
      }), j(g(b), "unloadImg", function () {
        delete b.i.onerror, delete b.i.onload, b.i.src = "";

        try {
          delete b.i.src;
        } catch (a) {}

        delete b.i;
      }), b.loaderContainer = a.loaderContainer || a.container, b.unloaderContainer = a.unloaderContainer || a.container, b.sourceList = b.srcToArray(b.props.src);

      for (var d = 0; d < b.sourceList.length && !!(b.sourceList[d] in n); d++) if (!0 === n[b.sourceList[d]]) return b.state = {
        currentIndex: d,
        isLoading: !1,
        isLoaded: !0
      }, e(b);

      return b.state = b.sourceList.length ? {
        currentIndex: 0,
        isLoading: !0,
        isLoaded: !1
      } : {
        isLoading: !1,
        isLoaded: !1
      }, b;
    }

    return h(k, i), d(k, [{
      key: "componentDidMount",
      value: function () {
        this.state.isLoading && this.loadImg();
      }
    }, {
      key: "componentWillUnmount",
      value: function () {
        this.i && this.unloadImg();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function (a) {
        var b = this;
        this.loaderContainer = a.loaderContainer || a.container, this.unloaderContainer = a.unloaderContainer || a.container;
        var c = this.srcToArray(a.src),
            d = c.filter(function (a) {
          return -1 === b.sourceList.indexOf(a);
        }),
            e = this.sourceList.filter(function (a) {
          return -1 === c.indexOf(a);
        });

        if (d.length || e.length) {
          if (this.sourceList = c, !c.length) return this.setState({
            isLoading: !1,
            isLoaded: !1
          });
          this.setState({
            currentIndex: 0,
            isLoading: !0,
            isLoaded: !1
          }, this.loadImg);
        }
      }
    }, {
      key: "render",
      value: function () {
        var c = this.props,
            d = c.container,
            e = c.loader,
            f = c.unloader,
            g = c.src,
            h = c.decode,
            i = c.loaderContainer,
            j = c.unloaderContainer,
            k = c.mockImage,
            l = b(c, ["container", "loader", "unloader", "src", "decode", "loaderContainer", "unloaderContainer", "mockImage"]);

        if (this.state.isLoaded) {
          var n = a({}, {
            src: this.sourceList[this.state.currentIndex]
          }, l);
          return d(m.createElement("img", n));
        }

        return !this.state.isLoaded && this.state.isLoading ? e ? this.loaderContainer(e) : null : this.state.isLoaded || this.state.isLoading ? void 0 : f ? this.unloaderContainer(f) : null;
      }
    }]), k;
  }(k.Component);

  return j(p, "defaultProps", {
    loader: !1,
    unloader: !1,
    decode: !0,
    src: [],
    container: function (a) {
      return a;
    }
  }), p.propTypes = {}, p;
});

/***/ }),

/***/ "./node_modules/react-input-range/lib/css/index.css":
/*!**********************************************************!*\
  !*** ./node_modules/react-input-range/lib/css/index.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../mini-css-extract-plugin/dist/loader.js!../../../css-loader??ref--5-2!../../../postcss-loader/src??postcss!./index.css */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/react-input-range/lib/css/index.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inputRange = __webpack_require__(/*! ./input-range/input-range */ "./node_modules/react-input-range/lib/js/input-range/input-range.js");

var _inputRange2 = _interopRequireDefault(_inputRange);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * @ignore
 * @typedef {Object} ClientRect
 * @property {number} height
 * @property {number} left
 * @property {number} top
 * @property {number} width
 */

/**
 * @typedef {Object} InputRangeClassNames
 * @property {string} activeTrack
 * @property {string} disabledInputRange
 * @property {string} inputRange
 * @property {string} labelContainer
 * @property {string} maxLabel
 * @property {string} minLabel
 * @property {string} slider
 * @property {string} sliderContainer
 * @property {string} track
 * @property {string} valueLabel
 */

/**
 * @typedef {Function} LabelFormatter
 * @param {number} value
 * @param {string} type
 * @return {string}
 */

/**
 * @ignore
 * @typedef {Object} Point
 * @property {number} x
 * @property {number} y
 */

/**
 * @typedef {Object} Range
 * @property {number} min - Min value
 * @property {number} max - Max value
 */


exports.default = _inputRange2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/default-class-names.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/default-class-names.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default CSS class names
 * @ignore
 * @type {InputRangeClassNames}
 */

var DEFAULT_CLASS_NAMES = {
  activeTrack: 'input-range__track input-range__track--active',
  disabledInputRange: 'input-range input-range--disabled',
  inputRange: 'input-range',
  labelContainer: 'input-range__label-container',
  maxLabel: 'input-range__label input-range__label--max',
  minLabel: 'input-range__label input-range__label--min',
  slider: 'input-range__slider',
  sliderContainer: 'input-range__slider-container',
  track: 'input-range__track input-range__track--background',
  valueLabel: 'input-range__label input-range__label--value'
};
exports.default = DEFAULT_CLASS_NAMES;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/input-range.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/input-range.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _desc, _value, _class;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__(/*! autobind-decorator */ "./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _valueTransformer = __webpack_require__(/*! ./value-transformer */ "./node_modules/react-input-range/lib/js/input-range/value-transformer.js");

var valueTransformer = _interopRequireWildcard(_valueTransformer);

var _defaultClassNames = __webpack_require__(/*! ./default-class-names */ "./node_modules/react-input-range/lib/js/input-range/default-class-names.js");

var _defaultClassNames2 = _interopRequireDefault(_defaultClassNames);

var _label = __webpack_require__(/*! ./label */ "./node_modules/react-input-range/lib/js/input-range/label.js");

var _label2 = _interopRequireDefault(_label);

var _rangePropType = __webpack_require__(/*! ./range-prop-type */ "./node_modules/react-input-range/lib/js/input-range/range-prop-type.js");

var _rangePropType2 = _interopRequireDefault(_rangePropType);

var _valuePropType = __webpack_require__(/*! ./value-prop-type */ "./node_modules/react-input-range/lib/js/input-range/value-prop-type.js");

var _valuePropType2 = _interopRequireDefault(_valuePropType);

var _slider = __webpack_require__(/*! ./slider */ "./node_modules/react-input-range/lib/js/input-range/slider.js");

var _slider2 = _interopRequireDefault(_slider);

var _track = __webpack_require__(/*! ./track */ "./node_modules/react-input-range/lib/js/input-range/track.js");

var _track2 = _interopRequireDefault(_track);

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/react-input-range/lib/js/utils/index.js");

var _keyCodes = __webpack_require__(/*! ./key-codes */ "./node_modules/react-input-range/lib/js/input-range/key-codes.js");

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}
/**
 * A React component that allows users to input numeric values within a range
 * by dragging its sliders.
 */


var InputRange = (_class = function (_React$Component) {
  _inherits(InputRange, _React$Component);

  _createClass(InputRange, null, [{
    key: 'propTypes',

    /**
     * @ignore
     * @override
     * @return {Object}
     */
    get: function get() {
      return {
        allowSameValues: _propTypes2.default.bool,
        ariaLabelledby: _propTypes2.default.string,
        ariaControls: _propTypes2.default.string,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string),
        disabled: _propTypes2.default.bool,
        draggableTrack: _propTypes2.default.bool,
        formatLabel: _propTypes2.default.func,
        maxValue: _rangePropType2.default,
        minValue: _rangePropType2.default,
        name: _propTypes2.default.string,
        onChangeStart: _propTypes2.default.func,
        onChange: _propTypes2.default.func.isRequired,
        onChangeComplete: _propTypes2.default.func,
        step: _propTypes2.default.number,
        value: _valuePropType2.default
      };
    }
    /**
     * @ignore
     * @override
     * @return {Object}
     */

  }, {
    key: 'defaultProps',
    get: function get() {
      return {
        allowSameValues: false,
        classNames: _defaultClassNames2.default,
        disabled: false,
        maxValue: 10,
        minValue: 0,
        step: 1
      };
    }
    /**
     * @param {Object} props
     * @param {boolean} [props.allowSameValues]
     * @param {string} [props.ariaLabelledby]
     * @param {string} [props.ariaControls]
     * @param {InputRangeClassNames} [props.classNames]
     * @param {boolean} [props.disabled = false]
     * @param {Function} [props.formatLabel]
     * @param {number|Range} [props.maxValue = 10]
     * @param {number|Range} [props.minValue = 0]
     * @param {string} [props.name]
     * @param {string} props.onChange
     * @param {Function} [props.onChangeComplete]
     * @param {Function} [props.onChangeStart]
     * @param {number} [props.step = 1]
     * @param {number|Range} props.value
     */

  }]);

  function InputRange(props) {
    _classCallCheck(this, InputRange);
    /**
     * @private
     * @type {?number}
     */


    var _this = _possibleConstructorReturn(this, (InputRange.__proto__ || Object.getPrototypeOf(InputRange)).call(this, props));

    _this.startValue = null;
    /**
     * @private
     * @type {?Component}
     */

    _this.node = null;
    /**
     * @private
     * @type {?Component}
     */

    _this.trackNode = null;
    /**
     * @private
     * @type {bool}
     */

    _this.isSliderDragging = false;
    /**
     * @private
     * @type {?string}
     */

    _this.lastKeyMoved = null;
    return _this;
  }
  /**
   * @ignore
   * @override
   * @return {void}
   */


  _createClass(InputRange, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeDocumentMouseUpListener();
      this.removeDocumentTouchEndListener();
    }
    /**
     * Return the CSS class name of the component
     * @private
     * @return {string}
     */

  }, {
    key: 'getComponentClassName',
    value: function getComponentClassName() {
      if (!this.props.disabled) {
        return this.props.classNames.inputRange;
      }

      return this.props.classNames.disabledInputRange;
    }
    /**
     * Return the bounding rect of the track
     * @private
     * @return {ClientRect}
     */

  }, {
    key: 'getTrackClientRect',
    value: function getTrackClientRect() {
      return this.trackNode.getClientRect();
    }
    /**
     * Return the slider key closest to a point
     * @private
     * @param {Point} position
     * @return {string}
     */

  }, {
    key: 'getKeyByPosition',
    value: function getKeyByPosition(position) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());

      if (this.isMultiValue()) {
        var distanceToMin = (0, _utils.distanceTo)(position, positions.min);
        var distanceToMax = (0, _utils.distanceTo)(position, positions.max);

        if (distanceToMin < distanceToMax) {
          return 'min';
        }
      }

      return 'max';
    }
    /**
     * Return all the slider keys
     * @private
     * @return {string[]}
     */

  }, {
    key: 'getKeys',
    value: function getKeys() {
      if (this.isMultiValue()) {
        return ['min', 'max'];
      }

      return ['max'];
    }
    /**
     * Return true if the difference between the new and the current value is
     * greater or equal to the step amount of the component
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'hasStepDifference',
    value: function hasStepDifference(values) {
      var currentValues = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      return (0, _utils.length)(values.min, currentValues.min) >= this.props.step || (0, _utils.length)(values.max, currentValues.max) >= this.props.step;
    }
    /**
     * Return true if the component accepts a min and max value
     * @private
     * @return {boolean}
     */

  }, {
    key: 'isMultiValue',
    value: function isMultiValue() {
      return (0, _utils.isObject)(this.props.value);
    }
    /**
     * Return true if the range is within the max and min value of the component
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'isWithinRange',
    value: function isWithinRange(values) {
      if (this.isMultiValue()) {
        return values.min >= this.props.minValue && values.max <= this.props.maxValue && this.props.allowSameValues ? values.min <= values.max : values.min < values.max;
      }

      return values.max >= this.props.minValue && values.max <= this.props.maxValue;
    }
    /**
     * Return true if the new value should trigger a render
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'shouldUpdate',
    value: function shouldUpdate(values) {
      return this.isWithinRange(values) && this.hasStepDifference(values);
    }
    /**
     * Update the position of a slider
     * @private
     * @param {string} key
     * @param {Point} position
     * @return {void}
     */

  }, {
    key: 'updatePosition',
    value: function updatePosition(key, position) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());
      positions[key] = position;
      this.lastKeyMoved = key;
      this.updatePositions(positions);
    }
    /**
     * Update the positions of multiple sliders
     * @private
     * @param {Object} positions
     * @param {Point} positions.min
     * @param {Point} positions.max
     * @return {void}
     */

  }, {
    key: 'updatePositions',
    value: function updatePositions(positions) {
      var values = {
        min: valueTransformer.getValueFromPosition(positions.min, this.props.minValue, this.props.maxValue, this.getTrackClientRect()),
        max: valueTransformer.getValueFromPosition(positions.max, this.props.minValue, this.props.maxValue, this.getTrackClientRect())
      };
      var transformedValues = {
        min: valueTransformer.getStepValueFromValue(values.min, this.props.step),
        max: valueTransformer.getStepValueFromValue(values.max, this.props.step)
      };
      this.updateValues(transformedValues);
    }
    /**
     * Update the value of a slider
     * @private
     * @param {string} key
     * @param {number} value
     * @return {void}
     */

  }, {
    key: 'updateValue',
    value: function updateValue(key, value) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      values[key] = value;
      this.updateValues(values);
    }
    /**
     * Update the values of multiple sliders
     * @private
     * @param {Range|number} values
     * @return {void}
     */

  }, {
    key: 'updateValues',
    value: function updateValues(values) {
      if (!this.shouldUpdate(values)) {
        return;
      }

      this.props.onChange(this.isMultiValue() ? values : values.max);
    }
    /**
     * Increment the value of a slider by key name
     * @private
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'incrementValue',
    value: function incrementValue(key) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var value = values[key] + this.props.step;
      this.updateValue(key, value);
    }
    /**
     * Decrement the value of a slider by key name
     * @private
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'decrementValue',
    value: function decrementValue(key) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var value = values[key] - this.props.step;
      this.updateValue(key, value);
    }
    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * Listen to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchEndListener',
    value: function addDocumentTouchEndListener() {
      this.removeDocumentTouchEndListener();
      this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);
    }
    /**
     * Stop listening to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * Stop listening to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchEndListener',
    value: function removeDocumentTouchEndListener() {
      this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);
    }
    /**
     * Handle any "mousemove" event received by the slider
     * @private
     * @param {SyntheticEvent} event
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'handleSliderDrag',
    value: function handleSliderDrag(event, key) {
      var _this2 = this;

      if (this.props.disabled) {
        return;
      }

      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());
      this.isSliderDragging = true;
      requestAnimationFrame(function () {
        return _this2.updatePosition(key, position);
      });
    }
    /**
     * Handle any "mousemove" event received by the track
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTrackDrag',
    value: function handleTrackDrag(event, prevEvent) {
      if (this.props.disabled || !this.props.draggableTrack || this.isSliderDragging) {
        return;
      }

      var _props = this.props,
          maxValue = _props.maxValue,
          minValue = _props.minValue,
          _props$value = _props.value,
          max = _props$value.max,
          min = _props$value.min;
      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());
      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());
      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);
      var prevPosition = valueTransformer.getPositionFromEvent(prevEvent, this.getTrackClientRect());
      var prevValue = valueTransformer.getValueFromPosition(prevPosition, minValue, maxValue, this.getTrackClientRect());
      var prevStepValue = valueTransformer.getStepValueFromValue(prevValue, this.props.step);
      var offset = prevStepValue - stepValue;
      var transformedValues = {
        min: min - offset,
        max: max - offset
      };
      this.updateValues(transformedValues);
    }
    /**
     * Handle any "keydown" event received by the slider
     * @private
     * @param {SyntheticEvent} event
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'handleSliderKeyDown',
    value: function handleSliderKeyDown(event, key) {
      if (this.props.disabled) {
        return;
      }

      switch (event.keyCode) {
        case _keyCodes.LEFT_ARROW:
        case _keyCodes.DOWN_ARROW:
          event.preventDefault();
          this.decrementValue(key);
          break;

        case _keyCodes.RIGHT_ARROW:
        case _keyCodes.UP_ARROW:
          event.preventDefault();
          this.incrementValue(key);
          break;

        default:
          break;
      }
    }
    /**
     * Handle any "mousedown" event received by the track
     * @private
     * @param {SyntheticEvent} event
     * @param {Point} position
     * @return {void}
     */

  }, {
    key: 'handleTrackMouseDown',
    value: function handleTrackMouseDown(event, position) {
      if (this.props.disabled) {
        return;
      }

      var _props2 = this.props,
          maxValue = _props2.maxValue,
          minValue = _props2.minValue,
          _props2$value = _props2.value,
          max = _props2$value.max,
          min = _props2$value.min;
      event.preventDefault();
      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());
      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);

      if (!this.props.draggableTrack || stepValue > max || stepValue < min) {
        this.updatePosition(this.getKeyByPosition(position), position);
      }
    }
    /**
     * Handle the start of any mouse/touch event
     * @private
     * @return {void}
     */

  }, {
    key: 'handleInteractionStart',
    value: function handleInteractionStart() {
      if (this.props.onChangeStart) {
        this.props.onChangeStart(this.props.value);
      }

      if (this.props.onChangeComplete && !(0, _utils.isDefined)(this.startValue)) {
        this.startValue = this.props.value;
      }
    }
    /**
     * Handle the end of any mouse/touch event
     * @private
     * @return {void}
     */

  }, {
    key: 'handleInteractionEnd',
    value: function handleInteractionEnd() {
      if (this.isSliderDragging) {
        this.isSliderDragging = false;
      }

      if (!this.props.onChangeComplete || !(0, _utils.isDefined)(this.startValue)) {
        return;
      }

      if (this.startValue !== this.props.value) {
        this.props.onChangeComplete(this.props.value);
      }

      this.startValue = null;
    }
    /**
     * Handle any "keydown" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.handleInteractionStart(event);
    }
    /**
     * Handle any "keyup" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyUp',
    value: function handleKeyUp(event) {
      this.handleInteractionEnd(event);
    }
    /**
     * Handle any "mousedown" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      this.handleInteractionStart(event);
      this.addDocumentMouseUpListener();
    }
    /**
     * Handle any "mouseup" event received by the component
     * @private
     * @param {SyntheticEvent} event
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      this.handleInteractionEnd(event);
      this.removeDocumentMouseUpListener();
    }
    /**
     * Handle any "touchstart" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      this.handleInteractionStart(event);
      this.addDocumentTouchEndListener();
    }
    /**
     * Handle any "touchend" event received by the component
     * @private
     * @param {SyntheticEvent} event
     */

  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      this.handleInteractionEnd(event);
      this.removeDocumentTouchEndListener();
    }
    /**
     * Return JSX of sliders
     * @private
     * @return {JSX.Element}
     */

  }, {
    key: 'renderSliders',
    value: function renderSliders() {
      var _this3 = this;

      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);
      var keys = this.props.allowSameValues && this.lastKeyMoved === 'min' ? this.getKeys().reverse() : this.getKeys();
      return keys.map(function (key) {
        var value = values[key];
        var percentage = percentages[key];
        var _props3 = _this3.props,
            maxValue = _props3.maxValue,
            minValue = _props3.minValue;

        if (key === 'min') {
          maxValue = values.max;
        } else {
          minValue = values.min;
        }

        var slider = _react2.default.createElement(_slider2.default, {
          ariaLabelledby: _this3.props.ariaLabelledby,
          ariaControls: _this3.props.ariaControls,
          classNames: _this3.props.classNames,
          formatLabel: _this3.props.formatLabel,
          key: key,
          maxValue: maxValue,
          minValue: minValue,
          onSliderDrag: _this3.handleSliderDrag,
          onSliderKeyDown: _this3.handleSliderKeyDown,
          percentage: percentage,
          type: key,
          value: value
        });

        return slider;
      });
    }
    /**
     * Return JSX of hidden inputs
     * @private
     * @return {JSX.Element}
     */

  }, {
    key: 'renderHiddenInputs',
    value: function renderHiddenInputs() {
      var _this4 = this;

      if (!this.props.name) {
        return [];
      }

      var isMultiValue = this.isMultiValue();
      var values = valueTransformer.getValueFromProps(this.props, isMultiValue);
      return this.getKeys().map(function (key) {
        var value = values[key];
        var name = isMultiValue ? '' + _this4.props.name + (0, _utils.captialize)(key) : _this4.props.name;
        return _react2.default.createElement('input', {
          key: key,
          type: 'hidden',
          name: name,
          value: value
        });
      });
    }
    /**
     * @ignore
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var componentClassName = this.getComponentClassName();
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);
      return _react2.default.createElement('div', {
        'aria-disabled': this.props.disabled,
        ref: function ref(node) {
          _this5.node = node;
        },
        className: componentClassName,
        onKeyDown: this.handleKeyDown,
        onKeyUp: this.handleKeyUp,
        onMouseDown: this.handleMouseDown,
        onTouchStart: this.handleTouchStart
      }, _react2.default.createElement(_label2.default, {
        classNames: this.props.classNames,
        formatLabel: this.props.formatLabel,
        type: 'min'
      }, this.props.minValue), _react2.default.createElement(_track2.default, {
        classNames: this.props.classNames,
        draggableTrack: this.props.draggableTrack,
        ref: function ref(trackNode) {
          _this5.trackNode = trackNode;
        },
        percentages: percentages,
        onTrackDrag: this.handleTrackDrag,
        onTrackMouseDown: this.handleTrackMouseDown
      }, this.renderSliders()), _react2.default.createElement(_label2.default, {
        classNames: this.props.classNames,
        formatLabel: this.props.formatLabel,
        type: 'max'
      }, this.props.maxValue), this.renderHiddenInputs());
    }
  }]);

  return InputRange;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleSliderDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleSliderKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionEnd'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchEnd'), _class.prototype)), _class);
exports.default = InputRange;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/key-codes.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/key-codes.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/** @ignore */

var DOWN_ARROW = exports.DOWN_ARROW = 40;
/** @ignore */

var LEFT_ARROW = exports.LEFT_ARROW = 37;
/** @ignore */

var RIGHT_ARROW = exports.RIGHT_ARROW = 39;
/** @ignore */

var UP_ARROW = exports.UP_ARROW = 38;

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/label.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/label.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Label;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * @ignore
 * @param {Object} props
 * @param {InputRangeClassNames} props.classNames
 * @param {Function} props.formatLabel
 * @param {string} props.type
 */


function Label(props) {
  var labelValue = props.formatLabel ? props.formatLabel(props.children, props.type) : props.children;
  return _react2.default.createElement('span', {
    className: props.classNames[props.type + 'Label']
  }, _react2.default.createElement('span', {
    className: props.classNames.labelContainer
  }, labelValue));
}
/**
 * @type {Object}
 * @property {Function} children
 * @property {Function} classNames
 * @property {Function} formatLabel
 * @property {Function} type
 */


Label.propTypes = {
  children: _propTypes2.default.node.isRequired,
  classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
  formatLabel: _propTypes2.default.func,
  type: _propTypes2.default.string.isRequired
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/range-prop-type.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/range-prop-type.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rangePropType;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/react-input-range/lib/js/utils/index.js");
/**
 * @ignore
 * @param {Object} props - React component props
 * @return {?Error} Return Error if validation fails
 */


function rangePropType(props) {
  var maxValue = props.maxValue,
      minValue = props.minValue;

  if (!(0, _utils.isNumber)(minValue) || !(0, _utils.isNumber)(maxValue)) {
    return new Error('"minValue" and "maxValue" must be a number');
  }

  if (minValue >= maxValue) {
    return new Error('"minValue" must be smaller than "maxValue"');
  }
}

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/slider.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/slider.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _desc, _value, _class;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__(/*! autobind-decorator */ "./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _label = __webpack_require__(/*! ./label */ "./node_modules/react-input-range/lib/js/input-range/label.js");

var _label2 = _interopRequireDefault(_label);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}
/**
 * @ignore
 */


var Slider = (_class = function (_React$Component) {
  _inherits(Slider, _React$Component);

  _createClass(Slider, null, [{
    key: 'propTypes',

    /**
     * Accepted propTypes of Slider
     * @override
     * @return {Object}
     * @property {Function} ariaLabelledby
     * @property {Function} ariaControls
     * @property {Function} className
     * @property {Function} formatLabel
     * @property {Function} maxValue
     * @property {Function} minValue
     * @property {Function} onSliderDrag
     * @property {Function} onSliderKeyDown
     * @property {Function} percentage
     * @property {Function} type
     * @property {Function} value
     */
    get: function get() {
      return {
        ariaLabelledby: _propTypes2.default.string,
        ariaControls: _propTypes2.default.string,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
        formatLabel: _propTypes2.default.func,
        maxValue: _propTypes2.default.number,
        minValue: _propTypes2.default.number,
        onSliderDrag: _propTypes2.default.func.isRequired,
        onSliderKeyDown: _propTypes2.default.func.isRequired,
        percentage: _propTypes2.default.number.isRequired,
        type: _propTypes2.default.string.isRequired,
        value: _propTypes2.default.number.isRequired
      };
    }
    /**
     * @param {Object} props
     * @param {string} [props.ariaLabelledby]
     * @param {string} [props.ariaControls]
     * @param {InputRangeClassNames} props.classNames
     * @param {Function} [props.formatLabel]
     * @param {number} [props.maxValue]
     * @param {number} [props.minValue]
     * @param {Function} props.onSliderKeyDown
     * @param {Function} props.onSliderDrag
     * @param {number} props.percentage
     * @param {number} props.type
     * @param {number} props.value
     */

  }]);

  function Slider(props) {
    _classCallCheck(this, Slider);
    /**
     * @private
     * @type {?Component}
     */


    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props));

    _this.node = null;
    return _this;
  }
  /**
   * @ignore
   * @override
   * @return {void}
   */


  _createClass(Slider, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
      this.removeDocumentTouchEndListener();
      this.removeDocumentTouchMoveListener();
    }
    /**
     * @private
     * @return {Object}
     */

  }, {
    key: 'getStyle',
    value: function getStyle() {
      var perc = (this.props.percentage || 0) * 100;
      var style = {
        position: 'absolute',
        left: perc + '%'
      };
      return style;
    }
    /**
     * Listen to mousemove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseMoveListener',
    value: function addDocumentMouseMoveListener() {
      this.removeDocumentMouseMoveListener();
      this.node.ownerDocument.addEventListener('mousemove', this.handleMouseMove);
    }
    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * Listen to touchmove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchMoveListener',
    value: function addDocumentTouchMoveListener() {
      this.removeDocumentTouchMoveListener();
      this.node.ownerDocument.addEventListener('touchmove', this.handleTouchMove);
    }
    /**
     * Listen to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchEndListener',
    value: function addDocumentTouchEndListener() {
      this.removeDocumentTouchEndListener();
      this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseMoveListener',
    value: function removeDocumentMouseMoveListener() {
      this.node.ownerDocument.removeEventListener('mousemove', this.handleMouseMove);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchMoveListener',
    value: function removeDocumentTouchMoveListener() {
      this.node.ownerDocument.removeEventListener('touchmove', this.handleTouchMove);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchEndListener',
    value: function removeDocumentTouchEndListener() {
      this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown() {
      this.addDocumentMouseMoveListener();
      this.addDocumentMouseUpListener();
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
    }
    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      this.props.onSliderDrag(event, this.props.type);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart() {
      this.addDocumentTouchEndListener();
      this.addDocumentTouchMoveListener();
    }
    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTouchMove',
    value: function handleTouchMove(event) {
      this.props.onSliderDrag(event, this.props.type);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd() {
      this.removeDocumentTouchMoveListener();
      this.removeDocumentTouchEndListener();
    }
    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.props.onSliderKeyDown(event, this.props.type);
    }
    /**
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var style = this.getStyle();
      return _react2.default.createElement('span', {
        className: this.props.classNames.sliderContainer,
        ref: function ref(node) {
          _this2.node = node;
        },
        style: style
      }, _react2.default.createElement(_label2.default, {
        classNames: this.props.classNames,
        formatLabel: this.props.formatLabel,
        type: 'value'
      }, this.props.value), _react2.default.createElement('div', {
        'aria-labelledby': this.props.ariaLabelledby,
        'aria-controls': this.props.ariaControls,
        'aria-valuemax': this.props.maxValue,
        'aria-valuemin': this.props.minValue,
        'aria-valuenow': this.props.value,
        className: this.props.classNames.slider,
        draggable: 'false',
        onKeyDown: this.handleKeyDown,
        onMouseDown: this.handleMouseDown,
        onTouchStart: this.handleTouchStart,
        role: 'slider',
        tabIndex: '0'
      }));
    }
  }]);

  return Slider;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchEnd'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype)), _class);
exports.default = Slider;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/track.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/track.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _desc, _value, _class;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__(/*! autobind-decorator */ "./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}
/**
 * @ignore
 */


var Track = (_class = function (_React$Component) {
  _inherits(Track, _React$Component);

  _createClass(Track, null, [{
    key: 'propTypes',

    /**
     * @override
     * @return {Object}
     * @property {Function} children
     * @property {Function} classNames
     * @property {Boolean} draggableTrack
     * @property {Function} onTrackDrag
     * @property {Function} onTrackMouseDown
     * @property {Function} percentages
     */
    get: function get() {
      return {
        children: _propTypes2.default.node.isRequired,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
        draggableTrack: _propTypes2.default.bool,
        onTrackDrag: _propTypes2.default.func,
        onTrackMouseDown: _propTypes2.default.func.isRequired,
        percentages: _propTypes2.default.objectOf(_propTypes2.default.number).isRequired
      };
    }
    /**
     * @param {Object} props
     * @param {InputRangeClassNames} props.classNames
     * @param {Boolean} props.draggableTrack
     * @param {Function} props.onTrackDrag
     * @param {Function} props.onTrackMouseDown
     * @param {number} props.percentages
     */

  }]);

  function Track(props) {
    _classCallCheck(this, Track);
    /**
     * @private
     * @type {?Component}
     */


    var _this = _possibleConstructorReturn(this, (Track.__proto__ || Object.getPrototypeOf(Track)).call(this, props));

    _this.node = null;
    _this.trackDragEvent = null;
    return _this;
  }
  /**
   * @private
   * @return {ClientRect}
   */


  _createClass(Track, [{
    key: 'getClientRect',
    value: function getClientRect() {
      return this.node.getBoundingClientRect();
    }
    /**
     * @private
     * @return {Object} CSS styles
     */

  }, {
    key: 'getActiveTrackStyle',
    value: function getActiveTrackStyle() {
      var width = (this.props.percentages.max - this.props.percentages.min) * 100 + '%';
      var left = this.props.percentages.min * 100 + '%';
      return {
        left: left,
        width: width
      };
    }
    /**
     * Listen to mousemove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseMoveListener',
    value: function addDocumentMouseMoveListener() {
      this.removeDocumentMouseMoveListener();
      this.node.ownerDocument.addEventListener('mousemove', this.handleMouseMove);
    }
    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseMoveListener',
    value: function removeDocumentMouseMoveListener() {
      this.node.ownerDocument.removeEventListener('mousemove', this.handleMouseMove);
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }
    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      if (!this.props.draggableTrack) {
        return;
      }

      if (this.trackDragEvent !== null) {
        this.props.onTrackDrag(event, this.trackDragEvent);
      }

      this.trackDragEvent = event;
    }
    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      if (!this.props.draggableTrack) {
        return;
      }

      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
      this.trackDragEvent = null;
    }
    /**
     * @private
     * @param {SyntheticEvent} event - User event
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      var clientX = event.touches ? event.touches[0].clientX : event.clientX;
      var trackClientRect = this.getClientRect();
      var position = {
        x: clientX - trackClientRect.left,
        y: 0
      };
      this.props.onTrackMouseDown(event, position);

      if (this.props.draggableTrack) {
        this.addDocumentMouseMoveListener();
        this.addDocumentMouseUpListener();
      }
    }
    /**
     * @private
     * @param {SyntheticEvent} event - User event
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      event.preventDefault();
      this.handleMouseDown(event);
    }
    /**
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var activeTrackStyle = this.getActiveTrackStyle();
      return _react2.default.createElement('div', {
        className: this.props.classNames.track,
        onMouseDown: this.handleMouseDown,
        onTouchStart: this.handleTouchStart,
        ref: function ref(node) {
          _this2.node = node;
        }
      }, _react2.default.createElement('div', {
        style: activeTrackStyle,
        className: this.props.classNames.activeTrack
      }), this.props.children);
    }
  }]);

  return Track;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleMouseMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype)), _class);
exports.default = Track;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/value-prop-type.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/value-prop-type.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valuePropType;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/react-input-range/lib/js/utils/index.js");
/**
 * @ignore
 * @param {Object} props
 * @return {?Error} Return Error if validation fails
 */


function valuePropType(props, propName) {
  var maxValue = props.maxValue,
      minValue = props.minValue;
  var value = props[propName];

  if (!(0, _utils.isNumber)(value) && (!(0, _utils.isObject)(value) || !(0, _utils.isNumber)(value.min) || !(0, _utils.isNumber)(value.max))) {
    return new Error('"' + propName + '" must be a number or a range object');
  }

  if ((0, _utils.isNumber)(value) && (value < minValue || value > maxValue)) {
    return new Error('"' + propName + '" must be in between "minValue" and "maxValue"');
  }

  if ((0, _utils.isObject)(value) && (value.min < minValue || value.min > maxValue || value.max < minValue || value.max > maxValue)) {
    return new Error('"' + propName + '" must be in between "minValue" and "maxValue"');
  }
}

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/value-transformer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/input-range/value-transformer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.getPercentageFromPosition = getPercentageFromPosition;
exports.getValueFromPosition = getValueFromPosition;
exports.getValueFromProps = getValueFromProps;
exports.getPercentageFromValue = getPercentageFromValue;
exports.getPercentagesFromValues = getPercentagesFromValues;
exports.getPositionFromValue = getPositionFromValue;
exports.getPositionsFromValues = getPositionsFromValues;
exports.getPositionFromEvent = getPositionFromEvent;
exports.getStepValueFromValue = getStepValueFromValue;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/react-input-range/lib/js/utils/index.js");
/**
 * Convert a point into a percentage value
 * @ignore
 * @param {Point} position
 * @param {ClientRect} clientRect
 * @return {number} Percentage value
 */


function getPercentageFromPosition(position, clientRect) {
  var length = clientRect.width;
  var sizePerc = position.x / length;
  return sizePerc || 0;
}
/**
 * Convert a point into a model value
 * @ignore
 * @param {Point} position
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {number}
 */


function getValueFromPosition(position, minValue, maxValue, clientRect) {
  var sizePerc = getPercentageFromPosition(position, clientRect);
  var valueDiff = maxValue - minValue;
  return minValue + valueDiff * sizePerc;
}
/**
 * Convert props into a range value
 * @ignore
 * @param {Object} props
 * @param {boolean} isMultiValue
 * @return {Range}
 */


function getValueFromProps(props, isMultiValue) {
  if (isMultiValue) {
    return _extends({}, props.value);
  }

  return {
    min: props.minValue,
    max: props.value
  };
}
/**
 * Convert a model value into a percentage value
 * @ignore
 * @param {number} value
 * @param {number} minValue
 * @param {number} maxValue
 * @return {number}
 */


function getPercentageFromValue(value, minValue, maxValue) {
  var validValue = (0, _utils.clamp)(value, minValue, maxValue);
  var valueDiff = maxValue - minValue;
  var valuePerc = (validValue - minValue) / valueDiff;
  return valuePerc || 0;
}
/**
 * Convert model values into percentage values
 * @ignore
 * @param {Range} values
 * @param {number} minValue
 * @param {number} maxValue
 * @return {Range}
 */


function getPercentagesFromValues(values, minValue, maxValue) {
  return {
    min: getPercentageFromValue(values.min, minValue, maxValue),
    max: getPercentageFromValue(values.max, minValue, maxValue)
  };
}
/**
 * Convert a value into a point
 * @ignore
 * @param {number} value
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {Point} Position
 */


function getPositionFromValue(value, minValue, maxValue, clientRect) {
  var length = clientRect.width;
  var valuePerc = getPercentageFromValue(value, minValue, maxValue);
  var positionValue = valuePerc * length;
  return {
    x: positionValue,
    y: 0
  };
}
/**
 * Convert a range of values into points
 * @ignore
 * @param {Range} values
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {Range}
 */


function getPositionsFromValues(values, minValue, maxValue, clientRect) {
  return {
    min: getPositionFromValue(values.min, minValue, maxValue, clientRect),
    max: getPositionFromValue(values.max, minValue, maxValue, clientRect)
  };
}
/**
 * Convert an event into a point
 * @ignore
 * @param {Event} event
 * @param {ClientRect} clientRect
 * @return {Point}
 */


function getPositionFromEvent(event, clientRect) {
  var length = clientRect.width;

  var _ref = event.touches ? event.touches[0] : event,
      clientX = _ref.clientX;

  return {
    x: (0, _utils.clamp)(clientX - clientRect.left, 0, length),
    y: 0
  };
}
/**
 * Convert a value into a step value
 * @ignore
 * @param {number} value
 * @param {number} valuePerStep
 * @return {number}
 */


function getStepValueFromValue(value, valuePerStep) {
  return Math.round(value / valuePerStep) * valuePerStep;
}

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/captialize.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/captialize.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = captialize;
/**
 * Captialize a string
 * @ignore
 * @param {string} string
 * @return {string}
 */

function captialize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

module.exports = exports["default"];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/clamp.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/clamp.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clamp;
/**
 * Clamp a value between a min and max value
 * @ignore
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

module.exports = exports["default"];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/distance-to.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/distance-to.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = distanceTo;
/**
 * Calculate the distance between pointA and pointB
 * @ignore
 * @param {Point} pointA
 * @param {Point} pointB
 * @return {number} Distance
 */

function distanceTo(pointA, pointB) {
  var xDiff = Math.pow(pointB.x - pointA.x, 2);
  var yDiff = Math.pow(pointB.y - pointA.y, 2);
  return Math.sqrt(xDiff + yDiff);
}

module.exports = exports["default"];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _captialize = __webpack_require__(/*! ./captialize */ "./node_modules/react-input-range/lib/js/utils/captialize.js");

Object.defineProperty(exports, 'captialize', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_captialize).default;
  }
});

var _clamp = __webpack_require__(/*! ./clamp */ "./node_modules/react-input-range/lib/js/utils/clamp.js");

Object.defineProperty(exports, 'clamp', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_clamp).default;
  }
});

var _distanceTo = __webpack_require__(/*! ./distance-to */ "./node_modules/react-input-range/lib/js/utils/distance-to.js");

Object.defineProperty(exports, 'distanceTo', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_distanceTo).default;
  }
});

var _isDefined = __webpack_require__(/*! ./is-defined */ "./node_modules/react-input-range/lib/js/utils/is-defined.js");

Object.defineProperty(exports, 'isDefined', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isDefined).default;
  }
});

var _isNumber = __webpack_require__(/*! ./is-number */ "./node_modules/react-input-range/lib/js/utils/is-number.js");

Object.defineProperty(exports, 'isNumber', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isNumber).default;
  }
});

var _isObject = __webpack_require__(/*! ./is-object */ "./node_modules/react-input-range/lib/js/utils/is-object.js");

Object.defineProperty(exports, 'isObject', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isObject).default;
  }
});

var _length = __webpack_require__(/*! ./length */ "./node_modules/react-input-range/lib/js/utils/length.js");

Object.defineProperty(exports, 'length', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_length).default;
  }
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-defined.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/is-defined.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isDefined;
/**
 * Check if a value is defined
 * @ignore
 * @param {*} value
 * @return {boolean}
 */

function isDefined(value) {
  return value !== undefined && value !== null;
}

module.exports = exports["default"];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-number.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/is-number.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNumber;
/**
 * Check if a value is a number
 * @ignore
 * @param {*} value
 * @return {boolean}
 */

function isNumber(value) {
  return typeof value === 'number';
}

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/is-object.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

exports.default = isObject;
/**
 * Check if a value is an object
 * @ignore
 * @param {*} value
 * @return {boolean}
 */

function isObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/length.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-input-range/lib/js/utils/length.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = length;
/**
 * Calculate the absolute difference between two numbers
 * @ignore
 * @param {number} numA
 * @param {number} numB
 * @return {number}
 */

function length(numA, numB) {
  return Math.abs(numA - numB);
}

module.exports = exports["default"];

/***/ }),

/***/ "./node_modules/react-sortable-hoc/dist/react-sortable-hoc.umd.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-sortable-hoc/dist/react-sortable-hoc.umd.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! react */ "./node_modules/react/index.js"), __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"), __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js")) : undefined;
})(this, function (exports, React, PropTypes, reactDom) {
  'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    module.exports = _extends;
  });

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof2(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof2(obj) {
          return typeof obj;
        };
      } else {
        _typeof2 = function _typeof2(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof2(obj);
    }

    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;
  var getPrototypeOf = createCommonjsModule(function (module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    module.exports = _getPrototypeOf;
  });
  var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var invariant = function (condition, format, a, b, c, d, e, f) {
    {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame

      throw error;
    }
  };

  var invariant_1 = invariant;

  var Manager = function () {
    function Manager() {
      classCallCheck(this, Manager);
      defineProperty(this, "refs", {});
    }

    createClass(Manager, [{
      key: "add",
      value: function add(collection, ref) {
        if (!this.refs[collection]) {
          this.refs[collection] = [];
        }

        this.refs[collection].push(ref);
      }
    }, {
      key: "remove",
      value: function remove(collection, ref) {
        var index = this.getIndex(collection, ref);

        if (index !== -1) {
          this.refs[collection].splice(index, 1);
        }
      }
    }, {
      key: "isActive",
      value: function isActive() {
        return this.active;
      }
    }, {
      key: "getActive",
      value: function getActive() {
        var _this = this;

        return this.refs[this.active.collection].find(function (_ref) {
          var node = _ref.node;
          return node.sortableInfo.index == _this.active.index;
        });
      }
    }, {
      key: "getIndex",
      value: function getIndex(collection, ref) {
        return this.refs[collection].indexOf(ref);
      }
    }, {
      key: "getOrderedRefs",
      value: function getOrderedRefs() {
        var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active.collection;
        return this.refs[collection].sort(sortByIndex);
      }
    }]);
    return Manager;
  }();

  function sortByIndex(_ref2, _ref3) {
    var index1 = _ref2.node.sortableInfo.index;
    var index2 = _ref3.node.sortableInfo.index;
    return index1 - index2;
  }

  function arrayMove(array, from, to) {
    {
      if (typeof console !== 'undefined') {
        console.warn("Deprecation warning: arrayMove will no longer be exported by 'react-sortable-hoc' in the next major release. Please install the `array-move` package locally instead. https://www.npmjs.com/package/array-move");
      }
    }
    array = array.slice();
    array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);
    return array;
  }

  function omit(obj) {
    for (var _len = arguments.length, keysToOmit = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      keysToOmit[_key - 1] = arguments[_key];
    }

    return Object.keys(obj).reduce(function (acc, key) {
      if (keysToOmit.indexOf(key) === -1) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  var events = {
    end: ['touchend', 'touchcancel', 'mouseup'],
    move: ['touchmove', 'mousemove'],
    start: ['touchstart', 'mousedown']
  };

  var vendorPrefix = function () {
    if (typeof window === 'undefined' || typeof document === 'undefined') {
      return '';
    }

    var styles = window.getComputedStyle(document.documentElement, '') || ['-moz-hidden-iframe'];
    var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

    switch (pre) {
      case 'ms':
        return 'ms';

      default:
        return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';
    }
  }();

  function setInlineStyles(node, styles) {
    Object.keys(styles).forEach(function (key) {
      node.style[key] = styles[key];
    });
  }

  function setTranslate3d(node, translate) {
    node.style["".concat(vendorPrefix, "Transform")] = translate == null ? '' : "translate3d(".concat(translate.x, "px,").concat(translate.y, "px,0)");
  }

  function setTransitionDuration(node, duration) {
    node.style["".concat(vendorPrefix, "TransitionDuration")] = duration == null ? '' : "".concat(duration, "ms");
  }

  function closest(el, fn) {
    while (el) {
      if (fn(el)) {
        return el;
      }

      el = el.parentNode;
    }

    return null;
  }

  function limit(min, max, value) {
    return Math.max(min, Math.min(value, max));
  }

  function getPixelValue(stringValue) {
    if (stringValue.substr(-2) === 'px') {
      return parseFloat(stringValue);
    }

    return 0;
  }

  function getElementMargin(element) {
    var style = window.getComputedStyle(element);
    return {
      bottom: getPixelValue(style.marginBottom),
      left: getPixelValue(style.marginLeft),
      right: getPixelValue(style.marginRight),
      top: getPixelValue(style.marginTop)
    };
  }

  function provideDisplayName(prefix, Component) {
    var componentName = Component.displayName || Component.name;
    return componentName ? "".concat(prefix, "(").concat(componentName, ")") : prefix;
  }

  function getPosition(event) {
    if (event.touches && event.touches.length) {
      return {
        x: event.touches[0].pageX,
        y: event.touches[0].pageY
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      return {
        x: event.changedTouches[0].pageX,
        y: event.changedTouches[0].pageY
      };
    } else {
      return {
        x: event.pageX,
        y: event.pageY
      };
    }
  }

  function isTouchEvent(event) {
    return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;
  }

  function getEdgeOffset(node, parent) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      left: 0,
      top: 0
    };

    if (!node) {
      return undefined;
    }

    var nodeOffset = {
      left: offset.left + node.offsetLeft,
      top: offset.top + node.offsetTop
    };

    if (node.parentNode === parent) {
      return nodeOffset;
    }

    return getEdgeOffset(node.parentNode, parent, nodeOffset);
  }

  function getLockPixelOffset(_ref) {
    var lockOffset = _ref.lockOffset,
        width = _ref.width,
        height = _ref.height;
    var offsetX = lockOffset;
    var offsetY = lockOffset;
    var unit = 'px';

    if (typeof lockOffset === 'string') {
      var match = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(lockOffset);
      invariant_1(match !== null, 'lockOffset value should be a number or a string of a ' + 'number followed by "px" or "%". Given %s', lockOffset);
      offsetX = parseFloat(lockOffset);
      offsetY = parseFloat(lockOffset);
      unit = match[1];
    }

    invariant_1(isFinite(offsetX) && isFinite(offsetY), 'lockOffset value should be a finite. Given %s', lockOffset);

    if (unit === '%') {
      offsetX = offsetX * width / 100;
      offsetY = offsetY * height / 100;
    }

    return {
      x: offsetX,
      y: offsetY
    };
  }

  function getLockPixelOffsets(_ref2) {
    var height = _ref2.height,
        width = _ref2.width,
        lockOffset = _ref2.lockOffset;
    var offsets = Array.isArray(lockOffset) ? lockOffset : [lockOffset, lockOffset];
    invariant_1(offsets.length === 2, 'lockOffset prop of SortableContainer should be a single ' + 'value or an array of exactly two values. Given %s', lockOffset);

    var _offsets = slicedToArray(offsets, 2),
        minLockOffset = _offsets[0],
        maxLockOffset = _offsets[1];

    return [getLockPixelOffset({
      height: height,
      lockOffset: minLockOffset,
      width: width
    }), getLockPixelOffset({
      height: height,
      lockOffset: maxLockOffset,
      width: width
    })];
  }

  function isScrollable(el) {
    var computedStyle = window.getComputedStyle(el);
    var overflowRegex = /(auto|scroll)/;
    var properties = ['overflow', 'overflowX', 'overflowY'];
    return properties.find(function (property) {
      return overflowRegex.test(computedStyle[property]);
    });
  }

  function getScrollingParent(el) {
    if (!(el instanceof HTMLElement)) {
      return null;
    } else if (isScrollable(el)) {
      return el;
    } else {
      return getScrollingParent(el.parentNode);
    }
  }

  var NodeType = {
    Anchor: 'A',
    Button: 'BUTTON',
    Canvas: 'CANVAS',
    Input: 'INPUT',
    Option: 'OPTION',
    Textarea: 'TEXTAREA',
    Select: 'SELECT'
  };

  function sortableHandle(WrappedComponent) {
    var _class, _temp;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      withRef: false
    };
    return _temp = _class = function (_React$Component) {
      inherits(WithSortableHandle, _React$Component);

      function WithSortableHandle() {
        classCallCheck(this, WithSortableHandle);
        return possibleConstructorReturn(this, getPrototypeOf(WithSortableHandle).apply(this, arguments));
      }

      createClass(WithSortableHandle, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var node = reactDom.findDOMNode(this);
          node.sortableHandle = true;
        }
      }, {
        key: "getWrappedInstance",
        value: function getWrappedInstance() {
          invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call');
          return this.refs.wrappedInstance;
        }
      }, {
        key: "render",
        value: function render() {
          var ref = config.withRef ? 'wrappedInstance' : null;
          return React.createElement(WrappedComponent, _extends_1({
            ref: ref
          }, this.props));
        }
      }]);
      return WithSortableHandle;
    }(React.Component), defineProperty(_class, "displayName", provideDisplayName('sortableHandle', WrappedComponent)), _temp;
  }

  function isSortableHandle(node) {
    return node.sortableHandle != null;
  }

  var AutoScroller = function () {
    function AutoScroller(container, onScrollCallback) {
      classCallCheck(this, AutoScroller);
      this.container = container;
      this.onScrollCallback = onScrollCallback;
    }

    createClass(AutoScroller, [{
      key: "clear",
      value: function clear() {
        clearInterval(this.interval);
        this.interval = null;
      }
    }, {
      key: "update",
      value: function update(_ref) {
        var _this = this;

        var translate = _ref.translate,
            minTranslate = _ref.minTranslate,
            maxTranslate = _ref.maxTranslate,
            width = _ref.width,
            height = _ref.height;
        var direction = {
          x: 0,
          y: 0
        };
        var speed = {
          x: 1,
          y: 1
        };
        var acceleration = {
          x: 10,
          y: 10
        };
        var _this$container = this.container,
            scrollTop = _this$container.scrollTop,
            scrollLeft = _this$container.scrollLeft,
            scrollHeight = _this$container.scrollHeight,
            scrollWidth = _this$container.scrollWidth,
            clientHeight = _this$container.clientHeight,
            clientWidth = _this$container.clientWidth;
        var isTop = scrollTop === 0;
        var isBottom = scrollHeight - scrollTop - clientHeight === 0;
        var isLeft = scrollLeft === 0;
        var isRight = scrollWidth - scrollLeft - clientWidth === 0;

        if (translate.y >= maxTranslate.y - height / 2 && !isBottom) {
          direction.y = 1;
          speed.y = acceleration.y * Math.abs((maxTranslate.y - height / 2 - translate.y) / height);
        } else if (translate.x >= maxTranslate.x - width / 2 && !isRight) {
          direction.x = 1;
          speed.x = acceleration.x * Math.abs((maxTranslate.x - width / 2 - translate.x) / width);
        } else if (translate.y <= minTranslate.y + height / 2 && !isTop) {
          direction.y = -1;
          speed.y = acceleration.y * Math.abs((translate.y - height / 2 - minTranslate.y) / height);
        } else if (translate.x <= minTranslate.x + width / 2 && !isLeft) {
          direction.x = -1;
          speed.x = acceleration.x * Math.abs((translate.x - width / 2 - minTranslate.x) / width);
        }

        if (this.interval) {
          this.clear();
          this.isAutoScrolling = false;
        }

        if (direction.x !== 0 || direction.y !== 0) {
          this.interval = setInterval(function () {
            _this.isAutoScrolling = true;
            var offset = {
              left: speed.x * direction.x,
              top: speed.y * direction.y
            };
            _this.container.scrollTop += offset.top;
            _this.container.scrollLeft += offset.left;

            _this.onScrollCallback(offset);
          }, 5);
        }
      }
    }]);
    return AutoScroller;
  }();

  function defaultGetHelperDimensions(_ref) {
    var node = _ref.node;
    return {
      height: node.offsetHeight,
      width: node.offsetWidth
    };
  }

  function defaultShouldCancelStart(event) {
    var disabledElements = [NodeType.Input, NodeType.Textarea, NodeType.Select, NodeType.Option, NodeType.Button];

    if (disabledElements.indexOf(event.target.tagName) !== -1) {
      return true;
    }

    return false;
  }

  var propTypes = {
    axis: PropTypes.oneOf(['x', 'y', 'xy']),
    contentWindow: PropTypes.any,
    disableAutoscroll: PropTypes.bool,
    distance: PropTypes.number,
    getContainer: PropTypes.func,
    getHelperDimensions: PropTypes.func,
    helperClass: PropTypes.string,
    helperContainer: PropTypes.oneOfType([PropTypes.func, typeof HTMLElement === 'undefined' ? PropTypes.any : PropTypes.instanceOf(HTMLElement)]),
    hideSortableGhost: PropTypes.bool,
    lockAxis: PropTypes.string,
    lockOffset: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]))]),
    lockToContainerEdges: PropTypes.bool,
    onSortEnd: PropTypes.func,
    onSortMove: PropTypes.func,
    onSortOver: PropTypes.func,
    onSortStart: PropTypes.func,
    pressDelay: PropTypes.number,
    pressThreshold: PropTypes.number,
    shouldCancelStart: PropTypes.func,
    transitionDuration: PropTypes.number,
    updateBeforeSortStart: PropTypes.func,
    useDragHandle: PropTypes.bool,
    useWindowAsScrollContainer: PropTypes.bool
  };
  var defaultProps = {
    axis: 'y',
    disableAutoscroll: false,
    distance: 0,
    getHelperDimensions: defaultGetHelperDimensions,
    hideSortableGhost: true,
    lockOffset: '50%',
    lockToContainerEdges: false,
    pressDelay: 0,
    pressThreshold: 5,
    shouldCancelStart: defaultShouldCancelStart,
    transitionDuration: 300,
    useWindowAsScrollContainer: false
  };
  var omittedProps = Object.keys(propTypes);

  function validateProps(props) {
    invariant_1(!(props.distance && props.pressDelay), 'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.');
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, value);
  }

  function sortableContainer(WrappedComponent) {
    var _class, _temp;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      withRef: false
    };
    return _temp = _class = function (_React$Component) {
      inherits(WithSortableContainer, _React$Component);

      function WithSortableContainer(props) {
        var _this;

        classCallCheck(this, WithSortableContainer);
        _this = possibleConstructorReturn(this, getPrototypeOf(WithSortableContainer).call(this, props));
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleStart", function (event) {
          var _this$props = _this.props,
              distance = _this$props.distance,
              shouldCancelStart = _this$props.shouldCancelStart;

          if (event.button === 2 || shouldCancelStart(event)) {
            return;
          }

          _this.touched = true;
          _this.position = getPosition(event);
          var node = closest(event.target, function (el) {
            return el.sortableInfo != null;
          });

          if (node && node.sortableInfo && _this.nodeIsChild(node) && !_this.state.sorting) {
            var useDragHandle = _this.props.useDragHandle;
            var _node$sortableInfo = node.sortableInfo,
                index = _node$sortableInfo.index,
                collection = _node$sortableInfo.collection,
                disabled = _node$sortableInfo.disabled;

            if (disabled) {
              return;
            }

            if (useDragHandle && !closest(event.target, isSortableHandle)) {
              return;
            }

            _this.manager.active = {
              collection: collection,
              index: index
            };

            if (!isTouchEvent(event) && event.target.tagName === NodeType.Anchor) {
              event.preventDefault();
            }

            if (!distance) {
              if (_this.props.pressDelay === 0) {
                _this.handlePress(event);
              } else {
                _this.pressTimer = setTimeout(function () {
                  return _this.handlePress(event);
                }, _this.props.pressDelay);
              }
            }
          }
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "nodeIsChild", function (node) {
          return node.sortableInfo.manager === _this.manager;
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleMove", function (event) {
          var _this$props2 = _this.props,
              distance = _this$props2.distance,
              pressThreshold = _this$props2.pressThreshold;

          if (!_this.state.sorting && _this.touched && !_this._awaitingUpdateBeforeSortStart) {
            var position = getPosition(event);
            var delta = {
              x: _this.position.x - position.x,
              y: _this.position.y - position.y
            };
            var combinedDelta = Math.abs(delta.x) + Math.abs(delta.y);
            _this.delta = delta;

            if (!distance && (!pressThreshold || combinedDelta >= pressThreshold)) {
              clearTimeout(_this.cancelTimer);
              _this.cancelTimer = setTimeout(_this.cancel, 0);
            } else if (distance && combinedDelta >= distance && _this.manager.isActive()) {
              _this.handlePress(event);
            }
          }
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleEnd", function () {
          _this.touched = false;

          _this.cancel();
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "cancel", function () {
          var distance = _this.props.distance;
          var sorting = _this.state.sorting;

          if (!sorting) {
            if (!distance) {
              clearTimeout(_this.pressTimer);
            }

            _this.manager.active = null;
          }
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handlePress", function (event) {
          try {
            var active = _this.manager.getActive();

            var _temp6 = function () {
              if (active) {
                var _temp7 = function _temp7() {
                  var index = _node.sortableInfo.index;
                  var margin = getElementMargin(_node);

                  var containerBoundingRect = _this.scrollContainer.getBoundingClientRect();

                  var dimensions = _getHelperDimensions({
                    collection: _collection,
                    index: index,
                    node: _node
                  });

                  _this.node = _node;
                  _this.margin = margin;
                  _this.width = dimensions.width;
                  _this.height = dimensions.height;
                  _this.marginOffset = {
                    x: _this.margin.left + _this.margin.right,
                    y: Math.max(_this.margin.top, _this.margin.bottom)
                  };
                  _this.boundingClientRect = _node.getBoundingClientRect();
                  _this.containerBoundingRect = containerBoundingRect;
                  _this.index = index;
                  _this.newIndex = index;
                  _this.axis = {
                    x: _axis.indexOf('x') >= 0,
                    y: _axis.indexOf('y') >= 0
                  };
                  _this.offsetEdge = getEdgeOffset(_node, _this.container);
                  _this.initialOffset = getPosition(event);
                  _this.initialScroll = {
                    left: _this.scrollContainer.scrollLeft,
                    top: _this.scrollContainer.scrollTop
                  };
                  _this.initialWindowScroll = {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                  };

                  var fields = _node.querySelectorAll('input, textarea, select, canvas');

                  var clonedNode = _node.cloneNode(true);

                  var clonedFields = toConsumableArray(clonedNode.querySelectorAll('input, textarea, select, canvas'));
                  clonedFields.forEach(function (field, i) {
                    if (field.type !== 'file' && fields[index]) {
                      field.value = fields[i].value;
                    }

                    if (field.tagName === NodeType.Canvas) {
                      var destCtx = field.getContext('2d');
                      destCtx.drawImage(fields[i], 0, 0);
                    }
                  });
                  _this.helper = _this.helperContainer.appendChild(clonedNode);
                  setInlineStyles(_this.helper, {
                    boxSizing: 'border-box',
                    height: "".concat(_this.height, "px"),
                    left: "".concat(_this.boundingClientRect.left - margin.left, "px"),
                    pointerEvents: 'none',
                    position: 'fixed',
                    top: "".concat(_this.boundingClientRect.top - margin.top, "px"),
                    width: "".concat(_this.width, "px")
                  });

                  if (_hideSortableGhost) {
                    _this.sortableGhost = _node;
                    setInlineStyles(_node, {
                      opacity: 0,
                      visibility: 'hidden'
                    });
                  }

                  _this.minTranslate = {};
                  _this.maxTranslate = {};

                  if (_this.axis.x) {
                    _this.minTranslate.x = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - _this.boundingClientRect.left - _this.width / 2;
                    _this.maxTranslate.x = (_useWindowAsScrollContainer ? _this.contentWindow.innerWidth : containerBoundingRect.left + containerBoundingRect.width) - _this.boundingClientRect.left - _this.width / 2;
                  }

                  if (_this.axis.y) {
                    _this.minTranslate.y = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - _this.boundingClientRect.top - _this.height / 2;
                    _this.maxTranslate.y = (_useWindowAsScrollContainer ? _this.contentWindow.innerHeight : containerBoundingRect.top + containerBoundingRect.height) - _this.boundingClientRect.top - _this.height / 2;
                  }

                  if (_helperClass) {
                    _helperClass.split(' ').forEach(function (className) {
                      return _this.helper.classList.add(className);
                    });
                  }

                  _this.listenerNode = event.touches ? _node : _this.contentWindow;
                  events.move.forEach(function (eventName) {
                    return _this.listenerNode.addEventListener(eventName, _this.handleSortMove, false);
                  });
                  events.end.forEach(function (eventName) {
                    return _this.listenerNode.addEventListener(eventName, _this.handleSortEnd, false);
                  });

                  _this.setState({
                    sorting: true,
                    sortingIndex: index
                  });

                  if (_onSortStart) {
                    _onSortStart({
                      collection: _collection,
                      index: index,
                      node: _node
                    }, event);
                  }
                };

                var _this$props3 = _this.props,
                    _axis = _this$props3.axis,
                    _getHelperDimensions = _this$props3.getHelperDimensions,
                    _helperClass = _this$props3.helperClass,
                    _hideSortableGhost = _this$props3.hideSortableGhost,
                    updateBeforeSortStart = _this$props3.updateBeforeSortStart,
                    _onSortStart = _this$props3.onSortStart,
                    _useWindowAsScrollContainer = _this$props3.useWindowAsScrollContainer;
                var _node = active.node,
                    _collection = active.collection;

                var _temp8 = function () {
                  if (typeof updateBeforeSortStart === 'function') {
                    _this._awaitingUpdateBeforeSortStart = true;

                    var _temp9 = _finallyRethrows(function () {
                      var index = _node.sortableInfo.index;
                      return Promise.resolve(updateBeforeSortStart({
                        collection: _collection,
                        index: index,
                        node: _node
                      }, event)).then(function () {});
                    }, function (_wasThrown, _result) {
                      _this._awaitingUpdateBeforeSortStart = false;
                      if (_wasThrown) throw _result;
                      return _result;
                    });

                    if (_temp9 && _temp9.then) return _temp9.then(function () {});
                  }
                }();

                return _temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8);
              }
            }();

            return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {}) : void 0);
          } catch (e) {
            return Promise.reject(e);
          }
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleSortMove", function (event) {
          var onSortMove = _this.props.onSortMove;
          event.preventDefault();

          _this.updateHelperPosition(event);

          _this.animateNodes();

          _this.autoscroll();

          if (onSortMove) {
            onSortMove(event);
          }
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleSortEnd", function (event) {
          var _this$props4 = _this.props,
              hideSortableGhost = _this$props4.hideSortableGhost,
              onSortEnd = _this$props4.onSortEnd;
          var collection = _this.manager.active.collection;
          var nodes = _this.manager.refs[collection];

          if (_this.listenerNode) {
            events.move.forEach(function (eventName) {
              return _this.listenerNode.removeEventListener(eventName, _this.handleSortMove);
            });
            events.end.forEach(function (eventName) {
              return _this.listenerNode.removeEventListener(eventName, _this.handleSortEnd);
            });
          }

          _this.helper.parentNode.removeChild(_this.helper);

          if (hideSortableGhost && _this.sortableGhost) {
            setInlineStyles(_this.sortableGhost, {
              opacity: '',
              visibility: ''
            });
          }

          for (var i = 0, len = nodes.length; i < len; i++) {
            var _node2 = nodes[i];
            var el = _node2.node;
            _node2.edgeOffset = null;
            setTranslate3d(el, null);
            setTransitionDuration(el, null);
          }

          _this.autoScroller.clear();

          _this.manager.active = null;

          _this.setState({
            sorting: false,
            sortingIndex: null
          });

          if (typeof onSortEnd === 'function') {
            onSortEnd({
              collection: collection,
              newIndex: _this.newIndex,
              oldIndex: _this.index
            }, event);
          }

          _this.touched = false;
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "autoscroll", function () {
          var disableAutoscroll = _this.props.disableAutoscroll;

          if (disableAutoscroll) {
            return;
          }

          _this.autoScroller.update({
            height: _this.height,
            maxTranslate: _this.maxTranslate,
            minTranslate: _this.minTranslate,
            translate: _this.translate,
            width: _this.width
          });
        });
        defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAutoScroll", function (offset) {
          _this.translate.x += offset.left;
          _this.translate.y += offset.top;

          _this.animateNodes();
        });
        validateProps(props);
        _this.state = {};
        _this.manager = new Manager();
        _this.events = {
          end: _this.handleEnd,
          move: _this.handleMove,
          start: _this.handleStart
        };
        return _this;
      }

      createClass(WithSortableContainer, [{
        key: "getChildContext",
        value: function getChildContext() {
          return {
            manager: this.manager
          };
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;

          var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;
          var container = this.getContainer();
          Promise.resolve(container).then(function (containerNode) {
            _this2.container = containerNode;
            _this2.document = _this2.container.ownerDocument || document;
            var contentWindow = _this2.props.contentWindow || _this2.document.defaultView || window;
            _this2.contentWindow = typeof contentWindow === 'function' ? contentWindow() : contentWindow;
            _this2.scrollContainer = useWindowAsScrollContainer ? _this2.document.scrollingElement || _this2.document.documentElement : getScrollingParent(_this2.container) || _this2.container;
            _this2.autoScroller = new AutoScroller(_this2.scrollContainer, _this2.onAutoScroll);
            Object.keys(_this2.events).forEach(function (key) {
              return events[key].forEach(function (eventName) {
                return _this2.container.addEventListener(eventName, _this2.events[key], false);
              });
            });
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var _this3 = this;

          if (this.container) {
            Object.keys(this.events).forEach(function (key) {
              return events[key].forEach(function (eventName) {
                return _this3.container.removeEventListener(eventName, _this3.events[key]);
              });
            });
          }
        }
      }, {
        key: "updateHelperPosition",
        value: function updateHelperPosition(event) {
          var _this$props5 = this.props,
              lockAxis = _this$props5.lockAxis,
              lockOffset = _this$props5.lockOffset,
              lockToContainerEdges = _this$props5.lockToContainerEdges;
          var offset = getPosition(event);
          var translate = {
            x: offset.x - this.initialOffset.x,
            y: offset.y - this.initialOffset.y
          };
          translate.y -= window.pageYOffset - this.initialWindowScroll.top;
          translate.x -= window.pageXOffset - this.initialWindowScroll.left;
          this.translate = translate;

          if (lockToContainerEdges) {
            var _getLockPixelOffsets = getLockPixelOffsets({
              height: this.height,
              lockOffset: lockOffset,
              width: this.width
            }),
                _getLockPixelOffsets2 = slicedToArray(_getLockPixelOffsets, 2),
                minLockOffset = _getLockPixelOffsets2[0],
                maxLockOffset = _getLockPixelOffsets2[1];

            var minOffset = {
              x: this.width / 2 - minLockOffset.x,
              y: this.height / 2 - minLockOffset.y
            };
            var maxOffset = {
              x: this.width / 2 - maxLockOffset.x,
              y: this.height / 2 - maxLockOffset.y
            };
            translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);
            translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);
          }

          if (lockAxis === 'x') {
            translate.y = 0;
          } else if (lockAxis === 'y') {
            translate.x = 0;
          }

          setTranslate3d(this.helper, translate);
        }
      }, {
        key: "animateNodes",
        value: function animateNodes() {
          var _this$props6 = this.props,
              transitionDuration = _this$props6.transitionDuration,
              hideSortableGhost = _this$props6.hideSortableGhost,
              onSortOver = _this$props6.onSortOver;
          var containerScrollDelta = this.containerScrollDelta,
              windowScrollDelta = this.windowScrollDelta;
          var nodes = this.manager.getOrderedRefs();
          var sortingOffset = {
            left: this.offsetEdge.left + this.translate.x + containerScrollDelta.left,
            top: this.offsetEdge.top + this.translate.y + containerScrollDelta.top
          };
          var prevIndex = this.newIndex;
          this.newIndex = null;

          for (var i = 0, len = nodes.length; i < len; i++) {
            var _node3 = nodes[i].node;
            var index = _node3.sortableInfo.index;
            var width = _node3.offsetWidth;
            var height = _node3.offsetHeight;
            var offset = {
              height: this.height > height ? height / 2 : this.height / 2,
              width: this.width > width ? width / 2 : this.width / 2
            };
            var translate = {
              x: 0,
              y: 0
            };
            var edgeOffset = nodes[i].edgeOffset;

            if (!edgeOffset) {
              edgeOffset = getEdgeOffset(_node3, this.container);
              nodes[i].edgeOffset = edgeOffset;
            }

            var nextNode = i < nodes.length - 1 && nodes[i + 1];
            var prevNode = i > 0 && nodes[i - 1];

            if (nextNode && !nextNode.edgeOffset) {
              nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);
            }

            if (index === this.index) {
              if (hideSortableGhost) {
                this.sortableGhost = _node3;
                setInlineStyles(_node3, {
                  opacity: 0,
                  visibility: 'hidden'
                });
              }

              continue;
            }

            if (transitionDuration) {
              setTransitionDuration(_node3, transitionDuration);
            }

            if (this.axis.x) {
              if (this.axis.y) {
                if (index < this.index && (sortingOffset.left + windowScrollDelta.left - offset.width <= edgeOffset.left && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height || sortingOffset.top + windowScrollDelta.top + offset.height <= edgeOffset.top)) {
                  translate.x = this.width + this.marginOffset.x;

                  if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width) {
                    if (nextNode) {
                      translate.x = nextNode.edgeOffset.left - edgeOffset.left;
                      translate.y = nextNode.edgeOffset.top - edgeOffset.top;
                    }
                  }

                  if (this.newIndex === null) {
                    this.newIndex = index;
                  }
                } else if (index > this.index && (sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top || sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top + height)) {
                  translate.x = -(this.width + this.marginOffset.x);

                  if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width) {
                    if (prevNode) {
                      translate.x = prevNode.edgeOffset.left - edgeOffset.left;
                      translate.y = prevNode.edgeOffset.top - edgeOffset.top;
                    }
                  }

                  this.newIndex = index;
                }
              } else {
                if (index > this.index && sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left) {
                  translate.x = -(this.width + this.marginOffset.x);
                  this.newIndex = index;
                } else if (index < this.index && sortingOffset.left + windowScrollDelta.left <= edgeOffset.left + offset.width) {
                  translate.x = this.width + this.marginOffset.x;

                  if (this.newIndex == null) {
                    this.newIndex = index;
                  }
                }
              }
            } else if (this.axis.y) {
              if (index > this.index && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top) {
                translate.y = -(this.height + this.marginOffset.y);
                this.newIndex = index;
              } else if (index < this.index && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height) {
                translate.y = this.height + this.marginOffset.y;

                if (this.newIndex == null) {
                  this.newIndex = index;
                }
              }
            }

            setTranslate3d(_node3, translate);
          }

          if (this.newIndex == null) {
            this.newIndex = this.index;
          }

          if (onSortOver && this.newIndex !== prevIndex) {
            onSortOver({
              collection: this.manager.active.collection,
              index: this.index,
              newIndex: this.newIndex,
              oldIndex: prevIndex
            });
          }
        }
      }, {
        key: "getWrappedInstance",
        value: function getWrappedInstance() {
          invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call');
          return this.refs.wrappedInstance;
        }
      }, {
        key: "getContainer",
        value: function getContainer() {
          var getContainer = this.props.getContainer;

          if (typeof getContainer !== 'function') {
            return reactDom.findDOMNode(this);
          }

          return getContainer(config.withRef ? this.getWrappedInstance() : undefined);
        }
      }, {
        key: "render",
        value: function render() {
          var ref = config.withRef ? 'wrappedInstance' : null;
          return React.createElement(WrappedComponent, _extends_1({
            ref: ref
          }, omit(this.props, omittedProps)));
        }
      }, {
        key: "helperContainer",
        get: function get() {
          var helperContainer = this.props.helperContainer;

          if (typeof helperContainer === 'function') {
            return helperContainer();
          }

          return this.props.helperContainer || this.document.body;
        }
      }, {
        key: "containerScrollDelta",
        get: function get() {
          var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;

          if (useWindowAsScrollContainer) {
            return {
              left: 0,
              top: 0
            };
          }

          return {
            left: this.scrollContainer.scrollLeft - this.initialScroll.left,
            top: this.scrollContainer.scrollTop - this.initialScroll.top
          };
        }
      }, {
        key: "windowScrollDelta",
        get: function get() {
          return {
            left: this.contentWindow.pageXOffset - this.initialWindowScroll.left,
            top: this.contentWindow.pageYOffset - this.initialWindowScroll.top
          };
        }
      }]);
      return WithSortableContainer;
    }(React.Component), defineProperty(_class, "displayName", provideDisplayName('sortableList', WrappedComponent)), defineProperty(_class, "defaultProps", defaultProps), defineProperty(_class, "propTypes", propTypes), defineProperty(_class, "childContextTypes", {
      manager: PropTypes.object.isRequired
    }), _temp;
  }

  var propTypes$1 = {
    index: PropTypes.number.isRequired,
    collection: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    disabled: PropTypes.bool
  };
  var omittedProps$1 = Object.keys(propTypes$1);

  function sortableElement(WrappedComponent) {
    var _class, _temp;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      withRef: false
    };
    return _temp = _class = function (_React$Component) {
      inherits(WithSortableElement, _React$Component);

      function WithSortableElement() {
        classCallCheck(this, WithSortableElement);
        return possibleConstructorReturn(this, getPrototypeOf(WithSortableElement).apply(this, arguments));
      }

      createClass(WithSortableElement, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.register();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this.node) {
            if (prevProps.index !== this.props.index) {
              this.node.sortableInfo.index = this.props.index;
            }

            if (prevProps.disabled !== this.props.disabled) {
              this.node.sortableInfo.disabled = this.props.disabled;
            }
          }

          if (prevProps.collection !== this.props.collection) {
            this.unregister(prevProps.collection);
            this.register();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unregister();
        }
      }, {
        key: "register",
        value: function register() {
          var _this$props = this.props,
              collection = _this$props.collection,
              disabled = _this$props.disabled,
              index = _this$props.index;
          var node = reactDom.findDOMNode(this);
          node.sortableInfo = {
            collection: collection,
            disabled: disabled,
            index: index,
            manager: this.context.manager
          };
          this.node = node;
          this.ref = {
            node: node
          };
          this.context.manager.add(collection, this.ref);
        }
      }, {
        key: "unregister",
        value: function unregister() {
          var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.collection;
          this.context.manager.remove(collection, this.ref);
        }
      }, {
        key: "getWrappedInstance",
        value: function getWrappedInstance() {
          invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call');
          return this.refs.wrappedInstance;
        }
      }, {
        key: "render",
        value: function render() {
          var ref = config.withRef ? 'wrappedInstance' : null;
          return React.createElement(WrappedComponent, _extends_1({
            ref: ref
          }, omit(this.props, omittedProps$1)));
        }
      }]);
      return WithSortableElement;
    }(React.Component), defineProperty(_class, "displayName", provideDisplayName('sortableElement', WrappedComponent)), defineProperty(_class, "contextTypes", {
      manager: PropTypes.object.isRequired
    }), defineProperty(_class, "propTypes", propTypes$1), defineProperty(_class, "defaultProps", {
      collection: 0
    }), _temp;
  }

  exports.SortableContainer = sortableContainer;
  exports.sortableContainer = sortableContainer;
  exports.SortableElement = sortableElement;
  exports.sortableElement = sortableElement;
  exports.SortableHandle = sortableHandle;
  exports.sortableHandle = sortableHandle;
  exports.arrayMove = arrayMove;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/recompose/compose.js":
/*!*******************************************!*\
  !*** ./node_modules/recompose/compose.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var compose = function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  }, function (arg) {
    return arg;
  });
};

var _default = compose;
exports.default = _default;

/***/ }),

/***/ "./node_modules/redux-devtools-extension/index.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-devtools-extension/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compose = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js").compose;

exports.__esModule = true;
exports.composeWithDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
  if (arguments.length === 0) return undefined;
  if (typeof arguments[0] === 'object') return compose;
  return compose.apply(null, arguments);
};
exports.devToolsEnhancer = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function () {
  return function (noop) {
    return noop;
  };
};

/***/ }),

/***/ "./node_modules/redux-thunk/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/redux-thunk/es/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
/* harmony default export */ __webpack_exports__["default"] = (thunk);

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "./node_modules/wkt-parser/index.js":
/*!******************************************!*\
  !*** ./node_modules/wkt-parser/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ "./node_modules/wkt-parser/parser.js");
/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./process */ "./node_modules/wkt-parser/process.js");
var D2R = 0.01745329251994329577;



function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];

  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];

    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }

  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();

    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }

    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }

  var geogcs = wkt.GEOGCS;

  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }

  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }

    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }

    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }

    if (wkt.datumCode === 'wgs_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }

      wkt.datumCode = 'wgs84';
    }

    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, -6);
    }

    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, -8);
    }

    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }

    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');

      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }

    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }

    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }

    if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }

    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }

    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }

  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }

  var renamer = function (a) {
    return rename(wkt, a);
  };

  var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_2', 'Standard_Parallel_2'], ['false_easting', 'False_Easting'], ['false_northing', 'False_Northing'], ['central_meridian', 'Central_Meridian'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_Of_Center'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longitude_of_center', 'Longitude_of_center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['azimuth', 'Azimuth'], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];
  list.forEach(renamer);

  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }

  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function (wkt) {
  var lisp = Object(_parser__WEBPACK_IMPORTED_MODULE_0__["default"])(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  Object(_process__WEBPACK_IMPORTED_MODULE_1__["sExpr"])(lisp, obj);
  cleanWKT(obj);
  return obj;
});

/***/ }),

/***/ "./node_modules/wkt-parser/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkt-parser/parser.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (parseString);
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/; // const ignoredChar = /[\s_\-\/\(\)]/g;

function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }

  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}

Parser.prototype.readCharicter = function () {
  var char = this.text[this.place++];

  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }

      char = this.text[this.place++];
    }
  }

  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);

    case KEYWORD:
      return this.keyword(char);

    case QUOTED:
      return this.quoted(char);

    case AFTERQUOTE:
      return this.afterquote(char);

    case NUMBER:
      return this.number(char);

    case ENDED:
      return;
  }
};

Parser.prototype.afterquote = function (char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }

  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
};

Parser.prototype.afterItem = function (char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }

    this.word = null;
    this.state = NEUTRAL;
    return;
  }

  if (char === ']') {
    this.level--;

    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }

    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();

    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};

Parser.prototype.number = function (char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }

  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
};

Parser.prototype.quoted = function (char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }

  this.word += char;
  return;
};

Parser.prototype.keyword = function (char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }

  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;

    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }

    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }

  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
};

Parser.prototype.neutral = function (char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }

  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }

  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }

  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }

  throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
};

Parser.prototype.output = function () {
  while (this.place < this.text.length) {
    this.readCharicter();
  }

  if (this.state === ENDED) {
    return this.root;
  }

  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

/***/ }),

/***/ "./node_modules/wkt-parser/process.js":
/*!********************************************!*\
  !*** ./node_modules/wkt-parser/process.js ***!
  \********************************************/
/*! exports provided: sExpr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sExpr", function() { return sExpr; });
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }

  var thing = key ? {} : obj;
  var out = value.reduce(function (newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);

  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }

  var key = v.shift();

  if (key === 'PARAMETER') {
    key = v.shift();
  }

  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }

    obj[key] = v[0];
    return;
  }

  if (!v.length) {
    obj[key] = true;
    return;
  }

  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }

  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;

  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };

      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }

      return;

    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };

      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }

      return;

    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;

    default:
      i = -1;

      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }

      return mapit(obj, key, v);
  }
}

/***/ }),

/***/ "./src/actions/app.js":
/*!****************************!*\
  !*** ./src/actions/app.js ***!
  \****************************/
/*! exports provided: setAppSettingsAction, updateAppSettingsAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAppSettingsAction", function() { return setAppSettingsAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateAppSettingsAction", function() { return updateAppSettingsAction; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/actions/constants.js");

function setAppSettingsAction(settings) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["SET_APP_SETTINGS"],
    payload: settings
  };
}
function updateAppSettingsAction(settings) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_APP_SETTINGS"],
    payload: settings
  };
}

/***/ }),

/***/ "./src/actions/constants.js":
/*!**********************************!*\
  !*** ./src/actions/constants.js ***!
  \**********************************/
/*! exports provided: SET_WEB_MAP, UPDATE_WEB_MAP, SET_APP_SETTINGS, UPDATE_APP_SETTINGS, SET_MAP_VIEW, UPDATE_MAP_VIEW, SET_MAP_LAYERS, ADD_MAP_LAYERS, DELETE_MAP_LAYERS, ADD_ERRORS, DELETE_ERROR, SET_ERRORS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_WEB_MAP", function() { return SET_WEB_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPDATE_WEB_MAP", function() { return UPDATE_WEB_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_APP_SETTINGS", function() { return SET_APP_SETTINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPDATE_APP_SETTINGS", function() { return UPDATE_APP_SETTINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_MAP_VIEW", function() { return SET_MAP_VIEW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPDATE_MAP_VIEW", function() { return UPDATE_MAP_VIEW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_MAP_LAYERS", function() { return SET_MAP_LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ADD_MAP_LAYERS", function() { return ADD_MAP_LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DELETE_MAP_LAYERS", function() { return DELETE_MAP_LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ADD_ERRORS", function() { return ADD_ERRORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DELETE_ERROR", function() { return DELETE_ERROR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_ERRORS", function() { return SET_ERRORS; });
var SET_WEB_MAP = "SET_WEB_MAP";
var UPDATE_WEB_MAP = "UPDATE_WEB_MAP";
var SET_APP_SETTINGS = "SET_APP_SETTINGS";
var UPDATE_APP_SETTINGS = "UPDATE_APP_SETTINGS";
var SET_MAP_VIEW = "SET_MAP_VIEW";
var UPDATE_MAP_VIEW = "UPDATE_MAP_VIEW";
var SET_MAP_LAYERS = "SET_MAP_LAYERS";
var ADD_MAP_LAYERS = "ADD_MAP_LAYERS";
var DELETE_MAP_LAYERS = "DELETE_MAP_LAYERS";
var ADD_ERRORS = "ADD_ERRORS";
var DELETE_ERROR = "DELETE_ERROR";
var SET_ERRORS = "SET_ERRORS";

/***/ }),

/***/ "./src/actions/errors.js":
/*!*******************************!*\
  !*** ./src/actions/errors.js ***!
  \*******************************/
/*! exports provided: setErrors, deleteError, addError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setErrors", function() { return setErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteError", function() { return deleteError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addError", function() { return addError; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/actions/constants.js");

function setErrors(errors) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["SET_ERRORS"],
    payload: errors
  };
}
function deleteError(error) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["DELETE_ERROR"],
    payload: error
  };
}
function addError(errors) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["ADD_ERRORS"],
    payload: errors
  };
}

/***/ }),

/***/ "./src/actions/map.js":
/*!****************************!*\
  !*** ./src/actions/map.js ***!
  \****************************/
/*! exports provided: setWebMapAction, updateWebMapAction, setMapViewAction, updateMapViewAction, setMapLayersAction, addMapLayersAction, deleteMapLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setWebMapAction", function() { return setWebMapAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWebMapAction", function() { return updateWebMapAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMapViewAction", function() { return setMapViewAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateMapViewAction", function() { return updateMapViewAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMapLayersAction", function() { return setMapLayersAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMapLayersAction", function() { return addMapLayersAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteMapLayers", function() { return deleteMapLayers; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/actions/constants.js");

function setWebMapAction(map) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["SET_WEB_MAP"],
    payload: map
  };
}
function updateWebMapAction(map) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_WEB_MAP"],
    payload: map
  };
}
function setMapViewAction(view) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["SET_MAP_VIEW"],
    payload: view
  };
}
function updateMapViewAction(view) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_MAP_VIEW"],
    payload: view
  };
}
function setMapLayersAction(layers) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["SET_MAP_LAYERS"],
    payload: layers
  };
}
function addMapLayersAction(layers) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["ADD_MAP_LAYERS"],
    payload: layers
  };
}
function deleteMapLayers(layerIDS) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["DELETE_MAP_LAYERS"],
    payload: layerIDS
  };
}

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! exports provided: mapJsonSerializer, fetchAppSettings, fetchServers, fetchServerLayers, fetchMapById, saveMap, createMap, saveMapThumbnail */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapJsonSerializer", function() { return mapJsonSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchAppSettings", function() { return fetchAppSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchServers", function() { return fetchServers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchServerLayers", function() { return fetchServerLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchMapById", function() { return fetchMapById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveMap", function() { return saveMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMap", function() { return createMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveMapThumbnail", function() { return saveMapThumbnail; });
/* harmony import */ var _actions_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/errors */ "./src/actions/errors.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/api/utils.js");
/* harmony import */ var _actions_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../actions/app */ "./src/actions/app.js");
/* harmony import */ var _actions_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../actions/map */ "./src/actions/map.js");
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var apiInstance = axios__WEBPACK_IMPORTED_MODULE_1___default.a.create({
  baseURL: "".concat(window.location.origin, "/api/"),
  timeout: 1000,
  headers: {
    "X-CSRFToken": Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getCRSFToken"])()
  }
});
function mapJsonSerializer(mapJson) {
  var map = {
    name: mapJson.title,
    title: mapJson.title,
    description: mapJson.description,
    layers: mapJson.layers,
    view: {
      center: mapJson.center,
      constrainRotation: mapJson.constrain_rotation,
      rotation: mapJson.rotation | 0,
      enableRotation: mapJson.enable_rotation,
      extent: mapJson.bounding_box.length > 0 ? mapJson.bounding_box : undefined,
      maxZoom: mapJson.max_zoom,
      minZoom: mapJson.min_zoom,
      projection: mapJson.projection,
      zoomFactor: mapJson.zoom_factor,
      zoom: mapJson.zoom
    },
    renderOptions: mapJson.render_options,
    loadTilesWhileAnimating: false,
    loadTilesWhileInteracting: false,
    moveTolerance: 1
  };
  return map;
}
function fetchAppSettings(id) {
  return function (dispatch) {
    return apiInstance.get("appinstance/".concat(id)).then(function (response) {
      var data = response.data;
      dispatch(Object(_actions_app__WEBPACK_IMPORTED_MODULE_3__["setAppSettingsAction"])(_objectSpread({}, data.config, {
        title: data.title,
        description: data.description
      })));
      axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(data.map_url, {
        headers: {
          "X-CSRFToken": Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getCRSFToken"])()
        }
      }).then(function (response) {
        dispatch(Object(_actions_map__WEBPACK_IMPORTED_MODULE_4__["setWebMapAction"])(mapJsonSerializer(response.data)));
      });
    })["catch"](function (error) {
      dispatch(Object(_actions_errors__WEBPACK_IMPORTED_MODULE_0__["addError"])(error.message));
    });
  };
}
function fetchServers() {
  return apiInstance.get("servers", {
    timeout: 20000
  }).then(function (response) {
    var data = response.data;
    return data.results;
  });
}
function fetchServerLayers(serverId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return apiInstance.get("layers?server=".concat(serverId, "&limit=").concat(limit, "&offset=").concat(offset), {
    timeout: 20000
  }).then(function (response) {
    var data = response.data;
    return data;
  });
}
function fetchMapById(mapId) {
  return apiInstance.get("maps/".concat(mapId, "/map_json/"), {
    timeout: 30000
  });
}
function saveMap(mapId, data) {
  return apiInstance.patch("maps/".concat(mapId, "/"), data, {
    timeout: 30000,
    headers: {
      'Content-Type': 'application/json'
    }
  });
}
function createMap(data) {
  return apiInstance.post("maps/", data, {
    timeout: 30000,
    headers: {
      'Content-Type': 'application/json'
    }
  });
}
function saveMapThumbnail(mapId, data) {
  return apiInstance.patch("maps/".concat(mapId, "/"), data, {
    timeout: 30000
  });
}

/***/ }),

/***/ "./src/api/utils.js":
/*!**************************!*\
  !*** ./src/api/utils.js ***!
  \**************************/
/*! exports provided: getCRSFToken */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCRSFToken", function() { return getCRSFToken; });
function getCRSFToken() {
  var csrfToken,
      csrfMatch = document.cookie.match(/csrftoken=(\w+)/);

  if (csrfMatch && csrfMatch.length > 0) {
    csrfToken = csrfMatch[1];
  }

  return csrfToken;
}

/***/ }),

/***/ "./src/components/AddLayers.jsx":
/*!**************************************!*\
  !*** ./src/components/AddLayers.jsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api */ "./src/api/index.js");
/* harmony import */ var _material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/icons/Add */ "./node_modules/@material-ui/icons/Add.js");
/* harmony import */ var _material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _material_ui_icons_ArrowBackSharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/icons/ArrowBackSharp */ "./node_modules/@material-ui/icons/ArrowBackSharp.js");
/* harmony import */ var _material_ui_icons_ArrowBackSharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_ArrowBackSharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _material_ui_icons_Delete__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/icons/Delete */ "./node_modules/@material-ui/icons/Delete.js");
/* harmony import */ var _material_ui_icons_Delete__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Delete__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_FormControl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/FormControl */ "./node_modules/@material-ui/core/FormControl/index.js");
/* harmony import */ var _material_ui_core_FormControl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_FormControl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/IconButton */ "./node_modules/@material-ui/core/IconButton/index.js");
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _material_ui_core_InputLabel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/core/InputLabel */ "./node_modules/@material-ui/core/InputLabel/index.js");
/* harmony import */ var _material_ui_core_InputLabel__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_InputLabel__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _services_Legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../services/Legend */ "./src/services/Legend.jsx");
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/List */ "./node_modules/@material-ui/core/List/index.js");
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/ListItem */ "./node_modules/@material-ui/core/ListItem/index.js");
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/ListItemSecondaryAction */ "./node_modules/@material-ui/core/ListItemSecondaryAction/index.js");
/* harmony import */ var _material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/ListItemText */ "./node_modules/@material-ui/core/ListItemText/index.js");
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _services_MapLoadService__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../services/MapLoadService */ "./src/services/MapLoadService.jsx");
/* harmony import */ var _material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @material-ui/core/MenuItem */ "./node_modules/@material-ui/core/MenuItem/index.js");
/* harmony import */ var _material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var material_ui_flat_pagination__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! material-ui-flat-pagination */ "./node_modules/material-ui-flat-pagination/lib/index.js");
/* harmony import */ var material_ui_flat_pagination__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(material_ui_flat_pagination__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _material_ui_core_Select__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @material-ui/core/Select */ "./node_modules/@material-ui/core/Select/index.js");
/* harmony import */ var _material_ui_core_Select__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Select__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! react-redux */ "./node_modules/react-redux/es/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_20__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// import * as mapActions from '../actions/map'






















var styles = function styles(theme) {
  return {
    divFlex: {
      display: 'flex',
      margin: '0px 10px'
    },
    controlFlex: {
      display: 'flex',
      margin: '0px 10px',
      'flex': '1',
      'flex-direction': 'column'
    },
    customPagination: {
      alignItems: 'center',
      display: 'flex',
      justifyContent: 'center'
    }
  };
};

var AddLayers =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(AddLayers, _React$PureComponent);

  function AddLayers(props) {
    var _this;

    _classCallCheck(this, AddLayers);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddLayers).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "handleOffsetChange", function (offset) {
      _this.setState({
        offset: offset
      }, function () {
        return _this.getLayers();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "addLayer", function (layerJson) {
      var _this$context = _this.context,
          map = _this$context.map,
          setStateKey = _this$context.setStateKey,
          mapLayers = _this$context.mapLayers;
      var service = new _services_MapLoadService__WEBPACK_IMPORTED_MODULE_13__["default"](map, {});
      var layer = service.generateLayerFromConfig(layerJson);

      if (layer) {
        map.addLayer(layer);
        setStateKey('mapLayers', [layer].concat(_toConsumableArray(mapLayers)));
        Promise.all(_services_Legend__WEBPACK_IMPORTED_MODULE_8__["default"].getLegends(map)).then(function (result) {
          return setStateKey('legends', result);
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "deleteLayer", function (layerJson) {
      var _this$context2 = _this.context,
          map = _this$context2.map,
          mapLayers = _this$context2.mapLayers,
          setStateKey = _this$context2.setStateKey;
      var id = layerJson.id;
      map.getLayers().getArray().map(function (lyr) {
        var metadata = lyr.get('metadata');

        if (metadata && metadata.identifier === id) {
          map.removeLayer(lyr);
          setStateKey('mapLayers', mapLayers.filter(function (lyr) {
            var metadata = lyr.get('metadata');
            return metadata && metadata.name !== name;
          }));
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "getLayers", function () {
      var me = _assertThisInitialized(_this);

      var _me$state = me.state,
          selectedServerId = _me$state.selectedServerId,
          limit = _me$state.limit,
          offset = _me$state.offset;

      if (selectedServerId > -1) {
        me.setState({
          layersLoading: true
        }, function () {
          Object(_api__WEBPACK_IMPORTED_MODULE_0__["fetchServerLayers"])(selectedServerId, limit, offset).then(function (data) {
            return me.setState({
              layers: data.results,
              count: data.count,
              layersLoading: false
            });
          })["catch"](function (err) {
            me.setState({
              count: 0,
              layers: [],
              layersLoading: false
            });
            console.error(err);
          });
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (event) {
      var me = _assertThisInitialized(_this);

      me.setState(_defineProperty({}, event.target.name, event.target.value), function () {
        return _this.getLayers();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "layerMapExist", function (id) {
      var map = _this.context.map;
      var found = map.getLayers().getArray().filter(function (layer) {
        var metadata = layer.get('metadata');

        if (metadata && metadata.identifier === id) {
          return true;
        }

        return false;
      });

      if (found.length > 0) {
        return true;
      }

      return false;
    });

    _defineProperty(_assertThisInitialized(_this), "handleDetailsExpand", function () {
      _this.setState({
        expanded: !_this.state.expanded
      });
    });

    _this.state = {
      servers: [],
      layers: [],
      layersLoading: false,
      selectedServerId: -1,
      offset: 0,
      count: 0,
      limit: 25
    };
    return _this;
  }

  _createClass(AddLayers, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      Object(_api__WEBPACK_IMPORTED_MODULE_0__["fetchServers"])().then(function (servers) {
        return _this2.setState({
          servers: servers
        });
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props = this.props,
          classes = _this$props.classes,
          setComponent = _this$props.setComponent;
      var _this$state = this.state,
          servers = _this$state.servers,
          selectedServerId = _this$state.selectedServerId,
          layers = _this$state.layers,
          count = _this$state.count,
          offset = _this$state.offset,
          limit = _this$state.limit;
      return react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement("div", {
        className: classes.controlFlex
      }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default.a, {
        onClick: function onClick() {
          return setComponent(null);
        }
      }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_icons_ArrowBackSharp__WEBPACK_IMPORTED_MODULE_2___default.a, null)), react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_FormControl__WEBPACK_IMPORTED_MODULE_5___default.a, {
        className: classes.divFlex
      }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_InputLabel__WEBPACK_IMPORTED_MODULE_7___default.a, {
        htmlFor: "server-select"
      }, "Server"), react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_Select__WEBPACK_IMPORTED_MODULE_18___default.a, {
        value: selectedServerId,
        onChange: this.handleChange,
        inputProps: {
          name: 'selectedServerId',
          id: 'server-select'
        }
      }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14___default.a, {
        value: -1
      }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement("em", null, "------")), servers.length > 0 && servers.map(function (server) {
        return react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14___default.a, {
          key: server.id,
          value: server.id
        }, server.title);
      })))), react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_9___default.a, null, layers.map(function (layer) {
        return react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_10___default.a, {
          key: layer.id
        }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_12___default.a, {
          primary: layer.title,
          secondary: layer.layer_type
        }), react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_11___default.a, null, !_this3.layerMapExist(layer.id) && react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default.a, {
          onClick: function onClick() {
            return _this3.addLayer(layer);
          },
          "aria-label": "Add"
        }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1___default.a, null)), _this3.layerMapExist(layer.id) && react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default.a, {
          onClick: function onClick() {
            return _this3.deleteLayer(layer);
          },
          "aria-label": "Add"
        }, react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(_material_ui_icons_Delete__WEBPACK_IMPORTED_MODULE_4___default.a, null))));
      })), react__WEBPACK_IMPORTED_MODULE_17___default.a.createElement(material_ui_flat_pagination__WEBPACK_IMPORTED_MODULE_15___default.a, {
        classes: {
          'root': classes.customPagination
        },
        limit: limit,
        offset: offset,
        total: count,
        onClick: function onClick(e, offset) {
          return _this3.handleOffsetChange(offset);
        }
      }));
    }
  }]);

  return AddLayers;
}(react__WEBPACK_IMPORTED_MODULE_17___default.a.PureComponent);

AddLayers.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_16___default.a.object.isRequired,
  reduxMap: prop_types__WEBPACK_IMPORTED_MODULE_16___default.a.object.isRequired,
  setComponent: prop_types__WEBPACK_IMPORTED_MODULE_16___default.a.func.isRequired
};
AddLayers.contextType = _context__WEBPACK_IMPORTED_MODULE_3__["BasicViewerContext"];

var mapStateToProps = function mapStateToProps(state) {
  return {
    reduxMap: state.map
  };
};

var App = Object(react_redux__WEBPACK_IMPORTED_MODULE_19__["connect"])(mapStateToProps, null)(AddLayers);
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_20__["withStyles"])(styles)(App));

/***/ }),

/***/ "./src/components/CollapsibleItem.jsx":
/*!********************************************!*\
  !*** ./src/components/CollapsibleItem.jsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_ui_core_Collapse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material-ui/core/Collapse */ "./node_modules/@material-ui/core/Collapse/index.js");
/* harmony import */ var _material_ui_core_Collapse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Collapse__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _material_ui_core_Divider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/core/Divider */ "./node_modules/@material-ui/core/Divider/index.js");
/* harmony import */ var _material_ui_core_Divider__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Divider__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _material_ui_icons_ExpandMore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/icons/ExpandMore */ "./node_modules/@material-ui/icons/ExpandMore.js");
/* harmony import */ var _material_ui_icons_ExpandMore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_ExpandMore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/IconButton */ "./node_modules/@material-ui/core/IconButton/index.js");
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/core/ListItem */ "./node_modules/@material-ui/core/ListItem/index.js");
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/ListItemIcon */ "./node_modules/@material-ui/core/ListItemIcon/index.js");
/* harmony import */ var _material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/ListItemSecondaryAction */ "./node_modules/@material-ui/core/ListItemSecondaryAction/index.js");
/* harmony import */ var _material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/core/ListItemText */ "./node_modules/@material-ui/core/ListItemText/index.js");
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_11__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














var styles = function styles(theme) {
  return {
    expand: {
      transform: 'rotate(0deg)',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shortest
      })
    },
    expandOpen: {
      transform: 'rotate(180deg)'
    }
  };
};

var Collapsible =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Collapsible, _React$Component);

  function Collapsible(props) {
    var _this;

    _classCallCheck(this, Collapsible);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collapsible).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "handleDetailsExpand", function () {
      _this.setState({
        expanded: !_this.state.expanded
      });
    });

    var open = _this.props.open;
    _this.state = {
      expanded: typeof open !== "undefined" ? open : true
    };
    return _this;
  }

  _createClass(Collapsible, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          classes = _this$props.classes,
          children = _this$props.children,
          title = _this$props.title,
          icon = _this$props.icon;
      return react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_4___default.a, {
        button: true,
        onClick: this.handleDetailsExpand
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_5___default.a, null, icon), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_7___default.a, {
        primary: title
      }), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_ListItemSecondaryAction__WEBPACK_IMPORTED_MODULE_6___default.a, null, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_3___default.a, {
        className: classnames__WEBPACK_IMPORTED_MODULE_10___default()(classes.expand, _defineProperty({}, classes.expandOpen, this.state.expanded)),
        onClick: this.handleDetailsExpand,
        "aria-expanded": this.state.expanded,
        "aria-label": "Show more"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_icons_ExpandMore__WEBPACK_IMPORTED_MODULE_2___default.a, null)))), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Collapse__WEBPACK_IMPORTED_MODULE_0___default.a, {
        "in": this.state.expanded,
        transitionduration: "auto",
        unmountOnExit: true
      }, children, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Divider__WEBPACK_IMPORTED_MODULE_1___default.a, null)));
    }
  }]);

  return Collapsible;
}(react__WEBPACK_IMPORTED_MODULE_9___default.a.Component);

Collapsible.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object.isRequired,
  title: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.string.isRequired,
  children: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object.isRequired,
  open: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.bool,
  icon: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_11__["withStyles"])(styles)(Collapsible));

/***/ }),

/***/ "./src/components/CommonComponents.jsx":
/*!*********************************************!*\
  !*** ./src/components/CommonComponents.jsx ***!
  \*********************************************/
/*! exports provided: Loader, Message, CartoviewSnackBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Message", function() { return Message; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartoviewSnackBar", function() { return CartoviewSnackBar; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/core/CircularProgress */ "./node_modules/@material-ui/core/CircularProgress/index.js");
/* harmony import */ var _material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _material_ui_core_LinearProgress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/LinearProgress */ "./node_modules/@material-ui/core/LinearProgress/index.js");
/* harmony import */ var _material_ui_core_LinearProgress__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_LinearProgress__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_Snackbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/Snackbar */ "./node_modules/@material-ui/core/Snackbar/index.js");
/* harmony import */ var _material_ui_core_Snackbar__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Snackbar__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/Typography/index.js");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_6__);







var Loader = function Loader(props) {
  var size = props.size,
      thickness = props.thickness,
      align = props.align,
      type = props.type;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    className: "text-".concat(align || "center")
  }, (typeof type === "undefined" || type === "circle") && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_2___default.a, {
    size: size ? size : 50,
    thickness: thickness ? thickness : 5,
    className: "text-center"
  }), type === "line" && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_LinearProgress__WEBPACK_IMPORTED_MODULE_3___default.a, {
    size: size ? size : 50,
    thickness: thickness ? thickness : 5,
    className: "text-center"
  }));
};
Loader.propTypes = {
  size: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
  thickness: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
  align: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
  type: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string
};
var Message = function Message(props) {
  var align = props.align,
      type = props.type,
      message = props.message,
      color = props.color,
      noWrap = props.noWrap;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_6___default.a, {
    variant: type,
    align: align ? align : "center",
    noWrap: typeof noWrap !== "undefined" ? noWrap : message.length > 70 ? true : false,
    color: color ? color : "inherit",
    className: "element-flex"
  }, message);
};
Message.propTypes = {
  type: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string.isRequired,
  message: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string.isRequired,
  align: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
  color: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
  noWrap: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool
};

var SnackMessage = function SnackMessage(props) {
  var message = props.message;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
    className: "element-flex",
    id: "message-id"
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Loader, {
    size: 20,
    thickness: 4
  }), " ", message, " ");
};

SnackMessage.propTypes = {
  message: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string.isRequired
};
var CartoviewSnackBar = function CartoviewSnackBar(props) {
  var _useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_context__WEBPACK_IMPORTED_MODULE_1__["BasicViewerContext"]),
      featureIdentifyLoading = _useContext.featureIdentifyLoading;

  var messageComponent = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SnackMessage, {
    message: "Searching For Features at this Point"
  });
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Snackbar__WEBPACK_IMPORTED_MODULE_5___default.a, {
    open: featureIdentifyLoading,
    ContentProps: {
      'aria-describedby': 'message-id'
    },
    message: messageComponent
  });
};

/***/ }),

/***/ "./src/components/ContentGrid.jsx":
/*!****************************************!*\
  !*** ./src/components/ContentGrid.jsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _Drawer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Drawer */ "./src/components/Drawer.jsx");
/* harmony import */ var _Popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Popup */ "./src/components/Popup.jsx");
/* harmony import */ var _CommonComponents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CommonComponents */ "./src/components/CommonComponents.jsx");
/* harmony import */ var _material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/Grid */ "./node_modules/@material-ui/core/Grid/index.js");
/* harmony import */ var _material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/IconButton */ "./node_modules/@material-ui/core/IconButton/index.js");
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _MapViewer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MapViewer */ "./src/components/MapViewer.jsx");
/* harmony import */ var _material_ui_icons_Menu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/icons/Menu */ "./node_modules/@material-ui/icons/Menu.js");
/* harmony import */ var _material_ui_icons_Menu__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Menu__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/Paper */ "./node_modules/@material-ui/core/Paper/index.js");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_Slide__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/Slide */ "./node_modules/@material-ui/core/Slide/index.js");
/* harmony import */ var _material_ui_core_Slide__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Slide__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var recompose_compose__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! recompose/compose */ "./node_modules/recompose/compose.js");
/* harmony import */ var recompose_compose__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(recompose_compose__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @material-ui/core/withWidth */ "./node_modules/@material-ui/core/withWidth/index.js");
/* harmony import */ var _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_15__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















var styles = function styles(theme) {
  var _DrawerBar, _DrawerOpenBar;

  return {
    root: {
      height: "100%"
    },
    drawer: _defineProperty({
      width: "30%",
      height: "100%",
      zIndex: "1150",
      position: "fixed"
    }, theme.breakpoints.down('sm'), {
      width: "90%"
    }),
    drawerClose: {
      width: "0%",
      height: "100%",
      zIndex: "1150",
      position: "fixed"
    },
    drawerContentClose: {
      display: 'none'
    },
    drawerContainer: {
      left: "0px !important"
    },
    DrawerBar: (_DrawerBar = {
      width: '28%',
      zIndex: '12',
      display: 'flex',
      flexDirection: 'column',
      position: 'fixed',
      top: '1%'
    }, _defineProperty(_DrawerBar, theme.breakpoints.down('sm'), {
      width: "88%",
      top: ".5%"
    }), _defineProperty(_DrawerBar, "left", '1%'), _DrawerBar),
    DrawerOpenBar: (_DrawerOpenBar = {
      width: '97% !important',
      zIndex: '12',
      display: 'flex',
      flexDirection: 'column',
      position: 'absolute',
      top: '1%'
    }, _defineProperty(_DrawerOpenBar, theme.breakpoints.down('sm'), {
      top: ".5%"
    }), _defineProperty(_DrawerOpenBar, "left", '1%'), _DrawerOpenBar)
  };
};

function Transition(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Slide__WEBPACK_IMPORTED_MODULE_11___default.a, _extends({
    direction: "left"
  }, props));
}

var ContentGrid =
/*#__PURE__*/
function (_Component) {
  _inherits(ContentGrid, _Component);

  function ContentGrid() {
    _classCallCheck(this, ContentGrid);

    return _possibleConstructorReturn(this, _getPrototypeOf(ContentGrid).apply(this, arguments));
  }

  _createClass(ContentGrid, [{
    key: "render",
    value: function render() {
      var _classnames;

      var _this$context = this.context,
          drawerOpen = _this$context.drawerOpen,
          toggleDrawer = _this$context.toggleDrawer;
      var classes = this.props.classes;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: classes.root
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_12___default()((_classnames = {}, _defineProperty(_classnames, classes.drawer, drawerOpen ? true : false), _defineProperty(_classnames, classes.drawerClose, drawerOpen ? false : true), _classnames))
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_9___default.a, {
        className: classnames__WEBPACK_IMPORTED_MODULE_12___default()(classes.DrawerBar, _defineProperty({}, classes.DrawerOpenBar, drawerOpen))
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "element-flex "
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_6___default.a, {
        onClick: toggleDrawer,
        color: "default",
        "aria-label": "Open Menu"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_Menu__WEBPACK_IMPORTED_MODULE_8___default.a, null)))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Transition, {
        "in": drawerOpen,
        direction: "right"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Drawer__WEBPACK_IMPORTED_MODULE_2__["default"], {
        className: classnames__WEBPACK_IMPORTED_MODULE_12___default()(_defineProperty({}, classes.drawerContentClose, !drawerOpen))
      }))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_5___default.a, {
        className: classes.root,
        container: true,
        alignItems: "stretch",
        spacing: 0
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_5___default.a, {
        item: true,
        xs: 12,
        sm: 12,
        md: 12,
        lg: 12,
        xl: 12
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_MapViewer__WEBPACK_IMPORTED_MODULE_7__["default"], null), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Popup__WEBPACK_IMPORTED_MODULE_3__["default"], null))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_4__["CartoviewSnackBar"], null));
    }
  }]);

  return ContentGrid;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

ContentGrid.contextType = _context__WEBPACK_IMPORTED_MODULE_1__["BasicViewerContext"];
ContentGrid.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_10___default.a.object.isRequired,
  width: prop_types__WEBPACK_IMPORTED_MODULE_10___default.a.string
};
/* harmony default export */ __webpack_exports__["default"] = (recompose_compose__WEBPACK_IMPORTED_MODULE_13___default()(Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_14__["withStyles"])(styles), _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_15___default()())(ContentGrid));

/***/ }),

/***/ "./src/components/Drawer.jsx":
/*!***********************************!*\
  !*** ./src/components/Drawer.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/icons/Add */ "./node_modules/@material-ui/icons/Add.js");
/* harmony import */ var _material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _AddLayers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AddLayers */ "./src/components/AddLayers.jsx");
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LayerSwitcher */ "./src/components/LayerSwitcher.jsx");
/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Legend */ "./src/components/Legend.jsx");
/* harmony import */ var _CollapsibleItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CollapsibleItem */ "./src/components/CollapsibleItem.jsx");
/* harmony import */ var _material_ui_icons_Image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/icons/Image */ "./node_modules/@material-ui/icons/Image.js");
/* harmony import */ var _material_ui_icons_Image__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Image__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _material_ui_icons_Layers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/icons/Layers */ "./node_modules/@material-ui/icons/Layers.js");
/* harmony import */ var _material_ui_icons_Layers__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Layers__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/List */ "./node_modules/@material-ui/core/List/index.js");
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/ListItem */ "./node_modules/@material-ui/core/ListItem/index.js");
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/ListItemIcon */ "./node_modules/@material-ui/core/ListItemIcon/index.js");
/* harmony import */ var _material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/ListItemText */ "./node_modules/@material-ui/core/ListItemText/index.js");
/* harmony import */ var _material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _Navbar_jsx__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Navbar.jsx */ "./src/components/Navbar.jsx");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/Paper */ "./node_modules/@material-ui/core/Paper/index.js");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _SaveDialog__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SaveDialog */ "./src/components/SaveDialog.jsx");
/* harmony import */ var _material_ui_icons_Save__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @material-ui/icons/Save */ "./node_modules/@material-ui/icons/Save.js");
/* harmony import */ var _material_ui_icons_Save__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Save__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





















var styles = function styles(theme) {
  return {
    root: {
      height: "100%"
    },
    drawerPaper: {
      padding: 0,
      height: "calc(100% - 64px)",
      overflowY: 'scroll'
    },
    button: {
      margin: theme.spacing.unit
    }
  };
};

var CartoviewDrawer = function CartoviewDrawer(props) {
  var classes = props.classes,
      className = props.className;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(null),
      _useState2 = _slicedToArray(_useState, 2),
      component = _useState2[0],
      setComponent = _useState2[1];

  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(false),
      _useState4 = _slicedToArray(_useState3, 2),
      saveMapOpen = _useState4[0],
      setSaveMapOpen = _useState4[1];

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_13___default.a, {
    elevation: 6,
    className: classnames__WEBPACK_IMPORTED_MODULE_17___default()(classes.root, className)
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Navbar_jsx__WEBPACK_IMPORTED_MODULE_12__["default"], null), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_13___default.a, {
    className: classes.drawerPaper,
    elevation: 0
  }, !component && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_8___default.a, {
    disablePadding: true
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_9___default.a, {
    button: true,
    onClick: function onClick() {
      return setSaveMapOpen(true);
    }
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_10___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_Save__WEBPACK_IMPORTED_MODULE_16___default.a, null)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_11___default.a, {
    primary: "Save Map"
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_9___default.a, {
    onClick: function onClick() {
      return setComponent('AddLayers');
    },
    button: true
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItemIcon__WEBPACK_IMPORTED_MODULE_10___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_Add__WEBPACK_IMPORTED_MODULE_1___default.a, null)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_ListItemText__WEBPACK_IMPORTED_MODULE_11___default.a, {
    primary: "Add Layers"
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_CollapsibleItem__WEBPACK_IMPORTED_MODULE_5__["default"], {
    open: false,
    title: "Layers",
    icon: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_Layers__WEBPACK_IMPORTED_MODULE_7___default.a, null)
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_LayerSwitcher__WEBPACK_IMPORTED_MODULE_3__["default"], null)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_CollapsibleItem__WEBPACK_IMPORTED_MODULE_5__["default"], {
    open: false,
    title: "Legend",
    icon: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_Image__WEBPACK_IMPORTED_MODULE_6___default.a, null)
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Legend__WEBPACK_IMPORTED_MODULE_4__["default"], null))), component == "AddLayers" && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_AddLayers__WEBPACK_IMPORTED_MODULE_2__["default"], {
    setComponent: setComponent
  })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_SaveDialog__WEBPACK_IMPORTED_MODULE_15__["default"], {
    open: saveMapOpen,
    handleClose: function handleClose() {
      return setSaveMapOpen(false);
    }
  }));
};

CartoviewDrawer.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_14___default.a.object.isRequired,
  className: prop_types__WEBPACK_IMPORTED_MODULE_14___default.a.string.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__["withStyles"])(styles)(CartoviewDrawer));

/***/ }),

/***/ "./src/components/DropDown.jsx":
/*!*************************************!*\
  !*** ./src/components/DropDown.jsx ***!
  \*************************************/
/*! exports provided: guidGenerator, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "guidGenerator", function() { return guidGenerator; });
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material-ui/core/IconButton */ "./node_modules/@material-ui/core/IconButton/index.js");
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/core/Menu */ "./node_modules/@material-ui/core/Menu/index.js");
/* harmony import */ var _material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/icons/MoreVert */ "./node_modules/@material-ui/icons/MoreVert.js");
/* harmony import */ var _material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var ITEM_HEIGHT = 30;
var guidGenerator = function guidGenerator() {
  var S4 = function S4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  };

  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
};

var styles = function styles(theme) {
  return {
    button: {
      margin: 0
    }
  };
};

var DropDown =
/*#__PURE__*/
function (_React$Component) {
  _inherits(DropDown, _React$Component);

  function DropDown(props) {
    var _this;

    _classCallCheck(this, DropDown);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropDown).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (event) {
      _this.setState({
        anchorEl: event.currentTarget
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleClose", function () {
      _this.setState({
        anchorEl: null
      });
    });

    _this.state = {
      anchorEl: null
    };
    _this.id = guidGenerator();
    return _this;
  }

  _createClass(DropDown, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          classes = _this$props.classes;
      var anchorEl = this.state.anchorEl;
      return react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_0___default.a, {
        className: classes.button,
        "aria-label": "More",
        "aria-owns": anchorEl ? this.id : null,
        "aria-haspopup": "true",
        onClick: this.handleClick
      }, react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(_material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_2___default.a, null)), react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(_material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_1___default.a, {
        id: this.id,
        anchorEl: anchorEl,
        open: Boolean(anchorEl),
        onClose: this.handleClose,
        PaperProps: {
          style: {
            maxHeight: ITEM_HEIGHT * 5,
            width: 200
          }
        }
      }, children));
    }
  }]);

  return DropDown;
}(react__WEBPACK_IMPORTED_MODULE_4___default.a.Component);

DropDown.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any.isRequired,
  classes: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__["withStyles"])(styles)(DropDown));

/***/ }),

/***/ "./src/components/LayerSwitcher.jsx":
/*!******************************************!*\
  !*** ./src/components/LayerSwitcher.jsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_input_range_lib_css_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-input-range/lib/css/index.css */ "./node_modules/react-input-range/lib/css/index.css");
/* harmony import */ var react_input_range_lib_css_index_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_input_range_lib_css_index_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-sortable-hoc */ "./node_modules/react-sortable-hoc/dist/react-sortable-hoc.umd.js");
/* harmony import */ var react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _material_ui_core_Checkbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/Checkbox */ "./node_modules/@material-ui/core/Checkbox/index.js");
/* harmony import */ var _material_ui_core_Checkbox__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Checkbox__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_ui_icons_DragHandle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/icons/DragHandle */ "./node_modules/@material-ui/icons/DragHandle.js");
/* harmony import */ var _material_ui_icons_DragHandle__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_DragHandle__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _DropDown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DropDown */ "./src/components/DropDown.jsx");
/* harmony import */ var react_input_range__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-input-range */ "./node_modules/react-input-range/lib/js/index.js");
/* harmony import */ var react_input_range__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_input_range__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/core/List */ "./node_modules/@material-ui/core/List/index.js");
/* harmony import */ var _material_ui_core_List__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/ListItem */ "./node_modules/@material-ui/core/ListItem/index.js");
/* harmony import */ var _material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _material_ui_core_ListSubheader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/ListSubheader */ "./node_modules/@material-ui/core/ListSubheader/index.js");
/* harmony import */ var _material_ui_core_ListSubheader__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_ListSubheader__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/MenuItem */ "./node_modules/@material-ui/core/MenuItem/index.js");
/* harmony import */ var _material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _CommonComponents__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CommonComponents */ "./src/components/CommonComponents.jsx");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/Paper */ "./node_modules/@material-ui/core/Paper/index.js");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_15__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















var DragHandle = Object(react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__["SortableHandle"])(function () {
  return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_icons_DragHandle__WEBPACK_IMPORTED_MODULE_4___default.a, null);
});

var styles = function styles(theme) {
  return {
    legendsPaper: {
      padding: theme.spacing.unit * 2
    }
  };
};

var LayerItem = Object(react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__["SortableElement"])(function (_ref) {
  var layer = _ref.layer,
      layerIndex = _ref.layerIndex,
      handleLayerVisibilty = _ref.handleLayerVisibilty,
      zoomToLayerData = _ref.zoomToLayerData,
      handleLayerOpacity = _ref.handleLayerOpacity;
  var metadata = layer.get('metadata');
  var layerTitle = metadata['title'];
  var bbox = metadata['bbox'].map(function (coord) {
    return parseFloat(coord);
  });
  var projection = metadata['projection'];
  return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_ListItem__WEBPACK_IMPORTED_MODULE_8___default.a, {
    disableGutters: true,
    className: "layer-switcher-item dense"
  }, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(DragHandle, null), react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_Checkbox__WEBPACK_IMPORTED_MODULE_3___default.a, {
    checked: layer.getVisible(),
    tabIndex: -1,
    onChange: handleLayerVisibilty(layerIndex),
    disableRipple: true
  }), react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement("div", {
    className: "element-flex element-column title-noWrap"
  }, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_11__["Message"], {
    message: layerTitle,
    noWrap: true,
    align: "left",
    type: "body1"
  }), react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(react_input_range__WEBPACK_IMPORTED_MODULE_6___default.a, {
    minValue: 0,
    maxValue: 1,
    step: .1,
    value: layer.getOpacity(),
    onChange: handleLayerOpacity(layerIndex)
  })), react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_DropDown__WEBPACK_IMPORTED_MODULE_5__["default"], null, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_10___default.a, {
    onClick: function onClick() {
      return zoomToLayerData(bbox, projection);
    }
  }, "Zoom To Layer Data")));
});
var LayerList = Object(react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__["SortableContainer"])(function (_ref2) {
  var layers = _ref2.layers,
      handleLayerVisibilty = _ref2.handleLayerVisibilty,
      zoomToLayerData = _ref2.zoomToLayerData,
      handleLayerOpacity = _ref2.handleLayerOpacity;
  return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_List__WEBPACK_IMPORTED_MODULE_7___default.a, {
    disablePadding: true,
    subheader: react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_ListSubheader__WEBPACK_IMPORTED_MODULE_9___default.a, {
      disableSticky: true
    }, "Drag & Drop To Order the Layers")
  }, layers.map(function (layer, index) {
    return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(LayerItem, {
      handleLayerVisibilty: handleLayerVisibilty,
      zoomToLayerData: zoomToLayerData,
      handleLayerOpacity: handleLayerOpacity,
      key: "item-".concat(index),
      index: index,
      layerIndex: index,
      layer: layer
    });
  }));
});

var CartoviewLayerSwitcher =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CartoviewLayerSwitcher, _React$PureComponent);

  function CartoviewLayerSwitcher() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, CartoviewLayerSwitcher);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CartoviewLayerSwitcher)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "handleLayerVisibilty", function (layerIndex) {
      return function (event, checked) {
        var _this$context = _this.context,
            mapLayers = _this$context.mapLayers,
            setStateKey = _this$context.setStateKey;
        var layer = mapLayers[layerIndex];
        layer.setVisible(checked);
        setStateKey('mapLayers', mapLayers);
      };
    });

    _defineProperty(_assertThisInitialized(_this), "changeLayerOrder", function (_ref3) {
      var oldIndex = _ref3.oldIndex,
          newIndex = _ref3.newIndex;
      var _this$context2 = _this.context,
          mapLayers = _this$context2.mapLayers,
          setStateKey = _this$context2.setStateKey;
      var newMapLayers = Object(react_sortable_hoc__WEBPACK_IMPORTED_MODULE_1__["arrayMove"])(mapLayers, oldIndex, newIndex);
      newMapLayers.map(function (layer, index) {
        layer.setZIndex(mapLayers.length - index);
      });
      setStateKey('mapLayers', newMapLayers);
    });

    _defineProperty(_assertThisInitialized(_this), "handleLayerOpacity", function (layerIndex) {
      return function (value) {
        var _this$context3 = _this.context,
            mapLayers = _this$context3.mapLayers,
            setStateKey = _this$context3.setStateKey;
        var layer = mapLayers[layerIndex];
        layer.setOpacity(value);
        setStateKey('mapLayers', mapLayers);
      };
    });

    return _this;
  }

  _createClass(CartoviewLayerSwitcher, [{
    key: "render",
    value: function render() {
      var classes = this.props.classes;
      var _this$context4 = this.context,
          mapLayers = _this$context4.mapLayers,
          mapLoading = _this$context4.mapLoading,
          zoomToExtent = _this$context4.zoomToExtent;
      return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_12___default.a, {
        className: classes.legendsPaper,
        elevation: 0
      }, mapLayers.length > 0 && !mapLoading && react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(LayerList, {
        layers: mapLayers,
        useDragHandle: true,
        handleLayerVisibilty: this.handleLayerVisibilty,
        zoomToLayerData: zoomToExtent,
        handleLayerOpacity: this.handleLayerOpacity,
        helperClass: "sortable-container",
        onSortEnd: this.changeLayerOrder
      }), mapLayers.length == 0 && react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_11__["Message"], {
        message: "No Layers",
        align: "center",
        type: "body1"
      }));
    }
  }]);

  return CartoviewLayerSwitcher;
}(react__WEBPACK_IMPORTED_MODULE_14___default.a.PureComponent);

CartoviewLayerSwitcher.contextType = _context__WEBPACK_IMPORTED_MODULE_2__["BasicViewerContext"];
CartoviewLayerSwitcher.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_13___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_15__["withStyles"])(styles)(CartoviewLayerSwitcher));

/***/ }),

/***/ "./src/components/Legend.jsx":
/*!***********************************!*\
  !*** ./src/components/Legend.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CommonComponents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CommonComponents */ "./src/components/CommonComponents.jsx");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var react_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-image */ "./node_modules/react-image/umd/index.js");
/* harmony import */ var react_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_image__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/Paper */ "./node_modules/@material-ui/core/Paper/index.js");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_6__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }









var styles = function styles(theme) {
  return {
    legendsPaper: {
      padding: theme.spacing.unit * 2,
      textAlign: "center"
    }
  };
};

var LegendItem = function LegendItem(props) {
  var legend = props.legend;
  return react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement("div", {
    className: "full-width element-block"
  }, react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_0__["Message"], {
    align: "center",
    message: "".concat(legend.layer),
    type: "body1"
  }), react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(react_image__WEBPACK_IMPORTED_MODULE_2___default.a, {
    src: [legend.url],
    loader: react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_0__["Loader"], {
      align: "center",
      size: 30
    })
  }));
};

LegendItem.propTypes = {
  legend: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object.isRequired
};

var CartoviewLegends =
/*#__PURE__*/
function (_React$Component) {
  _inherits(CartoviewLegends, _React$Component);

  function CartoviewLegends() {
    _classCallCheck(this, CartoviewLegends);

    return _possibleConstructorReturn(this, _getPrototypeOf(CartoviewLegends).apply(this, arguments));
  }

  _createClass(CartoviewLegends, [{
    key: "render",
    value: function render() {
      var legends = this.context.legends;
      var classes = this.props.classes;
      return react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_3___default.a, {
        className: classes.legendsPaper,
        elevation: 0
      }, legends.length > 0 && legends.map(function (legend, index) {
        return react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(LegendItem, {
          key: index,
          legend: legend
        });
      }), legends.length === 0 && react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_0__["Message"], {
        message: "No Legends",
        align: "center",
        type: "body1"
      }));
    }
  }]);

  return CartoviewLegends;
}(react__WEBPACK_IMPORTED_MODULE_5___default.a.Component);

CartoviewLegends.contextType = _context__WEBPACK_IMPORTED_MODULE_1__["BasicViewerContext"];
CartoviewLegends.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_6__["withStyles"])(styles)(CartoviewLegends));

/***/ }),

/***/ "./src/components/MapViewer.jsx":
/*!**************************************!*\
  !*** ./src/components/MapViewer.jsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var recompose_compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recompose/compose */ "./node_modules/recompose/compose.js");
/* harmony import */ var recompose_compose__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(recompose_compose__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-redux */ "./node_modules/react-redux/es/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/withWidth */ "./node_modules/@material-ui/core/withWidth/index.js");
/* harmony import */ var _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_6__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }









var styles = function styles(theme) {
  return {};
};

var MapViewer =
/*#__PURE__*/
function (_React$Component) {
  _inherits(MapViewer, _React$Component);

  function MapViewer(props) {
    _classCallCheck(this, MapViewer);

    return _possibleConstructorReturn(this, _getPrototypeOf(MapViewer).call(this, props));
  }

  _createClass(MapViewer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var map = this.context.map;
      map.setTarget(this.mapDiv);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props = this.props,
          width = _this$props.width,
          reduxMap = _this$props.reduxMap;
      var _this$context = this.context,
          map = _this$context.map,
          setStateKey = _this$context.setStateKey;

      if (prevProps.width !== width) {
        map.updateSize();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
        id: "map",
        ref: function ref(mapDiv) {
          return _this.mapDiv = mapDiv;
        },
        className: "map-panel"
      });
    }
  }]);

  return MapViewer;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

MapViewer.contextType = _context__WEBPACK_IMPORTED_MODULE_0__["BasicViewerContext"];
MapViewer.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,
  width: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any.isRequired,
  reduxMap: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
  return {
    reduxMap: state.map
  };
};

var App = Object(react_redux__WEBPACK_IMPORTED_MODULE_4__["connect"])(mapStateToProps, null)(MapViewer);
/* harmony default export */ __webpack_exports__["default"] = (recompose_compose__WEBPACK_IMPORTED_MODULE_3___default()(Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_5__["withStyles"])(styles), _material_ui_core_withWidth__WEBPACK_IMPORTED_MODULE_6___default()())(App));

/***/ }),

/***/ "./src/components/Navbar.jsx":
/*!***********************************!*\
  !*** ./src/components/Navbar.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_ui_core_AppBar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material-ui/core/AppBar */ "./node_modules/@material-ui/core/AppBar/index.js");
/* harmony import */ var _material_ui_core_AppBar__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_AppBar__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _material_ui_core_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/Toolbar */ "./node_modules/@material-ui/core/Toolbar/index.js");
/* harmony import */ var _material_ui_core_Toolbar__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Toolbar__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_4__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var drawerWidth = '100%';

var styles = function styles(theme) {
  return {
    root: {
      width: '100%'
    },
    drawerPaper: {
      width: drawerWidth
    },
    drawerHeader: _objectSpread({
      background: theme.palette.primary[500],
      display: 'flex',
      justifyContent: 'flex-end',
      padding: '0 8px'
    }, theme.mixins.toolbar)
  };
};

var NavBar =
/*#__PURE__*/
function (_React$Component) {
  _inherits(NavBar, _React$Component);

  function NavBar() {
    _classCallCheck(this, NavBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(NavBar).apply(this, arguments));
  }

  _createClass(NavBar, [{
    key: "render",
    value: function render() {
      var classes = this.props.classes;
      return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
        className: classes.root
      }, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_material_ui_core_AppBar__WEBPACK_IMPORTED_MODULE_0___default.a, {
        className: classes.drawerHeader,
        position: "static"
      }, react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_material_ui_core_Toolbar__WEBPACK_IMPORTED_MODULE_3___default.a, null)));
    }
  }]);

  return NavBar;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

NavBar.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_4__["withStyles"])(styles, {
  withTheme: true
})(NavBar));

/***/ }),

/***/ "./src/components/Popup.jsx":
/*!**********************************!*\
  !*** ./src/components/Popup.jsx ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_ui_icons_KeyboardArrowLeft__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material-ui/icons/KeyboardArrowLeft */ "./node_modules/@material-ui/icons/KeyboardArrowLeft.js");
/* harmony import */ var _material_ui_icons_KeyboardArrowLeft__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_KeyboardArrowLeft__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _material_ui_icons_KeyboardArrowRight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/icons/KeyboardArrowRight */ "./node_modules/@material-ui/icons/KeyboardArrowRight.js");
/* harmony import */ var _material_ui_icons_KeyboardArrowRight__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_KeyboardArrowRight__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/Button/index.js");
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_ui_icons_Close__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/icons/Close */ "./node_modules/@material-ui/icons/Close.js");
/* harmony import */ var _material_ui_icons_Close__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Close__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/IconButton */ "./node_modules/@material-ui/core/IconButton/index.js");
/* harmony import */ var _material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _CommonComponents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CommonComponents */ "./src/components/CommonComponents.jsx");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/core/Paper */ "./node_modules/@material-ui/core/Paper/index.js");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _material_ui_core_Table__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/Table */ "./node_modules/@material-ui/core/Table/index.js");
/* harmony import */ var _material_ui_core_Table__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Table__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_TableBody__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/TableBody */ "./node_modules/@material-ui/core/TableBody/index.js");
/* harmony import */ var _material_ui_core_TableBody__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_TableBody__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _material_ui_core_TableCell__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/TableCell */ "./node_modules/@material-ui/core/TableCell/index.js");
/* harmony import */ var _material_ui_core_TableCell__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_TableCell__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _material_ui_core_TableRow__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/TableRow */ "./node_modules/@material-ui/core/TableRow/index.js");
/* harmony import */ var _material_ui_core_TableRow__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_TableRow__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _material_ui_core_Tooltip__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @material-ui/core/Tooltip */ "./node_modules/@material-ui/core/Tooltip/index.js");
/* harmony import */ var _material_ui_core_Tooltip__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Tooltip__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/Typography/index.js");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _material_ui_icons_ZoomIn__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @material-ui/icons/ZoomIn */ "./node_modules/@material-ui/icons/ZoomIn.js");
/* harmony import */ var _material_ui_icons_ZoomIn__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_ZoomIn__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





















var styles = function styles(theme) {
  return {
    root: {
      width: '100%',
      maxWidth: 360,
      backgroundColor: theme.palette.background.paper,
      position: 'relative',
      overflow: 'auto',
      maxHeight: 300
    },
    button: {
      height: 'auto'
    },
    titlePanel: {
      backgroundColor: theme.palette.primary.light,
      borderColor: '#777777',
      alignItems: 'center'
    },
    content: {
      backgroundColor: theme.palette.background.paper
    },
    table: {
      display: 'block',
      width: '100%',
      overflowX: 'auto'
    },
    tableRow: {
      display: 'flex',
      width: '100%',
      flexGrow: "1",
      height: 'auto !important',
      flexBasis: "0",
      '&:nth-of-type(odd)': {
        backgroundColor: theme.palette.background["default"]
      }
    },
    tableCell: {
      flex: ".5",
      alignItems: "center",
      padding: "".concat(theme.spacing.unit, "px !important"),
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    }
  };
};

var FeatureAttributesTable = Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__["withStyles"])(styles)(function (props) {
  var currentFeature = props.currentFeature,
      classes = props.classes;
  return react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Table__WEBPACK_IMPORTED_MODULE_10___default.a, {
    className: classes.table
  }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_TableBody__WEBPACK_IMPORTED_MODULE_11___default.a, {
    className: classes.table
  }, Object.keys(currentFeature.getProperties()).map(function (key, index) {
    if (key && key != "geometry" && key != 'layerName') {
      var attibuteLabel = key;
      return react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_TableRow__WEBPACK_IMPORTED_MODULE_13___default.a, {
        classes: {
          root: classes.tableRow
        },
        key: index
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_TableCell__WEBPACK_IMPORTED_MODULE_12___default.a, {
        classes: {
          body: classes.tableCell
        }
      }, "".concat(attibuteLabel)), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_TableCell__WEBPACK_IMPORTED_MODULE_12___default.a, {
        classes: {
          body: classes.tableCell
        }
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Tooltip__WEBPACK_IMPORTED_MODULE_14___default.a, {
        id: "tooltip-top",
        title: "".concat(currentFeature.getProperties()[key]),
        placement: "top"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("span", null, "".concat(currentFeature.getProperties()[key])))));
    }
  })));
});
FeatureAttributesTable.propTypes = {
  currentFeature: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object.isRequired
};

var CartoviewPopup =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CartoviewPopup, _React$PureComponent);

  function CartoviewPopup() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, CartoviewPopup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CartoviewPopup)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      currentFeature: null
    });

    _defineProperty(_assertThisInitialized(_this), "ensureEvents", function () {
      var _this$context = _this.context,
          changeShowPopup = _this$context.changeShowPopup,
          nextFeature = _this$context.nextFeature,
          previousFeature = _this$context.previousFeature;

      var self = _assertThisInitialized(_this);

      var closer = self.popupCloser;
      var nextB = self.nextButton;
      var prevB = self.prevButton; // var zoomToB = self.zoomToButton

      if (closer.onclick === null) {
        closer.onclick = function () {
          // resetFeatureCollection()
          changeShowPopup();
          return false;
        };
      }

      if (nextB.onclick === null) {
        nextB.onclick = function () {
          nextFeature();
        };
      }

      if (prevB.onclick === null) {
        prevB.onclick = function () {
          previousFeature();
        };
      } // if (zoomToB.onclick === null) {
      // 	zoomToB.onclick = () => {
      // 		let { currentFeature } = this.state
      // 		// zoomToFeature(currentFeature)
      // 	}
      // }

    });

    return _this;
  }

  _createClass(CartoviewPopup, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      var _this$context2 = this.context,
          addOverlay = _this$context2.addOverlay,
          featureIdentifyResult = _this$context2.featureIdentifyResult,
          activeFeature = _this$context2.activeFeature,
          showPopup = _this$context2.showPopup;

      if (showPopup) {
        this.node.style.display = 'block';
        var currentFeature = featureIdentifyResult && featureIdentifyResult.length > 0 ? featureIdentifyResult[activeFeature] : null;
        this.setState({
          currentFeature: currentFeature
        }, function () {
          return addOverlay(_this2.node);
        });
        this.ensureEvents();
      } else {
        this.node.style.display = 'none';
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var classes = this.props.classes;
      var _this$context3 = this.context,
          featureIdentifyResult = _this$context3.featureIdentifyResult,
          featureIdentifyLoading = _this$context3.featureIdentifyLoading,
          activeFeature = _this$context3.activeFeature;
      var nextButtonVisible = featureIdentifyResult.length > 0 && activeFeature != featureIdentifyResult.length - 1;
      var currentFeature = featureIdentifyResult[activeFeature];
      return react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("div", {
        ref: function ref(node) {
          return _this3.node = node;
        },
        id: "popup",
        className: "ol-popup-cartoview"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_7___default.a, {
        elevation: 2
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_17___default()("title-panel", _defineProperty({}, classes.titlePanel, true))
      }, featureIdentifyResult.length != 0 && react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_15___default.a, {
        type: "body1",
        align: "left",
        noWrap: true,
        color: "default",
        className: "element-flex title-text"
      }, "Layer : ".concat(currentFeature.get('layerName'))), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5___default.a, {
        color: "default",
        className: classnames__WEBPACK_IMPORTED_MODULE_17___default()(_defineProperty({
          'hidden': activeFeature === 0,
          'visible': activeFeature != 0,
          'popup-buttons': true
        }, classes.button, true)),
        buttonRef: function buttonRef(node) {
          return _this3.prevButton = node;
        },
        "aria-label": "Delete"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_icons_KeyboardArrowLeft__WEBPACK_IMPORTED_MODULE_0___default.a, null)), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5___default.a, {
        color: "default",
        className: classnames__WEBPACK_IMPORTED_MODULE_17___default()(_defineProperty({
          'hidden': !nextButtonVisible,
          'visible': nextButtonVisible,
          'popup-buttons': true
        }, classes.button, true)),
        buttonRef: function buttonRef(node) {
          return _this3.nextButton = node;
        },
        "aria-label": "Delete"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_icons_KeyboardArrowRight__WEBPACK_IMPORTED_MODULE_1___default.a, null)), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_core_IconButton__WEBPACK_IMPORTED_MODULE_5___default.a, {
        color: "default",
        buttonRef: function buttonRef(node) {
          return _this3.popupCloser = node;
        },
        className: classnames__WEBPACK_IMPORTED_MODULE_17___default()(_defineProperty({
          'popup-buttons': true
        }, classes.button, true)),
        "aria-label": "Delete"
      }, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_material_ui_icons_Close__WEBPACK_IMPORTED_MODULE_4___default.a, null))), react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_17___default()("cartoview-popup-content", _defineProperty({}, classes.content, true))
      }, featureIdentifyResult.length > 0 && react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(FeatureAttributesTable, {
        currentFeature: currentFeature
      })), featureIdentifyResult.length == 0 && !featureIdentifyLoading && react__WEBPACK_IMPORTED_MODULE_9___default.a.createElement(_CommonComponents__WEBPACK_IMPORTED_MODULE_6__["Message"], {
        message: "No Features at this Point",
        type: "subheading"
      }))));
    }
  }]);

  return CartoviewPopup;
}(react__WEBPACK_IMPORTED_MODULE_9___default.a.PureComponent);

CartoviewPopup.contextType = _context__WEBPACK_IMPORTED_MODULE_2__["BasicViewerContext"];
CartoviewPopup.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_18__["withStyles"])(styles)(CartoviewPopup));

/***/ }),

/***/ "./src/components/SaveDialog.jsx":
/*!***************************************!*\
  !*** ./src/components/SaveDialog.jsx ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/Button/index.js");
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _material_ui_core_Dialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/core/Dialog */ "./node_modules/@material-ui/core/Dialog/index.js");
/* harmony import */ var _material_ui_core_Dialog__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Dialog__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _material_ui_core_DialogActions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/DialogActions */ "./node_modules/@material-ui/core/DialogActions/index.js");
/* harmony import */ var _material_ui_core_DialogActions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_DialogActions__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_ui_core_DialogContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/core/DialogContent */ "./node_modules/@material-ui/core/DialogContent/index.js");
/* harmony import */ var _material_ui_core_DialogContent__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_DialogContent__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _material_ui_core_DialogTitle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/DialogTitle */ "./node_modules/@material-ui/core/DialogTitle/index.js");
/* harmony import */ var _material_ui_core_DialogTitle__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_DialogTitle__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/TextField */ "./node_modules/@material-ui/core/TextField/index.js");
/* harmony import */ var _material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/styles */ "./node_modules/@material-ui/core/styles/index.js");
/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_9__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var styles = function styles(theme) {
  return {
    root: {
      height: "100%"
    },
    drawerPaper: {
      padding: 0,
      height: "calc(100% - 64px)",
      overflowY: 'scroll'
    },
    button: {
      margin: theme.spacing.unit
    }
  };
};

var SaveDialog =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SaveDialog, _React$Component);

  function SaveDialog() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SaveDialog);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SaveDialog)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (name) {
      return function (event) {
        var _this$context = _this.context,
            currentMap = _this$context.currentMap,
            setStateKey = _this$context.setStateKey;
        var map = currentMap ? currentMap : {};
        setStateKey('currentMap', _objectSpread({}, map, _defineProperty({}, name, event.target.value)));
      };
    });

    return _this;
  }

  _createClass(SaveDialog, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          handleClose = _this$props.handleClose,
          open = _this$props.open,
          classes = _this$props.classes;
      var _this$context2 = this.context,
          currentMap = _this$context2.currentMap,
          saveMap = _this$context2.saveMap;
      return react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_Dialog__WEBPACK_IMPORTED_MODULE_2___default.a, {
        open: open,
        onClose: handleClose,
        "aria-labelledby": "form-dialog-title"
      }, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_DialogTitle__WEBPACK_IMPORTED_MODULE_5___default.a, {
        id: "form-dialog-title"
      }, "Save Map"), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_DialogContent__WEBPACK_IMPORTED_MODULE_4___default.a, null, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_8___default.a, {
        id: "outlined-name",
        label: "Title",
        className: classes.textField,
        fullWidth: true,
        value: currentMap.title,
        onChange: this.handleChange('title'),
        margin: "normal",
        variant: "outlined"
      }), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_8___default.a, {
        id: "outlined-name",
        label: "Description",
        fullWidth: true,
        className: classes.textField,
        value: currentMap.description,
        onChange: this.handleChange('description'),
        margin: "normal",
        variant: "outlined"
      })), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_DialogActions__WEBPACK_IMPORTED_MODULE_3___default.a, null, react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_1___default.a, {
        onClick: handleClose,
        color: "primary"
      }, "Cancel"), react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_1___default.a, {
        onClick: saveMap,
        color: "primary"
      }, "Save"))));
    }
  }]);

  return SaveDialog;
}(react__WEBPACK_IMPORTED_MODULE_7___default.a.Component);

SaveDialog.contextType = _context__WEBPACK_IMPORTED_MODULE_0__["BasicViewerContext"];
SaveDialog.propTypes = {
  classes: prop_types__WEBPACK_IMPORTED_MODULE_6___default.a.object.isRequired,
  handleClose: prop_types__WEBPACK_IMPORTED_MODULE_6___default.a.func.isRequired,
  open: prop_types__WEBPACK_IMPORTED_MODULE_6___default.a.bool.isRequired
};
SaveDialog.defaultProps = {
  handleClose: function handleClose() {},
  open: false
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_9__["withStyles"])(styles)(SaveDialog));

/***/ }),

/***/ "./src/containers/basicViewer.jsx":
/*!****************************************!*\
  !*** ./src/containers/basicViewer.jsx ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_polyfill_noConflict__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/polyfill/noConflict */ "./node_modules/@babel/polyfill/noConflict.js");
/* harmony import */ var _babel_polyfill_noConflict__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_polyfill_noConflict__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_base_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/base.css */ "./src/css/base.css");
/* harmony import */ var _css_base_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_base_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_ol_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _css_popup_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css/popup.css */ "./src/css/popup.css");
/* harmony import */ var _css_popup_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_popup_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api */ "./src/api/index.js");
/* harmony import */ var cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cartoview-sdk/helpers/BasicViewerHelper */ "./node_modules/cartoview-sdk/helpers/BasicViewerHelper.js");
/* harmony import */ var cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../context */ "./src/context/index.js");
/* harmony import */ var _components_ContentGrid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/ContentGrid */ "./src/components/ContentGrid.jsx");
/* harmony import */ var _services_Identify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../services/Identify */ "./src/services/Identify.jsx");
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cartoview-sdk/helpers/FeaturesHelper */ "./node_modules/cartoview-sdk/helpers/FeaturesHelper.js");
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _services_Legend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../services/Legend */ "./src/services/Legend.jsx");
/* harmony import */ var _services_MapLoadService__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../services/MapLoadService */ "./src/services/MapLoadService.jsx");
/* harmony import */ var ol_overlay__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/overlay */ "./node_modules/ol/overlay.js");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-redux */ "./node_modules/react-redux/es/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../store */ "./src/store/index.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















ol_proj__WEBPACK_IMPORTED_MODULE_16__["default"].setProj4(proj4__WEBPACK_IMPORTED_MODULE_17__["default"]);

var BasicViewer =
/*#__PURE__*/
function (_React$Component) {
  _inherits(BasicViewer, _React$Component);

  function BasicViewer(props) {
    var _this;

    _classCallCheck(this, BasicViewer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BasicViewer).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "setStateKey", function (key, value) {
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

      _this.setState(_defineProperty({}, key, value), function () {
        callback();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "changeShowPopup", function () {
      var showPopup = _this.state.showPopup;

      _this.setState({
        showPopup: !showPopup
      });
    });

    _defineProperty(_assertThisInitialized(_this), "nextFeature", function () {
      var activeFeature = _this.state.activeFeature;
      var nextIndex = activeFeature + 1;

      _this.setState({
        activeFeature: nextIndex
      });
    });

    _defineProperty(_assertThisInitialized(_this), "previousFeature", function () {
      var activeFeature = _this.state.activeFeature;
      var previuosIndex = activeFeature - 1;

      _this.setState({
        activeFeature: previuosIndex
      });
    });

    _defineProperty(_assertThisInitialized(_this), "getMapThumbnail", function () {
      var imagePromise = new Promise(function (resolve, reject) {
        var map = _this.state.map;
        map.once('postcompose', function (event) {
          var canvas = event.context.canvas;
          canvas.toBlob(function (blob) {
            var file = new File([blob], 'map.png', {
              type: 'image/png',
              lastModified: Date.now()
            });
            resolve(file);
          });
        });
        map.renderSync();
      });
      return imagePromise;
    });

    _defineProperty(_assertThisInitialized(_this), "toggleDrawer", function () {
      var drawerOpen = _this.state.drawerOpen;

      _this.setState({
        drawerOpen: !drawerOpen
      });
    });

    _defineProperty(_assertThisInitialized(_this), "save", function () {
      var _this$state = _this.state,
          currentMap = _this$state.currentMap,
          map = _this$state.map;
      var view = map.getView();
      var projection = view.getProjection().getCode();
      var zoom = view.getZoom();
      var rotation = view.getRotation();
      var center = view.getCenter();
      var layers = [];

      var mapLayers = _toConsumableArray(map.getLayers().getArray());

      mapLayers = mapLayers.reverse();

      for (var index = 0; index < mapLayers.length; index++) {
        var layer = mapLayers[index];
        var metadata = layer.get('metadata');

        if (metadata) {
          layers.push(metadata.identifier);
        }
      }

      var savePromises = [];
      var data = {
        title: currentMap.title,
        description: currentMap.description,
        projection: projection,
        zoom: zoom,
        rotation: rotation,
        center: center,
        layers: layers
      };

      if (currentMap.id) {
        savePromises.push(Object(_api__WEBPACK_IMPORTED_MODULE_4__["saveMap"])(currentMap.id, JSON.stringify(data)));

        _this.getMapThumbnail().then(function (thumb) {
          var formdata = new FormData();
          formdata.append('thumbnail', thumb);
          savePromises.push(Object(_api__WEBPACK_IMPORTED_MODULE_4__["saveMapThumbnail"])(currentMap.id, formdata));
        });

        Promise.all(savePromises).then(function (results) {
          return _this.setState({
            mapSaving: false
          });
        });
      } else {
        Object(_api__WEBPACK_IMPORTED_MODULE_4__["createMap"])(JSON.stringify(data)).then(function (resp) {
          if (resp.status < 400) {
            _this.setState({
              currentMap: resp.data
            });

            _this.getMapThumbnail().then(function (thumb) {
              var formdata = new FormData();
              formdata.append('thumbnail', thumb);
              savePromises.push(Object(_api__WEBPACK_IMPORTED_MODULE_4__["saveMapThumbnail"])(resp.data.id, formdata));
            });
          }
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "saveMap", function () {
      _this.setState({
        mapSaving: true
      }, _this.save);
    });

    _defineProperty(_assertThisInitialized(_this), "loadMap", function (mapJson) {
      var map = _this.state.map;
      var service = new _services_MapLoadService__WEBPACK_IMPORTED_MODULE_11__["default"](map, mapJson);
      service.load(function () {
        var layers = map.getLayers().getArray();
        layers = _toConsumableArray(layers).reverse().filter(function (layer) {
          var metadata = layer.get('metadata');

          if (metadata && metadata['name'] !== undefined) {
            return true;
          }

          return false;
        });

        _this.setState({
          mapLayers: layers
        });

        Promise.all(_services_Legend__WEBPACK_IMPORTED_MODULE_10__["default"].getLegends(map)).then(function (result) {
          return _this.setState({
            legends: result
          });
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "zoomToExtent", function (extent) {
      var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EPSG:4326';
      var map = _this.state.map;
      cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_9___default.a.getCRS(projection.split(":").pop()).then(function (newCRS) {
        var transformedExtent = cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5___default.a.reprojectExtent(extent, map, projection);
        cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5___default.a.fitExtent(transformedExtent, map);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "addOverlay", function (node) {
      var _this$state2 = _this.state,
          activeFeature = _this$state2.activeFeature,
          featureIdentifyResult = _this$state2.featureIdentifyResult,
          mouseCoordinates = _this$state2.mouseCoordinates;
      var position = mouseCoordinates;

      if (featureIdentifyResult && featureIdentifyResult.length > 0) {
        var currentFeature = featureIdentifyResult[activeFeature];
        var geometry = currentFeature.getGeometry();
        position = cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_9___default.a.getGeometryCenter(geometry);
      }

      _this.overlay.setElement(node);

      _this.overlay.setPosition(position);
    });

    _defineProperty(_assertThisInitialized(_this), "getContextValue", function () {
      return _objectSpread({}, _this.state, {
        toggleDrawer: _this.toggleDrawer,
        nextFeature: _this.nextFeature,
        previousFeature: _this.previousFeature,
        changeShowPopup: _this.changeShowPopup,
        addOverlay: _this.addOverlay,
        setStateKey: _this.setStateKey,
        zoomToExtent: _this.zoomToExtent,
        saveMap: _this.saveMap
      });
    });

    _defineProperty(_assertThisInitialized(_this), "identify", function (evt) {
      var map = _this.state.map;
      Promise.all(_services_Identify__WEBPACK_IMPORTED_MODULE_8__["default"].identify(map, evt)).then(function (featureGroups) {
        var features = [];

        for (var g = 0, gg = featureGroups.length; g < gg; g++) {
          var layers = Object.keys(featureGroups[g]);

          var _loop = function _loop(l, ll) {
            var layer = layers[l];
            var newFeatures = featureGroups[g][layer].map(function (f) {
              f.set('layerName', layer);
              return f;
            });
            features = [].concat(_toConsumableArray(features), _toConsumableArray(newFeatures));
          };

          for (var l = 0, ll = layers.length; l < ll; l++) {
            _loop(l, ll);
          }
        }

        _this.setState({
          featureIdentifyLoading: false,
          activeFeature: 0,
          featureIdentifyResult: features,
          showPopup: true
        });
      });
    });

    _this.state = {
      map: cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_5___default.a.getMap(),
      drawerOpen: false,
      featureIdentifyLoading: false,
      featureIdentifyResult: [],
      showPopup: false,
      activeFeature: 0,
      legends: [],
      mapSaving: false,
      mapLayers: [],
      mouseCoordinates: [0, 0],
      mapLoading: false,
      currentMap: {
        title: "No Title Provided",
        description: "No Description Provided"
      }
    };
    return _this;
  }

  _createClass(BasicViewer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var map = this.state.map;

      if (window.mapId) {
        Object(_api__WEBPACK_IMPORTED_MODULE_4__["fetchMapById"])(window.mapId).then(function (response) {
          var data = response.data;
          var transformedData = Object(_api__WEBPACK_IMPORTED_MODULE_4__["mapJsonSerializer"])(data);

          _this2.setState({
            currentMap: data
          }, function () {
            _this2.loadMap(transformedData);
          });
        });
      }

      this.overlay = new ol_overlay__WEBPACK_IMPORTED_MODULE_12__["default"]({
        autoPan: true,
        autoPanAnimation: {
          duration: 250
        },
        positioning: 'center-center'
      });
      map.addOverlay(this.overlay);
      map.on('singleclick', function (evt) {
        if (_this2.overlay) {
          _this2.overlay.setElement(undefined);
        }

        _this2.setState({
          featureIdentifyLoading: true,
          activeFeature: 0,
          featureIdentifyResult: [],
          showPopup: false,
          mouseCoordinates: evt.coordinate
        }, function () {
          return _this2.identify(evt);
        });
      });
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(react_redux__WEBPACK_IMPORTED_MODULE_13__["Provider"], {
        store: _store__WEBPACK_IMPORTED_MODULE_18__["default"]
      }, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_14___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_context__WEBPACK_IMPORTED_MODULE_6__["BasicViewerProvider"], {
        value: this.getContextValue()
      }, react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(_components_ContentGrid__WEBPACK_IMPORTED_MODULE_7__["default"], null))));
    }
  }]);

  return BasicViewer;
}(react__WEBPACK_IMPORTED_MODULE_14___default.a.Component);

var elem = document.getElementById("basicviewer-app");

if (!elem) {
  elem = document.createElement('div', {
    "id": "basicviewer-app"
  });
  document.body.prepend(elem);
}

react_dom__WEBPACK_IMPORTED_MODULE_15___default.a.render(react__WEBPACK_IMPORTED_MODULE_14___default.a.createElement(BasicViewer, null), elem);

if (false) {}

/***/ }),

/***/ "./src/context/index.js":
/*!******************************!*\
  !*** ./src/context/index.js ***!
  \******************************/
/*! exports provided: BasicViewerContext, BasicViewerProvider, BasicViewerConsumer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicViewerContext", function() { return BasicViewerContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicViewerProvider", function() { return BasicViewerProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicViewerConsumer", function() { return BasicViewerConsumer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var BasicViewerContext = react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({});
var BasicViewerProvider = BasicViewerContext.Provider;
var BasicViewerConsumer = BasicViewerContext.Consumer;

/***/ }),

/***/ "./src/css/base.css":
/*!**************************!*\
  !*** ./src/css/base.css ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader??ref--5-2!../../node_modules/postcss-loader/src??postcss!./base.css */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/css/base.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/css/popup.css":
/*!***************************!*\
  !*** ./src/css/popup.css ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader??ref--5-2!../../node_modules/postcss-loader/src??postcss!./popup.css */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/css/popup.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/reducers/app.js":
/*!*****************************!*\
  !*** ./src/reducers/app.js ***!
  \*****************************/
/*! exports provided: appSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appSettings", function() { return appSettings; });
/* harmony import */ var _actions_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/constants */ "./src/actions/constants.js");
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var appInitialState = {
  keywords: [],
  bookmarks: [],
  showLegend: true,
  geocodingKey: null,
  enableHistory: true,
  showExportMap: true,
  showLayerSwitcher: true,
  enableFeatureTable: true,
  boundlessGeoCodingEnabled: false
};
function appSettings() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : appInitialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["SET_APP_SETTINGS"]:
      return action.payload;

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_APP_SETTINGS"]:
      return _objectSpread({}, state, action.payload);

    default:
      return state;
  }
}

/***/ }),

/***/ "./src/reducers/errors.js":
/*!********************************!*\
  !*** ./src/reducers/errors.js ***!
  \********************************/
/*! exports provided: appErrors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appErrors", function() { return appErrors; });
/* harmony import */ var _actions_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/constants */ "./src/actions/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var errorsInitailState = {
  errors: []
};
function appErrors() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : errorsInitailState;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["ADD_ERRORS"]:
      return _objectSpread({}, state, {
        errors: [].concat(_toConsumableArray(state.errors), _toConsumableArray(action.payload))
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["DELETE_ERROR"]:
      return _objectSpread({}, state, {
        errors: state.errors.filter(function (error) {
          return error !== action.payload;
        })
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["SET_ERRORS"]:
      return _objectSpread({}, state, {
        errors: action.payload
      });

    default:
      return state;
  }
}

/***/ }),

/***/ "./src/reducers/index.js":
/*!*******************************!*\
  !*** ./src/reducers/index.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ "./src/reducers/errors.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ "./src/reducers/app.js");
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./src/reducers/map.js");




/* harmony default export */ __webpack_exports__["default"] = (Object(redux__WEBPACK_IMPORTED_MODULE_2__["combineReducers"])({
  map: _map__WEBPACK_IMPORTED_MODULE_3__["map"],
  appSettings: _app__WEBPACK_IMPORTED_MODULE_1__["appSettings"],
  appErrors: _errors__WEBPACK_IMPORTED_MODULE_0__["appErrors"]
}));

/***/ }),

/***/ "./src/reducers/map.js":
/*!*****************************!*\
  !*** ./src/reducers/map.js ***!
  \*****************************/
/*! exports provided: map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony import */ var _actions_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/constants */ "./src/actions/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var mapInitialState = {
  name: "Web Map",
  layers: [],
  view: {
    center: [0, 0],
    constrainRotation: true,
    enableRotation: true,
    rotation: 0,
    extent: undefined,
    maxZoom: 28,
    minZoom: 0,
    projection: "EPSG:3857",
    zoomFactor: 2,
    zoom: 6
  },
  renderOptions: {},
  loadTilesWhileAnimating: false,
  loadTilesWhileInteracting: false,
  moveTolerance: 1
};
function map() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : mapInitialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["SET_WEB_MAP"]:
      return action.payload;

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_MAP_VIEW"]:
      return _objectSpread({}, state, {
        view: _objectSpread({}, state.view, action.payload)
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["SET_MAP_VIEW"]:
      return _objectSpread({}, state, {
        view: action.payload
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["SET_MAP_LAYERS"]:
      return _objectSpread({}, state, {
        layers: action.payload
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["ADD_MAP_LAYERS"]:
      return _objectSpread({}, state, {
        layers: [].concat(_toConsumableArray(state.layers), _toConsumableArray(action.payload))
      });

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["UPDATE_WEB_MAP"]:
      return _objectSpread({}, state, action.payload);

    case _actions_constants__WEBPACK_IMPORTED_MODULE_0__["DELETE_MAP_LAYERS"]:
      return _objectSpread({}, state, {
        layers: state.layers.filter(function (lyr) {
          return !action.payload.includes(lyr.id);
        })
      });

    default:
      return state;
  }
}

/***/ }),

/***/ "./src/services/Identify.jsx":
/*!***********************************!*\
  !*** ./src/services/Identify.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cartoview-sdk/helpers/FeaturesHelper */ "./node_modules/cartoview-sdk/helpers/FeaturesHelper.js");
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_format_geojson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/format/geojson */ "./node_modules/ol/format/geojson.js");
/* harmony import */ var cartoview_sdk_helpers_LayersHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cartoview-sdk/helpers/LayersHelper */ "./node_modules/cartoview-sdk/helpers/LayersHelper.js");
/* harmony import */ var cartoview_sdk_helpers_LayersHelper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_LayersHelper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_3__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var geojsonFormat = new ol_format_geojson__WEBPACK_IMPORTED_MODULE_1__["default"]();

var FeatureIdentify =
/*#__PURE__*/
function () {
  function FeatureIdentify() {
    _classCallCheck(this, FeatureIdentify);
  }

  _createClass(FeatureIdentify, [{
    key: "identify",
    value: function identify(map, evt) {
      var view = map.getView();
      var mapResolution = view.getResolution();
      var mapProjection = view.getProjection();
      var wmsLayers = cartoview_sdk_helpers_LayersHelper__WEBPACK_IMPORTED_MODULE_2___default.a.getLayers(map.getLayers().getArray()).reverse();
      var wfsPromise = new Promise(function (resolve) {
        var layerFeatures = {};
        map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
          var metadata = layer.get('metadata');
          var layer_name = metadata['name'];

          if (layerFeatures[layer_name] === undefined) {
            layerFeatures[layer_name] = [];
          }

          layerFeatures[layer_name].push(feature);
        });
        resolve(layerFeatures);
      });
      var identifyPromises = wmsLayers.map(function (layer) {
        var metadata = layer.get('metadata');
        var layerName = metadata["name"];
        var serverProxy = metadata["server_proxy"];
        var identifyPromiseHandler = new Promise(function (resolve, reject) {
          var source = layer.getSource();
          var url = source.getGetFeatureInfoUrl(evt.coordinate, mapResolution, mapProjection, {
            "INFO_FORMAT": 'application/json',
            "FEATURE_COUNT": 10
          });
          axios__WEBPACK_IMPORTED_MODULE_3___default.a.get("".concat(serverProxy).concat(encodeURIComponent(url))).then(function (response) {
            var data = response.data;

            if (data.features && data.features.length > 0) {
              var crs = data.features.length > 0 ? data.crs.properties.name.split(":").pop() : null;
              cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_0___default.a.getCRS(crs).then(function (newCRS) {
                var features = geojsonFormat.readFeatures(data);
                resolve(_defineProperty({}, layerName, features));
              }, function (error) {
                reject(error);
              });
            } else {
              resolve(_defineProperty({}, layerName, []));
            }
          })["catch"](function (err) {
            console.error("Layer ".concat(layerName, " => Feature Identify Error:"), err);
            resolve(_defineProperty({}, layerName, []));
          });
        });
        return identifyPromiseHandler;
      });
      return [wfsPromise].concat(_toConsumableArray(identifyPromises));
    }
  }]);

  return FeatureIdentify;
}();

/* harmony default export */ __webpack_exports__["default"] = (new FeatureIdentify());

/***/ }),

/***/ "./src/services/Legend.jsx":
/*!*********************************!*\
  !*** ./src/services/Legend.jsx ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_layer_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/layer/group */ "./node_modules/ol/layer/group.js");
/* harmony import */ var merge_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! merge-images */ "./node_modules/merge-images/dist/index.es2015.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/services/utils.jsx");
/* harmony import */ var _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/MapLoadService */ "./src/services/MapLoadService.jsx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }






var LegendService =
/*#__PURE__*/
function () {
  function LegendService() {
    _classCallCheck(this, LegendService);
  }

  _createClass(LegendService, [{
    key: "getOGCWMSLegend",
    value: function getOGCWMSLegend(metadata, url) {
      var serverProxy = metadata['server_proxy'];
      var wmsURL = url;
      var query = {
        'REQUEST': 'GetLegendGraphic',
        'VERSION': '1.0.0',
        'FORMAT': 'image/png',
        "LAYER": metadata['name']
      };
      wmsURL = new URL('', wmsURL);
      var keys = Object.keys(query);

      for (var index = 0; index < keys.length; index++) {
        var key = keys[index];
        var value = query[key];
        wmsURL.searchParams.append(key, value);
      }

      wmsURL = wmsURL.href;

      if (serverProxy) {
        wmsURL = "".concat(serverProxy).concat(encodeURIComponent(wmsURL));
      }

      return wmsURL;
    }
  }, {
    key: "getForMerge",
    value: function getForMerge(src) {
      var promiseObj = new Promise(function (resolve, reject) {
        var i = new Image();

        i.onload = function () {
          resolve({
            src: src,
            x: 0,
            y: i.height
          });
        };

        i.src = src;
      });
      return promiseObj;
    }
  }, {
    key: "getArgisLegend",
    value: function getArgisLegend(legendJson) {
      var promiseObj = new Promise(function (resolve, reject) {
        var canvas = document.createElement('canvas');
        var context = canvas.getContext("2d"); // const height = legendJson.height || 50
        // const width = legendJson.height || 100
        // canvas.height = height
        // canvas.width = width

        var image = new Image();

        function getbase64() {
          canvas.toBlob(function (blob) {
            var reader = new FileReader();
            reader.readAsDataURL(blob);

            reader.onloadend = function () {
              var base64data = reader.result;
              resolve(base64data);
            };

            canvas.parentNode.removeChild(canvas);
          }, 'image/png');
        }

        image.onload = function () {
          context.drawImage(this, 0, 0);
          context.fillStyle = "black";
          context.textBaseline = 'middle';
          context.font = "15px 'sans-serif'";
          var textHeight = image.height / 2;
          var textWidth = image.width + 5;
          context.fillText(legendJson.label, textWidth, textHeight);
          getbase64();
        }; // set src last (recommend to use relative paths where possible)


        image.src = "data:".concat(legendJson.contentType, ";base64,").concat(legendJson.imageData);
        document.body.appendChild(canvas);
      });
      return promiseObj;
    }
  }, {
    key: "getLegendURL",
    value: function getLegendURL(layer) {
      var _this = this;

      var metadata = layer.get('metadata');
      var serverProxy = null;

      if (metadata) {
        serverProxy = metadata['server_proxy'];
      }

      var promiseObj = new Promise(function (resolve, reject) {
        var source = layer.getSource();

        var url = _this.getLayerURL(layer);

        if (source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileWMS'] || source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileWMS']) {
          resolve(_this.getOGCWMSLegend(metadata, url));
        } else if (source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileArcGISRest'] || source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['ImageArcGISRest']) {
          url = url.endsWith("/") ? "".concat(url, "legend?f=json") : "".concat(url, "/legend?f=json");
          url = "".concat(serverProxy).concat(encodeURIComponent(url));
          var imagesPromises = [];
          var images = [];
          fetch(url).then(function (resp) {
            return resp.json();
          }).then(function (data) {
            data.layers.map(function (lyr) {
              lyr.legend.map(function (leg) {
                imagesPromises.push(_this.getArgisLegend(leg));
              });
            });
            Promise.all(imagesPromises).then(function (values) {
              for (var index = 0; index < values.length; index++) {
                var element = values[index];
                images.push({
                  src: element,
                  x: 0,
                  y: 0
                });
              }

              var current = 0;

              for (var _index = 0; _index < images.length; _index++) {
                var _element = images[_index];
                _element.y = current + 25;
                current = _element.y;
              }

              Object(merge_images__WEBPACK_IMPORTED_MODULE_1__["default"])(images, {
                height: 25 * images.length + 50,
                width: 200
              }).then(function (b64) {
                resolve(b64);
              });
            });
          });
        }
      });
      return promiseObj;
    }
  }, {
    key: "getLayerURL",
    value: function getLayerURL(layer) {
      var source = layer.getSource();
      var layerURL = null;

      try {
        layerURL = source.getUrls()[0];
      } catch (err) {
        layerURL = source.getUrl();
      }

      var url = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["resolveURL"])(layerURL);
      return url;
    }
  }, {
    key: "getLayers",
    value: function getLayers(mapLayers) {
      var _this2 = this;

      var children = [];
      mapLayers.forEach(function (layer) {
        if (layer instanceof ol_layer_group__WEBPACK_IMPORTED_MODULE_0__["default"]) {
          children = children.concat(_this2.getLayers(layer.getLayers()));
        } else if (layer.getVisible()) {
          children.push(layer);
        }
      });
      return children;
    }
  }, {
    key: "getLegendObj",
    value: function getLegendObj(layer) {
      var _this3 = this;

      var metadata = layer.get('metadata');
      var promiseObj = new Promise(function (resolve, reject) {
        _this3.getLegendURL(layer).then(function (url) {
          var legend = {
            layer: metadata['name'],
            url: url
          };
          resolve(legend);
        });
      });
      return promiseObj;
    }
  }, {
    key: "getLegends",
    value: function getLegends(map) {
      var layers = this.getLayers(map.getLayers().getArray()).reverse();
      var legendsPromises = [];

      for (var index = 0; index < layers.length; index++) {
        var lyr = layers[index];
        var source = lyr.getSource();

        if (source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileArcGISRest'] || source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['ImageArcGISRest'] || source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileWMS'] || source instanceof _services_MapLoadService__WEBPACK_IMPORTED_MODULE_3__["sourceMapping"]['TileWMS']) {
          legendsPromises.push(this.getLegendObj(lyr));
        }
      }

      return legendsPromises;
    }
  }]);

  return LegendService;
}();

/* harmony default export */ __webpack_exports__["default"] = (new LegendService());

/***/ }),

/***/ "./src/services/MapLoadService.jsx":
/*!*****************************************!*\
  !*** ./src/services/MapLoadService.jsx ***!
  \*****************************************/
/*! exports provided: sourceMapping, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sourceMapping", function() { return sourceMapping; });
/* harmony import */ var ol_attribution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/attribution */ "./node_modules/ol/attribution.js");
/* harmony import */ var ol_layer_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/layer/base */ "./node_modules/ol/layer/base.js");
/* harmony import */ var cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cartoview-sdk/helpers/BasicViewerHelper */ "./node_modules/cartoview-sdk/helpers/BasicViewerHelper.js");
/* harmony import */ var cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_source_bingmaps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/source/bingmaps */ "./node_modules/ol/source/bingmaps.js");
/* harmony import */ var ol_source_cartodb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/source/cartodb */ "./node_modules/ol/source/cartodb.js");
/* harmony import */ var ol_source_cluster__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/source/cluster */ "./node_modules/ol/source/cluster.js");
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cartoview-sdk/helpers/FeaturesHelper */ "./node_modules/cartoview-sdk/helpers/FeaturesHelper.js");
/* harmony import */ var cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_format_geojson__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/format/geojson */ "./node_modules/ol/format/geojson.js");
/* harmony import */ var ol_layer_group__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/layer/group */ "./node_modules/ol/layer/group.js");
/* harmony import */ var ol_layer_heatmap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/layer/heatmap */ "./node_modules/ol/layer/heatmap.js");
/* harmony import */ var ol_layer_image__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/layer/image */ "./node_modules/ol/layer/image.js");
/* harmony import */ var ol_source_imagearcgisrest__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/source/imagearcgisrest */ "./node_modules/ol/source/imagearcgisrest.js");
/* harmony import */ var ol_source_imagecanvas__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/source/imagecanvas */ "./node_modules/ol/source/imagecanvas.js");
/* harmony import */ var ol_source_imagemapguide__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ol/source/imagemapguide */ "./node_modules/ol/source/imagemapguide.js");
/* harmony import */ var ol_source_imagestatic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ol/source/imagestatic */ "./node_modules/ol/source/imagestatic.js");
/* harmony import */ var ol_source_imagevector__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ol/source/imagevector */ "./node_modules/ol/source/imagevector.js");
/* harmony import */ var ol_source_imagewms__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ol/source/imagewms */ "./node_modules/ol/source/imagewms.js");
/* harmony import */ var ol_format_kml__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ol/format/kml */ "./node_modules/ol/format/kml.js");
/* harmony import */ var ol_layer_layer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ol/layer/layer */ "./node_modules/ol/layer/layer.js");
/* harmony import */ var ol_source_osm__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ol/source/osm */ "./node_modules/ol/source/osm.js");
/* harmony import */ var ol_source_raster__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ol/source/raster */ "./node_modules/ol/source/raster.js");
/* harmony import */ var ol_source_source__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ol/source/source */ "./node_modules/ol/source/source.js");
/* harmony import */ var ol_source_image__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ol/source/image */ "./node_modules/ol/source/image.js");
/* harmony import */ var ol_source_tile__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ol/source/tile */ "./node_modules/ol/source/tile.js");
/* harmony import */ var ol_source_vector__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ol/source/vector */ "./node_modules/ol/source/vector.js");
/* harmony import */ var ol_source_vectortile__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ol/source/vectortile */ "./node_modules/ol/source/vectortile.js");
/* harmony import */ var ol_source_stamen__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ol/source/stamen */ "./node_modules/ol/source/stamen.js");
/* harmony import */ var cartoview_sdk_helpers_StyleHelper__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! cartoview-sdk/helpers/StyleHelper */ "./node_modules/cartoview-sdk/helpers/StyleHelper.js");
/* harmony import */ var cartoview_sdk_helpers_StyleHelper__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(cartoview_sdk_helpers_StyleHelper__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var ol_layer_tile__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ol/layer/tile */ "./node_modules/ol/layer/tile.js");
/* harmony import */ var ol_source_tilearcgisrest__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ol/source/tilearcgisrest */ "./node_modules/ol/source/tilearcgisrest.js");
/* harmony import */ var ol_source_tiledebug__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ol/source/tiledebug */ "./node_modules/ol/source/tiledebug.js");
/* harmony import */ var ol_source_tileimage__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ol/source/tileimage */ "./node_modules/ol/source/tileimage.js");
/* harmony import */ var ol_source_tilejson__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ol/source/tilejson */ "./node_modules/ol/source/tilejson.js");
/* harmony import */ var ol_source_tileutfgrid__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ol/source/tileutfgrid */ "./node_modules/ol/source/tileutfgrid.js");
/* harmony import */ var ol_source_tilewms__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ol/source/tilewms */ "./node_modules/ol/source/tilewms.js");
/* harmony import */ var ol_layer_vector__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ol/layer/vector */ "./node_modules/ol/layer/vector.js");
/* harmony import */ var ol_layer_vectortile__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ol/layer/vectortile */ "./node_modules/ol/layer/vectortile.js");
/* harmony import */ var ol_view__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ol/view */ "./node_modules/ol/view.js");
/* harmony import */ var ol_source_wmts__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ol/source/wmts */ "./node_modules/ol/source/wmts.js");
/* harmony import */ var ol_source_xyz__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ol/source/xyz */ "./node_modules/ol/source/xyz.js");
/* harmony import */ var ol_source_zoomify__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ol/source/zoomify */ "./node_modules/ol/source/zoomify.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var _api_utils__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ../api/utils */ "./src/api/utils.js");
/* harmony import */ var ol_loadingstrategy__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ol/loadingstrategy */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }














































var sourceMapping = {
  'BingMaps': ol_source_bingmaps__WEBPACK_IMPORTED_MODULE_3__["default"],
  'CartoDB': ol_source_cartodb__WEBPACK_IMPORTED_MODULE_4__["default"],
  'Cluster': ol_source_cluster__WEBPACK_IMPORTED_MODULE_5__["default"],
  'Image': ol_source_image__WEBPACK_IMPORTED_MODULE_22__["default"],
  'ImageArcGISRest': ol_source_imagearcgisrest__WEBPACK_IMPORTED_MODULE_11__["default"],
  'ImageCanvas': ol_source_imagecanvas__WEBPACK_IMPORTED_MODULE_12__["default"],
  'ImageMapGuide': ol_source_imagemapguide__WEBPACK_IMPORTED_MODULE_13__["default"],
  'ImageStatic': ol_source_imagestatic__WEBPACK_IMPORTED_MODULE_14__["default"],
  'ImageVector': ol_source_imagevector__WEBPACK_IMPORTED_MODULE_15__["default"],
  'ImageWMS': ol_source_imagewms__WEBPACK_IMPORTED_MODULE_16__["default"],
  'Stamen': ol_source_stamen__WEBPACK_IMPORTED_MODULE_26__["default"],
  'Raster': ol_source_raster__WEBPACK_IMPORTED_MODULE_20__["default"],
  'Source': ol_source_source__WEBPACK_IMPORTED_MODULE_21__["default"],
  'Tile': ol_source_tile__WEBPACK_IMPORTED_MODULE_23__["default"],
  'TileArcGISRest': ol_source_tilearcgisrest__WEBPACK_IMPORTED_MODULE_29__["default"],
  'TileDebug': ol_source_tiledebug__WEBPACK_IMPORTED_MODULE_30__["default"],
  'TileImage': ol_source_tileimage__WEBPACK_IMPORTED_MODULE_31__["default"],
  'TileJSON': ol_source_tilejson__WEBPACK_IMPORTED_MODULE_32__["default"],
  'TileUTFGrid': ol_source_tileutfgrid__WEBPACK_IMPORTED_MODULE_33__["default"],
  'TileWMS': ol_source_tilewms__WEBPACK_IMPORTED_MODULE_34__["default"],
  'Zoomify': ol_source_zoomify__WEBPACK_IMPORTED_MODULE_40__["default"],
  'SourceVectorTile': ol_source_vectortile__WEBPACK_IMPORTED_MODULE_25__["default"],
  'WMTS': ol_source_wmts__WEBPACK_IMPORTED_MODULE_38__["default"],
  'OSM': ol_source_osm__WEBPACK_IMPORTED_MODULE_19__["default"],
  'XYZ': ol_source_xyz__WEBPACK_IMPORTED_MODULE_39__["default"],
  'Vector': ol_source_vector__WEBPACK_IMPORTED_MODULE_24__["default"]
};
var layersMaping = {
  'Tile': ol_layer_tile__WEBPACK_IMPORTED_MODULE_28__["default"],
  'Group': ol_layer_group__WEBPACK_IMPORTED_MODULE_8__["default"],
  'Base': ol_layer_base__WEBPACK_IMPORTED_MODULE_1__["default"],
  'Heatmap': ol_layer_heatmap__WEBPACK_IMPORTED_MODULE_9__["default"],
  'Image': ol_layer_image__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Layer': ol_layer_layer__WEBPACK_IMPORTED_MODULE_18__["default"],
  'Vector': ol_layer_vector__WEBPACK_IMPORTED_MODULE_35__["default"],
  'VectorTile': ol_layer_vectortile__WEBPACK_IMPORTED_MODULE_36__["default"]
};
var formatMapping = {
  'geojson': ol_format_geojson__WEBPACK_IMPORTED_MODULE_7__["default"],
  'wfs': ol_format_geojson__WEBPACK_IMPORTED_MODULE_7__["default"],
  'kml': ol_format_kml__WEBPACK_IMPORTED_MODULE_17__["default"]
};

var MapConfigService =
/*#__PURE__*/
function () {
  function MapConfigService(map, mapJson) {
    _classCallCheck(this, MapConfigService);

    this.map = map;
    this.config = mapJson;
    this.styleHelper = new cartoview_sdk_helpers_StyleHelper__WEBPACK_IMPORTED_MODULE_27___default.a();
  }

  _createClass(MapConfigService, [{
    key: "getLayerClass",
    value: function getLayerClass(layerType) {
      var t = 'Tile';

      switch (layerType) {
        case 'arcgis_msl':
        case 'wms':
          t = 'Tile';
          break;

        case 'wfs':
        case 'geojson':
        case 'kml':
          t = 'Vector';
          break;

        default:
          break;
      }

      return layersMaping[t];
    }
  }, {
    key: "getSourceClass",
    value: function getSourceClass(layerType) {
      var t = 'Tile';

      switch (layerType) {
        case 'wms':
          t = 'TileWMS';
          break;

        case 'wfs':
        case 'geojson':
        case 'kml':
          t = 'Vector';
          break;

        case 'arcgis_msl':
          t = 'TileArcGISRest';
          break;

        default:
          break;
      }

      return sourceMapping[t];
    }
  }, {
    key: "getSource",
    value: function getSource(layerJson) {
      var s = undefined;
      var serverInfo = layerJson.server_info;
      var serverURL = serverInfo.url;
      var layerName = layerJson.name;
      var layerProjection = layerJson.projection;
      var serverProxy = serverInfo.proxy;
      var serverType = serverInfo.type.toLowerCase();
      var layer_type = layerJson.layer_type;
      var proxyable = layerJson.proxyable;
      var isLocalhost = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
      var sourceClass = this.getSourceClass(layer_type);
      var notWFS = ['geojson', 'kml'].includes(layer_type);

      if (sourceClass === ol_source_tilewms__WEBPACK_IMPORTED_MODULE_34__["default"]) {
        var params = {
          params: {
            TILED: 'TRUE',
            serverType: serverType,
            'LAYERS': [layerName]
          },
          url: "".concat(serverURL),
          crossOrigin: 'anonymous',
          tileLoadFunction: function tileLoadFunction(tile, src) {
            var url = proxyable || isLocalhost ? "".concat(serverProxy).concat(encodeURIComponent(src)) : src;
            tile.getImage().src = url;
          }
        };
        s = new sourceClass(params);
      } else if (sourceClass === ol_source_vector__WEBPACK_IMPORTED_MODULE_24__["default"]) {
        var source = new sourceClass({
          format: new formatMapping[layer_type](),
          loader: function loader(extent, resolution, projection) {
            var proj = projection.getCode();
            var uri = notWFS ? serverURL : "".concat(serverURL, "?service=wfs&version=2.0.0&request=GetFeature&typeNames=").concat(layerName, "&srsName=").concat(proj, "&bbox=").concat(extent.join(','), "&outputFormat=application/json");
            var url = proxyable || isLocalhost ? "".concat(serverProxy).concat(encodeURIComponent(uri)) : uri;

            var onError = function onError() {
              source.removeLoadedExtent(extent);
            };

            var layerFormat = source.getFormat();
            var options = notWFS ? {
              dataProjection: layerProjection,
              featureProjection: proj
            } : {};
            axios__WEBPACK_IMPORTED_MODULE_41___default.a.get(url, {
              headers: {
                "X-CSRFToken": Object(_api_utils__WEBPACK_IMPORTED_MODULE_42__["getCRSFToken"])()
              }
            }).then(function (response) {
              source.addFeatures(layerFormat.readFeatures(response.data, options));
            })["catch"](function (error) {
              console.error(error);
              onError();
            });
          },
          strategy: notWFS ? ol_loadingstrategy__WEBPACK_IMPORTED_MODULE_43__["default"].all : ol_loadingstrategy__WEBPACK_IMPORTED_MODULE_43__["default"].bbox
        });
        s = source;
      } else if (sourceClass === ol_source_tilearcgisrest__WEBPACK_IMPORTED_MODULE_29__["default"]) {
        var _source = new sourceClass({
          url: serverURL,
          crossOrigin: 'anonymous',
          tileLoadFunction: function tileLoadFunction(tile, src) {
            var url = proxyable || isLocalhost ? "".concat(serverProxy).concat(encodeURIComponent(src)) : src;
            tile.getImage().src = url;
          }
        });

        s = _source;
      }

      return s;
    }
  }, {
    key: "generateLayerFromConfig",
    value: function generateLayerFromConfig(layerJson) {
      var _this = this;

      var layer_type = layerJson.layer_type;
      var serverInfo = layerJson.server_info;
      var LayerClass = this.getLayerClass(layer_type);
      var layerMetadata = {
        'name': layerJson.name,
        'identifier': layerJson.id,
        'title': layerJson.title,
        'server_url': serverInfo.url,
        'server_proxy': serverInfo.proxy,
        "server_operations": serverInfo.operations,
        'layer_type': layer_type,
        'bbox': layerJson.bounding_box,
        'projection': layerJson.projection === "EPSG:102100" ? "EPSG:3857" : layerJson.projection
      };
      var layer = new LayerClass({
        source: this.getSource(layerJson)
      });

      if (layer_type == 'wfs') {
        layer.setStyle(this.styleHelper.styleFunction);
      }

      if (layer_type == 'arcgis_msl') {
        var extent = layerJson.bounding_box.map(function (coord) {
          return parseFloat(coord);
        });
        cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_6___default.a.getCRS(layerJson.projection.split(":").pop()).then(function (newCRS) {
          extent = cartoview_sdk_helpers_BasicViewerHelper__WEBPACK_IMPORTED_MODULE_2___default.a.reprojectExtent(extent, _this.map, layerJson.projection);
          layer.setExtent(extent);
        });
      }

      layer.set('metadata', layerMetadata);
      return layer;
    }
  }, {
    key: "loadLayers",
    value: function loadLayers() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var layerConfig = this.config.layers;
      var remove = [];
      var map = this.map;
      map.getLayers().forEach(function (lyr) {
        var metadata = lyr.get('metadata');

        if (metadata && metadata['title'] !== null) {
          remove.push(lyr);
        }
      });
      var i, ii;

      for (i = 0, ii = remove.length; i < ii; ++i) {
        map.removeLayer(remove[i]);
      }

      for (i = 0, ii = layerConfig.length; i < ii; ++i) {
        var layer = this.generateLayerFromConfig(layerConfig[i]);

        if (layer) {
          map.addLayer(layer);
        }
      }

      callback();
    }
  }, {
    key: "load",
    value: function load() {
      var _this2 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var map = this.map;
      var viewConfig = this.config.view;
      var viewProj = viewConfig.projection;
      var projCode = viewProj.split(':').pop();
      cartoview_sdk_helpers_FeaturesHelper__WEBPACK_IMPORTED_MODULE_6___default.a.getCRS(projCode).then(function (newCRS) {
        var view = map.getView(),
            proj = ol_proj__WEBPACK_IMPORTED_MODULE_44__["default"].get(viewConfig.projection);

        if (proj && !ol_proj__WEBPACK_IMPORTED_MODULE_44__["default"].equivalent(view.getProjection(), proj)) {
          map.setView(new ol_view__WEBPACK_IMPORTED_MODULE_37__["default"](viewConfig));
        } else {
          view.setCenter(viewConfig.center);

          if (viewConfig.resolution !== undefined) {
            view.setResolution(viewConfig.resolution);
          } else if (viewConfig.zoom !== undefined) {
            view.setZoom(viewConfig.zoom);
          }

          if (viewConfig.rotation !== undefined) {
            view.setRotation(viewConfig.rotation);
          }
        }

        _this2.loadLayers(callback);
      });
    }
  }]);

  return MapConfigService;
}();

/* harmony default export */ __webpack_exports__["default"] = (MapConfigService);

/***/ }),

/***/ "./src/services/utils.jsx":
/*!********************************!*\
  !*** ./src/services/utils.jsx ***!
  \********************************/
/*! exports provided: resolveURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveURL", function() { return resolveURL; });
function resolveURL(url, base) {
  if ('string' !== typeof url || !url) {
    return null; // wrong or empty url
  } else if (url.match(/^[a-z]+\:\/\//i)) {
    return url; // url is absolute already 
  } else if (url.match(/^\/\//)) {
    return 'http:' + url; // url is absolute already 
  } else if (url.match(/^[a-z]+\:/i)) {
    return url; // data URI, mailto:, tel:, etc.
  } else if ('string' !== typeof base) {
    var a = document.createElement('a');
    a.href = url; // try to resolve url without base  

    if (!a.pathname) {
      return null; // url not valid 
    }

    return 'http://' + url;
  } else {
    base = resolve(base); // check base

    if (base === null) {
      return null; // wrong base
    }
  }

  var a = document.createElement('a');
  a.href = base;

  if (url[0] === '/') {
    base = []; // rooted path
  } else {
    base = a.pathname.split('/'); // relative path

    base.pop();
  }

  url = url.split('/');

  for (var i = 0; i < url.length; ++i) {
    if (url[i] === '.') {
      // current directory
      continue;
    }

    if (url[i] === '..') {
      // parent directory
      if ('undefined' === typeof base.pop() || base.length === 0) {
        return null; // wrong url accessing non-existing parent directories
      }
    } else {
      // child directory
      base.push(url[i]);
    }
  }

  return a.protocol + '//' + a.hostname + base.join('/');
}

/***/ }),

/***/ "./src/store/configureStore.js":
/*!*************************************!*\
  !*** ./src/store/configureStore.js ***!
  \*************************************/
/*! exports provided: configureStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureStore", function() { return configureStore; });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js");
/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux-thunk */ "./node_modules/redux-thunk/es/index.js");
/* harmony import */ var redux_devtools_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux-devtools-extension */ "./node_modules/redux-devtools-extension/index.js");
/* harmony import */ var redux_devtools_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(redux_devtools_extension__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reducers */ "./src/reducers/index.js");




function configureStore(initialState) {
  return Object(redux__WEBPACK_IMPORTED_MODULE_0__["createStore"])(_reducers__WEBPACK_IMPORTED_MODULE_3__["default"], initialState, Object(redux_devtools_extension__WEBPACK_IMPORTED_MODULE_2__["composeWithDevTools"])(Object(redux__WEBPACK_IMPORTED_MODULE_0__["applyMiddleware"])(redux_thunk__WEBPACK_IMPORTED_MODULE_1__["default"])));
}

/***/ }),

/***/ "./src/store/index.js":
/*!****************************!*\
  !*** ./src/store/index.js ***!
  \****************************/
/*! exports provided: store, storeWithInitial, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "store", function() { return store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storeWithInitial", function() { return storeWithInitial; });
/* harmony import */ var _configureStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configureStore */ "./src/store/configureStore.js");

var store = Object(_configureStore__WEBPACK_IMPORTED_MODULE_0__["configureStore"])();
function storeWithInitial(initialState) {
  return Object(_configureStore__WEBPACK_IMPORTED_MODULE_0__["configureStore"])(initialState);
}
/* harmony default export */ __webpack_exports__["default"] = (store);

/***/ }),

/***/ 5:
/*!**********************************************!*\
  !*** multi ./src/containers/basicViewer.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/hishamkaram/Projects-Active/geonode_oauth_client/cartoview/static/basic_viewer/src/containers/basicViewer.jsx */"./src/containers/basicViewer.jsx");


/***/ })

/******/ });
//# sourceMappingURL=basicViewer.js.map